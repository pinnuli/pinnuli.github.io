---
title: Java并发之对象的共享
date: 2019-02-26 21:13:36
categories: "Java并发"
tags:
    - Java并发
copyright:
---
### 一、可见性

#### 非原子的64位操作
- 对于非volatile类型的long和double变量，JVM允许将来64位的读操作或写操作分解为两个32位的操作，如果该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位
- 在多线程中使用共享且可变的long和double等类型变量是不安全的，需要用volatile声明或加锁
#### 加锁与可见性
- 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享可变变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。
#### Volatile变量
一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程
- 从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块
- 当volatile变量能简化代码的实现以及对同步策略的验证时才使用
- 加锁机制既可以确保可见性又可以确保原子性，volatile变量只能确保可见性（因此不足以确保递增操作的原子性）
- 当且仅当满足以下所有条件时，才应该使用volatile变量：

    1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
    2.变量不需要与其他的状态变量共同参与不变约束
    3.在访问变量时不需要加锁
- volatile的适用场景：

    1.作为状态标志：
    ```java
    volatile boolean asleep;
    ...
    while(!asleep){
        countSomeSheep();
    }
    ```
    2.一次性安全发布:
    ```java
    public class Singleton {

        private Singleton() {}

        private static volatile Singleton instance = null;

        public static Singleton getInstance() {
            if (instance == null) { // 双重检测机制        
                synchronized (Singleton.class) { // 同步锁
                    if (instance == null) {
                        instance = new Singleton(); 
                    }
                }
            }
            return instance;
        }
    }
    ```
### 二、发布与逸出

- 发布一个对象：
- 逸出：

### 三、线程封闭
#### ad-hoc
这是完全靠实现者控制的线程封闭，他的线程封闭完全靠实现者实现

#### 栈封闭
在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中国，他们位于执行线程的栈中，其他线程无法访问。

#### ThreadLocal类
- 这个类能使线程中的某个值与保存值的对象关联起来，ThreadLocal类提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
- ThreadLocal通常用于防止对可变的单实例变量或全局变量进行共享：比如：
    1. 通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接；
    2. 当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配临时对象。

- 可以将ThreadLocal<T>视为包含了Map<Thread, T>对象，但ThreadLocal的实现并非如此，这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。


### 四、不变性
- 不可变对象：对象在被创建后其状态就不可以被修改
- 不可变对象一定是线程安全的。
- 不可变对象必须满足的条件：
    1. 对象创建后其状态就不能修改
    2. 对象的所有域都是final类型
    3. 对象是正确创建的(创建期间this没有逸出)
- 不可变对象的创建：
    1. Collections。unmodifiableXXX:Collection、Map、Set、List等，例如：`map = Collections.unmodifiableMap(map);`

    2. Guava：ImmutableXXX:Collection、Map、Set、List等
- Final域
    1. final类型的域是不可修改的，但如果final域锁引用的对象是可变的，那么这些被引用的对象是可以修改的； 因此， 在没有额外同步的情况下，也可以安全第访问final域， 但是如果final域执行的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。
    2. final域能确保初始化过程的安全性,从而可以不受限制地访问不可变对象,并在共享这些对象时无须同步。
    3. 除非需要更高的可见性,否则所有域都应声明为私有，除非需要某个域是可变的,否则应将其声明为final。
- 事实不可变对象：雄技术上来看是可变的，但其状态在发布后不会再改变，这种对象不需要满足前面提到的条件。
    > 在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

### 五、安全发布对象
#### 安全发布的常用模式：
1. 在静态初始化函数中初始化一个对象引用
> 要发布一个对象,最简单安全的方式是使用静态的初始化器:`public static Holder holder = new Holder(42);`， 静态初始化器由JVM在类初始化阶段执行。由于JVM内部存在同步机制,所以这种方式初始化的任何对象都可以被安全发布。
2. 将对象的引用保存到volatile类型的域或AtomicReference对象中
3. 将对象的引用保存到某个正确构造对象的final类型域中
4. 将对象的引用保存到一个由锁保护的域中

#### 对象的发布取决于他的可变性：
- 不可变对象可以通过任意机制来发布；
- 事实不可变对象必须通过安全方式来发布；
- 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来

#### 安全共享对象的策略
1. 线程封闭: 线程封闭的对象只能由一个线程拥有
2. 只读共享: 在没有额外同步的情况下,共享的只读对象可以由多个线程并发访问,但任何线程都不能修改它(共享的只读对象包括不可变对象和事实不可变对象)
3. 线程安全共享: 线程安全的对象在其内部实现同步,多个线程可通过对象的共有接口来进行访问
4. 保护对象: 被保护的对象只能通过持有特定的锁来访问.保护对象包括封装在其他线程安全对象中的对象,以及已发布的并且由某个特定锁保护的对象
