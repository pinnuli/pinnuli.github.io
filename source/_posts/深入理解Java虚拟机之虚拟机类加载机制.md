---
title: 深入理解Java虚拟机之虚拟机类加载机制
date: 2018-11-30 21:18:22
categories: "深入理解java虚拟机"
tags:
    - JVM
copyright:
---
### 类加载的时机
- 类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载，其中验证、准备、解析3个部分统称为 **连接**
- 加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，但是解析阶段则不一定，有些情况下可在初始化阶段之后再开始（为了支持Java语言的运行时绑定）
- 虚拟机规范严格规定了 **有且只有**5种情况必须立即对类进行“初始化”：
    - 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时
    - 使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化
    - 当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化
    - 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
    - 使用JDK1,7的动态语言支持时，java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄

> 这5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用

- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化
----
### 类加载的过程
#### 1. 加载
在加载阶段，虚拟机需要完成以下3件事：
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

- 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中
- 对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面

#### 2. 验证
验证阶段大致上会完成下面4个阶段的校验动作：**文件格式验证、元数据验证、字节码验证、符号引用验证**:
- **文件格式验证**：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，保证输入的字节流能正确地解析并存储于方法区，格式上符合描述一个Java类型信息的要求
- **元数据验证**:对类的元数据信息语义校验，保证不存在不符合Java语言规范的元数据信息
- **字节码验证**:通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
- **符合引用验证**:可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行，发生在虚拟机将符号引用转化为直接引用时
> 如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间
- 验证的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全

#### 3. 准备
准备阶段是 **正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值）** 的阶段，这些变量所使用的内存都将在方法区中进行分配
- 这里进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中
- 如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值

#### 4. 解析
解析阶段是 **虚拟机将常量池内的符号引用替换为直接引用的过程** 
- **符号引用与直接引用**：
    - 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可
    - 直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄

- **解析发生的时间**：虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它
- 除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行
- **解析动作**：
    - 类和接口的解析
    - 字段解析
    - 类方法解析
    - 接口方法解析
    
#### 5. 初始化
在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，可以从另外一个角度来表达：初始化阶段是执行类构造器`<clinit>()`方法的过程
- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
示例：如下例子输出结果为-1（静态语句块中x为局部变量，不影响静态变量x的值）
```java
public class Test{
    static{
        int x=5;
    }
    static int x,y;
    public static void main(String args[]){
        x--;
        System.out.println(x);
    }
}

```
- 虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕
- 父类的`<clinit>()`方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作
- `<clinit>()`方法对于类和接口不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法
- 执行接口的`<clinit>()`方法不需要先执行父接口菜单`<clinit>()`方法，只要当父接口中定义的变量使用时，父接口才会初始化
- 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步

----
### 类加载器
#### 类与类加载器
对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
> 即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等

#### 双亲委派模型
从Java虚拟机的角度来讲，只存在两种不同的类加载器：
i. 启动类加载器，是虚拟机的一部分;
ii. 另一种是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader

- **启动类加载器**：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，开发者无法直接引用
- **扩展类加载器**：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用
- **应用程序类加载器**：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，开发者可以直接使用
- **双亲委派模型的工作过程**：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载
> 这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码

![](/images/jvm_classloader_doubleparent.jpg)


