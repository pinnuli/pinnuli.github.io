<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的锁优化]]></title>
    <url>%2F2018%2F11%2F12%2FJava%E4%B8%AD%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[自旋锁: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁 自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统方式挂起线程 自旋适应锁: 自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且尺有所 的线程正在运行中，那么自旋等待时间将会持续相对更长；如果对于某个锁，自旋很少成功获得过，拿在以后要获取这个锁时将可能省略掉自旋过程 锁消除: 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不存在共享数据竞争的锁进行消除 锁粗化: 虚拟机探测到有一串零碎的操作对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，例如： 1234567public String concatString(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.tostring();&#125; 这里原先每次append操作都需要加一次锁，而虚拟机会扩展到第一个append操作之前到最后一个append操作之后，就只需要加一次锁 轻量级锁: 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制称为“重量级”锁 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。 偏向锁: 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即在无精准的情况下把整个同步都消除掉]]></content>
      <categories>
        <category>深入理解java虚拟机笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F2018%2F11%2F12%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[主内存与工作内存 主内存: Java内存模型规定了所有的变量都存储在主内存中。 这里的主内存与物理硬件的主内存可以类比，但这里的主内存仅是指虚拟机内存的一部分。 工作内存: 每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中，而不能直接读写主内存中的变量。 工作内存可以与处理器的高速缓存类比 线程、主内存、工作内存的交互关系 内存间交互操作java内存模型定义的8种操作 lock(锁定): 作用于主内存的变量，它把一个变量标识为一条线程独占的状态 unlock(解锁): 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read(读取): 作用于主内存的变量，它把一个变量的值从主内存传输到线程的总做内存中，以便随后的load动作使用 load(载入): 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存给的变量副本中 把一个变量从主内存复制到工作内存，那就要顺序地执行read和load，但不要求连续执行 use(使用): 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时会执行这个操作 assign(赋值): 作用于工作内存的变量，它把一个从执行亲情接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 store(存储): 作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中一遍随后的write操作使用 write(写入): 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 把一个变量从工作内存同步到主内存，那就要顺序地执行store和write，但不要求连续执行 8种操作需要满足的规则 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须将该变化同步回主内存 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中 一个新的变量只能在主内存”诞生“，不允许在工作内存中直接使用一个未被初始化（load或assign）的变脸，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这变量前，，需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定住的变量 对一个变量执行unlock操作之前，必须先把此变量同步回主内存。 volatile型变量的特殊规则volatile当一个变量定义为volatile之后，它将具备两种特性： 可见性: 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存完成 volatile变量只能在一下两种场景保证可见性 1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值 2.变量不需要与其他的状态变量共同参与不变约束 禁止指令重排序优化: 普通变量仅仅会保证在该方法的执行过程中所有依赋值结果的地方都能获取到正确的结果，而不能保证变量复制的顺序与程序代码中的执行顺序一致。 volatile与锁之间的区别 volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，不过大多数场景volatile的总开销仍然要比锁低，我们在volatile与锁之间的选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求 volatile变量的特殊规则 假设T表示一个线程，V和W分别表示两个volatile变量，在进行read、load、use、assign、store和write操作时需要满足如下规则： 线程T对变量V的use动作可以认为是和线程T对变量的load、read动作的相关联，必须连续一起出现（即在工作内存中，每次使用V之前必须先从主内存刷新最新的值） 线程T对变量V的assign动作可以认为是和线程T对变量的store、write动作的相关联，必须连续一起出现（即在工作内存中，每次修改V之后必须立刻同步回主内存中） 假设A是T对V的use或assign动作，F是和A相关联的load或store动作，P是和F相关联的read或write动作；类似的B是T对W实施的use或assign动作，G是和B相关联的load或store动作，Q是和G相关联的read或write动作。 如果A先于B，那么P先于Q（这要求volatile变量不会被指令重排序优化） 原子性、可见性、有序性原子性 基本数据类型的访问读写是具备原子性的（long和double除外） synchronized可以满足更大范围的原子性保证可见性 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改 volatile： 保证多线程操作时变量的可见性而普通变量不可以 synchronized： 对一个变量执行unlock之前，必须先把此变量同步回主内存 final： 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递，拿在其他线程中就能看见final字段的值 有序性 如果在本线程内管程，所有的操作都是有序的（线程内表现为串行）， 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序，工作内存与主内存同步延迟） volatile关键字本身包含了禁止指令重排序的语义 synchronized决定了持有用一个锁的同步快只能串行地进行 “天然的“先行发生关系 程序次序规则: 在一个线程内，按照控制流顺序发生 管程锁定规则: 一个unlock操作先行发生于后面对同一个锁的lock操作 volatile变量规则: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作 线程启动规则: Thread对象的start（）方法先行发生于此线程的每一个动作 线程中止规则: 线程中的所有操作都先行发生于对此线程的终止检测 线程中断规则: 对线程interrupt（）方法的调动先行发生于被中断线程的代码检测到中断事件的发生 对象终结规则: 一个对象的初始化完成先行发生于他的finalize（）方法的开始 传递性: A先行发生于B，B先行发生于C，则A先行发生于C 这些先行发生关系无须任何同步协助就已经存在，可以直接使用]]></content>
      <categories>
        <category>深入理解java虚拟机笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务管理]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务的ACID特性 原子性: 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。 一致性: 隔离执行事务时（即不考虑其他事务并发执行）保持数据库的一致性。 在数据库系统中由恢复系统负责。 隔离性: 尽管多个事务可能并发执行，但系统保证对于多个事务，如T1和T2，对于T1来说，T1要么在T2开始之前已经完成执行，要么在T2完成之后开始执行。确保隔离性在数据库系统中由并发控制系统部件负责。 持久性: 一旦事务成功完成后，它对数据库的更新必须是永久的，即使出现系统故障，在数据库系统中由恢复系统负责。 可以通过一下两条中的其中任何一条来确保持久性。 事务做的更新在事务结束前已经给写入磁盘 有关事务已执行的更新信息已写到磁盘上，并且此类信息必须充分，能让数据库在系统出现故障后重新启动时重新构造更新 事务原子性和持久性五种状态可以为事务建立一个简单的抽象事务类型，分为五种状态，事务必须处于以下状态之一 活动的： 初始状态，事务正在执行时处于此状态 部分提交的： 最后一条语句执行后 失败的： 发现正常的执行不能继续后 中止的： 事务回滚并且数据库已恢复到事务开始执行前的状态后 提交的： 成功完成后 中止状态事务回滚的两种选择 重启事务，但仅当引起事务中止的是硬件错误而不是有事务内部逻辑所产生的软件错误。 杀死事务, 这样做通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正 事务隔离性可串行化调度 冲突: 假设I和J是不同事务在在相同数据项上的操作，并且其中至少有一个是write指令时，I与J是冲突的 冲突等价: 调度S经过一系列非冲突指令交换转换成S’，S与S’冲突等价 冲突可串行化: 一个调度S与另一个串行调度冲突等价，则称调度S是冲突可串行化的 可恢复性 可恢复调度: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1先于T2提交 无级联调度: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1必须在T2这一读操作前提交 事务隔离性级别 可串行化: 通常保证可串行化调度 可重复读: 只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据，但该事务不要求与其他事务可串行化 已提交读: 只允许读取已提交数据，但不要求可重复读功能 未提交读: 允许读未提交数据 并发控制基于锁的协议锁 共享锁（S): 如果事务T1获得了数据项Q上的共享型锁（记为S），则T1可读但不能写 排他锁(X): 如果事务T1获得了数据项Q上的排他型锁（记为X），则T1既可读又可写Q 相容的锁: 数据项Q上存在B类型锁，如果事务T可以立即获得数据项Q上的A类型锁，则说A类型锁与B类型锁是相容的，即comp(A,B)=true 锁的授予 避免饿死: 可以通过在数据项Q上加M型锁，加锁条件如下： 1.不存在在数据项Q上持有与M型锁冲突的锁的事务 2.不存在等待对数据项Q上先于T申请枷锁的事务 两阶段封锁协议 增长阶段: 事务可以获得锁，但不能释放锁 缩减阶段: 事务可以释放锁，但不能获得新锁 严格两阶段封锁协议: 事务持有的所有排他锁必须在事务提交后方可释放 强两阶段封锁协议: 事务提交之前不得释放任何锁 多粒度 多级粒度机制: 通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大力度数据项中来实现。这种层次结构可以图形化地表示为树 意向锁: 如果一个结点佳航了意向锁，则意味着要在树的叫底层进行显式加锁，在一个结点显式加锁前，该结点的的全部祖先结点都加上了意向锁。 这样子可以避免了需要从头遍历结点才能发现子结点已经加锁 共享意向锁(IS): 一个结点加上了共享意向锁，树的较低层进行显式封锁，但只能加共享锁。 排他意向锁(IX): 一个结点加上了排他意向锁，树的较低层进行显式封锁，可以加共享锁或排他锁。 共享排他意向锁(SIX): 一个结点加上了共享排他意向锁，则以该结点为根的子树显式地加上了共享锁，并且将在数的更低层显式地加排他锁。 各种锁类型相容函数： 基于时间戳的协议对于系统中的每个事务T，把一个唯一的固定时间戳与他联系起来，此时间戳记为TS(T)。该时间戳是在事务T开始执行前由数据库系统赋予的。实现这种机制可以用以下两种方法： 使用系统始终的值作为时间戳，即事务的时间戳等于该事务进入系统时的时钟值。 使用逻辑计数器，没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值。 每个数据项需要与两个时间戳相关联： W-timestamp（Q）表示成功执行write（Q）的所有事务的最大时间戳 R-timestamp（Q）表示成功执行read（Q）的所有事务的最大时间戳 协议运作方式如下：1.假设事务T发出read（Q）&emsp; a.若TS（T）&lt; W-timestamp（Q），则T需要读入的Q值已被覆盖。因此read操作被拒绝，T回滚；&emsp; b.若TS（T）&gt;= W-timestamp（Q），则执行read操作，R-timestamp（Q）被设置为R-timestamp（Q）与TS(T)两者的最大值2.假设事务T发出write（Q）&emsp; a.若TS（T）&lt; R-timestamp（Q），则T产生的Q值是先前所需要的值，且系统已假定该值不会在产生，因此write被拒绝，T回滚&emsp; b.若TS（T）&lt; W-timestamp（Q），则T试图写入的Q值已过时，write操作被拒绝，T回滚&emsp; c.其他情况，系统执行write操作，将W-timestamp（Q）设置为TS（T）。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的XML之与HTML的区别验证，定位信息，命名空间]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%AE%9A%E4%BD%8D%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[HTML与XML的区别 HTML对大小写不敏感，XML大小写敏感 HTML结束标签可以省略，如&lt;/p&gt;，XML不能 XML只有单个标签而没有结束标签的元素必须以/结束 XML属性值必须用引号括起来 HTML属性可以没有值，XML所有属性必须有值 验证XML文档需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema 文档类型定义 将这些规则纳入XML文档 123456789&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE configuration[ &lt;!ELEMENT configuration...&gt; ...]&gt;&lt;configuration&gt;...&lt;/configuration&gt; 这些规则被纳入到DOCTYPE声明中，代码块[…]用来限定其界限，比如configuration SYSTEM声明，将DTD存储在外面 12&lt;!DOCTYPE configuration SYSTEM "config.dtd"&gt;&lt;!DOCTYPE configuration SYSTEM "http://myserver.com/config.dtd"&gt; 标记PUBLIC标识符 123456789class MyEntityResolver implements EntityResolver&#123; public InputSource resolveEntity(String publicId, String systemID)&#123; if(publicID.equals(a knowx ID))&#123; return new InputSource(DTD data): &#125;else&#123; return null; &#125; &#125;&#125; PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空 XML Schema 声明Schema文件 123&lt;?xml version="1.0"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;/project&gt; 使用xsd:表示XSL Schema定义的命名空间 12345678&lt;xsd:element name="name" type="xsd:string"/&gt;- ref属性引用Schema中位于别处的定义&lt;xsd:element ref="name"/&gt;&lt;xsd:element name="style" type=StyleType"/&gt; &lt;xsd:restriction base="xsd:string"/&gt; &lt;xsd:enumeration value="PLAIN"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:element&gt; 使用XPath定位信息 查找下列的username的值，,通过XPath表达式/configuration/database/username 123456&lt;configfuration&gt; &lt;database&gt; &lt;username id="test"&gt;pinnuli&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/database&gt;&lt;/configfuration&gt; 用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式 123XPathFactory xpFactory = XPathFactory.newInstance();path = xpfactory.newXPath();String username = path.evaluate(/configuration/database/username",doc); 具体的语法看文档 XML的命名空间 使用xmlns给定命名空间 12345&lt;element xmlns="namespaceURI1"&gt; &lt;child xmlns="namespaceURI2"&gt; grandchildren &lt;/child&gt;&lt;/element&gt; 这里第一个子元素和孙元素都是第二个命名空间的一部分 使用xmlns:prefix=”namespaceURI”定义命名空间和前缀 1234&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;xsd:element name=&quot;pinnuli&quot; type=&quot;haha&quot;/&gt; ...&lt;/xsd:schema&gt; 在这里xsd:schema实际上指的是命名空间http://www.w3.org/2001/XMLSchema中的schema 可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性1factory.serNamespaceAware(true); 参阅： 慕课网：Java眼中的XML—文件读取 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J%2F</url>
    <content type="text"><![CDATA[现有以下XML文档books.xml,下面的示例生成此文档部分内容123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt; &lt;book id="1"&gt; &lt;name&gt;冰与火之歌&lt;/name&gt; &lt;author&gt;乔治马丁&lt;/author&gt; &lt;year&gt;2014&lt;/year&gt; &lt;price&gt;89&lt;/price&gt; &lt;/book&gt; &lt;book id="2"&gt; &lt;name&gt;安徒生童话&lt;/name&gt; &lt;year&gt;2004&lt;/year&gt; &lt;price&gt;77&lt;/price&gt; &lt;language&gt;English&lt;/language&gt; &lt;/book&gt;&lt;/bookstore&gt; DOM1、创建DocumentBuilder对象12DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); 2、添加节点12345678910111213document.setXmlStandalone(true);Element bookstore = document.createElement("bookStore");//向bookstore根节点中添加子节点bookElement book = document.createElement("book");Element name = document.createElement("name");name.setTextContent("???");book.appendChild(name);book.setAttribute("id", "1");//将book节点添加到bookstore根节点中bookstore.appendChild(book);//将bookstore节点（已经包含了book）添加到dom树中document.appendChild(bookstore); 3、生成xml文件12345TransformerFactory tff = TransformerFactory.newInstance();Transformer tf = tff.newTransformer();//设置文件tf.setOutputProperty(OutputKeys.INDENT, "yes");tf.transform(new DOMSource(document),new StreamResult(new File("books1.xml"))); SAX1、创建一个TransformerFactory类的对象1SAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance(); 2、通过SAXTransformerFactory对象创建一个TransformerHandler对象1TransformerHandler handler = tff.newTransformerHandler(); 3、通过handler对象创建一个Transformer对象1Transformer tr = handler.getTransformer(); 4、通过Transformer对象对生成的xml文件进行设置12345678910// 设置xml的编码tr.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);// 设置xml的“是否换行”tr.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);5、创建一个Result对象```javaFile f = new File(&quot;newbooks.xml&quot;);if (!f.exists()) &#123; f.createNewFile();&#125; 6、创建Result对象，并且使其与handler关联12Result result = new StreamResult(new FileOutputStream(f));handler.setResult(result); 7、利用handler对象进行xml文件内容的编写O12// 打开documenthandler.startDocument(); 8、添加节点属性和节点值12345678910111213141516171819AttributesImpl attr = new AttributesImpl();handler.startElement("", "", "bookstore", attr);for (Book book : bookList) &#123; attr.clear(); attr.addAttribute("", "", "id", "", book.getId()); handler.startElement("", "", "book", attr); // 创建name节点 if (book.getName() != null &amp;&amp; !book.getName().trim().equals("")) &#123; attr.clear(); handler.startElement("", "", "name", attr); handler.characters(book.getName().toCharArray(), 0, book .getName().length()); handler.endElement("", "", "name"); &#125; handler.endElement("", "", "book");&#125;handler.endElement("", "", "bookstore");// 关闭documenthandler.endDocument(); JDOM1.生成一个根节点1Element rss = new Element("rss"); 2.为节点添加属性1rss.setAttribute("version", "2.0"); 3.生成一个document对象12345678910Document document = new Document(rss);Element channel = new Element("channel");rss.addContent(channel);Element title = new Element("title");title.setText("&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;");channel.addContent(title);//设置文件编码和换行Format format = Format.getCompactFormat();format.setIndent("");format.setEncoding("GBK"); 4.创建XMLOutputter的对象1XMLOutputter outputer = new XMLOutputter(format); 5.利用outputer将document对象转换成xml文档1outputer.output(document, new FileOutputStream(new File("rssnews.xml"))); DOM4J 使用DOM4J生成RSS文件 1.创建document对象，代表整个xml文档1Document document = DocumentHelper.createDocument(); 2.创建根节点rss1Element rss = document.addElement("rss"); 3.向rss节点中添加version属性1rss.addAttribute("version", "2.0"); 4.生成子节点及节点内容123Element channel = rss.addElement("channel");Element title = channel.addElement("title");title.setText("&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;"); 5.设置生成xml的格式12OutputFormat format = OutputFormat.createPrettyPrint();format.setEncoding("GBK"); 6.生成xml文件1234567File file = new File("rssnews.xml");XMLWriter writer;writer = new XMLWriter(new FileOutputStream(file), format);//设置是否转义，默认值是true，代表转义writer.setEscapeText(false);writer.write(document);writer.close(); 参阅： 慕课网：Java眼中的XML—文件读取 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J%2F</url>
    <content type="text"><![CDATA[现有以下XML文档books.xml,下面的解析示例解析此文档部分内容123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt; &lt;book id="1"&gt; &lt;name&gt;冰与火之歌&lt;/name&gt; &lt;author&gt;乔治马丁&lt;/author&gt; &lt;year&gt;2014&lt;/year&gt; &lt;price&gt;89&lt;/price&gt; &lt;/book&gt; &lt;book id="2"&gt; &lt;name&gt;安徒生童话&lt;/name&gt; &lt;year&gt;2004&lt;/year&gt; &lt;price&gt;77&lt;/price&gt; &lt;language&gt;English&lt;/language&gt; &lt;/book&gt;&lt;/bookstore&gt; DOM解析1、创建一个DocumentBuilder的对象12DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); 2、调用parser方法加载books.xml文件到当前项目下1Document document = db.parse("books.xml"); 3、进行解析1234567891011121314151617181920//获取所有book节点的集合NodeList bookList = document.getElementsByTagName("book");//?????book??for (int i = 0; i &lt; bookList.getLength(); i++) &#123; //通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始 Node book = bookList.item(i); //获取book节点的所有属性集合 NamedNodeMap attrs = book.getAttributes(); //前提：已经知道book节点有且只能有1个id属性 //将book节点进行强制类型转换，转换成Element类型 Element book = (Element) bookList.item(i); //通过getAttribute("id")方法获取属性值 String attrValue = book.getAttribute("id"); //解析book节点的子节点 NodeList childNodes = book.getChildNodes();&#125; 更多解析方法查看API SAX解析1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例1SAXParserFactory factory = SAXParserFactory.newInstance(); 2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例1SAXParser parser = factory.newSAXParser(); 3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler12SAXParserHandler handler = new SAXParserHandler();parser.parse("books.xml", handler); handler类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//标识解析开始@Overridepublic void startDocument() throws SAXException &#123; // TODO Auto-generated method stub super.startDocument(); System.out.println("SAX解析开始");&#125;//标识解析结束@Overridepublic void endDocument() throws SAXException &#123; // TODO Auto-generated method stub super.endDocument(); System.out.println("SAX解析结束");&#125;//解析xml元素@Overridepublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; //调用DefaultHandler类的startElement方法 super.startElement(uri, localName, qName, attributes); if (qName.equals("book")) &#123; //已知book元素下属性的名称，根据属性名称获取属性值 String value = attributes.getValue("id"); System.out.println("book的属性值是：" + value); &#125;else if (!qName.equals("name") &amp;&amp; !qName.equals("bookstore")) &#123; System.out.print("节点名是：" + qName + "---"); &#125;&#125;@Overridepublic void endElement(String uri, String localName, String qName) throws SAXException &#123; //调用DefaultHandler类的endElement方法 super.endElement(uri, localName, qName); //判断是否针对一本书已经遍历结束 if (qName.equals("book")) &#123; System.out.println("结束遍历某一本书的内容"); &#125;&#125;@Overridepublic void characters(char[] ch, int start, int length) throws SAXException &#123; // TODO Auto-generated method stub super.characters(ch, start, length); value = new String(ch, start, length); if (!value.trim().equals("")) &#123; System.out.println("节点值是：" + value); &#125;&#125; JDOM解析1、创建一个SAXBuilder的对象1SAXBuilder saxBuilder = new SAXBuilder(); 2、创建一个输入流，将xml文件加载到输入流中1in = new FileInputStream(&quot;books.xml&quot;); 3、通过saxBuilder的build方法，将输入流加载到saxBuilder中1Document document = saxBuilder.build(in); 4、通过document对象获取xml文件的根节点1Element rootElement = document.getRootElement(); 5、获取根节点下的子节点的List集合1234567891011121314List&lt;Element&gt; bookList = rootElement.getChildren();for (Element book : bookList) &#123; // 解析book的属性集合 List&lt;Attribute&gt; attrList = book.getAttributes(); //知道节点下属性名称时，获取节点值 book.getAttributeValue(&quot;id&quot;); // 对book节点的子节点的节点名以及节点值的遍历 List&lt;Element&gt; bookChilds = book.getChildren(); for (Element child : bookChilds) &#123; System.out.println(&quot;????&quot; + child.getName() + &quot;----????&quot; + child.getValue()); &#125;&#125; 如果需要设置编码可以按照以下方式设置 12InputStreamReader isr = new InputStreamReader(in, "UTF-8");Document document = saxBuilder.build(isr); DOM4J解析1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象12SAXReader reader = new SAXReader();Document document = reader.read(new File("src/res/books.xml")); 2、通过document对象获取根节点1Element bookStore = document.getRootElement(); 3、通过element对象的elementIterator方法获取迭代器1Iterator it = bookStore.elementIterator(); 4、遍历迭代器，获取根节点中的信息123456789101112131415while (it.hasNext()) &#123; Element book = (Element) it.next(); // 获取book的属性名以及 属性值 List&lt;Attribute&gt; bookAttrs = book.attributes(); for (Attribute attr : bookAttrs) &#123; System.out.println("????" + attr.getName() + "--????" + attr.getValue()); &#125; //遍历子节点 Iterator itt = book.elementIterator(); while (itt.hasNext()) &#123; Element bookChild = (Element) itt.next(); System.out.println("????" + bookChild.getName() + "--????" + bookChild.getStringValue()); &#125;&#125; 四种解析方式的区别 DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时 优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改 缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出 SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时 优点：内存消耗小 缺点：不易编码；很难同时访问同一个xml中的多处不同数据 JDOM：API大量使用了Collections类 DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用 参阅： 慕课网：Java眼中的XML—文件读取 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配之基于Java的容器注解]]></title>
    <url>%2F2018%2F07%2F29%2FSpring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Bean用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的，通常和@Configuration配合使用 12345678@Configurationpublic class StoreConfig &#123; @Bean(name = "store",initMethod = "init",destroyMethod="destroy") public BeanStore beanStore()&#123; return new BeanStore(); &#125;&#125; 相当于以下XML配置1234&lt;beans&gt; &lt;bean id="store" class="com.pinnuli.spring.ioc.beanannotation.BeanStore" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt;&lt;/beans&gt; 如果@Bean没有指定名称，则默认为方法名，这里即是beanStore。如果需要指定范围，即XML配置时的属性scope，那么可以用@Scope注解，且可以配置@Scope注解的proxyMode属性来配置代理方式，即XML配置时的scope-proxy属性 1@Scope(value="prototype", proxyMode = ScopedProxyMode.TARGET_CLASS) @ImportResource,@Value 通过@ImportResource加载资源文件,@Value获取属性值，比如有文件config.properties内容如下：123jdbc.username=rootpassword=rooturl=127.0.0.1 则可以通过将此内容配置到XML文件，如config.xml：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd" &gt; &lt;context:property-placeholder location="classpath:/config.properties"/&gt;&lt;/beans&gt; 然后在定义bean时，通过@ImportResource加载文件，通过@Value获取属性的值123456789101112131415161718@Configuration@ImportResource("classpath:config.xml")public class StoreConfig &#123; @Value("$&#123;url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;password&#125;") private String password; @Bean public MyDriverManager myDriverManager() &#123; return new MyDriverManager(url, username, password); &#125;&#125; 注意：这里的用户名字段如果直接为username，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如jdbc.username,jdbc.password等 基于泛型的自动装配比如现有如下接口：12public interface Store&lt;T&gt; &#123;&#125; IntegerStore和StringStore是他的两个实现类：12public class IntegerStore implements Store&lt;Integer&gt; &#123;&#125; 12public class StringStore implements Store&lt;String&gt; &#123;&#125; 那么在定义bean时可以按照如下方法：123456789101112131415@Autowiredprivate Store&lt;String&gt; s1;@Autowiredprivate Store&lt;Integer&gt; s2;@Beanpublic StringStore stringStore() &#123; return new StringStore();&#125;@Beanpublic IntegerStore integerStore() &#123; return new IntegerStore();&#125; 那么s1将会自动装配到StringStore，s2将会是IntegerStore JSR支持JSR250的支持1.@Resource注解变量或方法，且有一个name属性值，默认Spring解释改值为被注入bean的名称，若没有指定name,那么名称从方法名或者属性名得出1234567891011@Servicepublic class JsrServie &#123; @Resource private JsrDAO jsrDAO; @Resource public void setJsrDAO(@Named("jsrDAO") JsrDAO jsrDAO) &#123; this.jsrDAO = jsrDAO; &#125;&#125; 2.@PostConstruct和@PreDestroy@PostConstruct,初始化，相当于init-Method属性@PreDestroy，销毁，相当于destroy-Method属性1234567@PostConstructpublic void init() &#123;&#125;@PreDestroypublic void destroy() &#123;&#125; JSR330的支持 需要依赖javax.injet包 1.@Inject与@Autowired等效，可以使用于类，属性，方法，构造器2.@Named使用特定名称进行依赖注入，与@Component等效 1234567891011@Namedpublic class JsrServie &#123; @Inject private JsrDAO jsrDAO; @Inject public void setJsrDAO(@Named("jsrDAO") JsrDAO jsrDAO) &#123; this.jsrDAO = jsrDAO; &#125;&#125; 参阅: 慕课网：Spring入门篇]]></content>
      <categories>
        <category>Spring笔记</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配之Autowired注解]]></title>
    <url>%2F2018%2F07%2F28%2FSpring-Bean%E8%A3%85%E9%85%8D%E4%B9%8BAutowired%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.可以将@Autowired注解为setter方法1234@Autowiredpublic void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 2.可以用于构造器或成员变量1234@Autowired(required=false)public void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 默认情况下，如果因找不到合适的bean将会导致autowiring失败抛出异常，可以通过将其required设置为false表示并非必须，每个类只能有一个构造器标记为required=true,也就是只能有一个构造器为必须，这种情况下建议使用@Required注解： 1234@Requiredpublic void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; @Required表示标记的bean属性在bean装配时必须被填充，通过在bean定义或者自动装配一个明确的属性值 3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等1234public class BeanSutowired&#123; @Autowired private ApplicationContext context;&#125; 4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean下面的示例中，list添加了@Autowired注解，那么所有的实现BeanInterface接口的bean，假如有BeanimplOne和BeanimplTwo都实现了BeanInterface接口，那么这时list中将包含有BeanimplOne和BeanimplTwo。 123456789101112@Componentpublic class BeanInvoker implements BeanInterface&#123; @Autowired private List&lt;BeanInterface&gt; list; public void say()&#123; System.out.println("list..."); for (BeanInterface bean : list) &#123; System.out.println(bean.getClass().getName()); &#125;&#125; 如果希望数组有序，可以使用@Order注解或者实现org.springframework.core.Ordered接口，但是对map无效 1234@Order(1)@Componentpublic class BeanimplTwo implements BeanInterface&#123;&#125; 5.用于装配key为String的Map下面的示例中，map添加了@Autowired注解，那么所有的实现BeanInterface接口的bean，加入有BeanimplOne和BeanimplTwo都实现了BeanInterface接口，那么这时map中将包含有键为bean名称和值为bean的两个元素。123456789101112@Componentpublic class BeanInvoker implements BeanInterface&#123; @Autowired private Map&lt;String, BeanInterface&gt; map; public void say()&#123; System.out.println("map..."); for (Map.Entry&lt;String, BeanInterface&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + " " + entry.getValue().getClass().getName()); &#125;&#125; 6.@Qualifier 按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一 123@Autowired@Qualifier("beanImplTwo")private BeanInterface beanInterface; 用于指定单独的构造器参数或方法参数 用于注解集合类型变量 可以在bean的定义中使用@Qualifier注解给他限定一个范围，比如1234@Qualifier("beanImpl")@Componentpublic class BeanImplTwo implements BeanInterface&#123;&#125; 然后在注入时，使用@Qualifier限定，则下面的list将会匹配到所有@Qualifier(&quot;beanImp&quot;)的bean123@Autowired@Qualifier("beanImpl")private List&lt;BeanInterface&gt; list; 参阅： 慕课网：Spring入门篇]]></content>
      <categories>
        <category>Spring笔记</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配之各装配项 XML实现和注解实现]]></title>
    <url>%2F2018%2F07%2F27%2FSpring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%90%84%E8%A3%85%E9%85%8D%E9%A1%B9-XML%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、Bean管理的XML配置实现1.Bean的配置项 Id:Bean的唯一标识 Class：对应实现的类 Scope：范围 Constructor arguments：构造器参数 Properties：属性 Autowiring mode：自动装配模式 lazy-initialization mode：懒加载模式 Initialization/destruction method：初始化/销毁方法 2.Bean的定义这里以InjectionImpl中包含InjectionDAO成员变量为例，说明设置注入和构造注入,InjectionImpl类如下： 123public class InjectionServiceImpl implements InjectionService &#123; private InjectionDAO injectionDAO;&#125; 方式一：设置注入bean的XML配置: 1234&lt;bean id="injectionService" class="com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl"&gt; &lt;property name="injectionDAO" ref="injectionDAO"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="injectionDAO" class="com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt; InjectionIml中setter方法: 123public void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 方式二：构造注入bean的XML配置： 1234&lt;bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl"&gt; &lt;constructor-arg name="injectionDAO" ref="injectionDAO"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="injectionDAO" class="com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt; InjectionIml中构造方法： 123public InjectionServiceImpl(InjectionDAOImpl injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 2.Bean的作用域 singleton:单例，一个Bean容器中指存在一份（默认情况下为singleton) prototype：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效 request：每次http请求创建一个实例且仅在当前request内有效 session：同上，每次http请求创建，当前session有效 global session：给予portel的web中有效，如果是在web中，则同session XML文件中的配置1&lt;bean id="beanScope" class="com.pinnuli.spring.ioc.bean.BeanScope" scope="singleton"&gt;&lt;/bean&gt; 3.Bean的生命周期 定义 &rArr; 初始化 &rArr; 使用 &rArr; 销毁 初始化 方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法123456public class ExampleInitializingBean implements InitialingBean&#123; @Override public void afterPropertiesSet() throws Exception&#123; &#125;&#125; 方式二：配置init-methodXML文件中的配置：1&lt;bean id="exampleInitBean" class="example.Example" init-method="init"/&gt; 对应实现类：1234public class ExampleBean&#123; public void init()&#123; &#125;&#125; 销毁: 方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法123456public class ExampleInitializingBean implements DisposableBean&#123; @Override public void destroy() throws Exception&#123; &#125;&#125; 方式二：配置destory-methodXML文件中的配置：1&lt;bean id="exampleInitBean" class="example.Example" init-method="destroy"/&gt; destory方法：1234public class ExampleBean&#123; public void destroy()&#123; &#125;&#125; 配置全局默认初始化、销毁方法123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-init-method="init" default-destroy-mothod="destroy"&gt;&lt;/beans&gt; i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效； ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错； iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。 4.Bean的自动装配 No：什么都不操作 byname：即中的id，根据属性名自动装配， byType：即中的class i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；ii.如果存在多个该类型的bean，则抛出异常，并指出不能使用byType方式进行自动装配iii.如果没有找到匹配的bean，则不进行任何操作以上两种情况bean的XML配置如下： 12345&lt;beans default-autowire="byType"/"byName"&gt; &lt;bean id="autoWiringService" class="com.pinnuli.spring.ioc.autowiring.AutoWiringService"&gt;&lt;/bean&gt; &lt;bean id="autoWiringDAO" class="com.pinnuli.spring.ioc.autowiring.AutoWiringDAO"&gt;&lt;/bean&gt;&lt;/beans&gt; Constructor: 应用于构造器参数，与byType类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常 对应的类中的构造方法和setter方法与设置注入或构造注入一致 二、Bean管理的注解实现1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd" &gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; &lt;context:annotation-config/&gt;仅会查找同一个applicat context中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解通过在基于XML的Spring配置如下标签 &lt;context:component-scan&gt;会扫描所有有bean注解的类，并注册到IOC容器，包含了&lt;context:annotation-config&gt;的全部功能，因而通常只需要使用前者，而不用后者 1&lt;context:component-scan base-package="org.example&gt; base-package表示扫描包下的所有类 2.使用过滤器进行自定义扫描默认情况下，类被自动发现并注册bean的条件是：使用了@Component，@Repository，@Service，@Controller注解，或者使用@Component的自定义注解，可以通过过滤器修改上述的行为 123456&lt;beans&gt; &lt;context:component-scan base-package="org.example"&gt; &lt;context:include-filter type="regex" expression=".*Stub.*Respository"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;context:component-scan/&gt; &lt;/beans&gt; 还可以使用use-default-filters=&quot;false&quot;禁用自动发现与注册 Bean的定义Bean名称是由BeannameGenerator生成的，默认情况下为类名的首字母变为小写 @Component，@Repository，@Service,@Controller都有一个那么属性用于显示设置Bean的名称,如123@Component("beanName")public class BeanAnnotation &#123;&#125; 也可自定义命名策略,实现BeanNameGenerator接口，并一定要包含一个无参构造器123&lt;beans&gt; &lt;context:component-scan base-package="org.example" name-generator="org.example.MyNameGenerator"/&gt;&lt;/beans&gt; Bean的作用域通常情况下启动查找的Spring组件，其scope是singleton，可用@Scope表示scope,1@Scope("prototype") 也可自定义scope策略，实现实现ScopeMetadataResolver接口，并一定要包含一个无参构造器123&lt;beans&gt; &lt;context:component-scan base-package="org.example" name-generator="org.example.MyScopeResolver"/&gt;&lt;/beans&gt; 对于自动装配注解，参见Spring Bean装配之Autowired注解 代理方式有三个值可选：no,interfaces,targetClass，默认情况下为no 可以配置@Scope注解的proxyMode属性来配置代理方式，即XML配置时的scope-proxy属性1@Scope(value="prototype", proxyMode = ScopedProxyMode.TARGET_CLASS) 可以在XML文件中使用scope-proxy属性指定代理123&lt;beans&gt; &lt;context:component-scan base-package="org.example" scope-proxy="interfaces"/&gt;&lt;/beans&gt; 三、Resource&amp;ResourceLoaderResource针对资源文件的统一入口，用于Spring加载资源文件 UrlResource:URL对应的资源，根据一个URL地址即可构建 ClassPathResource：获取类路径下的资源文件 FileSystemResource：获取文件系统里面的资源 ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源 InputStreamResource：针对于输入流封装的资源 ByArrayResource：针对于字节数组封装的资源 ResourceLoader i.所有的application contexts都实现了ResourceLoader接口，即可以通过ApplicationContext获得Resource实例ii.使用参数的前缀说明获取资源的类型 1.类路径下的资源文件1Resource resource = applicationContext.getResource("classpath:config.txt"); 2.文件系统中的资源1Resource resource = applicationContext.getResource("file:/var/SpringDemo/src/main/resources/config.txt"); 3.URL对应的资源1Resource resource = applicationContext.getResource("url:httpS://www.pinnuli.com/index.html"); 没有前缀时，取决于ApplicationContext的路径（之后再添加解释） 1Resource resource = applicationContext.getResource("config.txt"); 参阅： 慕课网：Spring入门篇]]></content>
      <categories>
        <category>Spring笔记</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb 监听器]]></title>
    <url>%2F2018%2F07%2F25%2FJava-Web-%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[按监听的对象划分1.用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口123456789101112public class MyServletContextListener implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent servletcontextevent) &#123; String initParam = servletcontextevent.getServletContext().getInitParameter("initParam"); System.out.println("contextInitialized : initParam = "+initParam); &#125; public void contextDestroyed(ServletContextEvent servletcontextevent) &#123; System.out.println("contextDestroyed"); &#125;&#125; 2.用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口1234567891011public class MyHttpSessionListener implements HttpSessionListener &#123; public void sessionCreated(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionCreated"); &#125; public void sessionDestroyed(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionDestroyed"); &#125;&#125; 3.用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口123456789101112public class MyServletRequestListener implements ServletRequestListener &#123; public void requestDestroyed(ServletRequestEvent servletrequestevent) &#123; System.out.println("requestDestroyed "); &#125; public void requestInitialized(ServletRequestEvent servletrequestevent) &#123; String name = servletrequestevent.getServletRequest().getParameter("name"); System.out.println("requestInitialized name:"+name); &#125;&#125; 按监听的事件划分1.监听域对象自身的创建和销毁的事件监听器 即按监听对象划分的那几种 2.监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener 或 ServletRequestAttributeListener接口1234567891011121314151617public class MyServletContextAttributeListener implements ServletContextAttributeListener &#123; public void attributeAdded(ServletContextAttributeEvent servletcontextattributeevent) &#123; System.out.println("ServletContext_attributeAdded:"+servletcontextattributeevent.getName()); &#125; public void attributeRemoved(ServletContextAttributeEvent servletcontextattributeevent) &#123; System.out.println("ServletContext_attributeRemoved:"+servletcontextattributeevent.getName()); &#125; public void attributeReplaced(ServletContextAttributeEvent servletcontextattributeevent) &#123; System.out.println("ServletContext_attributeReplaced:"+servletcontextattributeevent.getName()); &#125;&#125; HttpSession 和 ServletRequest 同理，只是方法参数类型不同 3.监听绑定到HttpSession域中的某个对象的状态的事件监听器 这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口： 1234567891011121314151617181920212223242526272829public class User implements HttpSessionBindingListener,HttpSessionActivationListener,Serializable &#123; private String username; public void valueBound(HttpSessionBindingEvent httpsessionbindingevent) &#123; System.out.println("valueBound Name:"+httpsessionbindingevent.getName()); &#125; public void valueUnbound(HttpSessionBindingEvent httpsessionbindingevent) &#123; System.out.println("valueUnbound Name:"+httpsessionbindingevent.getName()); &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; //钝化 public void sessionWillPassivate(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionWillPassivate "+httpsessionevent.getSource()); &#125; //活化 public void sessionDidActivate(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionDidActivate "+httpsessionevent.getSource()); &#125;&#125; 绑定和解除绑定：实现HttpSessionBindingListener接口钝化和活化：实现HttpSessionActivationListener和Serializable接口 实现Serializable接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化 参阅： 慕课网：JAVA Web开发技术应用——监听器]]></content>
      <categories>
        <category>JavaWeb笔记</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web 过滤器]]></title>
    <url>%2F2018%2F07%2F25%2FJava-Web-%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器的工作原理过滤器的生命周期过滤器链Web项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？ 过滤器链：过滤器链执行过程: 过滤器分类 @WebFilter,在servlet3中，可以使用@WebFilter注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置 参阅： 慕课网：Java Web开发技术应用——过滤器]]></content>
      <categories>
        <category>JavaWeb笔记</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet]]></title>
    <url>%2F2018%2F07%2F23%2Fservlet%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[servlet生命周期1.初始化，调用init()方法，生成Servlet实例2.响应客户请求，调用service()方法，由service()方法根据提交方式悬着执行doGet()或者doPost()方法3.终止，调用destroy()方法 tomcat装载servlet的三种情况1.Servlet容器启动时自动装载某些Servlet，需要在web.xml文件中的&lt;Servlet&gt;&lt;/Servlet&gt;之间添加&lt;loadon-startup&gt;1&lt;load-sartup&gt; 数字越小优先级越高2.在Servlet容器启动后，客户首次向Servlet发送请求3.Servlet类文件被修改时，重新装载Servlet 获取初始化参数在web.xml中配置Servle时可以配置初始化参数，通过`配置：1234&lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;pinnuli&lt;/param-value&gt;&lt;/init-param&gt; 在Servlet类中可以通过getInitParameter()获取：1String username = this.getInitParameter("username"); 未完待续。。。]]></content>
      <categories>
        <category>JavaWeb笔记</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2F2018%2F07%2F23%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、注解分类 源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在 编译时注解（CLASS）：注解在源码和.class文件都存在 运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解 元注解：注解的注解 二、自定义注解定义：123456789101112//元注解@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented//定义注解和成员变量public @interface Description&#123; String desc(); String author(); int age() default 20;&#125; @Target({ElementType.METHOD,ElementType.TYPE}) 作用域,可以包括CONSTRUCTOR(构造方法)、FIELD(字段)、LOCAL_VARIABLE(局部变量)、METHOD(方法)、PACKAGE(包)、PARAMETER(参数)、TYPE(类和接口)声明中，这里作用域为方法、类和接口 @Retention(RetentionPolicy.RUNTIME) 生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时 @Inherited 标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解 @Documented 生成javadoc包含注解信息 @interface 1.使用关键字@interface定义注解，2.成员以无参无异常方式声明，可以用default指定一个默认值3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即Description(&quot;test&quot;)5.注解可以没有成员名，叫标识注解 使用：@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)1234Description(desc="I am pinnuli",author="pinnuli",age=20)public String test()&#123; return "test";&#125; 三、解析注解 通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑 1.使用类加载器加载类1Class c = Class.forname("com.test.Student"); 2.找到类上的注解,拿到注解实例123if(c.isAnnotationPresent(Description.class))&#123; Description d = (Description)c.getAnnotation(Description.class);&#125; 3.找到方法上的注解 方法一 123456Method[] ms = c.getMethods();for(Method m:ms)&#123; if(m.isAnnotationPresent(Description.class))&#123; Description d = (Description)m.getAnnotation(Description.class); &#125;&#125; 方法二 12345678Method[] ms = c.getMethods();for(Method m:ms)&#123; for(Annotation a:as)&#123; if(a instanceof Description)&#123; Description d = (Description)a; &#125; &#125;&#125; 参阅： 慕课网：全面解析Java注解]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F07%2F22%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一、Class类的使用类是对象，任何一个类都是java.lang.class类的实例对象，这个类，这个实例对象可以有三种表达方式，比如Student类： 任何一个类都有一个隐含的静态成员变量class 1Class c1 = Student.class; 通过getClass方法获得 1Class c2 = Student.getClass(); forName 1Class c3 = Class.forName("com.Student"); c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例—-&gt;通过c1 or c2 or c3创建Student的实例对象1Student stu = c1.newInstance(); 二、动态加载类 静态加载类：编译时加载的类，通过new创建对象是静态加载类 动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题 三、获取方法信息和成员变量，构造函数信息方法信息 所有的public的函数，包括父类继承而来的 1Method[] ms = c.getMethods(); 所有该类自己声明的方法，不问访问权限 1Method[] ms = c.getDeclaredMethods(); 返回值类型的类类型 1Class returnType = ms[i].getReturnType(); 参数列表的类型的类类型 1Class[] paramTypes = ms[i].getParameterTypes(); 方法的名称 1String methodName = ms[i].getName(); 成员变量 所有的public的成员变量的信息 1Field[] fs = c.getFields(); 该类自己声明的成员变量的信息 1Field[] fs = c.getDeclaredFields(); 成员变量的类型的类类型 1Class fieldType = field.getType(); 成员变量的名称 1String fieldName = field.getName(); 构造函数 所有的public构造函数 1Constructor[] cs = c.getConstructors(); 所有的构造函数 1Constructor[] cs = c.getDeclaredConstructors(); 构造函数的参数列表，得到的是参数列表的类类型 1Class fieldType = field.getType(); 更多方法看API文档 四、方法反射的基本操作现有A类如下：1234567891011class A&#123; public void print()&#123; System.out.println("helloworld"); &#125; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase()+","+b.toLowerCase()); &#125;&#125; 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型12A a1 = new A();Class c = a1.getClass(); 2.通过名称和参数列表来获取方法1Method m = c.getMethod("print", int.class,int.class); 3.方法的反射操作1Object o = m.invoke(a1, 10,20); 这个操作的效果等同于a1.print(10,20) 通过方法的反射，我们可以绕过编译 参阅： 慕课网：反射——Java高级开发必须懂的]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Socket应用]]></title>
    <url>%2F2018%2F07%2F21%2FJava-Socket%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、Socket使用时应当注意的一些问题1.设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时 调用setSoTimeout方法设置 12Socket s = new Socket(...);s.setSoTimeout(10000); 对构造器Socket(String host,int port)，可以先构建一个无连接的套接字，再使用超时 123Socket s = new Socket();s.connect(new InetSocketAddress(host,port),timeout);` 2.可中断套接字，用SocketChannel类3.需要解析因特网地址时，可以用InetAddress类4.为多个客户端服务时，可以用多线程解决5.半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用Socket.shutdownInput或Socket.shutdownOutput 二、获取Web数URI和URL URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN 一个URI具有一下语法：[scema:]schemaSpecficPart[#fragment] i.包含schema:部分的URI成为绝对URI，否则为相对URIii.绝对URI的schemaSpecficPart不是以/揩油，则称为不透明的，如:mialto:pinnuli!hostname.comiii.所有绝对的透明URI和所有相对URI都是分层的，如：http://hostname.com/index.html，../../java/net/Socket.html#Socket()iv.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port] java中URI类的作用 解析表示福并将它分解成各种不同组成成分 标识符的相对化和解析相对标识符 使用URLCollection&gt; URLConnection类可以比URL类有更多的控制 必须严格按照以下步骤进行操作：1.调用URL类中的openConnection方法得到URLConnection对象：URLConnection connection = url.openConnection();2.设置请求属性3.调用connect方法连接远程资源:connection.connect();4.建立连接后，可以查询头信息5.访问资源数据，使用getInputStream方法获取一个输入流 这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能 三、提交表单1.提交数据之前，需要创建一个URLConnection对象12URL url = new URL("http;??host/script");URLConnection connection = url.openConnection(); 2.调用setDoOutput方法建立一个输出的连接12connection.setRequestMethod("POST");connection.setDoOutput（true); 3.调用getOutputStream方法获得一个输出流，想服务器发送数据123OutputStreamWriter osw = new OutputStreamWriter(connection.getOutputStream(), "UTF-8");osw.write(name1 + "=" + URLEncoder.eccode(value1,"UTF-8") + "&amp;);osw.write(name2 + "=" + URLEncoder.encode(value2,"UTF-8")); 4.关闭输出流12osw.flush();osw.close(); 5.调用getInputStream方法对服务器的响应1234567BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));StringBuffer response = new StringBuffer();String temp;while ((temp = br.readLine()) != null) &#123; response.append(temp); response.append("\n");&#125; i.设置请求方法时，必须使用大写，如POST，使用post无法识别ii.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法InputStream err = ((HTTPURLConnection) connection).getErrorStream(); URL编码需遵循以下规则： i.保留字符A-Z、a-z、0-9 以及.-*_ii.用+替换所有空格iii.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字比如发送”New York, NY”，可以使用New+York%2C+NY 四、基于TCP的Socket通信1.创建ServerSocket和Socket2.打开连接到Socket的输入/输出流3.按照协议对Socket进行读/写操作4.关闭输入/输出流，关闭Socket服务端（多线程响应多个客户端） 123456789101112//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口ServerSocket serverSocket=new ServerSocket(8888);Socket socket=null;System.out.println("***服务器即将启动，等待客户端的连接***");while(true)&#123; //调用accept()方法开始监听，等待客户端的连接 socket=serverSocket.accept(); //创建一个新的线程 ServerThread serverThread=new ServerThread(socket); //启动线程 serverThread.start();&#125; ServerThread类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public class ServerThread extends Thread &#123; Socket socket = null; public ServerThread(Socket socket) &#123; this.socket = socket; &#125; //线程执行的操作，响应客户端的请求 public void run()&#123; InputStream is=null; InputStreamReader isr=null; BufferedReader br=null; OutputStream os=null; PrintWriter pw=null; try &#123; //获取输入流，并读取客户端信息 is = socket.getInputStream(); isr = new InputStreamReader(is); br = new BufferedReader(isr); String info=null; while((info=br.readLine())!=null)&#123;//循环读取客户端的信息 System.out.println("我是服务器，客户端说："+info); &#125; socket.shutdownInput();//关闭输入流，半关闭 //获取输出流，响应客户端的请求 os = socket.getOutputStream(); pw = new PrintWriter(os); pw.write("欢迎您！"); pw.flush();//调用flush()方法将缓冲输出 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; //关闭资源 try &#123; if(pw!=null) pw.close(); if(os!=null) os.close(); if(br!=null) br.close(); if(isr!=null) isr.close(); if(is!=null) is.close(); if(socket!=null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 客户端 123456789101112131415161718192021//1.创建客户端Socket，指定服务器地址和端口Socket socket=new Socket("localhost", 8888);//2.获取输出流，向服务器端发送信息OutputStream os=socket.getOutputStream();//字节输出流PrintWriter pw=new PrintWriter(os);//将输出流包装为打印流pw.write("用户名：alice;密码：789");pw.flush();socket.shutdownOutput();//关闭输出流//3.获取输入流，并读取服务器端的响应信息InputStream is=socket.getInputStream();BufferedReader br=new BufferedReader(new InputStreamReader(is));String info=null;while((info=br.readLine())!=null)&#123; System.out.println("我是客户端，服务器说："+info);&#125;//4.关闭资源br.close();is.close();pw.close();os.close();socket.close(); 五、基于UDP的SOcket通信1.定义发送信息2.创建DatagramPacket，包含将要发送的信息3.创建DatagramSocket4.发送数据服务端 接收客户端发送的数据 12345678910//1.创建服务器端DatagramSocket，指定端口DatagramSocket socket=new DatagramSocket(8800);//2.创建数据报，用于接收客户端发送的数据byte[] data =new byte[1024];//创建字节数组，指定接收的数据包的大小DatagramPacket packet=new DatagramPacket(data, data.length);//3.接收客户端发送的数据socket.receive(packet);//此方法在接收到数据报之前会一直阻塞//4.读取数据String info=new String(data, 0, packet.getLength());System.out.println("我是服务器，客户端说："+info); 向客户端响应数据 12345678910//1.定义客户端的地址、端口号、数据InetAddress address=packet.getAddress();int port=packet.getPort();byte[] data2="欢迎您!".getBytes();//2.创建数据报，包含响应的数据信息DatagramPacket packet2=new DatagramPacket(data2, data2.length, address, port);//3.响应客户端socket.send(packet2);//4.关闭资源socket.close(); 客户端 向服务器端发送数据 12345678910//1.定义服务器的地址、端口号、数据InetAddress address=InetAddress.getByName("localhost");int port=8800;byte[] data="用户名：admin;密码：123".getBytes();//2.创建数据报，包含发送的数据信息DatagramPacket packet=new DatagramPacket(data, data.length, address, port);//3.创建DatagramSocket对象DatagramSocket socket=new DatagramSocket();//4.向服务器端发送数据报socket.send(packet); 接收服务器端响应的数据 12345678910//1.创建数据报，用于接收服务器端响应的数据byte[] data2=new byte[1024];DatagramPacket packet2=new DatagramPacket(data2, data2.length);//2.接收服务器响应的数据socket.receive(packet2);//3.读取数据String reply=new String(data2, 0, packet2.getLength());System.out.println("我是客户端，服务器说："+reply);//4.关闭资源socket.close(); 当Socket关闭时，输入输出流也就关闭了 参阅： 慕课网：Java Socket应用—通信是这样练成的 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java io流与文件]]></title>
    <url>%2F2018%2F07%2F19%2Fjava-io%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、流读写字节InputStream.read和OutpueStream.write组合流过滤器 某些流（如FileInputStream或者FileOutputStream）只能支持在字节级别上的读写，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如： 123FileInputStream fin = new FileInputStream("test.txt");DataInputStream din = new DataInputStream(fin);double s = din.readDouble(); 需要使用缓冲，可以使用一下构造器： 123DataInputStream din = new DataInputStream( new BUfferInputStream( new FileInputStream(test.txt"))); 需要浏览下一个字节以确定是否是想要的值时，可以： 1234567PushbackInputStream pbin = new PushbackInputStream( new BUfferInputStream( new FileInputStream(test.txt")));//预读写一个字节int b = pbin.read();//不是所期望时将其推回流中if(b != '&lt;') pbin.unead(b); 二、文本输入与输出输出：PrintWritePrintWrite out = new PrintWrite(&quot;test.txt&quot;);等同于PrintWrite out = new PrintWrite(new FileWrite(&quot;test.txt&quot;));输入：Scanner文本格式存储对象用自己的格式依次存储各个字段，以特定字符分隔，如：PINUULI|201625010417|1997|guangdong 三、读写二进制数据读：实现DataInput接口，如DataInputStream，readInt，readBoolean等方法写：实现DataOutput接口，如DataOutputStream，writeInt，writeBoolean等方法随机访问文件：RandomAccessFile可以在文件中的任何位置查找或者写入数据：12RandomAccessFile in = new RandomAccessFile("test.txt","r");RandomAccessFile inOut = new RandomAccessFile("test.txt","rw"); 四、ZIP文件每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。读：ZipInputStream 用getNextEntry方法返回文档中这些项（文件）的ZipEntry对象 ZipInputStream的read方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用closeEntry读入下一项 在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项 通读zip文件： 123456789ZipInputStream zin = new ZipInputStream(new FileInputStream("test.zip"));ZipEntry entry;Scanner in = new Scanner(zin);while((entry = zin.getNextEntry()) != null)&#123; while(in.hasNextLine())&#123; System.out.println(in.nextLine()); &#125; zin.closeEntry();&#125; 写：ZipOutputStream 对于想要放入到zip文件中的每一个项，都应该创建一个ZipEntry对象，并将文件名传递给ZipEntry的构造器 调用ZipOutputStream的putNextEntry方法开始写出新文件，并将数据发送到zip流中 完成时调用closeEntry方法,如： 12345678910FileOutputStream fout = new FilePutputStream("test.zip");ZipOutputStream zout = new ZipOutputStream(fout);// 写一个文件ZipEntry ze = new ZipEntry("filename");zout.putNextENtry(ze);send data to zout;zout.closeEntry();zout.close(); 五、对象流与序列化 序列化:ObjectOutputStream.writeObject(), 反序列化：ObjectInputream.readObject()， 都需要实现Serializable接口 只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等 序列化算法： 对于遇到的每个对象都关联一个序列号 对于每个对象，第一次遇到时，保存其对象数据到流中 如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反 对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联 当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用 修改默认的序列化机制 一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。 当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现Serializable接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如： 1234567891011121314151617181920public class LabeledPoint implements Serializable&#123; private String label; //对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标 private transient Point2D.Double point; ··· //重写读写方法 private void writeObject(ObjectOutputStream out) throws Exception&#123; out.defaultWriteObjecy(); out.writeDouble(point.getX()); out.writeDouble(point.getY()); &#125; private void readObject(ObjectInputStream in) throws IOException&#123; in.defaultReadObject(); double x = in.readDouble(); double y = in.readDouble(); point = new Point2D.DOuble(x,y); &#125;&#125; 当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现Externalizable接口，指定要保存的域 12345678910111213141516public class Student implements Externalizable&#123; private String name; private String stuId; private int age; ··· //重写读写方法 private void writeExternal(ObjectOutput out) throws IOException&#123; out.writeUTF(name); out.writeInt(age); &#125; private void readExternal(ObjectInput in) throws IOException&#123; name = in.readUTF(): age = in.readInt(); &#125;&#125; &gt; PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。 六、操作文件Path 静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\）连接起来，返回一个Path对象，详情见API。如 12Path absolutye = Paths.get("/home"."cay");Path relative = Paths.get("myprog","conf","user.properties"); 读写文件：Files类可以使得普通文件操作变得快捷 读取文件所有内容：byte[] bytes = Files.readAllBytes(path);,之后可以将其当做字符串String content = new String(bytes,charset); 向指定文件追加内容：Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND); 参阅： 慕课网：文件传输基础——Java IO流 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 Let's Encrypt用Certbot获取Https证书 部署nginx]]></title>
    <url>%2F2018%2F07%2F15%2Fcentos7-Let-s-Encrypt%E7%94%A8Certbot%E8%8E%B7%E5%8F%96Https%E8%AF%81%E4%B9%A6-%E9%83%A8%E7%BD%B2nginx%2F</url>
    <content type="text"><![CDATA[1.检查nginx下是否有--with-http_stub_status_module 和--with-http_ssl_module两个模块，安装之后再重新编译1nginx -V 2.用http克隆github上的certbot1git clone https://github.com/certbot/certbot /opt/certbot-master 3.安装所有依赖1/opt/certbot-master/letsencrypt-auto --help 4.关闭nginx，检出80端口，443端口是否有开启1nginx -s stop 1firewall-cmd --query-port=80/tcp 1firewall-cmd --query-port=443/tcp 没有的话就开启1firewall-cmd --permanent --zone=public --add-port=80/tcp 5.获取证书1/opt/certbot-master/letsencrypt-auto --nginx -d www.pinnuli.com 6.配置nginx（也可选择自动配置)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main '$remote_addr - $remote_user [$time_local] "$request" '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/www/pinnuli.github.io; include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; server &#123; server_name www.pinnuli.com; # managed by Certbot root /var/www/pinnuli.github.io; include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; listen [::]:443 ssl ipv6only=on; # managed by Certbot listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot &#125;&#125; 7.设置自动更新 未完待续。。。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架]]></title>
    <url>%2F2018%2F07%2F11%2Fjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一、迭代器iterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素， next()方法 逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用； java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用 用”for each”循环遍历类集的内容， remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态 对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉 二、List有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类 ArrayList 基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道 适用于需要进行随机访问时 LinkedList 基于双向链表， 对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值 适用于顺序访问 三、Set等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一 HashSet 基于散列表的集，无序 存入的元素必须定义有hashCode()，以得到散列码 可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变 可以设置装填因子来实现再散列 适用于不关心访问顺序，需要查找大容量容器时 TreeSet 基于红黑树排序，有序 存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator 每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问 适用于存储大量需要进行快速检索的排序信息的情况 BitSet 用于存放一个位序列 四、Queue双端队列可以同时在头部或者尾部添加或删除元素，有两个实现 inkedList ArrayList PriorityQueue 基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序 按照任意顺序插入，却可以按照顺序进行检索 和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator 五、Map对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。键不存在时get方法返回null，可以用getOrDefault返回默认值，test.get(id,0)更新映射项正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，counts.put(word,counts.get(word)+1),需要解决一个问题，就是键第一次出现时，这时可以有三种方法 counts.put(word,counts.getOrDefault(word,0) + 1) 先调用putIfAbsent，只有原先键存在时才会放一个值,counts.putIfAnsent(word,0) counts.put(word,counts.get(word)+1) counts.merge(word,1,Interger::sum)(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联 映射视图集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图 键集：Set&lt;K&gt; keySet()， 值集：Collection&lt;V&gt; values()， 键/值对集：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除 散列 散列码，由对象的实例域产生的一个整数，由hashCOde()产生 散列表，用链表数组实现，每个列表称为桶 散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询 新版jdk使用红黑树和List（数据多用树，少时用List) 散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表 HashMap 比较快，适用于不需要按照排列顺序访问键时 TreeMap 按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序 WeakHashMap 使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键 如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目 适用于需要缓存时 LinkedHashMap 链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，收到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置 用于实现高速缓存的“最近最少使用”原则 六、视图与包装器轻量级集合包装器例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法12Card[] cardDeck = new Card[52];List&lt;Card&gt; cardList = Arrays.asList(cardDeck); 返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小,例如Collections类的一些使用方法，nCopied(100,&quot;KKK&quot;),single(anObject)等，返回一个不可修改的试图对象 子范围 相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用List group2 = staff.subList(10,20);,类似于String类中获取子串 可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除 对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集， SortedSet subSet(E from, E to)SortedSet headSet(E to)SortedSet tailSet(E from) 不可修改的视图 只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改 访问器方法从原始集合对象中获取值 视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如： unmodifiableCollection方法将返回一个集合，但他的equals()方法不调用底层集合的，而是调用它继承了Object类的equals()方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的 同步视图 实现多线程访问，确保集合的线程安全，例如Collections.synchronizedMap 受查视图 用来对泛型类型进行检测，例如Collections.checkedList 参阅： java核心技术 卷I：基础知识]]></content>
      <categories>
        <category>JavaSE笔记</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习笔记]]></title>
    <url>%2F2018%2F05%2F03%2FJSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、jsp简介1、jsp三大指令page指令:&lt;%@page 属性=”” %&gt;,位于jsp页面顶端，可以有多个 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" import="java.text.*"%&gt; taglib指令：标签库 includeinclude指令:&lt;%@include file=&quot;date.jsp&quot;%&gt;include动作:&lt;jsp:include page=&quot;url&quot; flush=&quot;true|false&quot;/&gt; page:要包含的页面,flush：被包含的页面是否从缓冲区读取 include指令与include动作的区别： forward动作：&lt;jsp: forward page=&quot;url&quot;/&gt;等同于：request.getRequestDispatcher(&quot;/url&quot;).forward(request,response); param动作：&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt;常与一起使用，作为其的子标签: 1234&lt;jsp:forward page="user.jsp"&gt; &lt;%--用&lt;jsp:param "&gt;&lt;/jsp:param&gt;添加参数--%&gt; &lt;jsp:param name="email" value="11111111@163.com"&gt;&lt;/jsp:param&gt;&lt;/jsp:forward&gt; 2、jsp注释 html的注释 jsp的注释&lt;%– jsp注释 –&gt;（客户端不可见） jsp脚本注释://单行/ / 多行 3、jsp脚本&lt;% java代码 %&gt; 4、jsp声明变量或方法&lt;%! java代码 %&gt; 5、jsp表达式&lt;%=表达式 %&gt; ps:不可;分号结束 6、jsp页面的生命周期 二、jsp内置对象 九大内置对象：out,request,response,session,application,Page,pageContext,exception,config out 123456789101112131415&lt;% out.println("&lt;h2&gt;静夜思&lt;/h2&gt;"); out.println("床前明月光&lt;br&gt;"); out.println("疑是地上霜&lt;br&gt;"); out.flush(); /*out.clear();会抛出异常*/ out.clearBuffer();//这里不会抛出异常 out.println("举头望明月&lt;br&gt;"); out.println("低头思故乡&lt;br&gt;"); %&gt; 缓冲区大小：&lt;%= out.getBufferSize()%&gt;byte&lt;br&gt; 缓冲区剩余大小：&lt;%= out.getRemaining()%&gt;byte&lt;br&gt; 是否自动清空缓冲区：&lt;%= out.isAutoFlush()%&gt;&lt;br&gt; request 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;% request.setCharacterEncoding("utf-8");//解决post中文乱码问题，但无法解决get，get解决需要直接Tomcat配置文件 request.setAttribute("password","123456");//设置属性密码 %&gt; 用户名：&lt;%= request.getParameter("username")%&gt;&lt;br&gt; 爱好： &lt;% if(request.getParameterValues("favorite") != null)&#123; //这里需要判断为不为空，jsp这里不能将String数组看为Boolean String[] favorites = request.getParameterValues("favorite"); for (int i = 0; i &lt; favorites.length; i++) &#123; out.println(favorites[i] + "&amp;nbsp;&amp;nbsp;&amp;nbsp;"); &#125; &#125; String realPath = request.getRealPath("requset.jsp");%&gt;&lt;br&gt; 密码： &lt;%=request.getAttribute("password")%&gt;&lt;br&gt; 请求体的MIME类型： &lt;%=request.getContentType()%&gt;&lt;br&gt; 协议类型和版本号： &lt;%=request.getProtocol()%&gt;&lt;br&gt; 服务器主机名： &lt;%=request.getServerName()%&gt;&lt;br&gt; 服务器端口号： &lt;%=request.getServerPort()%&gt;&lt;br&gt; 请求文件长度： &lt;%=request.getContentLength()%&gt;&lt;br&gt; 请求的客户端地址： &lt;%=request.getRemoteAddr()%&gt;&lt;&lt;br&gt; 请求的真实路径： &lt;%=request.getRealPath("requset.jsp")%&gt;&lt;br&gt; 请求的上下文路径： &lt;%=request.getContextPath()%&gt; response 12345678910111213141516&lt;% response.setContentType("text/html;charset=utf-8"); out.println("&lt;h1&gt;response内置对象&lt;/h1&gt;"); out.println("&lt;hr&gt;"); //out.flush(); /* 因为getWrite获得的输出流对象会先于内置对象out输出， 所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer 再输出out*/ PrintWriter outer = response.getWriter(); outer.println("大家好，我是response生成的输出流outer");// response.sendRedirect("login.jsp");//重定向// response.sendRedirect("request.jsp"); request.getRequestDispatcher("request.jsp").forward(request,response);//转发 %&gt; 请求转发和请求重定向的区别： sessionHttpSession的实例，周期：在第一个jsp页面被加载时自动创建，即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束，在服务器的几个页面之间切换，服务器应当知道这是一个客户，就可以用session对象 12345678910111213141516171819202122232425262728293031&lt;% SimpleDateFormat sdf = new SimpleDateFormat("yyyy年mm月dd日 HH:mm:ss"); Date d = new Date(session.getCreationTime()); session.setAttribute("username","pinnuli"); session.setAttribute("password","123456"); session.setAttribute("age",20);// session.setMaxInactiveInterval(10);//设置session最大生成期限，单位秒,也可在web.xml中设置session-timeout %&gt; Session创建时间： &lt;%=sdf.format(d)%&gt;&lt;br&gt; Session的ID： &lt;%=session.getId()%&gt;&lt;br&gt; Session中获取属性值： &lt;%=session.getAttribute("username")%&gt;&lt;br&gt; Session保存的属性数组： &lt;% String[] names = session.getValueNames(); for(int i=0; i&lt;names.length; i++)&#123; out.println(names[i] + "&amp;nbsp;&amp;nbsp;"); &#125;// session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session %&gt;&lt;br&gt; &lt;%--测试不同页面是否同一个session--%&gt; &lt;a href="session_page2.jsp"&gt;跳转到session_page2&lt;/a&gt; application实现用户间数据的共享，可存放全局边变量，相当于java的静态变量 12345678910111213141516&lt;% application.setAttribute("city","广州"); application.setAttribute("postcode","510000"); application.setAttribute("email","guangzhou@163.com"); %&gt; 所在城市：&lt;%=application.getAttribute("city")%&gt;&lt;br&gt; 所有属性： &lt;% Enumeration attributes = application.getAttributeNames(); while (attributes.hasMoreElements())&#123; out.println(attributes.nextElement() + "&amp;nbsp;&amp;nbsp;"); &#125; %&gt;&lt;br&gt; jsp(serviet)引擎名和版本号：&lt;%=application.getServerInfo()%&gt;&lt;br&gt; page、pageContext 123456789101112&lt;h3&gt;page:&lt;/h3&gt;当前page页面的字符串描述：&lt;%=page.toString()%&gt;&lt;br&gt;&lt;br&gt; &lt;h3&gt;pageContext:&lt;/h3&gt;用户名：从session中获取属性-&lt;%=pageContext.getSession().getAttribute("username")%&gt;&lt;br&gt; &lt;%--跳转到其他页面--%&gt; &lt;%--&lt;% pageContext.forward("out.jsp"); %&gt;--%&gt; include方法，包含其他页面: &lt;% pageContext.include("out.jsp"); %&gt; exception 123异常消息：&lt;%=exception.getMessage()%&gt;&lt;br&gt; 异常的字符串描述：&lt;%=exception.toString()%&gt; 三、jsp使用Javabean1. Javabean的设计原则 必须是公有类 必须包含无参构造方法 属性私有 用getter()和setter()进行封装 例如： 1234567891011121314151617181920212223242526public class Students&#123; private String name; private int age; public Students()&#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 2. 存取Javabean有关的jsp动作元素在jsp页面中使用Javabeans： 方法一：像使用普通java类一样，创建Javabean实例方法二：在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty &lt;jsp:useBeans&gt; 在jsp页面中实例化或者在指定范围内使用Javabean： &lt;jsp:useBeans id=&quot;标示符&quot; class=&quot;java类名&quot; scope=&quot;作用范围&quot;/&gt; scope属性：指定Javabean的作用范围page：当前页面,重定向和转发都无效request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效application:可通过application.getAttribute()取得Javabean对象，不同会话都有效 例如：123&lt;jsp:useBean id="myUsers" class="com.po.Users" scope="application"&gt;&lt;/jsp:useBean&gt;用户名：&lt;jsp:getProperty name="myUsers" property="username"&gt;&lt;/jsp:getProperty&gt;密码：&lt;jsp:getProperty name="myUsers" property="password"&gt;&lt;/jsp:getProperty&gt; 也可使用内置对象获取：12用户名：&lt;%=((Users)application.getAttribute("myUsers")).getUsername()%&gt;密码： &lt;%=((Users) application.getAttribute("myUsers")).getPassword()%&gt; &lt;jsp:setProperty&gt; 1234567891011根据表单自动匹配所有属性:&lt;jsp:setProperty name="myUsers" property="username"&gt;&lt;/jsp:setProperty&gt;根据表单匹配部分属性:&lt;jsp:setProperty name="myUsers" property="username"&gt;&lt;/jsp:setProperty&gt;与表单无关，通过手工赋值给属性:&lt;jsp:setProperty name="myUsers" property="password" value="hahahaha"&gt;&lt;/jsp:setProperty&gt;通过url传参数给属性赋值:&lt;jsp:setProperty name="myUsers" property="password" param="testparam"&gt;&lt;/jsp:setProperty&gt; &lt;jsp:getProperty&gt; 12使用getProperty获取属性值:&lt;jsp:getProperty name="myUsers" property="username"&gt;&lt;/jsp:getProperty&gt; 参阅： 慕课网：JAVA遇见HTML——JSP篇]]></content>
      <categories>
        <category>Jsp笔记</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的使用]]></title>
    <url>%2F2018%2F04%2F30%2Fvim%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、一般模式：光标的移动、复制粘贴、搜索替换移动光标： 向左移动一个字符：h 或 ← 向右移动一个字符：l 或 → 向上移动一个字符：k 或 ↑ 向下移动一个字符：j 或 ↓ 向左移动n个字符：n + h（其他同理)，如10h向右移动这一行的n个字符(会换到下一行)：n + space,如20space屏幕向上移动一页：Ctrl + b屏幕向下移动一页：Ctrl + f屏幕向上移动半页：Ctrl + u屏幕向下移动半页：Ctrl + d移动到非空格的下一行：+移动到非空格的上一行：-移动到屏幕最上方那一行的第一个字符：H移动到屏幕最中间那一行的第一个字符：M移动到屏幕最下方那一行的第一个字符：L 移动到这个文件的最后一行：G 移动到这个文件的第n行：nG 移动到这个文件的第一行:gg 向下移动n行：n + enter,如10enter 加粗部分为常用，以下同理 搜索替换： 向光标往下搜索一个word的字符串：/word 向光标往上搜索一个word的字符串：?word 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc 删除 向前（后）删除一个字符：x(X)，相当于backspace 连续向后删除n个字符： nx,如10x 删除光标所在的一整行：dd 删除光标所在的向下n行：ndd 删除光标所在到第一行的所有数据：d1G输出光标所在到最后一行的所有数据:dG删除光标所在到该行最后一个字符：d$删除光标所在到该行第一个字符：d0 复制 复制光标所在的那一行：yy 复制光标所在的向下n行：nyy 复制光标所在行到第一行的所有数据：y1G复制光标所在行到最后一行的所有数据:yG复制光标所在到该行最后一个字符：y$复制光标所在到该行第一个字符：y0 粘贴 将已复制的数据在光标下（上）一行贴上：p(P); 将光标所在行与 下一行的数据结合成一行： J 重复删除多个数据:c，如向下删除10行：10cj 复原前一个动作：u 重复上一个动作：Ctrl + r 二、一般模式到编辑模式的切换进去输入模式 i/I 从目前光标所在处输入：i 从目前所在行的第一个非空格符处开始输入：I a/A从目前光标所在的下一个字符处开始输入:a从光标所在行的最后一个字符处开始输入:A o/O 在光标所在的下一行输入新的一行：o 在光标所在的上一行输入新的一行：O 进入取代模式 r/R 取代光标所在的那一个字符一次：r 一直取代光标所在的字符，直到按esc 三、一般模式到命令行模式的切换指令行的存储、离开等 保存编辑： :w 强制写入： :w! 退出： :q 强制退出，不保存修改： :q! 保存修改后退出： :wq 将修改后的数据另存为一个文件： :w filename 在当前编辑的数据中，读入另一个文件的数据： :r filename将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename 暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 vim环境的变更显示行号： :set nu取消显示行号： :set nonu]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用技巧]]></title>
    <url>%2F2018%2F04%2F30%2FIntelliJ-IDEA-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一、跳转快捷键窗口切换：Ctrl + alt + [ / ]文件切换：alt + -&gt; / &lt;-关闭文件：ctrl + f4最近修改文件： ctrl + tab + E最近浏览文件： ctrl + E回到上次编辑的地方 last edit location: ctrl + shift + backspace回到上次浏览的地方 back/forward: ctrl + alt + -&gt;/&lt;-利用书签跳转：bookmarks:f11bookmarks mnemonic: ctrl + f11show bookmarks: shift + f11书签跳转：Ctrl + 1（n）收藏（类或方法）：shift + alt + FemacsIDEAs 跳转：shift + j(这个是自己设的) 然后按要找单词的首字母，如p，然后选择编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n) 从文件去到编辑区：esc 二、精准搜索搜索类：ctrl + alt + N(Ctrl + N 已被vim占用）搜索文件： ctrl + shift + N搜索符号（方法和属性）：ctrl + shift + alt + N搜索字符串： ctrl + shift + F Match case :区分大小写 Words：搜索的字符串是一个单词 Regex：按照正则表达式搜索 File mask:指定文件类型 In Project：在项目下搜搜 Module：在当前模块下搜索 Directory：在指定目录下搜索 Scope：在指定范围下搜索 待补充。。。 参阅： 慕课网：IntelliJ IDEA神器使用技巧]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程并发常见问题基于信号量解决方法总结：生产者/消费者问题、读/写者问题、银行家算法、哲学家进餐]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%2F</url>
    <content type="text"><![CDATA[一、信号量 信号量是一个与队列有关的整型变量。 可以初始化成非负数； semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行； semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。 信号量原语semWait和semSignal的定义1234567891011121314151617181920strcut semaphore&#123; int count; aueueType queue;&#125;;void semWait(semaphore s) &#123; s.count--; if(s.count &lt; 0) &#123; place this process in s.queue; block this process; &#125;&#125;void semSignal(semaphore s) &#123; s.count ++; if(s.count &lt;= 0) &#123; remove a process P from s.queue; place process P on ready list; &#125;&#125; 信号量实现互斥12345678910111213const int n;semaphore s = 1;void P(int i) &#123; while(true) &#123; semWait(s); operate; semSignal(s); &#125;&#125;void main() &#123; parbegin(P(1), P(2), ...,P(n));&#125; 总结信号量 一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。 用于互斥时，S初值为1，取值为1~ - (n-1) （相当于临界区的通行证，实际上也是资源个数） S=1：临界区可用 S=0：已有一进程进入临界区 S&lt;0：临界区已被占用，|S|个进程正等待进入 用于同步时，S初值&gt;=0 S&gt;=0:表示可用资源个数 S&lt;0: 表示该资源的等待队列长度 semWait、semSignal操作 semWait(S)：请求分配一个资源。 semSignal(S)：释放一个资源。 semWait、semSignal操作必须成对出现。 用于互斥时，位于同一进程内； 用于同步时，交错出现于两个合作进程内。 多个semWait操作的次序不能颠倒，否则可能导致死锁。 多个semSignal操作的次序可任意。 二、生产者/消费者问题 问题描述： 有一个或多个生产者生产某种类型的数据，并放置在缓冲区中； 有一个消费者从缓冲区中取数据，每次取一项； 系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区; 缓存已满时，生产者不能继续添加数据； 缓存已空时，消费者不能继续移走数据。 producer: 12345678while(true) &#123; /* produce item v */ while((in + 1) % n == out) //等待缓存有空位 /* doing nothing */ b[in] = v; in = (in + 1) % n;&#125; consumer: 12345678while(true) &#123; while(in == out) //此时缓存为空，等待生产者生产放入缓存后才可消费 /* doing nothing */ w = b[out]; out = (out + 1) % n; /* consume item w */&#125; 有限缓冲区： 使用信号量解决有限缓冲区生产者消费者问题: n 表示已生产产品的数量s 用来控制互斥e 表示空闲空间数目 123456789101112131415161718192021222324semaphore n = 0, s = 1, e = buf - size;void producer() &#123; while(true) &#123; produce(); semWait(e); semWait(s); append(); semSignal(s); semSignal(e); &#125;&#125;void consumer() &#123; while(true) &#123; semWait(n); semWait(s); take(); semSignal(s); semSignal(e); consume(); &#125;&#125; 例题1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。 分析： 生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。 数据结构： semaphore dish, apple, banana; dish: 表示盘子是否为空,用于控制互斥 apple：表示盘子中是否有苹果，初始值为0 banana:表示盘子中是否有香蕉，初始值为0 123456789101112131415161718192021222324 process father() &#123; semWait(dish); put the apple in the dish; semSignal(apple);&#125;process mother() &#123; semWait(dish); put the banana in the dish; semSignal(banana);&#125;process son() &#123; semWait(banana); get the banana from the dish; semSignal(dish);&#125;process daughter() &#123; semWait(apple); get the apple from the dish; semSignal(dish);&#125; 2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。 分析： 实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系 数据结构：semaphore s1, s2; s1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0； 12345678910111213141516process p1() &#123; while(true)&#123; semWait(s1); Pick a white chessman; semSignal(s2); &#125;&#125;process p2() &#123; while(true)&#123; semWait(s2); Pick a white chessman; semSignal(s1); &#125;&#125; 3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。 分析： 实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室 数据结构： strcut { char name[10]; int number; } a[100]; //表示进入阅览室的小朋友 semaphore mutex, seatcount; mutex: 用来控制互斥，初始值为1 seatcount： 对空座位进行计数，初始值为100； 初始化入室人员信息 for(int i = 0; i &lt; 100; i++){ a[i].number = i; a[i].name = null; } 12345678910111213141516171819202122 process readeri(char readername[]) &#123; semWait(seatcount); //等待空余作为，若人数未满100，则直接进入，到达100，则等待 semWait(mutex); //控制互斥 /* 进入是登记 */ for(int i = 0; i &lt; 100; i++) if(a[i].name == null)&#123; //找到名字为空的座位 a[i].name = readername; break; &#125; reader get the seat nember i; semSiganl(mutex); go into the reading room and sit down at the seat number i. /* 离开时登记 */ semWait(mutex); a[i].name = null; semSignal(mutex); semSignal(seatcount); leave reading room;&#125; 二、读/写者问题 描述： 有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件： 任意多的读进程可以同时读文件； 一次只有一个写进程可以写文件； 如果一个写进程正在写文件，那么禁止任何读进程读文件。 读者优先 分析： 当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。 数据结构： readcount: 控制wsem的的设置 wsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。 x: 用于确保readcount被正确更新。 123456789101112131415161718192021222324252627int readcount;semphore x = 1, wsem = 1;void reader() &#123; while (true) &#123; semWait(x); readcount++; if(readcount==1) semWait(wsem); //如果是第一个读者，则要控制wsem semSignal(x); READUNIT(); semWait(x); readcount--; if(readcount==0) semSignal(wsem); semSignal(x); &#125;&#125;void writer()&#123; while (true) &#123; semWait(wsem); WRITEUNIT(); semSignal(wsem); &#125;&#125; 实例： 独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法) 数据结构： mutex1/mutex2: 用于确保count1/count2被准备更新 count1/count2: 控制wait的设置 wait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。 123456789101112131415161718192021222324252627 semaphore wait=1, mutex1=1, mutex2=1; int count1=0, count2=0; process P east()&#123; semWait(mutex1); count1++; if(count1==1) semWait(wait); semSignal(mutex1); through the singal-log bridge； semWait(mutex1); count1--; if(count1==0) semSignal(wait); semSignal(mutex1); &#125;process P west()&#123; semWait(mutex2); count2++; if(count2==1) semWait(wait); semSignal(mutex2); through the singal-log bridge； semWait(mutex2); count2--; if(count2==0) semSignal(wait); semSignal(mutex2); &#125; 待整理。。。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git多账号配置，同时使用多个代码托管平台]]></title>
    <url>%2F2018%2F04%2F09%2Fgit%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。 ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。 1 生成密钥这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空 1ssh-keygen -T rsa -C "example@qq.com" 生成github的密钥 生成osc的密钥 查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc) 1ls -a /root/.ssh 2 接下来配置多账号在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容 123456789101112#github Host github.com HostName github.com IdentityFile ~/.ssh/id_rsa_github User pinnuli#osc Host gitee.com HostName gitee.com IdentityFile ~/.ssh/id_rsa_osc User pinnuli 3 把对应的公钥放到github和osc上面 4 测试是否成功1ssh -T git@github.com 1ssh -T git@gitee.com 至此，git多账号配置完毕，需要更多账号也是一样的道理]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 配置实现端口转发]]></title>
    <url>%2F2018%2F04%2F04%2Fnginx-%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[最近在部署一个小程序的后台，但是小程序调用的接口是不能带端口号的，那么如果服务器上面80端口已经被其他程序占用，就只能采用端口转发或者虚拟目录，我采用的是端口转发，或者说当在一台主机上需要部署多个web应用，并且需要能在80端口访问这些web时，就可以采用这种方法，也可以叫做nginx反向代理用于实现负载均衡，这里记录一下遇到的一些小问题。 加入服务器域名是test.com,那么你可以通过test.com/news在80端口访问新闻应用，但是服务器上分配的是其他端口，如8081。对应的nginx配置如下： 80端口的配置： 访问test.com/news =&gt; 127.0.0.1:8081 ,这里有一个需要注意的地方是转发的url最后需要加上’/‘，这相当指定了url’/‘,如果代理服务器地址中是带有URL的，此URL会替换掉 location 所匹配的URL部分, test.com/news/api,访问的是ip:8081/api;而如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器,test.com/news/api,访问的是ip:8081/news/api; 123456789101112131415161718server &#123; listen 80; # listen [::]:80 default_server; server_name test.com root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; location /news&#123; proxy_pass http:test.com:8081/; &#125; &#125; 8081端口的配置： 与平时配置没什么差别 1234567891011121314151617181920212223242526272829 server &#123; listen 8081; server_name localhost; root /var/www/project; location / &#123; index index.php index.html index.htm; if ( !-e $request_filename)&#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125; &#125; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; #root /usr/share/ngixn/html; #&#125; #我部署的是PHP项目，这里配置PHP解析 location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include /etc/nginx/fastcgi_params; include /etc/nginx/fastcgi.conf; &#125;&#125;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsoup要点记录]]></title>
    <url>%2F2018%2F03%2F16%2Fjsoup%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[查找dom元素 getElementById: 根据id查询 getElementsByTag: 根据tag名称查询 getElementsByClass: 根据样式class名称查询 getElementsByAttribute: 根据属性名查询 getElementsByAttributeValue: 根据属性名和属性值查询 实例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //通过标签名称查询 Elements elements = doc.getElementsByTag("title"); Element element = elements.get(0); String title = element.text(); System.out.println("网页标题：" + title); //获取首个标题标签内容 Element titleElement = doc.getElementsByTag("title").first(); System.out.println("首个标题： " + titleElement.text()); //通过id查询 Element idElement = doc.getElementById("site_nav_top"); System.out.println("id查询：" + idElement.text()); //通过class样式获取查询 Elements itemElements = doc.getElementsByClass("post_item"); System.out.println("**********样式查询**********"); for(Element e: itemElements) &#123; System.out.println(e.text()); System.out.println("-------"); &#125; //属性名称查询 Elements attrElements = doc.getElementsByAttribute("width"); System.out.println("**********属性查询**********"); for(Element e: attrElements) &#123; System.out.println(e.toString()); &#125; //属性名称和属性值查询 Elements attrValueElements = doc.getElementsByAttributeValue("target", "_blank"); System.out.println("**********属性和属性值查询**********"); for(Element e: attrValueElements) &#123; System.out.println(e.toString()); &#125; &#125;&#125; 查找dom元素属性值实例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo2 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //获取带有href属性的a标签 Elements attrElements = doc.select("a[href]"); System.out.println("**********获取属性值**********"); for(Element e: attrElements) &#123; System.out.println(e.toString()); System.out.println("-------"); &#125; //查找拓展名为gif的img标签 Elements imgElements = doc.select("img[src$=.gif]"); System.out.println("**********带有拓展名查询**********"); for(Element e: imgElements) &#123; System.out.println(e.toString()); &#125; &#125;&#125; 使用选择器查询 Jsoup 支持css，jquery的选择器 实例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo03 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //通过选择器查询 Elements linkElements = doc.select(".headline ul .editor_pick a"); System.out.println("**********选择器查询**********"); for(Element e: linkElements) &#123; System.out.println(e.toString()); System.out.println("地址： " + e.attr("href")); System.out.println("-------"); &#125; Element linkElement = doc.select(".headline ul li").first(); System.out.println("文本： " + linkElement.text()); System.out.println("html: " + linkElement.html()); System.out.println("class属性值： " + linkElement.attr("class")); &#125;&#125;]]></content>
      <categories>
        <category>Jsoup笔记</category>
      </categories>
      <tags>
        <tag>java爬虫</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支管理常用命令]]></title>
    <url>%2F2018%2F03%2F11%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建分支： git branch branch_name 切换分支： git checkout branch_name 创建并切换分支 git checkout -b branch_name 创建远程分支到本地： git checkout -b branch_name origin/branch_name 查看当前分支： git branch 获取所有分支： git fetch 合并某分支到当前分支： git merge branch_name 禁用Fast forward（快速合并）， 普通模式合并： git merge --no-ff -m &quot;merge with no-ff&quot; branch_name 这里会在合并的时候自动生成一个新的commit 删除分支： git branch -d branch_name 强制删除分支（用于为合并就删除时）： git branch -D branch_name 查看分支合并图： git log --graph 保存分支工作现场： git stash 查看保存列表： git stash list 恢复保存状态： git stash apply git stash apply stash@{x} 删除保存状态： git stash drop git stash drop stash@{x} 恢复并删除保存状态： git stash pop 推送分支到远程仓库： git push origin branch_name 建立本地分支与远程分支的关联： git branch --set-upstream branch-name origin/branch-name]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdownpad2 无法预览 显示This view has crashed!]]></title>
    <url>%2F2018%2F03%2F10%2Fmarkdownpad2-%E6%97%A0%E6%B3%95%E9%A2%84%E8%A7%88-%E6%98%BE%E7%A4%BAThis-view-has-crashed%2F</url>
    <content type="text"><![CDATA[在使用markdownpad2时，一直报错，说html渲染错误，上了官网查看解释如下，要安装 Awesomium 1.6.6 SDK，如果不行再安装DirectX最终用户运行时,不过一般只需要安装sdk就没问题了]]></content>
      <categories>
        <category>踩过的坑</category>
      </categories>
      <tags>
        <tag>markdownPad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018要学的知识]]></title>
    <url>%2F2018%2F03%2F08%2F2018%E8%A6%81%E5%AD%A6%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[java 《java核心技术》 《servlet、jsp、spring mvc初学指南》 《Spring技术内幕》 《轻量级javaEE》 《java编程思想》 《深入理解java虚拟机》 前端入门 bootstrap写页面 jquery 数据库 《高性能mysql》 linux 《Linux私房菜基础学习》 专业基础课 计算机组成原理 操作系统 计算机网络 数据库 编译原理]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
</search>
