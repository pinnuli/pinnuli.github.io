<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入ArrayList看fast-fail机制]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%B7%B1%E5%85%A5ArrayList%E7%9C%8Bfast-fail%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[fail-fast机制简介什么是fail-fastfail-fast 机制是java集合(Collection)中的一种错误机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 这种“ 及时失败” 的迭代器井不是一种完备的处理机制，而只是“ 善意地” 捕获并发错误，因此只能作为并发问题的预警指示器。 fail-fast示例12345678910111213141516171819202122232425public class FailFastTest &#123; static final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; exec.execute(() -&gt; &#123; add((int)(Math.random() * 10)); print(); &#125;); &#125; &#125; private static void add(int number) &#123; list.add(number); &#125; private static void print() &#123; Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 以上代码会抛出java.util.ConcurrentModificationException异常 fail-fast的解决办法使用java.util.concurrent.*下的工具类 深入ArrayList源码看fast-fail的原理先放上首先看下ArrayList中的内部类Itr的域12345private class Itr implements Iterator&lt;E&gt; &#123; int cursor; //1 int lastRet = -1; //2 int expectedModCount = modCount; //3&#125; 表示迭代器下一个元素的索引; 表示迭代器上一个元素的索引; 在创建一个迭代器时，将当前ArrayList的修改次数赋值给expectedModCount保存。 在上面的示例中，我们可以看到一般的迭代过程是1234Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; 分别看下iterator()、hasNext()、next()三个方法： iterator()：没有做任何处理，不过构造时三个域会进行初始化 1Itr() &#123;&#125; hasNext()：判断下一个元素索引是否等于ArrayList的大小，等于说明没有元素了 123public boolean hasNext() &#123; return cursor != size;&#125; 接下来重点看next()方法 1234567891011public E next() &#123; checkForComodification(); //1 int i = cursor; //2 if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; 在获取下一个元素之前，先调用checkForComodification()进行了检查，检查当前集合的修改次数是不是跟之前保存的相同，如果相同则表示没有被其他线程修改，1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; modCount：modCount 是 AbstractList 的属性值：`protected transient int modCount = 0; 他是一个修改次数计数器，实例化一个集合之后，每次修改（源码的注释成为结构性修改），比如set，add，clear等，计数器都会加1。 这里其实就是fail-fast机制的实现原理了，将修改计数器的变化与容器关联起来：首先在构造迭代器的时候，将当前的修改计数器的值保存，之后进行遍历的时候，每访问一个数据，都要检查当前集合的修改次数是否合法，如果有其他线程修改了集合，那么modCount就会被修改，当前修改计数器的值与之前保存的值（即期望值）不同，那么将抛出ConcurrentModificationException。 fail-fast与fail-safe的区别待补充]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码阅读]]></title>
    <url>%2F2019%2F04%2F02%2FArrayList%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[简介 数据结构：基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容。 继承关系：继承自AbstractList，实现了List、RandomAccess、Cloneable、Serializable接口。其类图如下： 空值：允许 null 的存在。 线程安全性：线程不安全。 相关域1234567891011private static final long serialVersionUID = 8683452581122892189L;private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; private int size; serialVersionUID: 序列号 DEFAULT_CAPACITY: 默认初始化容量，默认为10 EMPTY_ELEMENTDATA: 空数组，当用户指定ArrayList的容量为0时，返回该空数组 DEFAULTCAPACITY_EMPTY_ELEMENTDATA: 空数组，当用户没有指定ArrayList的容量时，elementData将会引用此数组 elementData: 用户存储数据的数组 size: 当前ArrayList实际存储的数量数量 构造器 ArrayList(int initialCapacity)：构造一个指定初始容量的ArrayList 123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125;&#125; 当初始化容量等于0时，返回EMPTY_ELEMENTDATA ArrayList()：构造一个默认容量的ArrayList 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 创建一个空的 ArrayList，此时其内数组elementData = {}, 长度为 0, 当元素第一次被加入时，扩容至默认容量 10 ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含collection的ArrayList，传入一个collection，其内元素将会全部添加到新建的ArrayList实例中 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) //1 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); //2 &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; //3 &#125;&#125; c.toArray可能不会返回 Object[]，可以查看 java 官方编号为 6260652 的 bug 若 c.toArray() 返回的数组类型不是 Object[]，则利用 Arrays.copyOf(); 来构造一个大小为 size 的 Object[] 数组 若collection长度为0，则替换为空数组 自动扩容机制 因为扩容发生在添加元素时，首先看一下add()方法 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125; 这里调用了ensureCapacityInternal(size + 1),size + 1保证资源空间不被浪费，按当前情况，保证要存多少个元素，就只分配多少空间资源，这里后续会修改modCount的值， 看下ensureCapacityInternal方法 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 这里计算了ArrayList当前合理的容量（即size+1)， 我们看下计算方式：calculateCapacity 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //1 return Math.max(DEFAULT_CAPACITY, minCapacity); //2 &#125; return minCapacity;&#125; 一个私有静态方法，当用户没有指定ArrayList的容量时，构造器会将DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给elementData； 当前合理的容量计算方式如下：如果当前的数组缓冲区是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，说明当前容量为默认初始容量，ArrayList在以默认初始化容量构造之后还没有进行扩容过，那么如果当前所需的容量小于默认初始容量时，当前所需的最小容量依然不变，为默认初始容量如果当前所需的容量大于默认初始容量时，当前所需的容量变为minCapacity（size+1）。 接着看下ensureExplicitCapacity： 12345private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //1 if (minCapacity - elementData.length &gt; 0) //2 grow(minCapacity); //3&#125; 这里修改了modCount的值，至于modCount的作用，详见深入ArrayList看fast-fail机制 防止溢出代码：确保指定的最小容量大于数组缓冲区当前的长度 当当前合理的容量大于数组缓冲区的长度时，才真正调用grow(minCapacity)进行扩容 grow(int minCapacity)：真正进行扩容的操作 1234567891011private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //1private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //2 if (newCapacity - minCapacity &lt; 0) //3 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //4 newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 数组缓冲区最大存储容量，在一些 VM 会在一个数组中存储某些数据，所以需要减去8； 计算新的容量newCapacity：扩充当前容量的1.5倍； 如果newCapacity 依旧小于 minCapacity ，那么新的容量就为minCapacity； 若 newCapacity 大于最大存储容量，则进行大容量分配。 大容量分配方法：hugeCapacity(int minCapacity),最大分配 Integer.MAX_VALUE 1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 综上，ArrayList的整个扩容流程如下： 调用add方法时，在添加元素之前，需要确保当前容量足够，按照当前所需最小容量（size+1，下面用minCapacity代替）调用ensureCapacityInternal确保容量足够，在这个过程中可能会触发扩容。 ensureCapacityInternal先计算当前合理的容量，计算方法如下：如果当前的数组缓冲区是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，说明当前容量为默认初始容量，ArrayList在以默认初始化容量构造之后还没有进行扩容过，那么如果当前所需的容量小于默认初始容量时，当前合理的容量依然不变，为默认初始容量，如果当前合理的容量大于默认初始容量时，当前合理的容量变为minCapacity（size+1）。 得到合理的所需容量之后，就调用ensureExplicitCapacity判断是否需要扩容，判断方式如下：当当前合理的容量大于数组缓冲区的长度时，才真正调用grow(minCapacity)进行扩容 真正扩容的过程是grow方法，流程如下：计算新的容量newCapacity：当前容量的1.5倍；如果newCapacity 依旧小于 minCapacity ，那么新的容量就为minCapacity；如果 newCapacity 大于最大存储容量，则进行大容量分配。确定好新数组的容量之后，调用Arrays.copyOf(elementData, newCapacity)复制数组； 到了这里才算是确保容量足够，可以添加元素了，执行添加元素的操作 常见操作添加 add(int index, E element)：在指定位置插入新元素，原先在 index 位置的值往后移动一位 12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index); //1 ensureCapacityInternal(size + 1); //2 System.arraycopy(elementData, index, elementData, index + 1, size - index); //3 elementData[index] = element; size++;&#125; 检查下标是否越界: 1234private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 确保空间足够，又不浪费资源 参数说明：第一个是要复制的数组，第二个是从要复制的数组的第几个开始，第三个是复制到那，四个是复制到的数组第几个开始，最后一个是复制长度。 addAll(Collection&lt;? extends E&gt; c)：将一个集合的所有元素顺序添加（追加）到 lits 末尾 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; //1 ensureCapacityInternal(size + numNew); //2 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125; 要添加的个数 扩容 addAll(int index, Collection&lt;? extends E&gt; c):在指定下标之后插入集合中的元素 12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); //1 int numNew = a.length; ensureCapacityInternal(size + numNew); int numMoved = size - index; //2 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 将集合中的元素转为数组 要移动的数量 删除 remove(int index): 删除指定下标的元素 1234567891011121314 public E remove(int index) &#123; rangeCheck(index); //1 modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; //2 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; //3 return oldValue; //4&#125; 检查下标是否越界 要移动的长度 将最后一个元素置空 返回删除的元素 remove(Object o): 删除指定第一个的元素，即符合条件的索引最低值。如果list中不包含这个元素，这个list不会改变，如果包含，index之后的元素都左移一位。 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); //1 return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 快删除，跳过检查，不返回被删除的值 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; removeAll(Collection&lt;?&gt; c): 移除list中指定集合包含的所有元素 1234public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); //1 return batchRemove(c, false); //2&#125; 判断集合是否为空，为空报NPE； 批量删除c集合的元素,第二个参数是否采补集,如果true：移除list中除了c集合中的所有元素,如果false：移除list中c集合中的元素 12345678910111213141516171819202122232425262728private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) //1 elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; //2 System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; //3 // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 判断元素是否保留，complement是否采补集,如果true：移除list中除了c集合中的所有元素,如果false：移除list中c集合中的元素 最后当r!=size表示可能出错了，将r后面的元素都复制到w之后 如果w == size，表示全部元素都保留了，所以也就没有删除操作发生，所以会返回false；反之，返回true，并更改数组； w!=size; 即使try抛出异常，也能正常处理异常抛出前的操作，因为w始终为要保留的前半部分，数组也不会因此乱序。 removeIf(Predicate&lt;? super E&gt; filter)：根据Predicate条件来移除元素 1234567891011121314151617181920212223242526272829303132333435363738394041public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings("unchecked") final E element = (E) elementData[i]; if (filter.test(element)) &#123; //1 removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); //2 &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; //3 if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; //4 elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove;&#125; 判断是否满足条件， 如果满足就将对应的下标存放到bitset中，并增加应移除元素的数量 检查遍历过程中是否被外部改变 如果有要移除的元素，则获取bitset中置位0的下标，并将元素移到新位置 将剩余空间置空 查询 get(int index): 获取指定位置上的元素，下标从0开始 1234public E get(int index) &#123; rangeCheck(index); //1 return elementData(index); //2&#125; 检查数组是否越界，代码如下： 1234private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 返回数组中改位置的元素： 123E elementData(int index) &#123; return (E) elementData[index];&#125; contains(Object o)：判断ArrayList是否包含某元素 123public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; size(): 返回ArrayList实际存储的元素数量 123public int size() &#123; return size;&#125; isEmpty()：判断ArrayList是否为空 123public boolean isEmpty() &#123; return size == 0;&#125; indexOf(Object o)：获取元素的下标 123456789101112public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; lastIndexOf(Object o): 逆序查找，返回元素的最低索引值(最首先出现的索引位置)，其实就是最后一个出现的位置 123456789101112public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 修改 set(int index, E element): 将index位置的元素设置为element 1234567public E set(int index, E element) &#123; rangeCheck(index); //1 E oldValue = elementData(index); //2 elementData[index] = element; return oldValue; //3&#125; 检查下标是否越界 获取元素旧值 返回旧值 clear()：将ArrayList清空 123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 其他 trimToSize(): 将数组缓冲区大小调整到实际 ArrayList 存储元素的大小，该方法由用户手动调用，以减少空间资源浪费的目的。 12345678public void trimToSize() &#123; modCount++; //1 if (size &lt; elementData.length) &#123; elementData = (size == 0) //2 ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 当实际大小 &lt; 数组缓冲区大小时,比如调用默认构造函数后，刚添加一个元素，此时 elementData.length = 10，而 size = 1，通过这一步，可以使得空间得到有效利用，而不会出现资源浪费的情况。 clone(): 深拷贝，克隆一个ArrayList实例,对拷贝出来的ArrayList对象的操作不会对原来的ArrayList造成影响 1234567891011public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); //1 v.elementData = Arrays.copyOf(elementData, size); //2 v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125;&#125; Object 的克隆方法：会复制本对象及其内所有基本类型成员和 String 类型成员，但不会复制对象成员、引用对象; 对需要进行复制的引用变量，进行独立的拷贝：将存储的元素移入新的 ArrayList 中 toArray(): 返回 ArrayList 的 Object 数组 123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; toArray(T[] a):返回ArrayList 元素组成的数组,存储早a数组中 123456789public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); //1 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 如果数组a的大小 &lt; ArrayList的元素个数,则新建一个T[]数组。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之线程池的使用]]></title>
    <url>%2F2019%2F03%2F18%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[无限制创建线程的不足 线程生命周期的开销非常高 线程的创建与销毁并不是没有代价的。根据平台的不同， 实际的开销也有所不同， 但线程的创建过程都会需要时间， 延迟处理的请求， 并且需要JVM和操作系统提供一些辅助操作。 资源消耗 活跃的线程会消耗系统资源， 尤其是内存。如果可运行的线程数量多于可用处理器的数量， 那么有些线程将闲置。大量空闲的线程会占用许多内存， 给垃圾回收器带来压力， 而且大量线程在竞争CPU资源时还将产生其他的性能开销。如果你已经拥有足够多的线程使所有CPU保持忙碌状态， 那么再创建更多的线程反而会降低性能。 稳定性 在可创建线程的数批上存在一个限制。这个限制值将随着平台的不同而不同， 并且受多个因素制约， 包括JVM的启动参数、Thread构造函数中请求的栈大小， 以及底层操作系统对线程的限制等。如果破坏了这些限制， 那么很可能抛出OutOfMemoryError 异常，想从这种错误中恢复过来是非常危险的。 什么是线程池线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。 使用线程池的好处 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高响应速度。当任务到达的时候，任务可以不需要等待线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优、监控。 线程池的类图 线程池的状态：运行、关闭、已终止。 线程池的使用：ThreadPoolExecutor线程池的创建new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,milliseconds,runnableTaskQueue, handler); 创建一个线程池时需要输入几个参数，如下： corePoolSize：线程池的基本大小 runnableTaskQueue：任务队列，用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 maximumPoolSize：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。 值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。 ThreadFactory：用于设置创建线程的工厂，可以通过指定一个线程工厂方法，定制线程池的配置信息。 如：使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下:new ThreadFactoryBuilder().setNameFormat(&quot;XX-task-%d&quot;).build(); RejectedExecutionHandler：饱和策略,当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。在JDK 1.5中Java线程池框架提供了以下4种策略。 AbortPolicy：直接抛出异常。(默认情况下是这种策略) CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。 keepAliveTime：线程活动保持时间,线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。 TimeUnit：线程活动保持时间的单位,可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。 在调用完ThreadPoolExecutor的构造函数后，仍然可以通过设置函数来修改大多数传递给它的构造函数的参数。如果Executor是通过Executors中的某个（newSingleThreadExecutor除外）工厂方法创建的，那么可以将结果的类型转换为ThreadPoolExecutor以访问设置器。ps: 在Executors中包含一个unconfigurableExecutorService工厂方法，该方法对一个现有的ExecutorService进行包装，使其只暴露出ExecutorService的方法，因此不能对它进行配置。newSingleThreadExecutor返回的按这种方式封装的ExecutorService，而不是最初的ThreadPoolExecutor。可以使用这项技术防止执行策略被修改。 向线程池提交任务可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。 execute()：execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 submit()：submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值 get 方法的行为取决于任务的状态（尚未开始、正在运行、已完成）。如果任务已经完成，那么 get 会立即返回或者抛出一个 Exception, 如果任务没有完成， 那么 get将阻塞并直到任务 完成。 如果任务抛出了异常， 那么 get 将该异常封装为 ExecutionException 并重新抛出。 如果 任务被取消，那么 get 将抛出CancellationException。 关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。 合理地配置线程池想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析: 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。 任务的优先级：高、中和低。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。 任务的执行时间：长、中和短。 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。 任务的依赖性：是否依赖其他系统资源，如数据库连接。 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。 线程池的监控以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性: taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。 getActiveCount：获取活动的线程数。 通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。 线程池的使用:Excutors可以通过调用Excutors中的静态工厂方法之一来创建一个线程池 newFixedTheadPool创建一个固定长度的线程池，每当提交一个任务时就创建一个线程， 直到达到线程池的最大数量， 这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。 newCachedThreadPool创建一个可缓存的线程池，如果线程池 的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程， 线程池的规模不存在任何 限制。 newScheduledThreadPool创建了一个固定长度的线程池， 而 且以延迟或定时（周期性地）的方式来执行任务， 类似千Timer。 newSingleThreadExecutor一个单线程的Executor, 它创建单个工作者线程来执行任务， 如果这个线程异常结束， 会创建另一个线程来替代。 newSingleThreadExecutor 能确保依照任务在队列中的顺序来串行执行（例如FIFO、LIFO、优先级）。]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之基础构建模块:同步容器、并发容器、阻塞队列、同步工具类]]></title>
    <url>%2F2019%2F02%2F27%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一、同步容器类常见的同步容器 ArrayList -&gt; Vecotr HashMap -&gt; Hashtable Collections.synchronizedXXX 同步容器并不是在任何情况下都能线程安全 导致混乱结果的符合操作 123456789public static Object getLast(Vector list) &#123; int lastIndex = list.siaze() - 1; return list.get(lastIndex);&#125;public static void deleteLast(Vector list) &#123; int lastIndex = list.siaze() - 1; list.remove(lastIndex);&#125; 如果线程A 在包含10 个元素的Vector 上调用getLast, 同时线程B 在同一个Vector 上调用deleteLast, 这些操作的交替执行如图所示， getLast 将抛出ArraylndexOutOffioundsException 异常。在调用size与调用getLast 这两个操作之间， Vector 变小了， 因此在调用size 时得到的索引值将不再有效。这种情况很好地遵循了Vector 的规范一一如果请求一个不存在的元素， 那么将抛出一个异常 解决方法：在容器上加锁123456public static Object getLast(Vector list) &#123; synchronized(list) &#123; int lastIndex = list.siaze() - 1; return list.get(lastIndex); &#125;&#125; 迭代操作抛出ArrayIndexOutOfBoundsException异常 123for (int i = 0; i &lt; vector.size(); i++) &#123; doSomething(vector.get(i));&#125; 如果在对Vector进行迭代时， 另一个线程删除了一个元素， 并且这两个操作交替执行， 那么这种迭代方法将抛出ArrayindexOutOfBoundsException异常。解决方法：在容器上加锁12345synchronized(vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; doSomething(vector.get(i)); &#125;&#125; 迭代器与ConcurrentModificationException无论在直接迭代还是在Java5.0引入的for-each循环语法中，对容器类进行迭代的标准方式都是使用Iterator, 然而， 如果有其他线程并发地修改容器， 那么即使是使用迭代器也无法避免在迭代期间对容器加锁。在设计同步容器类的迭代器时并没有考虑到并发修改的问题， 并且它们表现出的行为是“ 及时失败” (fail-fast)的。这种“ 及时失败” 的迭代器井不是一种完备的处理机制，而只是“ 善意地” 捕获并发错误，因此只能作为并发问题的预警指示器。它们采用的实现方式是，将计数器的变化与容器关联起来： 如果在迭代期间计数器被修改， 那么hasNext或next将抛出ConcurrentModificationException。 1234List&lt;Widget&gt; widgetList = Collections.synchronizedList(new ArrayList&lt;Wedget&gt;);for (Widget w : widgetList) &#123; doSomething(w);&#125; 解决方法： 可以通过持有容器的锁来避免出现这个异常 如果不希望在迭代期间对容器加锁， 那么一种替代方法就是“ 克隆” 容器， 并在副本上进行迭代。 在遍历容器的过程中(不管是不是线程安全的容器），特别是使用foreach和iterator时，尽量不要对容器进行删除等更新操作，可以遍历过程中做好标记，等遍历结束后再进行处理. 隐藏迭代器 1234567891011121314151617public class HiddenIterator &#123; @GuardedBy("this") private final Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); public synchronized void add(Integer i) &#123; set.add(i); &#125; public synchronized void remove(Integer i) &#123; set.remove(i); &#125; public void addTenThings() &#123; Random r = new Random(); for (int i = 0; i &lt; 10; i++) add(r.nextInt()); System.out.println("DEBUG: added ten elements to " + set); &#125;&#125; addTenThings方法可能会抛出ConcurrentModificationException, 因为在生成调试消息的过程中， toString 对容器进行迭代。 容器的hashCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样， containsAll、removeAll 和retainAll 等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都可能抛出ConcurrentModificationException。 二、并发容器并发容器是针对多个线程并发访问设计的,Java5.0提供了多种并发容器类来改进同步容器的性能,通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。 常见并发容器 ArrayList -&gt; CopyOnWriteArrayList HashSet、TreeSet -&gt; CopyOnWriteArraySet、ConcurrentSkipListSet HashMap、TreeMap -&gt; ConcurrentHashMap、ConcurrentSkipListMap ConcurrentHashMap ConcurrentHashMap并不是想同步容器那样对容器加独占锁进行访问，它采用分段锁机制：任意数量的读取线程可以并发地访问Map, 执行读取操作的线程和执行写入操作的线程可以并发地访问Map, 并且一定数量的写入线程可以并发地修改Map。 ConcurrentHashMap不能被加锁来执行独占访问，所以当需要使用客户端加锁新建新的原子操作时，可以通过实现ConcurrentMap来实现 ConcurrentHashMap与其他并发容器迭代器的弱一致性：它们提供的迭代器不会抛出ConcurrentModificationException, 因此不需要在迭代过程中对容器加锁。ConcurrentHashMap返回的迭代器具有弱一致性(Weakly Consistent), 而并非“ 及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素， 并可以（但是不保证） 在迭代器被构造后将修改操作反映给容器。 CopyOnWriteArrayList 写入时复制：CopyOnWriteArrayList,线程安全，当对CopyOnWriteArrayList进行写操作时，现将原来的数组拷贝一份，然后在新的数组里面进行写操作，写完之后再将原来的数组指向新的数组，读操作时不需要加锁，写操作时需要加锁； CopyOnWriteArrayList的缺点：1.拷贝的时候会消耗内存，当元素个数太多时，可能会导致Minor GC或者Full GC2.没办法满足实时读的要求，复制和新增元素都需要时间，他只能满足最终的一致性，适合于读多写少的场景 仅当迭代操作远远多于修改操作时， 才应该使用 “ 写入时复制” 容器。 三、阻塞队列常见阻塞队列 ArrayBlockingQueue：有界，初始化时指定大小，内部是一个数组 DelayQueue: 无界，内部元素必须实现Delayed接口，Delayed接口继承了Comparable接口，内部是PriorityBlockingQueue和lock，其中的对象只能在其到期时才能从队列中取走 LinkedBlockingQueue: 大小配置可选，初始化指定大小则是有边界，没有指定则无大小，内部是链表 PriorityBlockingQueue: 带优先级，没有边界，有排序规则，可以插入null,元素必须实现Comparable接口 SynchronousQueue: 内部仅允许容纳一个元素，当一个线程插入一个元素就会被阻塞，除非这个元素被其他线程消费 串行封闭 对于可变对象， 生产者 － 消费者这种设计与阻塞队列一起， 促进了串行线程封闭， 从而将对象所有权从生产者交付给消费者。 线程封闭对象只能由单个线程拥有， 但可以通过安全地发布该对象来 “转移 ” 所有权。在转移所有权后， 也只有另一个线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。这种安全的发布确保了对象状态对于新的所有者来说是可见的， 并且由于最初的所有者不会再访问它， 因此对象将被封闭在新的线程中。 新的所有者线程可以对该对象做任意修改， 因为它具有独占的访问权。 对象池利用了串行线程封闭， 将对象“借给“一个请求线程。只要对象池包含足够的内部同步来安全地发布池中的对象， 并且只要客户代码本身不会发布池中的对象， 或者在将对象返回给对象池后就不再使用它， 那么就可以安全地在线程之间传递所有权。 双端队列与工作密取 双端队列：Deque 是一个双端队列， 实现了在队列头和队列尾的高效插入和移除。 具体实现包括 ArrayDeque 和 LinkedBlockingDeque。 工作密取： 在生产者－消费者设计中，所有消费者有一个共享的工作队列， 而在 工作密取设计中， 每个消费者都有各自的双端队列。 如果一个消费者完成了自己双端队列中的 全部工作， 那么它可以从其他消费者双端队列末尾秘密地获取工作。 四、同步工具类闭锁CountDownLatch 闭锁的作用相当于一扇门：在闭锁到达结束状态之前， 这扇门 一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。 当闭锁到达结束状态后将不会再改变状态，因此这扇门将永远保持打开状态。 示例：通过CountDownLatch来启动和停止线程 123456789101112131415161718192021222324252627282930 public class TestHarness &#123; public long timeTasks(int nThreads, final Runnable task) throws InterruptedException &#123; final CountDownLatch startGate = new CountDownLatch(1); final CountDownLatch endGate = new CountDownLatch(nThreads); for (int i = 0; i &lt; nThreads; i++) &#123; Thread t = new Thread() &#123; public void run() &#123; try &#123; startGate.await(); try &#123; task.run(); &#125; finally &#123; endGate.countDown(); &#125; &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;; t.start(); &#125; long start = System.nanoTime(); startGate.countDown(); endGate.await(); long end = System.nanoTime(); return end - start; &#125;&#125; TestHarness创建一定数量的线程， 利用它们井发地执行指定的任务。 它使用两个闭锁， 分别表示 “起始门(Starting Gate)”和 “结束门(Ending Gate) “。 起始门计数器的初始值为 1, 而结束门计数器的初始值为工作线程的数量。 每个工作线程首先要做的值就是在启动门上等待， 从而确保所有线程都就绪 后才开始执行。 栅栏CyclicBarrier、Exchanger 栅栏类似于闭锁， 它能阻塞一组线程直到某个事件发生。 CyclicBarrier：可以使一定数量的参与方反复地在栅栏位置汇集，当线程到达栅栏位置时将调用await方法， 这个方法将阻塞直到所有线程都到达棚栏位置。如果所有线程都到达了栅栏位，那么栅栏将打开， 此时所有线程都被释放， 而栅栏将被重置以便下次使用。 12345678910111213141516171819202122232425262728293031public class CyclicBarrierExample3 &#123; private static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123; log.info("callback is running"); &#125;); public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error("exception", e); &#125; &#125;); &#125; executor.shutdown(); &#125; private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info("&#123;&#125; is ready", threadNum); barrier.await(); log.info("&#123;&#125; continue", threadNum); &#125;&#125; Exchanger: Exchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点,在这个同步点,两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据,如果第一个线程先执行exchange()方法,它会一直等待第二个线程也执行exchange方法,当两个线程都到达同步点时,这两个线程就可以交换数据,将本线程生产出来的数据传递给对方。 1234567891011121314151617181920212223242526272829public class ExchangerExample &#123; private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;(); private static ExecutorService threadPool =Executors.newFixedThreadPool(2); public static void main(String[] args) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; String A = "银行流水A"; // A录入银行流水数据 exgr.exchange(A); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;); threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; String B = "银行流水B"; // B录入银行流水数据 String A = exgr.exchange(B); System.out.println("A和B数据是否一致:" + A.equals(B) + ",A录入的是:" + A + ",B录入是:" + B); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;); threadPool.shutdown(); &#125;&#125; 输出结果：A和B数据是否一致:false,A录入的是:银行流水A,B录入是:银行流水B CountDownLatch与CyclicBarrier的区别 CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 CyclicBarrier: N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。 CountDownLatch的计数器只能使用一次,而CyclicBarrier的计数器可以使用reset()方法重置。 信号量Semaphore 用来控制同时访问某个特定资源的操作数量， 或者同时执行某个指定操作的数量。 Semaphore 可以用于实现资源池， 例如数据库连接池。我们可以构造一个固定长度的资源池， 当池为空时， 请求资源将会失败， 但你真正希望看到的行为是阻塞而不是失败并且当池非空时解除阻塞。 可以使用Semaphore 将任何一种容器变成有界阻塞容器，如下示例： 12345678910111213141516171819202122232425262728public class BoundedHashSet &lt;T&gt; &#123; private final Set&lt;T&gt; set; private final Semaphore sem; public BoundedHashSet(int bound) &#123; this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;()); sem = new Semaphore(bound); &#125; public boolean add(T o) throws InterruptedException &#123; sem.acquire(); boolean wasAdded = false; try &#123; wasAdded = set.add(o); return wasAdded; &#125; finally &#123; if (!wasAdded) sem.release(); &#125; &#125; public boolean remove(Object o) &#123; boolean wasRemoved = set.remove(o); if (wasRemoved) sem.release(); return wasRemoved; &#125;&#125; Callable和Future 当需要从执行任务返回值时，可以实现Callable接口，重写call()方法，并用Future接收返回值，当需要用到返回值时再从Future中取出来。 当使用Future.get()时，若任务已经执行完成，则直接返回结果，当任务未完成时，get会阻塞 12345678910111213141516171819public class FutureExample &#123; static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; log.info("do something in callable"); Thread.sleep(5000); return "Done"; &#125; &#125; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); log.info("do something in main"); Thread.sleep(1000); String result = future.get(); log.info("result：&#123;&#125;", result); &#125;&#125; FutureTaskFutureTask可以像Runnable一下，封装异步任务，然后提交给Thread或线程池执行，然后获取任务执行结果。123456789101112131415161718public class FutureTaskExample &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info("do something in callable"); Thread.sleep(5000); return "Done"; &#125; &#125;); new Thread(futureTask).start(); log.info("do something in main"); Thread.sleep(1000); String result = futureTask.get(); log.info("result：&#123;&#125;", result); &#125;&#125; Fork/Join框架用于并行执行任务的框架,是一个把大任务分割成若干个小任务,最终汇总每个小任务结果后得到大任务结果的框架。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123; public static final int threshold = 2; private int start; private int end; public ForkJoinTaskExample(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; //如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= threshold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算 int middle = (start + end) / 2; ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle); ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待任务执行结束合并其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkjoinPool = new ForkJoinPool(); //生成一个计算任务，计算1+2+3+4 ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100); //执行一个任务 Future&lt;Integer&gt; result = forkjoinPool.submit(task); try &#123; log.info("result:&#123;&#125;", result.get()); &#125; catch (Exception e) &#123; log.error("exception", e); &#125; &#125;&#125; 五、阻塞方法与中断方法什么是线程的中断中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。当线程A中断B时， A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作-前提是如果线程B愿意停止下来。 阻塞方法当在代码中调用了一个将抛出InterruptedException 异常的方法时， 你自己的方法也就变成了一个阻塞方法， 并且必须要处理对中断的响应。 中断方法Thread提供了interrupt方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性， 表示线程的中断状态， 当中断线程时将设置这个状态。 对中断的响应对于库代码来说，对中断的响应有两种基本选择： 传递InterruptedException。避开这个异常通常是最明智的策略——只需把InterruptedException 传递给方法的调用者。传递lnterruptedException 的方法包括， 根本不捕获该异常， 或者捕获该异常， 然后在执行某种简单的清理工作后再次抛出这个异常。 恢复中断。有时候不能抛出InterruptedException, 例如当代码是Runnable的一部分时。在这些情况下， 必须捕获InterruptedException, 并通过调用当前线程上的interrupt 方法恢复中断状态， 这样在调用栈中更高层的代码将看到引发了一个中断。 不可在InterruptedException出现， 捕获它但不做出任何响应。]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之对象的共享]]></title>
    <url>%2F2019%2F02%2F26%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[一、可见性非原子的64位操作 对于非volatile类型的long和double变量，JVM允许将来64位的读操作或写操作分解为两个32位的操作，如果该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位 在多线程中使用共享且可变的long和double等类型变量是不安全的，需要用volatile声明或加锁加锁与可见性 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享可变变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。Volatile变量一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程 从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块 当volatile变量能简化代码的实现以及对同步策略的验证时才使用 加锁机制既可以确保可见性又可以确保原子性，volatile变量只能确保可见性（因此不足以确保递增操作的原子性） 当且仅当满足以下所有条件时，才应该使用volatile变量： 1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值 2.变量不需要与其他的状态变量共同参与不变约束 3.在访问变量时不需要加锁 volatile的适用场景： 1.作为状态标志： 12345volatile boolean asleep;...while(!asleep)&#123; countSomeSheep();&#125; 2.一次性安全发布: 1234567891011121314151617public class Singleton &#123; private Singleton() &#123;&#125; private static volatile Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (Singleton.class) &#123; // 同步锁 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 二、发布与逸出 发布一个对象： 逸出： 三、线程封闭ad-hoc这是完全靠实现者控制的线程封闭，他的线程封闭完全靠实现者实现 栈封闭在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中国，他们位于执行线程的栈中，其他线程无法访问。 ThreadLocal类 这个类能使线程中的某个值与保存值的对象关联起来，ThreadLocal类提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。 ThreadLocal通常用于防止对可变的单实例变量或全局变量进行共享：比如： 通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会拥有属于自己的连接； 当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配临时对象。 可以将ThreadLocal视为包含了Map对象，但ThreadLocal的实现并非如此，这些特定于线程的值保存在Thread对象中，当线程终止后，这些值会作为垃圾回收。 四、不变性 不可变对象：对象在被创建后其状态就不可以被修改 不可变对象一定是线程安全的。 不可变对象必须满足的条件： 对象创建后其状态就不能修改 对象的所有域都是final类型 对象是正确创建的(创建期间this没有逸出) 不可变对象的创建： Collections。unmodifiableXXX:Collection、Map、Set、List等，例如：map = Collections.unmodifiableMap(map); Guava：ImmutableXXX:Collection、Map、Set、List等 Final域 final类型的域是不可修改的，但如果final域锁引用的对象是可变的，那么这些被引用的对象是可以修改的； 因此， 在没有额外同步的情况下，也可以安全第访问final域， 但是如果final域执行的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。 final域能确保初始化过程的安全性,从而可以不受限制地访问不可变对象,并在共享这些对象时无须同步。 除非需要更高的可见性,否则所有域都应声明为私有，除非需要某个域是可变的,否则应将其声明为final。 事实不可变对象：雄技术上来看是可变的，但其状态在发布后不会再改变，这种对象不需要满足前面提到的条件。 在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。 五、安全发布对象安全发布的常用模式： 在静态初始化函数中初始化一个对象引用 要发布一个对象,最简单安全的方式是使用静态的初始化器:public static Holder holder = new Holder(42);， 静态初始化器由JVM在类初始化阶段执行。由于JVM内部存在同步机制,所以这种方式初始化的任何对象都可以被安全发布。 将对象的引用保存到volatile类型的域或AtomicReference对象中 将对象的引用保存到某个正确构造对象的final类型域中 将对象的引用保存到一个由锁保护的域中 对象的发布取决于他的可变性： 不可变对象可以通过任意机制来发布； 事实不可变对象必须通过安全方式来发布； 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来 安全共享对象的策略 线程封闭: 线程封闭的对象只能由一个线程拥有 只读共享: 在没有额外同步的情况下,共享的只读对象可以由多个线程并发访问,但任何线程都不能修改它(共享的只读对象包括不可变对象和事实不可变对象) 线程安全共享: 线程安全的对象在其内部实现同步,多个线程可通过对象的共有接口来进行访问 保护对象: 被保护的对象只能通过持有特定的锁来访问.保护对象包括封装在其他线程安全对象中的对象,以及已发布的并且由某个特定锁保护的对象]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之对象的组合]]></title>
    <url>%2F2019%2F02%2F25%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[一、设计线程安全的类 设计线程安全类的过程中,需要包含以下三个基本要素: 找出构成对象状态的所有变量 找出约束状态变量的不变性条件 建立对象状态的并发访问管理策略 同步策略定义了如何在不违背对象不变性条件或后验条件的情况下对其状态的访问操作进行协同.同步策略规定了如何将不可变性,线程封闭与加锁机制等结合起来以维护线程的安全性,并且还规定了哪些变量由哪些锁来保护 收集同步需求 要确保类的线程安全性,就需要确保它的不变性条件不会在并发访问的情况下被破坏,这就需要对其状态进行推断 如果在一个不变性条件中包含多个变量， 那么在执行任何访问相关变量的操作时， 都必须持有保护这些变量的锁。 如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。 依赖状态的操作 什么是依赖状态的操作： 如果在某个操作中包含有基千状态的先验条件，那么这个操作就称为依赖状态的操作。 在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。 但在并发程序中， 先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作。 二、实例封闭 封装简化了线程安全类的实现过程，它提供了一种实例封闭机制(Instance Confinement), 通常也简称为 “封闭” 。当一 个对象被封装到另一 个对象中时，能够访问被封装对象的所有代码路径都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来， 可以确保以线程安全的方式来使用非线程安全的对象。 将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程访问数据时总能持有正确的锁。 被封闭对象一定不能超出它们既定的作用域。对象可以封闭在类的一 个实例（例如作为类 的一个私有成员）中， 或者封闭在某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如在某个线程中 将对象从一 个方法传递到另一 个方法， 而不是在多个线程之间共享该对象 ）。Java监视器模式 遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。（在许多类中都使用了Java监视器模式， 例如Vector和Hashtable） 使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁）， 有许多优点： 私有的锁对象可以将对象锁封装起来，使客户代码无法得到锁， 但客户代码可以通过公有方法来访问锁， 以便（正确或者不正确地）参与到它的同步策略中。 如果客户代码错误地获得了另一个对象的锁， 那么可能会产生活跃性问题。此外， 要想验证某个公有访问的锁在程序中否被正确地使用， 则需要检查整个程序， 而不是单个的类。 三、线程安全性的委托在某些 情况下， 通过多个线程安全类组合而成的类是线程安全的， 而在某些情况下， 这仅仅是一个好的开端。 将线程安全委托给单个线程安全的状态变量以下示例将线程安全性委托给AtomicLong：123456789public class CountingFactorizer&#123; private final AtomicLong count = new AtomicLong(0); public long getCount() &#123; return count.get(); &#125; public void add(ServletRequest req, ServletResponse resp) &#123; count.incrementAndGet(); &#125;&#125; 将线程安全性委托给多个状态变量 可以将线程安全性委托给多个状态变量,只要这些变量是彼此独立的,即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件： 12345678910111213141516171819202122public class VisualComponent &#123; private final List&lt;KeyListener&gt; keyListeners = new CopyOnWriteArrayList&lt;KeyListener&gt;(); private final List&lt;MouseListener&gt; mouseListeners = new CopyOnWriteArrayList&lt;MouseListener&gt;(); public void addKeyListener(KeyListener listener) &#123; keyListeners.add(listener); &#125; public void addMouseListener(MouseListener listener) &#123; mouseListeners.add(listener); &#125; public void removeKeyListener(KeyListener listener) &#123; keyListeners.remove(listener); &#125; public void removeMouseListener(MouseListener listener) &#123; mouseListeners.remove(listener); &#125;&#125; VisualComponent为鼠标和键盘备有一个注册监听器列表，因此当某个事件发生时，就会调用相应的监听器，然而鼠标事件监听器和键盘事件监听器之间不存在任何关联，二者是彼此独立的而因此VisualComponent可以将其线程安全性委托给这两个线程安全的监听器列表。 反例：当委托失效时 1234567891011121314151617181920212223public class NumberRange &#123; // INVARIANT: lower &lt;= upper private final AtomicInteger lower = new AtomicInteger(0); private final AtomicInteger upper = new AtomicInteger(0); public void setLower(int i) &#123; // Warning -- unsafe check-then-act if (i &gt; upper.get()) throw new IllegalArgumentException("can't set lower to " + i + " &gt; upper"); lower.set(i); &#125; public void setUpper(int i) &#123; // Warning -- unsafe check-then-act if (i &lt; lower.get()) throw new IllegalArgumentException("can't set upper to " + i + " &lt; lower"); upper.set(i); &#125; public boolean isInRange(int i) &#123; return (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get()); &#125;&#125; NumberRange使用两个AtomicInteger来管理状态，并且两个状态变量之间存在一个不变形条件：即第一个数值要小于或等于第二个数值。因而NumberRange不是线程安全的。 如果某个类含有符合操作，例如NumberRange,那么仅靠委托并不足以实现线程安全性。这种情况下,这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作,除非整个复合操作都可以委托给状态变量 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。 如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。 四、在现有的线程安全类中添加功能将新方法添加到类中要添加一个新的原子操作， 最安全的方法是修改原始的类，如果直接将新方法添加到类中， 那么意味着实现同步策略的所有代码仍然处于一个源代码文件中， 从而更容易理解与维护。但这通常无法做到。 扩展这个类12345678910public class BetterVector &lt;E&gt; extends Vector&lt;E&gt; &#123; static final long serialVersionUID = -3963416950630760754L; public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !contains(x); if (absent) add(x); return absent; &#125;&#125; “扩展” 方法比直接将代码添加到类中更加脆弱， 因为现在的同步策略实现被分布到多个单独维护的源代码文件中。 使用客户端加锁扩展类的功能， 但并不是扩展类本身， 而是将扩展代码放人一个“ 辅助类” 中。12345678910class BadListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125;&#125; 这种方法是线程不安全的，问题在于在错误的锁上进行了同步。无论List使用哪一个锁来保护它的状态，可以确定的是，这个锁并不是ListHelper上的锁。要使用客户端加锁， 你必须知道对象X使用的是哪一个锁。 以下的实现才是正确的：123456789101112class GoodListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x) &#123; synchronized (list) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125; &#125;&#125; 通过添加一个原子操作来扩展类是脆弱的， 因为它将类的加锁代码分布到多个类中。然而，客户端加锁却更加脆弱， 因为它将类 C的加锁代码放到与C完全无关的其他类中。 组合123456789101112131415public class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123; private final List&lt;T&gt; list; public ImprovedList(List&lt;T&gt; list) &#123; this.list = list; &#125; public synchronized boolean putIfAbsent(T x) &#123; boolean contains = list.contains(x); if (contains) list.add(x); return !contains; &#125; public synchronized void clear() &#123;list.clear();&#125; // ...按照类似的方式委托给List的其他方法&#125; ImprovedList通过自身的内置锁增加了一层额外的加锁。它并不关心底层的List是否是线程安全的， 即使List不是线程安全的或者修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式的几种写法对比]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[懒汉模式1. 最简单的懒汉模式线程不安全，不推荐12345678910111213public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 在多线程环境下，当多个线程执行到第9行代码时，此时instance都为空，那么这些线程都会执行第10行代码，从而创建了多个对象 2. 在上面的基础上给getInstance方法加上synchronized线程安全，不推荐，加上synchronized之后，方法内的所有实现在同一时间只允许一个线程访问，可以保证线程安全，但是synchronized会带来性上很大的开销 12345678910111213public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton instance = null; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 3. 双重同步锁单例模式线程不安全，可以改进 1234567891011121314151617public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (Singleton.class) &#123; // 同步锁 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 对于instance = new Singleton(); 这一行代码，实际上可以看出以下三步： 1、memory = allocate() 分配对象的内存空间 2、ctorInstance() 初始化对象 3、instance = memory 设置instance指向刚分配的内存 由于第二步和第三步不能由先行发生原则到处出来，JVM和cpu优化，发生了指令重排，顺序如下： 1、memory = allocate() 分配对象的内存空间 3、instance = memory 设置instance指向刚分配的内存 2、ctorInstance() 初始化对象 那么可能存在这样一种情况，在多线程情况下，当线程A执行到第10行代码instance = new Singleton();的第3步instance = memory 设置instance指向刚分配的内存时，线程B执行到第8行代码if (instance == null)， 这时对象还没有初始化完毕，然而instance已经指向了分配给对象的内存，instance已经不为空，会造成对象逸出，因而线程不安全； 4. volatile + 双重检测机制，禁止指令重排线程安全，推荐1234567891011121314151617public class Singleton &#123; private Singleton() &#123;&#125; private static volatile Singleton instance = null; public static Singleton getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (Singleton.class) &#123; // 同步锁 if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 饿汉模式，单例实例在类装载时进行创建如果构造方法中没有很多的处理，那么饿汉模式是可以接收的，但是如果构造方法中有非常多的处理，会导致类加载的时候很慢，会导致一些性能的问题。 如果只进行类的加载，而没有进行实际的调用，就会造成资源的浪费，因此使用饿汉模式的时候应该考虑两个问题： 构造方法有没有过多的处理 这个类是否一定会被使用，避免装载之后没有调用造成资源浪费 1. 普通饿汉模式线程安全，可以改进12345678910public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125;&#125; 2. 将创建对象的代码放到static块中线程安全，推荐1234567891011121314public class Singleton &#123; private Singleton() &#123;&#125; private static Singleton instance = null; static &#123; instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 枚举模式最安全，推荐1234567891011121314151617181920212223public class Singleton &#123; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private Singleton singleton; // JVM保证这个方法绝对只调用一次 Singleton() &#123; singleton = new Singleton(); &#125; public Singleton getInstance() &#123; return singleton; &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java并发</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之Java内存区域]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[运行时数据内存线程私有的内存区域 每条线程都有，各线程之间互不影响，独立存储的一类内存区域 程序计数器: 可以看成是当前线程所执行的字节码的行号指示器 Java虚拟机栈: 生命周期与线程相同，描述的是Java方法执行的内存模型：每个方法子执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息 本地方法栈: 为虚拟机使用到的Native方法服务（而虚拟机栈为Java方法服务）线程共享的内存区域 Java堆: 在虚拟机启动时创建，用于存放对象实例，可以处于物理上不连续的内存空间，主要逻辑上连续即可 方法区: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，可以选择笃定大小或者可拓展外，还可以选择不实现垃圾收集 运行时常量池: 方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这部分内容在类加载后进入方法区的运行时常量池存放） HotSpot虚拟机对象探秘对象的创建 虚拟机遇到一条new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用 为新生对象分配内存 两种分配内存的方法： i. 指针碰撞: Java堆中内存绝对规整时 ii. 空闲列表: Java堆中内存不规整，已使用的内存和空闲的内存相互交错时 并发情况下解决线程安全的两种方法： i. 对分配内存空间的动作进行同步 ii. 把内存分配动作按照线程划分在不同的空间之中进行 将分配到的内存空间都初始化为零值（对象头除外） 对对象进行必要的设置（对象头） 从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，还需要第5步 执行&lt;init&gt;方法 对象的内存布局 对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充 对象头: 包括两部分： i. 用于存储对象自身的运行时数据，如HashCode、GC分代年龄… ii. 类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例（如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据） 实例数据: 对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容 对齐填充: 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍） 对象的访问定位 取决于虚拟机的实现，主流的访问方式有两种： 使用句柄: Java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息 直接指针: reference中存储的直接就是对象地址]]></content>
      <categories>
        <category>深入理解java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之Class类文件结构]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BClass%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Class文件十一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上的空间的数据项时，按照 高位在前(最高位字节在地址最低位)的方式分割成若干个8为字节进行存储 Class文件格式： 1. 魔数与Class文件的版本 每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件（很多文件存储标准都是用魔数来进行身份识别，譬如图片格式等） 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件 2. 常量池 紧接着主次版本号之后的是常量池入口，常量池可以 理解为Class文件之中的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值，这个计数值从1开始 常量池中主要存放两大类常量：字面量和符号引用： 字面量：比较接近于Java语言层面的常量概念 符号引用：属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 常量池中每一项常量都是一个表，每个表开始的第一位都是一个u1类型的标志位，代表 当前这个常量属于那种类型常量 常量池的项目类型： 3. 访问标志 2个字节，用于标识一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否为abstract类型等 4. 类索引、父类索引与接口索引集合 Class文件中由这三项数据来确定这个类的继承关系 类索引和父类索引引用两个u2类型的索引值表示，他们各自指向一个类型为CONSTANT_Class_info的类描述常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串 接口索引集合，入口第一项–u2类型的数据为接口计数器，表示索引表的容量 5. 字段表集合 用于描述接口或者类中声明的变量 字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量 6. 方法表集合 Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式 7. 属性表集合 在Class文件，字段表、方法表都可以携带自己的属性表集合]]></content>
      <categories>
        <category>深入理解java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之虚拟机字节码执行引擎]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[运行时栈帧结构 i. 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。 ii. 每一个栈帧都包括了 局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息 iii. 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程 iv. 在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法 栈帧的概念结构：(/images/jvm_stackframe_structure.jpg) 1. 局部变量表 一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量 单位:局部变量表的容量以变量槽（Slot）为最小单位 虚拟机定位：虚拟机通过索引定位的方式使用局部变量表，索引值从0开始到局部变量表最大的Slot数量 64位数据的访问：对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用热任何方式单独访问其中的某一个 局部变量表的空间分配： i. 如果执行的是实例方法，在那局部变量表最后还给你第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。 ii. 其余参数按照参数表顺序排列，占用从1开始的局部变量Slot。 ii. 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用于分配其余的Slot Slot重用：如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用，但是Slot的复用会直接影响到系统的垃圾收集行为实例代码一：123456public static void main(String[] args)() &#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; System.gc();&#125; 实例代码二：1234567public static void main(String[] args)() &#123; &#123; byte[] placeholder = new byte[64 * 1024 * 1024]; &#125; int a = 0; System.gc();&#125; 代码一的placeholder没有被回收，而代码二的被回收了 2. 操作数栈当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈写入和提取内容，也就是出栈/入栈操作 在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的，但大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠(/images/jvm_stackframe_operandstack.jpg) 3. 动态链接常量池中的符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化为静态解析；另外一部分在每一次运行期间转化为直接引用，这部分称为动态连接 4. 方法返回地址一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器值；而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息 5. 附加信息虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息 方法调用方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程 ####1. 解析调用目标在程序代码写好，编译器进行编译时就必须确定下来，这类方法的调用称为解析。 非虚方法和虚方法:可以在解析阶段中确定唯一调用版本的方法有4类：静态方法、私有方法、实例构造器、父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为 非虚方法，其他方法称为 虚方法（除了final方法） 解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及引用全部转变为可确定的直接引用 2. 分派解析和分派两者之间的关系不是二选一的排他关系，他们是在不同层次上筛选、确定目标方法的过程。 静态分派所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的经典应用和是方法重载。 动态分派在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。 单分派与多分派方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。 Java的静态分派属于多分派类型，动态分派属于单分派类型，所以Java是一门静态多分派、动态单分派的语言 虚拟机动态分派的实现最常用的“稳定优化”手段是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找,虚方法中存放着各个方法的实际入口地址!(/images/jvm_method_dispatch.jpg)方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把类的方法表也初始化完毕 基于栈的字节码解释执行引擎解释执行Java编译器完成了程序代码经过了词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。 这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的变异就是 半独立的实现。 基于栈的解释器执行过程看一个例子的执行流程基本可以了解123456public int calc() &#123; int a = 100; int b = 200; int c = 300; return (a + b) * c;&#125; 字节码：12345678910111213141516public int calc(); Code: Stack=2, Locals=4, Args_size=1 0: bipush 100 2: istore_1 3: sipush 200 6: istore_2 7: sipush 300 10: istore_3 11: iload_1 12: iload_2 13: iadd 14: iload_3 15: imul 16: ireturn&#125; 上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述]]></content>
      <categories>
        <category>深入理解java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[对象存活判断算法引用计数算法给对象添加一个引用计数器，有一个地方引用它计数值就加1，引用失效时减1，任何时刻计数器为0则不可能再被使用 实现简单，判定效率高，但很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用这种方式管理内存 可达性分析算法通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过 的路径称为引用链，当一个对象到GC Roots没有任何引用链时，证明此对象是不可用的 Java中扩展为GC Roots的对象包括以下几种 ： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 对象死亡的判定真正宣告一个对象死亡，至少要经理两次标记过程： 在进行可达性分析后发现不可达，将会被第一次标记并且进行一次筛选 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，视为“没有必要执行finalize”的情况，若有必要执行finalize，则将对象放入F-Queue的队列之中，并稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行。（一个对象的finalize()方法只会被系统调用一次） GC对F-Queue中的对象进行第二次标记 对象逃脱的唯一机会就在finalize()方法中，只要重新与引用链上的任何一个对象建立关联即可 回收方法区（即HotSpot中的永久代） 永久代的垃圾主要回收两部分的内容：废弃常量和无用的类。 “无用的类”需要满足的三个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.class.Class对象没有在任何地方被引用 垃圾收集算法标记-清除算法 标记阶段: 标记所有需要回收的对象 清除阶段: 统一回收所有被标记的对象两个不足： 效率问题，标记和清除的效率都不高 空间问题，标记清除之后产生大量不连续的碎片 复制算法 将可用内存按容量划分为大小相等的凉快，每次之使用给一块。当这一块的内存用完时，就将还存活的对象复制到另外一块上，然后把已使用过的内存空间一次清理掉。 现在商业虚拟机用这种算法回收新生代，将内存分为一块 较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将这两块上还存活的对象一次性复制到Survivor上，最后清理掉Eden和Survivor（在HotSpot默认Eden和Survivor的大小比例为8:1） 当Survivor内存不够用时，需要依赖其他内存（这里指老年代）进行分配担保 标记-整理算法 和“标记-清除算法”一样，但后续步骤是不是直接对可回收对象进行清理，而是 让所有存活的对象都向一端移动 分代收集算法 把Java堆分为 新生代和 老年代，这样可以根据各个年代的特点采用最适当的收集算法 新生代每次垃圾收集都发现大批对象死去，只有少量存活，选用复制算法 老年代对象存活率高、没有额外空间对它进行分配担保，使用“标记清理”或者“标记整理”算法 HotSpot的算法实现枚举根节点在HotSpot中，使用OopMap来直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些未知是应用 安全点 HotSpot没有为每条指令都生成OopMap，只是在安全点（Safepoint）记录了这些信息 即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停 当GC发生时让所有线程都跑到最近的安全点上停顿下来的两种方案： 抢先式中断 主动式中断： 当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志 安全区域指正在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。 当线程执行到安全区域中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM发起GC时，就不用管标识自己为Safe Region的线程了 内存分配与回收策略1. 对象有限在Eden分配 大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC Minor GC期间虚拟机若发现已有的对象无法放入Survivor空间，就通过分配担保机制提前转移到老年代去 新生代GC（Minor GC）与老年代GC（Major GC/Full GC）： i. 新生代GC：Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快 ii. 老年代GC：出现了Major GC经常会伴随着至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上 2. 大对象直接进入老年代 大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，目的是避免在Eden区及两个Survivor区之间发送大量的内存复制 3. 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计数器 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，对象年龄设为1 对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（可以用过参数-XX：MaxTenuringThreshold设置，默认为15），就将会被晋升到老年代中 4. 动态对象年龄判定 虚拟机并不是永远地要求 对象的年龄必须达到了XX：MaxTenuringThreshold才能晋升老年代 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代 5. 空间分配担保 发送Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可以确保是安全的 如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败： 如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小： 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的； 如果小于，那么这时要改为进行一次Full GC 如果不允许，那么也要改为进行一次Full GC JDK6 Update24之后规则变为只要老年代最大可用的连续空间大于新生代总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。（HandlePromotionFailure仍存在但不起影响）]]></content>
      <categories>
        <category>深入理解java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之虚拟机类加载机制]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类加载的时机 类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载，其中验证、准备、解析3个部分统称为 连接 加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，但是解析阶段则不一定，有些情况下可在初始化阶段之后再开始（为了支持Java语言的运行时绑定） 虚拟机规范严格规定了 有且只有5种情况必须立即对类进行“初始化”： 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时 使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化 当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类 使用JDK1,7的动态语言支持时，java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄 这5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用 - 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化类加载的过程1. 加载在加载阶段，虚拟机需要完成以下3件事： - 通过一个类的全限定名来获取定义此类的二进制字节流 - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中 对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面 2. 验证验证阶段大致上会完成下面4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证: 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，保证输入的字节流能正确地解析并存储于方法区，格式上符合描述一个Java类型信息的要求 元数据验证:对类的元数据信息语义校验，保证不存在不符合Java语言规范的元数据信息 字节码验证:通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的 符合引用验证:可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行，发生在虚拟机将符号引用转化为直接引用时 如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间 验证的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全 3. 准备准备阶段是 正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值） 的阶段，这些变量所使用的内存都将在方法区中进行分配 这里进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中 如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值 4. 解析解析阶段是 虚拟机将常量池内的符号引用替换为直接引用的过程 符号引用与直接引用： 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可 直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄 解析发生的时间：虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它 除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行 解析动作： 类和接口的解析 字段解析 类方法解析 接口方法解析 5. 初始化在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，可以从另外一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程 &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。示例：如下例子输出结果为-1（静态语句块中x为局部变量，不影响静态变量x的值） 12345678910public class Test&#123; static&#123; int x=5; &#125; static int x,y; public static void main(String args[])&#123; x--; System.out.println(x); &#125;&#125; 虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕 父类的&lt;clinit&gt;()方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作 &lt;clinit&gt;()方法对于类和接口不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法 执行接口的&lt;clinit&gt;()方法不需要先执行父接口菜单&lt;clinit&gt;()方法，只要当父接口中定义的变量使用时，父接口才会初始化 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步 类加载器类与类加载器对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。 即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等 双亲委派模型从Java虚拟机的角度来讲，只存在两种不同的类加载器：i. 启动类加载器，是虚拟机的一部分;ii. 另一种是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader 启动类加载器：负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，开发者无法直接引用 扩展类加载器：负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用 应用程序类加载器：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，开发者可以直接使用 双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载 这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码]]></content>
      <categories>
        <category>深入理解java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五层体系结构之运输层]]></title>
    <url>%2F2018%2F11%2F18%2F%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[运输层协议概述进程之间的通信 运输层的重要功能：复用和分用 复用: 应用层所有的应用进程都可以通过运输层再传送到IP层 分用: 运输层从IP层收到数据后必须交付给指明的应用进程 网络层与运输层的区别 网络层: 为主机之间提供逻辑通信 运输层: 为应用进程之间提供端到端的逻辑通信 运输层的端口（软件端口） 给应用层的每个应用进程赋予一个明确的标志 服务器端使用的端口号 熟知端口号（系统端口号）：0~1023,指派给了TCP/IP最重要的一些应用程序 登记端口号: 1024~49151 客户端使用的端口号 又叫 短暂端口号 ,49152~65535，仅在客户进程运行时动态选择 用户数据报协议UDP 在IP的数据服务上加了复用和分用，差错检测的功能 主要特点 UDP是无连接的: 发送数据之前不需要建立连接 UDP使用尽最大努力交付 UDP是面向报文的: 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文 UDP没有拥塞控制: 因此网络出现的拥塞不会使源主机的发送速率降低 UDP支持一对一、一对多、多对一和多对多的交互通信 UDP的首部开销小:只要8个字节 UDP的首部格式 四个字段，每个字段两个字节 源端口 目的端口 长度 检验和 传输控制协议TCP概述 主要特点 TCP是面向连接的运输层协议: 使用之前，必须建立连接；数据传输完毕之后，必须释放已经建立的连接 每一条TCP连接只能有两个端点: 点对点（一对一） TCP提供可靠交付的服务: 无差错、不丢失、不重复，按序到达 TCP提供全双工通信: 允许通信双方的应用进程在任何时候都能发送数据。发送时，应用程序在把数据传送给TCP的缓存之后就可以做自己的事，然后TCP在合适的时候把数据发送出去；接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据 面向字节流: 应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流 TCP的连接 TCP连接的端点叫做套接字或插口 端口号拼接到IP地址构成了套接字 每一条TCP连接唯一地被通信两端的两个端点所确定 同一个IP地址可以有多个不同的TCP链接，而同一个端口号也可以出现在多个不同的TCP连接 可靠传输的工作原理停止等待协议 ”停止等待“就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组 无差错情况 出现差错(超时重传) 发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组 三点注意： 发送方发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传时使用）,收到确认后才可以清除副本。 分组和确认分组都必须编号（才能明确是哪一个发送出去的分组收到了确认） 重传时间应当比数据在分组传输的平均往返时间更长一些 确认丢失和确认迟到 确认丢失: 接收方发送的对分组的确认丢失了 当接收方又收到重传的分组时（发送方没有收到确认信息会重传），采取两个行动： i. 丢弃这个重复的分组 ii. 向发送方发送确认 确认迟到: 传输过程没有差错，但接收方对分组的确认迟到了 i. 发送方会收到重复的确认，收下后丢弃； ii. 接收方会收到重复的分组， 同样丢弃，并重传确认分组 信道利用率信道利用率计算： 当往返时间RTT远大于分组发送时间Td时，信道的利用率会非常低，因而需要采用流水线传输 连续ARQ协议 发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方的确认 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置 接收方一般采用累积确认的方式，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后对按序到达的最后一个分组发送确认，这表示：到这个分组为止的素有分组都已正确收到了 优点： 容易实现，确认丢失也不必重传 缺点： 不能正确反映出接收方已经正确收到的所有分组的信息，比如5个中的第3个丢了，就只能对前两个分组发出确认，后面三个重传 TCP报文段的首部格式 TCP的全部功能都体现在它首部中各字段的作用 源端口和目的端口: 序号: 范围[0, 2^32 - 1],序号增加到2^32 - 1后，下一个序号又回到0。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号 确认号: 期望收到对方下一个报文段的第一个数据字节的序号，若确认号=N,则表明：到序号N-1为止的所有数据都已正确收到 数据偏移: 单位是4个字节，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出TCP报文段的首部长度 保留: 保留为今后用，目前应置为0 紧急URG: 当URG=1时，表示文段中有紧急数据，发送应用进程告诉发送方的TCP有紧急数据要传送，发送方TCP就把紧急数据插入到被报文段的最前面，要与紧急指针字段配合使用 确认ACK: 在TCP连接建立后所有传送的报文都必须把ACK置1 推送PSH: 发送方TCP把PSH置为1时，立即创建一个报文段发送出去，接收方尽快地交付接收应用进程，不用等到缓存填满 复位RST: 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接 同步SYN: 在连接建立事用来同步序号 终止FIN: 用来释放一个连接 窗口: 指的是发送本报文段的一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量 校验和: 计算方法和UDP一样 紧急指针: 当URG=1时才有意义，指出本报文段中的紧急数据的字节数 选项: 长度可变，最长达40字节 TCP可靠传输的实现1.以字节为单位的滑动窗口 TCP的滑动窗口以字节为单位 发送窗口里面的序号表示允许发送出去的序号 如图，假定A收到B发来的确认报文段，其中窗口是20，确认窗口是31，表明B期望收到的下一个序号是31,30为止的数据已经收到了 凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传 描述一个发送窗口的状态需要三个指针，如图： 发送缓存用来暂时存放： i. 发送应用程序传送给发送方TCP准备发送的数据； ii. TCP已发送出但尚未收到确认的数据；tcp_recieve_cahce 接收缓存用来暂时存放： i. 按序到达的、但尚未被接收应用程序读取的数据； ii. 未按序到达的数据； 三点强调： i. 发送窗口并不总是和接收窗口一样大 ii. 对于不按序到达的数据，先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程 iii. TCP要求接收方必须有累积确认的功能 2.超时重传时间的选择RTTs（加权平均往返时间）计算：RTTd（RTT的偏差的加权平均值）计算：RTO（超时重传时间）： 3.选择确认SACK 用来解决只传送缺少的数据而不重传已经正确到达接收方的数据 TCP的流量控制 流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。 利用滑动窗口实现流量控制 发送方的发送窗口不能超过接收方给出的接收窗口的数值 传输效率三种控制TCP报文段发送时机的机制: 维持一个变量，等于最大报文段长度MSS 发送方的应有进程指明要求发送报文段，即推送(push)操作 发送方的计时器期限 TCP的拥塞控制 拥塞控制的一般原理两种方法： 开环控制：在设计网络时事先将有关发送拥塞的因素考虑周到，力求网络在工作时不发生拥塞，但系统运行起来中途不能改正 闭环控制：三种措施： i. 检测网络系统以便检测到拥塞何时、何处发生； ii. 把拥塞发送的信息传送到可采取行动的地方； iii. 调整网络系统的运行以解决问题； 四种拥塞控制方法慢开始和拥塞避免：发送方维持一个叫做拥塞窗口cwnd的状态变量，发送方让自己的发送窗口等于拥塞窗口； 慢开始：由小到大逐渐增大拥塞窗口数值（为了防止拥塞窗口cwnd增长过大引起网络拥塞，需要设置一个慢开始门限状态变量ssthresh） 拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间就把发送方的拥塞窗口加1（拥塞避免并非完全能够避免了拥塞）慢开始和拥塞避免算法实现举例：快重传和快恢复: 快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未搜到的报文段，而不必继续等待重传计时器到期 快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”，把慢开始门限ssthresh减半（而不是直接设置cwnd为1），然后开始拥塞避免算法快重传和快恢复算法实现举例： 随机早期检测RED 随机早期检测： 在检测到网络拥塞的早期征兆时，就以概率p随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，少量的分组被丢弃，避免发生全局性的拥塞控制 需要选择好三个参数：最小门限THmin，最大门限THmax和概率p 丢弃概率p与两个门限值的关系图： TCP的运输连接管理 运输连接有三个阶段：连接建立，数据传送，连接释放 TCP的连接建立：三次握手 第一次握手：客户进程A创建传输控制模块TCB，向服务进程发出连接请求报文段，等待B确认，这时A进入SYN-SENT（同步已发送）状态 报文段首部中SYN=1，同时选择一个初始序号seq=x，不携带任何数据，但要消耗一个序号 第二次握手：服务进程B收到请求报文段后，如同意建立连接，则向A发送确认，这时TCP服务进程进入SYN-RCVD（同步已发送）状态 将SYN和ACK都置1，确认号是ack=x+1，同时也为自己选一个初始序列号seq=y 第三次握手：A收到B的确认后，要向B给出确认，这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态，当B收到A的确认后，也进入ESTABLISHED状态 A发送的确认报文段ACK置1，确认号ack=y+1，自己的序号seq=x+1，ACK报文段可以携带数据，但不携带数据则不消耗序号。A发送一次确认是为了防止已失效的连接请求报文段突然又传到了B TCP的连接释放:四次挥手 第一次挥手：A向B发送释放连接报文段，A进入FIN-WAIT-1在（终止等待1）状态 报文段首部中终止控制位FIN置1，其序号是seq=u，等于前面已传送过的数据的最后一个字节的序号加1，即使不携带任何数据，但要消耗一个序号 第二次挥手：B收到连接释放报文段后发出确认，B进入CLOSE-WAIT（关闭等待）状态，这时TCP连接处于半关闭状态，即A已经没有数据发送给B，但B若发送数据，A仍要接收。A收到确认之后，进入FIN-WAIT-2（终止等待2）状态 确认号是ack=u+1，这个报文号自身的序号是v,等于前面已传送过的数据的最后一个字节的序号加1 第三次挥手：若B已经没有要想向A发送的数据，就通知TCP释放连接，B进入LAST-ACK（最后确认状态），等待A的确认 B发出的报文段令FIN=1，而且必须重复上次已发送过的确认号ack=u+1 第四次挥手：A收到B的连接释放报文段后，必须对此发出确认。然后A进入TIME-WAIT（时间等待）状态 A发送的确认报文段ACK置1，确认号ack=w+1，自身的序号是seq=u+1。注意这时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。 TCP的有限状态机 粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，细线箭头表示异常变迁]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发]]></title>
    <url>%2F2018%2F11%2F15%2FJava%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[基本的线程机制定义一个线程 实现Runnable接口，重写run()方法，并传递给Thread构造器 继承Thread类，重写run()方法 调用Thread.start()方法时，其实是创建一个线程，并初始化之后，再去调run()方法 使用Executor Executor从来管理Thread对象，在客户端和任务之间提供了一个间接层，可以管理一部任务的执行，无须显式地管理线程的生命周期。ExecutorService（具有服务生命周期的Executor）知道如何构建恰当的上下文来执行Runnable对象 有集中不同的Executor： CacheThreadPool：通常创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程（首先的Executor） FixedThreadPool：使用有限的线程集来执行所提交的任务，可以一次性预先执行代价高昂的线程分配 SingleThreadPool：像是线程数量为1的FixedThreadPool，当希望在另一个线程中连续运行某事物来说很有用。当提交多个任务时，这些任务会排队。示例（三种Executor都这样使用）： 123456789public class SingleThreadPool &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newSingleThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; exec.execute(new LiftOff()); &#125; exec.shutdown(); &#125;&#125; 从任务中产生返回值 实现Callable接口，从call（）方法中返回值，必须使用ExecutorService.submit()方法调用。submit()方法会产生Future对象。可以用isDone()方法来查询Future是否完成，完成时可以调用get()方法获取该结果，若完成就调用get()方法将阻塞到完成。 1234567891011121314151617181920212223242526272829public class TaskWithResult implements Callable&lt;String&gt; &#123; private int id ; public TaskWithResult(int id) &#123; this.id = id; &#125; public String call() &#123; return "result of TaskWithResult " + id; &#125;&#125;public class CallableDemo &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;Future&lt;String&gt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; results.add(exec.submit(new TaskWithResult(i))); &#125; for(Future&lt;String&gt; fs: results) &#123; try &#123; System.out.println(fs.get()); &#125; catch &#123; System.out.printLn(e); return; &#125; finally &#123; exce.shutdown(); &#125; &#125; &#125;&#125; 休眠(sleep) sleep(),使任务中止执行给定的时间，但不会释放持有的锁 优先级 Java有十个优先级，但不同的操作系统有不同的优先级，不能与操作系统有很好的映射。在调整优先级时只是用MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY三个等级 让步(yield) 暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。 加入一个线(join) 某个线程在另一个线程t上个调用join()，此线程被挂起，知道目标线程t结束(即.isAlive()为假)才恢复，也可调用join()时带一个超时参数，超时便返回 后台线程(维护线程) 可以在线程启动之前调用setDaemon()方法设置为后台线程 一个后台进程创建的任何线程被自动地设置为后台线程 后台线程在不执行finally子句时就终止器run()方法 编码变体 有时候可以使用内部类将代码隐藏在类中 继承Thread的两种写法：1.扩展自Thread的匿名内部类 123456789101112131415class InnerThread1 &#123; private Inner inner; private class Inner extends Thread &#123; Inner(String name) &#123; super(name); start(); &#125; public void run() &#123; ...... &#125; &#125; public InnerThread1(String name) &#123; inner = new Inner(name); &#125;&#125; 2.在构造器中穿件一个匿名的Thread子类，并且向上转型为Thread引用t 1234567891011class InnerThread2 &#123;&#125; private Thread t; public InnerThread2(String name) &#123; t = new Thread(name) &#123; public void run() &#123; ...... &#125; &#125;; t.start(); &#125;&#125; 实现Runnable的两种写法（同上两种情况） 12345678910111213141516class InnerRunnable1 &#123; private Inner inner; private class Inner implements Runnable &#123; Thread t; Inner(String name) &#123; t = new Thread(this, name); t.start(); &#125; public void run() &#123; ...... &#125; &#125; public InnerRunnable1(String name) &#123; inner = new Inner(name); &#125;&#125; 12345678910class InnerRunnable2 &#123; private Thread t; public InnerRunnable2(String name) &#123; t = new Thread(new Runnable() &#123; public void run() &#123; ...... &#125;, name); t.start(); &#125;&#125; 在方法内部创建线程 123456789101112131415class ThreadMethod &#123; private Thread t; private String name; public ThreadMethod(String name) &#123; this.name = name; &#125; public void runTask() &#123; if(t == null) &#123; t = new Thread(name) &#123; public void run() &#123; ...... &#125; &#125;; t.start(); &#125; &#125;&#125; 捕获异常 线程的本质特征使得我们態捕获从线程中逃逸的异常，而是直接向外传播到控制台，就算用try-catch语句也没有作用。因而要捕获异常，需要修改Executor产生线程的方式，为每个新创建的Thread附着一个Thread.UnCaughtExceptionHandler()，Thread.UnCaughtExceptionHandler.uncaughtException()会在线程因在线程因未捕获异常而临近死亡时被调用 实例： 123456789101112131415161718192021222324252627282930313233343536373839class ExceptionThread2 implements Runnable &#123; public void run() &#123; Thread t = Thread.currentThread(); System.out.println("run() by " + t); System.out.println( "eh = " + t.getUncaughtExceptionHandler()); throw new RuntimeException(); &#125;&#125;//创建一个uncaughtExceptionHandlerclass MyUncaughtExceptionHandler implementsThread.UncaughtExceptionHandler &#123; public void uncaughtException(Thread t, Throwable e) &#123; System.out.println("caught " + e); &#125;&#125;class HandlerThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable r) &#123; System.out.println(this + " creating new Thread"); Thread t = new Thread(r); System.out.println("created " + t); //设置uncaughtExceptionHandler t.setUncaughtExceptionHandler( new MyUncaughtExceptionHandler()); System.out.println( "eh = " + t.getUncaughtExceptionHandler()); return t; &#125;&#125;public class CaptureUncaughtException &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool( new HandlerThreadFactory()); exec.execute(new ExceptionThread2()); &#125;&#125; 以上代码将输出： HandlerThreadFactory@de6ced creating new Thread created Thread[Thread-0,5,main] eh = MyUncaughtExceptionHandler@1fb8ee3 run() by Thread[Thread-0,5,main] eh = MyUncaughtExceptionHandler@1fb8ee3 caught java.lang.RuntimeException 线程安全性 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。 无状态对象: 无状态对象一定是线程安全的 竞态条件： 由于不恰当的执行时序而出现不正确的结果的情况，大多数竞态条件的本质是———基于一种可能失效的观察结果做出判断或执行某个计算，比如“先检查后执行”操作 复合操作： 包含了一组必须以原子方式执行的操作以确保线程安全性 内置锁：每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁i.同步代码块分为两部分：一个作为锁的对象的引用，一个作为这个锁保护的代码块ii. 对象锁：用来控制实例方法之间的同步，包括用synchronized修饰的方法和代码块均是对象锁iii. 类锁： 即以Class对象作为锁，用来控制静态方法之间的同步，包括静态的synchronized方法 重入： 某个线程试图获得一个已经由它自己持有的锁，那么这个请求会成功 共享受限资源解决共享资源竞争1.使用synchronized关键字2.使用显式的Lock对象示例： 123456789101112131415161718public class MutexEvenGenerator extends IntGenerator &#123; private int currentEvenValue = 0; private Lock lock = new ReentrantLock(); public int next() &#123; lock.lock(); try &#123; ++currentEvenValue; Thread.yield(); ++currentEvenValue; return currentEvenValue; &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; EvenChecker.test(new MutexEvenGenerator()); &#125;&#125; 对lock()的调用必须放置在finally语句中带有unlock()的try-finally语句中 return语句必须出现在try子句中，以确保unlock()不会过早发生 这里finally子句也可以同时放置其他处理，以维护系统在正确的状态，避免抛出异常 lock.trylock(),ReentrantLock允许你尝试着获取但最终未获取锁，如果其他线程已经获取了这个锁，那可以离开去执行其他的任务 线程本地存储 一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储 线程之间的协作wait(),notify(),notifyAll() wait()使你将当前任务挂起，可以等待某个条件发生，而改变这个条件超出了当前方法的控制能力，通常这种条件由另一个任务来改变 调用wait()时，对象上的锁被释放，该对象上的其他synchronized方法可以在wait()期间被调用； 只有在notify()或notifyAll()发生时，调用wait()的任务才会被唤醒； wait()，notify()，notifyAll()是Object()的一部分，所以可以把wait()放在任何同步控制方法中，不需要考虑是否继承Thread或实现Runnable; 只能在同步控制方法或同步控制块里调用wait()，notify()，notifyAll()； 为了使任务从wait()中唤醒，必须首先重新获得当它进入wait()时释放的锁； 有两种形式的wait()：i. 接受毫秒数作为参数，可以通过notify()，notifyAll()，或者时间到期后恢复ii. 不接受任何参数，通过notify()，notifyAll()恢复 使用notify()，众多等待同一个锁的任务中只有一个会被唤醒，必须保证被唤醒的任务是恰当的任务，而且所有任务必须等待相同的条件 notifyAll()将唤醒所有等待这个锁的任务 新类库中的构件CountDownLatch 适用场景：用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成 CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()方法都将阻塞，知道这个计数值到达0； 其他任务结束时，可调用对象上的countDown()减小计数值 计数值不能被重置（需要重置计数值可以用CyclicBarrier） CyclicBarrier 适用场景： 希望创建一组任务，他们并行地执行工作，然后在下一个步骤之前等待，直至所有任务都完成与CountDownLatch的区别 可以重用 可以向CyclicBarrier提供一个Runnable，当计数值到达0时自动执行 DelayQueue 一个无边界的BlockingQueue，用于放置实现了Delayed接口的对象，队列是有序的，对头对象的延迟到期的时间最长，对象只能在到期时才能取走 PriorityBlockingQueue 基础的优先级队列，具有可阻塞的读取操作 ScheduleExecutor 解决在预定时间运行的任务，使用schedule()（运行一次）或scheduleThreadFixedRate()（每隔规定的时间重复执行任务），可以将Runnable对象设置为将来的某个时刻执行 Semaphore 计数信号量，允许n个任务同时访问这个资源 Exchanger 应用于一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象，通过使用Exchanger，可以有更多的对象在创建的同时被消费]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的锁优化]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E4%B8%AD%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[自旋锁: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁 自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统方式挂起线程 自旋适应锁: 自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且尺有所 的线程正在运行中，那么自旋等待时间将会持续相对更长；如果对于某个锁，自旋很少成功获得过，拿在以后要获取这个锁时将可能省略掉自旋过程 锁消除: 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不存在共享数据竞争的锁进行消除 锁粗化: 虚拟机探测到有一串零碎的操作对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，例如： 1234567public String concatString(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.tostring();&#125; 这里原先每次append操作都需要加一次锁，而虚拟机会扩展到第一个append操作之前到最后一个append操作之后，就只需要加一次锁 轻量级锁: 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制称为“重量级”锁 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。 偏向锁: 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即在无精准的情况下把整个同步都消除掉]]></content>
      <categories>
        <category>深入理解java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[主内存与工作内存 主内存: Java内存模型规定了所有的变量都存储在主内存中。 这里的主内存与物理硬件的主内存可以类比，但这里的主内存仅是指虚拟机内存的一部分。 工作内存: 每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中，而不能直接读写主内存中的变量。 工作内存可以与处理器的高速缓存类比 线程、主内存、工作内存的交互关系 内存间交互操作java内存模型定义的8种操作 lock(锁定): 作用于主内存的变量，它把一个变量标识为一条线程独占的状态 unlock(解锁): 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read(读取): 作用于主内存的变量，它把一个变量的值从主内存传输到线程的总做内存中，以便随后的load动作使用 load(载入): 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存给的变量副本中 把一个变量从主内存复制到工作内存，那就要顺序地执行read和load，但不要求连续执行 use(使用): 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时会执行这个操作 assign(赋值): 作用于工作内存的变量，它把一个从执行亲情接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 store(存储): 作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中一遍随后的write操作使用 write(写入): 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 把一个变量从工作内存同步到主内存，那就要顺序地执行store和write，但不要求连续执行 8种操作需要满足的规则 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须将该变化同步回主内存 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中 一个新的变量只能在主内存”诞生“，不允许在工作内存中直接使用一个未被初始化（load或assign）的变脸，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这变量前，，需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定住的变量 对一个变量执行unlock操作之前，必须先把此变量同步回主内存。 volatile型变量的特殊规则volatile当一个变量定义为volatile之后，它将具备两种特性： 可见性: 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存完成 volatile变量只能在以下两种场景保证可见性 1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值 2.变量不需要与其他的状态变量共同参与不变约束 禁止指令重排序优化: 普通变量仅仅会保证在该方法的执行过程中所有依赋值结果的地方都能获取到正确的结果，而不能保证变量复制的顺序与程序代码中的执行顺序一致。 volatile与锁之间的区别 volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，不过大多数场景volatile的总开销仍然要比锁低，我们在volatile与锁之间的选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求 volatile变量的特殊规则 假设T表示一个线程，V和W分别表示两个volatile变量，在进行read、load、use、assign、store和write操作时需要满足如下规则： 线程T对变量V的use动作可以认为是和线程T对变量的load、read动作的相关联，必须连续一起出现（即在工作内存中，每次使用V之前必须先从主内存刷新最新的值） 线程T对变量V的assign动作可以认为是和线程T对变量的store、write动作的相关联，必须连续一起出现（即在工作内存中，每次修改V之后必须立刻同步回主内存中） 假设A是T对V的use或assign动作，F是和A相关联的load或store动作，P是和F相关联的read或write动作；类似的B是T对W实施的use或assign动作，G是和B相关联的load或store动作，Q是和G相关联的read或write动作。 如果A先于B，那么P先于Q（这要求volatile变量不会被指令重排序优化） 原子性、可见性、有序性原子性 基本数据类型的访问读写是具备原子性的（long和double除外） synchronized可以满足更大范围的原子性保证可见性 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改 volatile： 保证多线程操作时变量的可见性而普通变量不可以 synchronized： 对一个变量执行unlock之前，必须先把此变量同步回主内存 final： 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递，拿在其他线程中就能看见final字段的值 有序性 如果在本线程内管程，所有的操作都是有序的（线程内表现为串行）， 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序，工作内存与主内存同步延迟） volatile关键字本身包含了禁止指令重排序的语义 synchronized决定了持有用一个锁的同步快只能串行地进行 “天然的“先行发生关系 程序次序规则: 在一个线程内，按照控制流顺序发生 管程锁定规则: 一个unlock操作先行发生于后面对同一个锁的lock操作 volatile变量规则: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作 线程启动规则: Thread对象的start（）方法先行发生于此线程的每一个动作 线程中止规则: 线程中的所有操作都先行发生于对此线程的终止检测 线程中断规则: 对线程interrupt（）方法的调动先行发生于被中断线程的代码检测到中断事件的发生 对象终结规则: 一个对象的初始化完成先行发生于他的finalize（）方法的开始 传递性: A先行发生于B，B先行发生于C，则A先行发生于C 这些先行发生关系无须任何同步协助就已经存在，可以直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。]]></content>
      <categories>
        <category>深入理解java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务管理]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务的ACID特性 原子性: 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。 一致性: 隔离执行事务时（即不考虑其他事务并发执行）保持数据库的一致性。 在数据库系统中由恢复系统负责。 隔离性: 尽管多个事务可能并发执行，但系统保证对于多个事务，如T1和T2，对于T1来说，T1要么在T2开始之前已经完成执行，要么在T2完成之后开始执行。确保隔离性在数据库系统中由并发控制系统部件负责。 持久性: 一旦事务成功完成后，它对数据库的更新必须是永久的，即使出现系统故障，在数据库系统中由恢复系统负责。 可以通过一下两条中的其中任何一条来确保持久性。 事务做的更新在事务结束前已经给写入磁盘 有关事务已执行的更新信息已写到磁盘上，并且此类信息必须充分，能让数据库在系统出现故障后重新启动时重新构造更新 数据库并发事务存在的问题 脏读：一个事务读取了另一个事物改写但还未提交的数据，如果这些数据回滚，则读到的数据是无效的 不可重复读：在同一个事物中，多次读取同一数据返回的结果有所不同 幻读：一个事务读取了几行记录后，另一个事物插入一些记录，幻读就发生了。在后来的查询中，第一个事物就会发现有些原来没有的记录 事务原子性和持久性五种状态可以为事务建立一个简单的抽象事务类型，分为五种状态，事务必须处于以下状态之一 活动的： 初始状态，事务正在执行时处于此状态 部分提交的： 最后一条语句执行后 失败的： 发现正常的执行不能继续后 中止的： 事务回滚并且数据库已恢复到事务开始执行前的状态后 提交的： 成功完成后 中止状态事务回滚的两种选择 重启事务，但仅当引起事务中止的是硬件错误而不是有事务内部逻辑所产生的软件错误。 杀死事务, 这样做通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正 事务隔离性可串行化调度 冲突: 假设I和J是不同事务在在相同数据项上的操作，并且其中至少有一个是write指令时，I与J是冲突的 冲突等价: 调度S经过一系列非冲突指令交换转换成S’，S与S’冲突等价 冲突可串行化: 一个调度S与另一个串行调度冲突等价，则称调度S是冲突可串行化的 可恢复性 可恢复调度: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1先于T2提交 无级联调度: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1必须在T2这一读操作前提交 事务隔离性级别 可串行化: 通常保证可串行化调度，（完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读） 可重复读: 只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据，但该事务不要求与其他事务可串行化。（可防止脏、不可重复读，但幻读依然有可能发生） 已提交读: 只允许读取已提交数据，但不要求可重复读功能。（可防止脏读，但幻读和不可重复读依然有可能发生） 未提交读: 允许读未提交数据。（可能导致脏、幻、不可重复读） 并发控制基于锁的协议锁 共享锁（S): 如果事务T1获得了数据项Q上的共享型锁（记为S），则T1可读但不能写 排他锁(X): 如果事务T1获得了数据项Q上的排他型锁（记为X），则T1既可读又可写Q 相容的锁: 数据项Q上存在B类型锁，如果事务T可以立即获得数据项Q上的A类型锁，则说A类型锁与B类型锁是相容的，即comp(A,B)=true 锁的授予 避免饿死: 可以通过在数据项Q上加M型锁，加锁条件如下： 1.不存在在数据项Q上持有与M型锁冲突的锁的事务 2.不存在等待对数据项Q上先于T申请枷锁的事务 两阶段封锁协议 增长阶段: 事务可以获得锁，但不能释放锁 缩减阶段: 事务可以释放锁，但不能获得新锁 严格两阶段封锁协议: 事务持有的所有排他锁必须在事务提交后方可释放 强两阶段封锁协议: 事务提交之前不得释放任何锁 多粒度 多级粒度机制: 通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大力度数据项中来实现。这种层次结构可以图形化地表示为树 意向锁: 如果一个结点佳航了意向锁，则意味着要在树的叫底层进行显式加锁，在一个结点显式加锁前，该结点的的全部祖先结点都加上了意向锁。 这样子可以避免了需要从头遍历结点才能发现子结点已经加锁 共享意向锁(IS): 一个结点加上了共享意向锁，树的较低层进行显式封锁，但只能加共享锁。 排他意向锁(IX): 一个结点加上了排他意向锁，树的较低层进行显式封锁，可以加共享锁或排他锁。 共享排他意向锁(SIX): 一个结点加上了共享排他意向锁，则以该结点为根的子树显式地加上了共享锁，并且将在数的更低层显式地加排他锁。 各种锁类型相容函数： 基于时间戳的协议对于系统中的每个事务T，把一个唯一的固定时间戳与他联系起来，此时间戳记为TS(T)。该时间戳是在事务T开始执行前由数据库系统赋予的。实现这种机制可以用以下两种方法： 使用系统始终的值作为时间戳，即事务的时间戳等于该事务进入系统时的时钟值。 使用逻辑计数器，没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值。 每个数据项需要与两个时间戳相关联： W-timestamp（Q）表示成功执行write（Q）的所有事务的最大时间戳 R-timestamp（Q）表示成功执行read（Q）的所有事务的最大时间戳 协议运作方式如下：1.假设事务T发出read（Q）&emsp; a.若TS（T）&lt; W-timestamp（Q），则T需要读入的Q值已被覆盖。因此read操作被拒绝，T回滚；&emsp; b.若TS（T）&gt;= W-timestamp（Q），则执行read操作，R-timestamp（Q）被设置为R-timestamp（Q）与TS(T)两者的最大值2.假设事务T发出write（Q）&emsp; a.若TS（T）&lt; R-timestamp（Q），则T产生的Q值是先前所需要的值，且系统已假定该值不会在产生，因此write被拒绝，T回滚&emsp; b.若TS（T）&lt; W-timestamp（Q），则T试图写入的Q值已过时，write操作被拒绝，T回滚&emsp; c.其他情况，系统执行write操作，将W-timestamp（Q）设置为TS（T）。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的XML之与HTML的区别验证，定位信息，命名空间]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%AE%9A%E4%BD%8D%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[HTML与XML的区别 HTML对大小写不敏感，XML大小写敏感 HTML结束标签可以省略，如&lt;/p&gt;，XML不能 XML只有单个标签而没有结束标签的元素必须以/结束 XML属性值必须用引号括起来 HTML属性可以没有值，XML所有属性必须有值 验证XML文档需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema 文档类型定义 将这些规则纳入XML文档 123456789&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE configuration[ &lt;!ELEMENT configuration...&gt; ...]&gt;&lt;configuration&gt;...&lt;/configuration&gt; 这些规则被纳入到DOCTYPE声明中，代码块[…]用来限定其界限，比如configuration SYSTEM声明，将DTD存储在外面 12&lt;!DOCTYPE configuration SYSTEM "config.dtd"&gt;&lt;!DOCTYPE configuration SYSTEM "http://myserver.com/config.dtd"&gt; 标记PUBLIC标识符 123456789class MyEntityResolver implements EntityResolver&#123; public InputSource resolveEntity(String publicId, String systemID)&#123; if(publicID.equals(a knowx ID))&#123; return new InputSource(DTD data): &#125;else&#123; return null; &#125; &#125;&#125; PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空 XML Schema 声明Schema文件 123&lt;?xml version="1.0"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;/project&gt; 使用xsd:表示XSL Schema定义的命名空间 12345678&lt;xsd:element name="name" type="xsd:string"/&gt;- ref属性引用Schema中位于别处的定义&lt;xsd:element ref="name"/&gt;&lt;xsd:element name="style" type=StyleType"/&gt; &lt;xsd:restriction base="xsd:string"/&gt; &lt;xsd:enumeration value="PLAIN"/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:element&gt; 使用XPath定位信息 查找下列的username的值，,通过XPath表达式/configuration/database/username 123456&lt;configfuration&gt; &lt;database&gt; &lt;username id="test"&gt;pinnuli&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/database&gt;&lt;/configfuration&gt; 用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式 123XPathFactory xpFactory = XPathFactory.newInstance();path = xpfactory.newXPath();String username = path.evaluate(/configuration/database/username",doc); 具体的语法看文档 XML的命名空间 使用xmlns给定命名空间 12345&lt;element xmlns="namespaceURI1"&gt; &lt;child xmlns="namespaceURI2"&gt; grandchildren &lt;/child&gt;&lt;/element&gt; 这里第一个子元素和孙元素都是第二个命名空间的一部分 使用xmlns:prefix=”namespaceURI”定义命名空间和前缀 1234&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;xsd:element name=&quot;pinnuli&quot; type=&quot;haha&quot;/&gt; ...&lt;/xsd:schema&gt; 在这里xsd:schema实际上指的是命名空间http://www.w3.org/2001/XMLSchema中的schema 可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性1factory.serNamespaceAware(true); 参阅： 慕课网：Java眼中的XML—文件读取 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J%2F</url>
    <content type="text"><![CDATA[现有以下XML文档books.xml,下面的示例生成此文档部分内容123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt; &lt;book id="1"&gt; &lt;name&gt;冰与火之歌&lt;/name&gt; &lt;author&gt;乔治马丁&lt;/author&gt; &lt;year&gt;2014&lt;/year&gt; &lt;price&gt;89&lt;/price&gt; &lt;/book&gt; &lt;book id="2"&gt; &lt;name&gt;安徒生童话&lt;/name&gt; &lt;year&gt;2004&lt;/year&gt; &lt;price&gt;77&lt;/price&gt; &lt;language&gt;English&lt;/language&gt; &lt;/book&gt;&lt;/bookstore&gt; DOM1、创建DocumentBuilder对象12DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); 2、添加节点12345678910111213document.setXmlStandalone(true);Element bookstore = document.createElement("bookStore");//向bookstore根节点中添加子节点bookElement book = document.createElement("book");Element name = document.createElement("name");name.setTextContent("???");book.appendChild(name);book.setAttribute("id", "1");//将book节点添加到bookstore根节点中bookstore.appendChild(book);//将bookstore节点（已经包含了book）添加到dom树中document.appendChild(bookstore); 3、生成xml文件12345TransformerFactory tff = TransformerFactory.newInstance();Transformer tf = tff.newTransformer();//设置文件tf.setOutputProperty(OutputKeys.INDENT, "yes");tf.transform(new DOMSource(document),new StreamResult(new File("books1.xml"))); SAX1、创建一个TransformerFactory类的对象1SAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance(); 2、通过SAXTransformerFactory对象创建一个TransformerHandler对象1TransformerHandler handler = tff.newTransformerHandler(); 3、通过handler对象创建一个Transformer对象1Transformer tr = handler.getTransformer(); 4、通过Transformer对象对生成的xml文件进行设置12345678910// 设置xml的编码tr.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);// 设置xml的“是否换行”tr.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);5、创建一个Result对象```javaFile f = new File(&quot;newbooks.xml&quot;);if (!f.exists()) &#123; f.createNewFile();&#125; 6、创建Result对象，并且使其与handler关联12Result result = new StreamResult(new FileOutputStream(f));handler.setResult(result); 7、利用handler对象进行xml文件内容的编写O12// 打开documenthandler.startDocument(); 8、添加节点属性和节点值12345678910111213141516171819AttributesImpl attr = new AttributesImpl();handler.startElement("", "", "bookstore", attr);for (Book book : bookList) &#123; attr.clear(); attr.addAttribute("", "", "id", "", book.getId()); handler.startElement("", "", "book", attr); // 创建name节点 if (book.getName() != null &amp;&amp; !book.getName().trim().equals("")) &#123; attr.clear(); handler.startElement("", "", "name", attr); handler.characters(book.getName().toCharArray(), 0, book .getName().length()); handler.endElement("", "", "name"); &#125; handler.endElement("", "", "book");&#125;handler.endElement("", "", "bookstore");// 关闭documenthandler.endDocument(); JDOM1.生成一个根节点1Element rss = new Element("rss"); 2.为节点添加属性1rss.setAttribute("version", "2.0"); 3.生成一个document对象12345678910Document document = new Document(rss);Element channel = new Element("channel");rss.addContent(channel);Element title = new Element("title");title.setText("&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;");channel.addContent(title);//设置文件编码和换行Format format = Format.getCompactFormat();format.setIndent("");format.setEncoding("GBK"); 4.创建XMLOutputter的对象1XMLOutputter outputer = new XMLOutputter(format); 5.利用outputer将document对象转换成xml文档1outputer.output(document, new FileOutputStream(new File("rssnews.xml"))); DOM4J 使用DOM4J生成RSS文件 1.创建document对象，代表整个xml文档1Document document = DocumentHelper.createDocument(); 2.创建根节点rss1Element rss = document.addElement("rss"); 3.向rss节点中添加version属性1rss.addAttribute("version", "2.0"); 4.生成子节点及节点内容123Element channel = rss.addElement("channel");Element title = channel.addElement("title");title.setText("&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;"); 5.设置生成xml的格式12OutputFormat format = OutputFormat.createPrettyPrint();format.setEncoding("GBK"); 6.生成xml文件1234567File file = new File("rssnews.xml");XMLWriter writer;writer = new XMLWriter(new FileOutputStream(file), format);//设置是否转义，默认值是true，代表转义writer.setEscapeText(false);writer.write(document);writer.close(); 参阅： 慕课网：Java眼中的XML—文件读取 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J]]></title>
    <url>%2F2018%2F07%2F30%2FJava%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J%2F</url>
    <content type="text"><![CDATA[现有以下XML文档books.xml,下面的解析示例解析此文档部分内容123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt; &lt;book id="1"&gt; &lt;name&gt;冰与火之歌&lt;/name&gt; &lt;author&gt;乔治马丁&lt;/author&gt; &lt;year&gt;2014&lt;/year&gt; &lt;price&gt;89&lt;/price&gt; &lt;/book&gt; &lt;book id="2"&gt; &lt;name&gt;安徒生童话&lt;/name&gt; &lt;year&gt;2004&lt;/year&gt; &lt;price&gt;77&lt;/price&gt; &lt;language&gt;English&lt;/language&gt; &lt;/book&gt;&lt;/bookstore&gt; DOM解析1、创建一个DocumentBuilder的对象12DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); 2、调用parser方法加载books.xml文件到当前项目下1Document document = db.parse("books.xml"); 3、进行解析1234567891011121314151617181920//获取所有book节点的集合NodeList bookList = document.getElementsByTagName("book");//?????book??for (int i = 0; i &lt; bookList.getLength(); i++) &#123; //通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始 Node book = bookList.item(i); //获取book节点的所有属性集合 NamedNodeMap attrs = book.getAttributes(); //前提：已经知道book节点有且只能有1个id属性 //将book节点进行强制类型转换，转换成Element类型 Element book = (Element) bookList.item(i); //通过getAttribute("id")方法获取属性值 String attrValue = book.getAttribute("id"); //解析book节点的子节点 NodeList childNodes = book.getChildNodes();&#125; 更多解析方法查看API SAX解析1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例1SAXParserFactory factory = SAXParserFactory.newInstance(); 2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例1SAXParser parser = factory.newSAXParser(); 3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler12SAXParserHandler handler = new SAXParserHandler();parser.parse("books.xml", handler); handler类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//标识解析开始@Overridepublic void startDocument() throws SAXException &#123; // TODO Auto-generated method stub super.startDocument(); System.out.println("SAX解析开始");&#125;//标识解析结束@Overridepublic void endDocument() throws SAXException &#123; // TODO Auto-generated method stub super.endDocument(); System.out.println("SAX解析结束");&#125;//解析xml元素@Overridepublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; //调用DefaultHandler类的startElement方法 super.startElement(uri, localName, qName, attributes); if (qName.equals("book")) &#123; //已知book元素下属性的名称，根据属性名称获取属性值 String value = attributes.getValue("id"); System.out.println("book的属性值是：" + value); &#125;else if (!qName.equals("name") &amp;&amp; !qName.equals("bookstore")) &#123; System.out.print("节点名是：" + qName + "---"); &#125;&#125;@Overridepublic void endElement(String uri, String localName, String qName) throws SAXException &#123; //调用DefaultHandler类的endElement方法 super.endElement(uri, localName, qName); //判断是否针对一本书已经遍历结束 if (qName.equals("book")) &#123; System.out.println("结束遍历某一本书的内容"); &#125;&#125;@Overridepublic void characters(char[] ch, int start, int length) throws SAXException &#123; // TODO Auto-generated method stub super.characters(ch, start, length); value = new String(ch, start, length); if (!value.trim().equals("")) &#123; System.out.println("节点值是：" + value); &#125;&#125; JDOM解析1、创建一个SAXBuilder的对象1SAXBuilder saxBuilder = new SAXBuilder(); 2、创建一个输入流，将xml文件加载到输入流中1in = new FileInputStream(&quot;books.xml&quot;); 3、通过saxBuilder的build方法，将输入流加载到saxBuilder中1Document document = saxBuilder.build(in); 4、通过document对象获取xml文件的根节点1Element rootElement = document.getRootElement(); 5、获取根节点下的子节点的List集合1234567891011121314List&lt;Element&gt; bookList = rootElement.getChildren();for (Element book : bookList) &#123; // 解析book的属性集合 List&lt;Attribute&gt; attrList = book.getAttributes(); //知道节点下属性名称时，获取节点值 book.getAttributeValue(&quot;id&quot;); // 对book节点的子节点的节点名以及节点值的遍历 List&lt;Element&gt; bookChilds = book.getChildren(); for (Element child : bookChilds) &#123; System.out.println(&quot;????&quot; + child.getName() + &quot;----????&quot; + child.getValue()); &#125;&#125; 如果需要设置编码可以按照以下方式设置 12InputStreamReader isr = new InputStreamReader(in, "UTF-8");Document document = saxBuilder.build(isr); DOM4J解析1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象12SAXReader reader = new SAXReader();Document document = reader.read(new File("src/res/books.xml")); 2、通过document对象获取根节点1Element bookStore = document.getRootElement(); 3、通过element对象的elementIterator方法获取迭代器1Iterator it = bookStore.elementIterator(); 4、遍历迭代器，获取根节点中的信息123456789101112131415while (it.hasNext()) &#123; Element book = (Element) it.next(); // 获取book的属性名以及 属性值 List&lt;Attribute&gt; bookAttrs = book.attributes(); for (Attribute attr : bookAttrs) &#123; System.out.println("????" + attr.getName() + "--????" + attr.getValue()); &#125; //遍历子节点 Iterator itt = book.elementIterator(); while (itt.hasNext()) &#123; Element bookChild = (Element) itt.next(); System.out.println("????" + bookChild.getName() + "--????" + bookChild.getStringValue()); &#125;&#125; 四种解析方式的区别 DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时 优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改 缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出 SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时 优点：内存消耗小 缺点：不易编码；很难同时访问同一个xml中的多处不同数据 JDOM：API大量使用了Collections类 DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用 参阅： 慕课网：Java眼中的XML—文件读取 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配之基于Java的容器注解]]></title>
    <url>%2F2018%2F07%2F29%2FSpring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Bean用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的，通常和@Configuration配合使用 12345678@Configurationpublic class StoreConfig &#123; @Bean(name = "store",initMethod = "init",destroyMethod="destroy") public BeanStore beanStore()&#123; return new BeanStore(); &#125;&#125; 相当于以下XML配置1234&lt;beans&gt; &lt;bean id="store" class="com.pinnuli.spring.ioc.beanannotation.BeanStore" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt;&lt;/beans&gt; 如果@Bean没有指定名称，则默认为方法名，这里即是beanStore。如果需要指定范围，即XML配置时的属性scope，那么可以用@Scope注解，且可以配置@Scope注解的proxyMode属性来配置代理方式，即XML配置时的scope-proxy属性 1@Scope(value="prototype", proxyMode = ScopedProxyMode.TARGET_CLASS) @ImportResource,@Value 通过@ImportResource加载资源文件,@Value获取属性值，比如有文件config.properties内容如下：123jdbc.username=rootpassword=rooturl=127.0.0.1 则可以通过将此内容配置到XML文件，如config.xml：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd" &gt; &lt;context:property-placeholder location="classpath:/config.properties"/&gt;&lt;/beans&gt; 然后在定义bean时，通过@ImportResource加载文件，通过@Value获取属性的值123456789101112131415161718@Configuration@ImportResource("classpath:config.xml")public class StoreConfig &#123; @Value("$&#123;url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;password&#125;") private String password; @Bean public MyDriverManager myDriverManager() &#123; return new MyDriverManager(url, username, password); &#125;&#125; 注意：这里的用户名字段如果直接为username，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如jdbc.username,jdbc.password等 基于泛型的自动装配比如现有如下接口：12public interface Store&lt;T&gt; &#123;&#125; IntegerStore和StringStore是他的两个实现类：12public class IntegerStore implements Store&lt;Integer&gt; &#123;&#125; 12public class StringStore implements Store&lt;String&gt; &#123;&#125; 那么在定义bean时可以按照如下方法：123456789101112131415@Autowiredprivate Store&lt;String&gt; s1;@Autowiredprivate Store&lt;Integer&gt; s2;@Beanpublic StringStore stringStore() &#123; return new StringStore();&#125;@Beanpublic IntegerStore integerStore() &#123; return new IntegerStore();&#125; 那么s1将会自动装配到StringStore，s2将会是IntegerStore JSR支持JSR250的支持1.@Resource注解变量或方法，且有一个name属性值，默认Spring解释改值为被注入bean的名称，若没有指定name,那么名称从方法名或者属性名得出1234567891011@Servicepublic class JsrServie &#123; @Resource private JsrDAO jsrDAO; @Resource public void setJsrDAO(@Named("jsrDAO") JsrDAO jsrDAO) &#123; this.jsrDAO = jsrDAO; &#125;&#125; 2.@PostConstruct和@PreDestroy@PostConstruct,初始化，相当于init-Method属性@PreDestroy，销毁，相当于destroy-Method属性1234567@PostConstructpublic void init() &#123;&#125;@PreDestroypublic void destroy() &#123;&#125; JSR330的支持 需要依赖javax.injet包 1.@Inject与@Autowired等效，可以使用于类，属性，方法，构造器2.@Named使用特定名称进行依赖注入，与@Component等效 1234567891011@Namedpublic class JsrServie &#123; @Inject private JsrDAO jsrDAO; @Inject public void setJsrDAO(@Named("jsrDAO") JsrDAO jsrDAO) &#123; this.jsrDAO = jsrDAO; &#125;&#125; 参阅: 慕课网：Spring入门篇]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配之Autowired注解]]></title>
    <url>%2F2018%2F07%2F28%2FSpring-Bean%E8%A3%85%E9%85%8D%E4%B9%8BAutowired%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.可以将@Autowired注解为setter方法1234@Autowiredpublic void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 2.可以用于构造器或成员变量1234@Autowired(required=false)public void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 默认情况下，如果因找不到合适的bean将会导致autowiring失败抛出异常，可以通过将其required设置为false表示并非必须，每个类只能有一个构造器标记为required=true,也就是只能有一个构造器为必须，这种情况下建议使用@Required注解： 1234@Requiredpublic void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; @Required表示标记的bean属性在bean装配时必须被填充，通过在bean定义或者自动装配一个明确的属性值 3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等1234public class BeanSutowired&#123; @Autowired private ApplicationContext context;&#125; 4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean下面的示例中，list添加了@Autowired注解，那么所有的实现BeanInterface接口的bean，假如有BeanimplOne和BeanimplTwo都实现了BeanInterface接口，那么这时list中将包含有BeanimplOne和BeanimplTwo。 123456789101112@Componentpublic class BeanInvoker implements BeanInterface&#123; @Autowired private List&lt;BeanInterface&gt; list; public void say()&#123; System.out.println("list..."); for (BeanInterface bean : list) &#123; System.out.println(bean.getClass().getName()); &#125;&#125; 如果希望数组有序，可以使用@Order注解或者实现org.springframework.core.Ordered接口，但是对map无效 1234@Order(1)@Componentpublic class BeanimplTwo implements BeanInterface&#123;&#125; 5.用于装配key为String的Map下面的示例中，map添加了@Autowired注解，那么所有的实现BeanInterface接口的bean，加入有BeanimplOne和BeanimplTwo都实现了BeanInterface接口，那么这时map中将包含有键为bean名称和值为bean的两个元素。123456789101112@Componentpublic class BeanInvoker implements BeanInterface&#123; @Autowired private Map&lt;String, BeanInterface&gt; map; public void say()&#123; System.out.println("map..."); for (Map.Entry&lt;String, BeanInterface&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + " " + entry.getValue().getClass().getName()); &#125;&#125; 6.@Qualifier 按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一 123@Autowired@Qualifier("beanImplTwo")private BeanInterface beanInterface; 用于指定单独的构造器参数或方法参数 用于注解集合类型变量 可以在bean的定义中使用@Qualifier注解给他限定一个范围，比如1234@Qualifier("beanImpl")@Componentpublic class BeanImplTwo implements BeanInterface&#123;&#125; 然后在注入时，使用@Qualifier限定，则下面的list将会匹配到所有@Qualifier(&quot;beanImp&quot;)的bean123@Autowired@Qualifier("beanImpl")private List&lt;BeanInterface&gt; list; 参阅： 慕课网：Spring入门篇]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean装配之各装配项 XML实现和注解实现]]></title>
    <url>%2F2018%2F07%2F27%2FSpring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%90%84%E8%A3%85%E9%85%8D%E9%A1%B9-XML%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、Bean管理的XML配置实现1.Bean的配置项 Id:Bean的唯一标识 Class：对应实现的类 Scope：范围 Constructor arguments：构造器参数 Properties：属性 Autowiring mode：自动装配模式 lazy-initialization mode：懒加载模式 Initialization/destruction method：初始化/销毁方法 2.Bean的定义这里以InjectionImpl中包含InjectionDAO成员变量为例，说明设置注入和构造注入,InjectionImpl类如下： 123public class InjectionServiceImpl implements InjectionService &#123; private InjectionDAO injectionDAO;&#125; 方式一：设置注入bean的XML配置: 1234&lt;bean id="injectionService" class="com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl"&gt; &lt;property name="injectionDAO" ref="injectionDAO"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="injectionDAO" class="com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt; InjectionIml中setter方法: 123public void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 方式二：构造注入bean的XML配置： 1234&lt;bean id="injectionService" class="com.imooc.ioc.injection.service.InjectionServiceImpl"&gt; &lt;constructor-arg name="injectionDAO" ref="injectionDAO"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="injectionDAO" class="com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"&gt;&lt;/bean&gt; InjectionIml中构造方法： 123public InjectionServiceImpl(InjectionDAOImpl injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 2.Bean的作用域 singleton:单例，一个Bean容器中指存在一份（默认情况下为singleton) prototype：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效 request：每次http请求创建一个实例且仅在当前request内有效 session：同上，每次http请求创建，当前session有效 global session：给予portel的web中有效，如果是在web中，则同session XML文件中的配置1&lt;bean id="beanScope" class="com.pinnuli.spring.ioc.bean.BeanScope" scope="singleton"&gt;&lt;/bean&gt; 3.Bean的生命周期 定义 &rArr; 初始化 &rArr; 使用 &rArr; 销毁 初始化 方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法123456public class ExampleInitializingBean implements InitialingBean&#123; @Override public void afterPropertiesSet() throws Exception&#123; &#125;&#125; 方式二：配置init-methodXML文件中的配置：1&lt;bean id="exampleInitBean" class="example.Example" init-method="init"/&gt; 对应实现类：1234public class ExampleBean&#123; public void init()&#123; &#125;&#125; 销毁: 方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法123456public class ExampleInitializingBean implements DisposableBean&#123; @Override public void destroy() throws Exception&#123; &#125;&#125; 方式二：配置destory-methodXML文件中的配置：1&lt;bean id="exampleInitBean" class="example.Example" init-method="destroy"/&gt; destory方法：1234public class ExampleBean&#123; public void destroy()&#123; &#125;&#125; 配置全局默认初始化、销毁方法123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-init-method="init" default-destroy-mothod="destroy"&gt;&lt;/beans&gt; i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效； ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错； iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。 4.Bean的自动装配 No：什么都不操作 byname：即中的id，根据属性名自动装配， byType：即中的class i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；ii.如果存在多个该类型的bean，则抛出异常，并指出不能使用byType方式进行自动装配iii.如果没有找到匹配的bean，则不进行任何操作以上两种情况bean的XML配置如下： 12345&lt;beans default-autowire="byType"/"byName"&gt; &lt;bean id="autoWiringService" class="com.pinnuli.spring.ioc.autowiring.AutoWiringService"&gt;&lt;/bean&gt; &lt;bean id="autoWiringDAO" class="com.pinnuli.spring.ioc.autowiring.AutoWiringDAO"&gt;&lt;/bean&gt;&lt;/beans&gt; Constructor: 应用于构造器参数，与byType类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常 对应的类中的构造方法和setter方法与设置注入或构造注入一致 二、Bean管理的注解实现1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd" &gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; &lt;context:annotation-config/&gt;仅会查找同一个applicat context中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解通过在基于XML的Spring配置如下标签 &lt;context:component-scan&gt;会扫描所有有bean注解的类，并注册到IOC容器，包含了&lt;context:annotation-config&gt;的全部功能，因而通常只需要使用前者，而不用后者 1&lt;context:component-scan base-package="org.example&gt; base-package表示扫描包下的所有类 2.使用过滤器进行自定义扫描默认情况下，类被自动发现并注册bean的条件是：使用了@Component，@Repository，@Service，@Controller注解，或者使用@Component的自定义注解，可以通过过滤器修改上述的行为 123456&lt;beans&gt; &lt;context:component-scan base-package="org.example"&gt; &lt;context:include-filter type="regex" expression=".*Stub.*Respository"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;context:component-scan/&gt; &lt;/beans&gt; 还可以使用use-default-filters=&quot;false&quot;禁用自动发现与注册 Bean的定义Bean名称是由BeannameGenerator生成的，默认情况下为类名的首字母变为小写 @Component，@Repository，@Service,@Controller都有一个那么属性用于显示设置Bean的名称,如123@Component("beanName")public class BeanAnnotation &#123;&#125; 也可自定义命名策略,实现BeanNameGenerator接口，并一定要包含一个无参构造器123&lt;beans&gt; &lt;context:component-scan base-package="org.example" name-generator="org.example.MyNameGenerator"/&gt;&lt;/beans&gt; Bean的作用域通常情况下启动查找的Spring组件，其scope是singleton，可用@Scope表示scope,1@Scope("prototype") 也可自定义scope策略，实现实现ScopeMetadataResolver接口，并一定要包含一个无参构造器123&lt;beans&gt; &lt;context:component-scan base-package="org.example" name-generator="org.example.MyScopeResolver"/&gt;&lt;/beans&gt; 对于自动装配注解，参见Spring Bean装配之Autowired注解 代理方式有三个值可选：no,interfaces,targetClass，默认情况下为no 可以配置@Scope注解的proxyMode属性来配置代理方式，即XML配置时的scope-proxy属性1@Scope(value="prototype", proxyMode = ScopedProxyMode.TARGET_CLASS) 可以在XML文件中使用scope-proxy属性指定代理123&lt;beans&gt; &lt;context:component-scan base-package="org.example" scope-proxy="interfaces"/&gt;&lt;/beans&gt; 三、Resource&amp;ResourceLoaderResource针对资源文件的统一入口，用于Spring加载资源文件 UrlResource:URL对应的资源，根据一个URL地址即可构建 ClassPathResource：获取类路径下的资源文件 FileSystemResource：获取文件系统里面的资源 ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源 InputStreamResource：针对于输入流封装的资源 ByArrayResource：针对于字节数组封装的资源 ResourceLoader i.所有的application contexts都实现了ResourceLoader接口，即可以通过ApplicationContext获得Resource实例ii.使用参数的前缀说明获取资源的类型 1.类路径下的资源文件1Resource resource = applicationContext.getResource("classpath:config.txt"); 2.文件系统中的资源1Resource resource = applicationContext.getResource("file:/var/SpringDemo/src/main/resources/config.txt"); 3.URL对应的资源1Resource resource = applicationContext.getResource("url:httpS://www.pinnuli.com/index.html"); 没有前缀时，取决于ApplicationContext的路径（之后再添加解释） 1Resource resource = applicationContext.getResource("config.txt"); 参阅： 慕课网：Spring入门篇]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb 监听器]]></title>
    <url>%2F2018%2F07%2F25%2FJava-Web-%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[按监听的对象划分1.用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口123456789101112public class MyServletContextListener implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent servletcontextevent) &#123; String initParam = servletcontextevent.getServletContext().getInitParameter("initParam"); System.out.println("contextInitialized : initParam = "+initParam); &#125; public void contextDestroyed(ServletContextEvent servletcontextevent) &#123; System.out.println("contextDestroyed"); &#125;&#125; 2.用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口1234567891011public class MyHttpSessionListener implements HttpSessionListener &#123; public void sessionCreated(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionCreated"); &#125; public void sessionDestroyed(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionDestroyed"); &#125;&#125; 3.用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口123456789101112public class MyServletRequestListener implements ServletRequestListener &#123; public void requestDestroyed(ServletRequestEvent servletrequestevent) &#123; System.out.println("requestDestroyed "); &#125; public void requestInitialized(ServletRequestEvent servletrequestevent) &#123; String name = servletrequestevent.getServletRequest().getParameter("name"); System.out.println("requestInitialized name:"+name); &#125;&#125; 按监听的事件划分1.监听域对象自身的创建和销毁的事件监听器 即按监听对象划分的那几种 2.监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener 或 ServletRequestAttributeListener接口1234567891011121314151617public class MyServletContextAttributeListener implements ServletContextAttributeListener &#123; public void attributeAdded(ServletContextAttributeEvent servletcontextattributeevent) &#123; System.out.println("ServletContext_attributeAdded:"+servletcontextattributeevent.getName()); &#125; public void attributeRemoved(ServletContextAttributeEvent servletcontextattributeevent) &#123; System.out.println("ServletContext_attributeRemoved:"+servletcontextattributeevent.getName()); &#125; public void attributeReplaced(ServletContextAttributeEvent servletcontextattributeevent) &#123; System.out.println("ServletContext_attributeReplaced:"+servletcontextattributeevent.getName()); &#125;&#125; HttpSession 和 ServletRequest 同理，只是方法参数类型不同 3.监听绑定到HttpSession域中的某个对象的状态的事件监听器 这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口： 1234567891011121314151617181920212223242526272829public class User implements HttpSessionBindingListener,HttpSessionActivationListener,Serializable &#123; private String username; public void valueBound(HttpSessionBindingEvent httpsessionbindingevent) &#123; System.out.println("valueBound Name:"+httpsessionbindingevent.getName()); &#125; public void valueUnbound(HttpSessionBindingEvent httpsessionbindingevent) &#123; System.out.println("valueUnbound Name:"+httpsessionbindingevent.getName()); &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; //钝化 public void sessionWillPassivate(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionWillPassivate "+httpsessionevent.getSource()); &#125; //活化 public void sessionDidActivate(HttpSessionEvent httpsessionevent) &#123; System.out.println("sessionDidActivate "+httpsessionevent.getSource()); &#125;&#125; 绑定和解除绑定：实现HttpSessionBindingListener接口钝化和活化：实现HttpSessionActivationListener和Serializable接口 实现Serializable接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化 参阅： 慕课网：JAVA Web开发技术应用——监听器]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web 过滤器]]></title>
    <url>%2F2018%2F07%2F25%2FJava-Web-%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器的工作原理过滤器的生命周期过滤器链Web项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？ 过滤器链：过滤器链执行过程: 过滤器分类 @WebFilter,在servlet3中，可以使用@WebFilter注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置 参阅： 慕课网：Java Web开发技术应用——过滤器]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet]]></title>
    <url>%2F2018%2F07%2F23%2Fservlet%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[servlet生命周期1.初始化，调用init()方法，生成Servlet实例2.响应客户请求，调用service()方法，由service()方法根据提交方式悬着执行doGet()或者doPost()方法3.终止，调用destroy()方法 tomcat装载servlet的三种情况1.Servlet容器启动时自动装载某些Servlet，需要在web.xml文件中的&lt;Servlet&gt;&lt;/Servlet&gt;之间添加&lt;loadon-startup&gt;1&lt;load-sartup&gt; 数字越小优先级越高2.在Servlet容器启动后，客户首次向Servlet发送请求3.Servlet类文件被修改时，重新装载Servlet 获取初始化参数在web.xml中配置Servle时可以配置初始化参数，通过`配置：1234&lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;pinnuli&lt;/param-value&gt;&lt;/init-param&gt; 在Servlet类中可以通过getInitParameter()获取：1String username = this.getInitParameter("username"); 未完待续。。。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2F2018%2F07%2F23%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、注解分类 源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在 编译时注解（CLASS）：注解在源码和.class文件都存在 运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解 元注解：注解的注解 二、自定义注解定义：123456789101112//元注解@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented//定义注解和成员变量public @interface Description&#123; String desc(); String author(); int age() default 20;&#125; @Target({ElementType.METHOD,ElementType.TYPE}) 作用域,可以包括CONSTRUCTOR(构造方法)、FIELD(字段)、LOCAL_VARIABLE(局部变量)、METHOD(方法)、PACKAGE(包)、PARAMETER(参数)、TYPE(类和接口)声明中，这里作用域为方法、类和接口 @Retention(RetentionPolicy.RUNTIME) 生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时 @Inherited 标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解 @Documented 生成javadoc包含注解信息 @interface 1.使用关键字@interface定义注解，2.成员以无参无异常方式声明，可以用default指定一个默认值3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即Description(&quot;test&quot;)5.注解可以没有成员名，叫标识注解 使用：@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)1234Description(desc="I am pinnuli",author="pinnuli",age=20)public String test()&#123; return "test";&#125; 三、解析注解 通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑 1.使用类加载器加载类1Class c = Class.forname("com.test.Student"); 2.找到类上的注解,拿到注解实例123if(c.isAnnotationPresent(Description.class))&#123; Description d = (Description)c.getAnnotation(Description.class);&#125; 3.找到方法上的注解 方法一 123456Method[] ms = c.getMethods();for(Method m:ms)&#123; if(m.isAnnotationPresent(Description.class))&#123; Description d = (Description)m.getAnnotation(Description.class); &#125;&#125; 方法二 12345678Method[] ms = c.getMethods();for(Method m:ms)&#123; for(Annotation a:as)&#123; if(a instanceof Description)&#123; Description d = (Description)a; &#125; &#125;&#125; 参阅： 慕课网：全面解析Java注解]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F07%2F22%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一、Class类的使用类是对象，任何一个类都是java.lang.class类的实例对象，这个类，这个实例对象可以有三种表达方式，比如Student类： 任何一个类都有一个隐含的静态成员变量class 1Class c1 = Student.class; 通过getClass方法获得 1Class c2 = Student.getClass(); forName 1Class c3 = Class.forName("com.Student"); c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例—-&gt;通过c1 or c2 or c3创建Student的实例对象1Student stu = c1.newInstance(); 二、动态加载类 静态加载类：编译时加载的类，通过new创建对象是静态加载类 动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题 三、获取方法信息和成员变量，构造函数信息方法信息 所有的public的函数，包括父类继承而来的 1Method[] ms = c.getMethods(); 所有该类自己声明的方法，不问访问权限 1Method[] ms = c.getDeclaredMethods(); 返回值类型的类类型 1Class returnType = ms[i].getReturnType(); 参数列表的类型的类类型 1Class[] paramTypes = ms[i].getParameterTypes(); 方法的名称 1String methodName = ms[i].getName(); 成员变量 所有的public的成员变量的信息 1Field[] fs = c.getFields(); 该类自己声明的成员变量的信息 1Field[] fs = c.getDeclaredFields(); 成员变量的类型的类类型 1Class fieldType = field.getType(); 成员变量的名称 1String fieldName = field.getName(); 构造函数 所有的public构造函数 1Constructor[] cs = c.getConstructors(); 所有的构造函数 1Constructor[] cs = c.getDeclaredConstructors(); 构造函数的参数列表，得到的是参数列表的类类型 1Class fieldType = field.getType(); 获取类的私有属性或私有方法直接获取私有属性或者方法会报java.lang.IllegalAccessException异常，AccessibleObject是Class、Method、Field的父类，通过设置setAccessible(true)可以获取类的私有属性，获取和调用私有方法 Student类：1234567891011121314151617181920public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; private void speck(String name) &#123; System.out.println("I am " + name); &#125; @Override public String toString() &#123; return "name: " + name + "age: " + age; &#125;&#125; 获取私有属性：123456789101112131415Student student = new Student("pinnuli", 18);Class studentClass = student.getClass();Field[] studentField = studentClass.getDeclaredFields();for (int i = 0; i &lt; studentField.length; i++) &#123; studentField[i].setAccessible(true); try &#123; System.out.println(studentField[i].get(student)); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; System.out.println(studentField[i].getName());&#125; 获取私有方法1234567Student student = new Student("pinnuli", 18);Class studentClass = student.getClass();Method[] studentMethods = studentClass.getDeclaredMethods();for (int i = 0; i &lt; studentMethods.length; i++) &#123; studentMethods[i].setAccessible(true); System.out.println(studentMethods[i].getName());&#125; 调用私有方法12345678910111213141516Student student = new Student("pinnuli", 18);Class studentClass = student.getClass();Method[] studentMethods = studentClass.getDeclaredMethods();for (int i = 0; i &lt; studentMethods.length; i++) &#123; studentMethods[i].setAccessible(true); try &#123; studentMethods[i].invoke(student,"pinnuli"); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; System.out.println(studentMethods[i].getName());&#125; 更多方法看API文档 四、方法反射的基本操作现有A类如下：1234567891011class A&#123; public void print()&#123; System.out.println("helloworld"); &#125; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase()+","+b.toLowerCase()); &#125;&#125; 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型12A a1 = new A();Class c = a1.getClass(); 2.通过名称和参数列表来获取方法1Method m = c.getMethod("print", int.class,int.class); 3.方法的反射操作1Object o = m.invoke(a1, 10,20); 这个操作的效果等同于a1.print(10,20) 通过方法的反射，我们可以绕过编译 参阅： 慕课网：反射——Java高级开发必须懂的]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Socket应用]]></title>
    <url>%2F2018%2F07%2F21%2FJava-Socket%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、Socket使用时应当注意的一些问题1.设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时 调用setSoTimeout方法设置 12Socket s = new Socket(...);s.setSoTimeout(10000); 对构造器Socket(String host,int port)，可以先构建一个无连接的套接字，再使用超时 123Socket s = new Socket();s.connect(new InetSocketAddress(host,port),timeout);` 2.可中断套接字，用SocketChannel类3.需要解析因特网地址时，可以用InetAddress类4.为多个客户端服务时，可以用多线程解决5.半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用Socket.shutdownInput或Socket.shutdownOutput 二、获取Web数URI和URL URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN 一个URI具有一下语法：[scema:]schemaSpecficPart[#fragment] i.包含schema:部分的URI成为绝对URI，否则为相对URIii.绝对URI的schemaSpecficPart不是以/揩油，则称为不透明的，如:mialto:pinnuli!hostname.comiii.所有绝对的透明URI和所有相对URI都是分层的，如：http://hostname.com/index.html，../../java/net/Socket.html#Socket()iv.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port] java中URI类的作用 解析表示福并将它分解成各种不同组成成分 标识符的相对化和解析相对标识符 使用URLCollection&gt; URLConnection类可以比URL类有更多的控制 必须严格按照以下步骤进行操作：1.调用URL类中的openConnection方法得到URLConnection对象：URLConnection connection = url.openConnection();2.设置请求属性3.调用connect方法连接远程资源:connection.connect();4.建立连接后，可以查询头信息5.访问资源数据，使用getInputStream方法获取一个输入流 这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能 三、提交表单1.提交数据之前，需要创建一个URLConnection对象12URL url = new URL("http;??host/script");URLConnection connection = url.openConnection(); 2.调用setDoOutput方法建立一个输出的连接12connection.setRequestMethod("POST");connection.setDoOutput（true); 3.调用getOutputStream方法获得一个输出流，想服务器发送数据123OutputStreamWriter osw = new OutputStreamWriter(connection.getOutputStream(), "UTF-8");osw.write(name1 + "=" + URLEncoder.eccode(value1,"UTF-8") + "&amp;);osw.write(name2 + "=" + URLEncoder.encode(value2,"UTF-8")); 4.关闭输出流12osw.flush();osw.close(); 5.调用getInputStream方法对服务器的响应1234567BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));StringBuffer response = new StringBuffer();String temp;while ((temp = br.readLine()) != null) &#123; response.append(temp); response.append("\n");&#125; i.设置请求方法时，必须使用大写，如POST，使用post无法识别ii.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法InputStream err = ((HTTPURLConnection) connection).getErrorStream(); URL编码需遵循以下规则： i.保留字符A-Z、a-z、0-9 以及.-*_ii.用+替换所有空格iii.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字比如发送”New York, NY”，可以使用New+York%2C+NY 四、基于TCP的Socket通信1.创建ServerSocket和Socket2.打开连接到Socket的输入/输出流3.按照协议对Socket进行读/写操作4.关闭输入/输出流，关闭Socket服务端（多线程响应多个客户端） 123456789101112//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口ServerSocket serverSocket=new ServerSocket(8888);Socket socket=null;System.out.println("***服务器即将启动，等待客户端的连接***");while(true)&#123; //调用accept()方法开始监听，等待客户端的连接 socket=serverSocket.accept(); //创建一个新的线程 ServerThread serverThread=new ServerThread(socket); //启动线程 serverThread.start();&#125; ServerThread类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public class ServerThread extends Thread &#123; Socket socket = null; public ServerThread(Socket socket) &#123; this.socket = socket; &#125; //线程执行的操作，响应客户端的请求 public void run()&#123; InputStream is=null; InputStreamReader isr=null; BufferedReader br=null; OutputStream os=null; PrintWriter pw=null; try &#123; //获取输入流，并读取客户端信息 is = socket.getInputStream(); isr = new InputStreamReader(is); br = new BufferedReader(isr); String info=null; while((info=br.readLine())!=null)&#123;//循环读取客户端的信息 System.out.println("我是服务器，客户端说："+info); &#125; socket.shutdownInput();//关闭输入流，半关闭 //获取输出流，响应客户端的请求 os = socket.getOutputStream(); pw = new PrintWriter(os); pw.write("欢迎您！"); pw.flush();//调用flush()方法将缓冲输出 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; //关闭资源 try &#123; if(pw!=null) pw.close(); if(os!=null) os.close(); if(br!=null) br.close(); if(isr!=null) isr.close(); if(is!=null) is.close(); if(socket!=null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 客户端 123456789101112131415161718192021//1.创建客户端Socket，指定服务器地址和端口Socket socket=new Socket("localhost", 8888);//2.获取输出流，向服务器端发送信息OutputStream os=socket.getOutputStream();//字节输出流PrintWriter pw=new PrintWriter(os);//将输出流包装为打印流pw.write("用户名：alice;密码：789");pw.flush();socket.shutdownOutput();//关闭输出流//3.获取输入流，并读取服务器端的响应信息InputStream is=socket.getInputStream();BufferedReader br=new BufferedReader(new InputStreamReader(is));String info=null;while((info=br.readLine())!=null)&#123; System.out.println("我是客户端，服务器说："+info);&#125;//4.关闭资源br.close();is.close();pw.close();os.close();socket.close(); 五、基于UDP的SOcket通信1.定义发送信息2.创建DatagramPacket，包含将要发送的信息3.创建DatagramSocket4.发送数据服务端 接收客户端发送的数据 12345678910//1.创建服务器端DatagramSocket，指定端口DatagramSocket socket=new DatagramSocket(8800);//2.创建数据报，用于接收客户端发送的数据byte[] data =new byte[1024];//创建字节数组，指定接收的数据包的大小DatagramPacket packet=new DatagramPacket(data, data.length);//3.接收客户端发送的数据socket.receive(packet);//此方法在接收到数据报之前会一直阻塞//4.读取数据String info=new String(data, 0, packet.getLength());System.out.println("我是服务器，客户端说："+info); 向客户端响应数据 12345678910//1.定义客户端的地址、端口号、数据InetAddress address=packet.getAddress();int port=packet.getPort();byte[] data2="欢迎您!".getBytes();//2.创建数据报，包含响应的数据信息DatagramPacket packet2=new DatagramPacket(data2, data2.length, address, port);//3.响应客户端socket.send(packet2);//4.关闭资源socket.close(); 客户端 向服务器端发送数据 12345678910//1.定义服务器的地址、端口号、数据InetAddress address=InetAddress.getByName("localhost");int port=8800;byte[] data="用户名：admin;密码：123".getBytes();//2.创建数据报，包含发送的数据信息DatagramPacket packet=new DatagramPacket(data, data.length, address, port);//3.创建DatagramSocket对象DatagramSocket socket=new DatagramSocket();//4.向服务器端发送数据报socket.send(packet); 接收服务器端响应的数据 12345678910//1.创建数据报，用于接收服务器端响应的数据byte[] data2=new byte[1024];DatagramPacket packet2=new DatagramPacket(data2, data2.length);//2.接收服务器响应的数据socket.receive(packet2);//3.读取数据String reply=new String(data2, 0, packet2.getLength());System.out.println("我是客户端，服务器说："+reply);//4.关闭资源socket.close(); 当Socket关闭时，输入输出流也就关闭了 参阅： 慕课网：Java Socket应用—通信是这样练成的 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java io流与文件]]></title>
    <url>%2F2018%2F07%2F19%2Fjava-io%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、流读写字节InputStream.read和OutpueStream.write组合流过滤器 某些流（如FileInputStream或者FileOutputStream）只能支持在字节级别上的读写，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如： 123FileInputStream fin = new FileInputStream("test.txt");DataInputStream din = new DataInputStream(fin);double s = din.readDouble(); 需要使用缓冲，可以使用一下构造器： 123DataInputStream din = new DataInputStream( new BUfferInputStream( new FileInputStream(test.txt"))); 需要浏览下一个字节以确定是否是想要的值时，可以： 1234567PushbackInputStream pbin = new PushbackInputStream( new BUfferInputStream( new FileInputStream(test.txt")));//预读写一个字节int b = pbin.read();//不是所期望时将其推回流中if(b != '&lt;') pbin.unead(b); 二、文本输入与输出输出：PrintWritePrintWrite out = new PrintWrite(&quot;test.txt&quot;);等同于PrintWrite out = new PrintWrite(new FileWrite(&quot;test.txt&quot;));输入：Scanner文本格式存储对象用自己的格式依次存储各个字段，以特定字符分隔，如：PINUULI|201625010417|1997|guangdong 三、读写二进制数据读：实现DataInput接口，如DataInputStream，readInt，readBoolean等方法写：实现DataOutput接口，如DataOutputStream，writeInt，writeBoolean等方法随机访问文件：RandomAccessFile可以在文件中的任何位置查找或者写入数据：12RandomAccessFile in = new RandomAccessFile("test.txt","r");RandomAccessFile inOut = new RandomAccessFile("test.txt","rw"); 四、ZIP文件每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。读：ZipInputStream 用getNextEntry方法返回文档中这些项（文件）的ZipEntry对象 ZipInputStream的read方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用closeEntry读入下一项 在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项 通读zip文件： 123456789ZipInputStream zin = new ZipInputStream(new FileInputStream("test.zip"));ZipEntry entry;Scanner in = new Scanner(zin);while((entry = zin.getNextEntry()) != null)&#123; while(in.hasNextLine())&#123; System.out.println(in.nextLine()); &#125; zin.closeEntry();&#125; 写：ZipOutputStream 对于想要放入到zip文件中的每一个项，都应该创建一个ZipEntry对象，并将文件名传递给ZipEntry的构造器 调用ZipOutputStream的putNextEntry方法开始写出新文件，并将数据发送到zip流中 完成时调用closeEntry方法,如： 12345678910FileOutputStream fout = new FilePutputStream("test.zip");ZipOutputStream zout = new ZipOutputStream(fout);// 写一个文件ZipEntry ze = new ZipEntry("filename");zout.putNextENtry(ze);send data to zout;zout.closeEntry();zout.close(); 五、对象流与序列化 序列化:ObjectOutputStream.writeObject(), 反序列化：ObjectInputream.readObject()， 都需要实现Serializable接口 只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等 序列化算法： 对于遇到的每个对象都关联一个序列号 对于每个对象，第一次遇到时，保存其对象数据到流中 如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反 对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联 当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用 修改默认的序列化机制 一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。 当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现Serializable接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如： 1234567891011121314151617181920public class LabeledPoint implements Serializable&#123; private String label; //对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标 private transient Point2D.Double point; ··· //重写读写方法 private void writeObject(ObjectOutputStream out) throws Exception&#123; out.defaultWriteObjecy(); out.writeDouble(point.getX()); out.writeDouble(point.getY()); &#125; private void readObject(ObjectInputStream in) throws IOException&#123; in.defaultReadObject(); double x = in.readDouble(); double y = in.readDouble(); point = new Point2D.DOuble(x,y); &#125;&#125; 当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现Externalizable接口，指定要保存的域 12345678910111213141516public class Student implements Externalizable&#123; private String name; private String stuId; private int age; ··· //重写读写方法 private void writeExternal(ObjectOutput out) throws IOException&#123; out.writeUTF(name); out.writeInt(age); &#125; private void readExternal(ObjectInput in) throws IOException&#123; name = in.readUTF(): age = in.readInt(); &#125;&#125; &gt; PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。 六、操作文件Path 静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\）连接起来，返回一个Path对象，详情见API。如 12Path absolutye = Paths.get("/home"."cay");Path relative = Paths.get("myprog","conf","user.properties"); 读写文件：Files类可以使得普通文件操作变得快捷 读取文件所有内容：byte[] bytes = Files.readAllBytes(path);,之后可以将其当做字符串String content = new String(bytes,charset); 向指定文件追加内容：Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND); 参阅： 慕课网：文件传输基础——Java IO流 java核心技术 卷II：高级特性]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 Let's Encrypt用Certbot获取Https证书 部署nginx]]></title>
    <url>%2F2018%2F07%2F15%2Fcentos7-Let-s-Encrypt%E7%94%A8Certbot%E8%8E%B7%E5%8F%96Https%E8%AF%81%E4%B9%A6-%E9%83%A8%E7%BD%B2nginx%2F</url>
    <content type="text"><![CDATA[1.检查nginx下是否有--with-http_stub_status_module 和--with-http_ssl_module两个模块，安装之后再重新编译1nginx -V 2.用http克隆github上的certbot1git clone https://github.com/certbot/certbot /opt/certbot-master 3.安装所有依赖1/opt/certbot-master/letsencrypt-auto --help 4.关闭nginx，检出80端口，443端口是否有开启1nginx -s stop 1firewall-cmd --query-port=80/tcp 1firewall-cmd --query-port=443/tcp 没有的话就开启1firewall-cmd --permanent --zone=public --add-port=80/tcp 5.获取证书1/opt/certbot-master/letsencrypt-auto --nginx -d www.pinnuli.com 6.配置nginx（也可选择自动配置)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main '$remote_addr - $remote_user [$time_local] "$request" '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/www/pinnuli.github.io; include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; server &#123; server_name www.pinnuli.com; # managed by Certbot root /var/www/pinnuli.github.io; include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; listen [::]:443 ssl ipv6only=on; # managed by Certbot listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot &#125;&#125; 7.设置自动更新 未完待续。。。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架]]></title>
    <url>%2F2018%2F07%2F11%2Fjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一、迭代器iterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素， next()方法 逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用； java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用 用”for each”循环遍历类集的内容， remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态 对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉 二、List有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类 ArrayList 基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道 适用于需要进行随机访问时 LinkedList 基于双向链表， 对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值 适用于顺序访问 三、Set等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一 HashSet 基于散列表的集，无序 存入的元素必须定义有hashCode()，以得到散列码 可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变 可以设置装填因子来实现再散列 适用于不关心访问顺序，需要查找大容量容器时 TreeSet 基于红黑树排序，有序 存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator 每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问 适用于存储大量需要进行快速检索的排序信息的情况 BitSet 用于存放一个位序列 四、Queue双端队列可以同时在头部或者尾部添加或删除元素，有两个实现 inkedList ArrayList PriorityQueue 基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序 按照任意顺序插入，却可以按照顺序进行检索 和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator 五、Map对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。键不存在时get方法返回null，可以用getOrDefault返回默认值，test.get(id,0)更新映射项正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，counts.put(word,counts.get(word)+1),需要解决一个问题，就是键第一次出现时，这时可以有三种方法 counts.put(word,counts.getOrDefault(word,0) + 1) 先调用putIfAbsent，只有原先键存在时才会放一个值,counts.putIfAnsent(word,0) counts.put(word,counts.get(word)+1) counts.merge(word,1,Interger::sum)(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联 映射视图集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图 键集：Set&lt;K&gt; keySet()， 值集：Collection&lt;V&gt; values()， 键/值对集：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除 散列 散列码，由对象的实例域产生的一个整数，由hashCOde()产生 散列表，用链表数组实现，每个列表称为桶 散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询 新版jdk使用红黑树和List（数据多用树，少时用List) 散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表 HashMap 比较快，适用于不需要按照排列顺序访问键时 TreeMap 按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序 WeakHashMap 使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键 如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目 适用于需要缓存时 LinkedHashMap 链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，受到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置 用于实现高速缓存的“最近最少使用”原则 六、视图与包装器轻量级集合包装器例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法12Card[] cardDeck = new Card[52];List&lt;Card&gt; cardList = Arrays.asList(cardDeck); 返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小,例如Collections类的一些使用方法，nCopied(100,&quot;KKK&quot;),single(anObject)等，返回一个不可修改的试图对象 子范围 相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用List group2 = staff.subList(10,20);,类似于String类中获取子串 可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除 对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集， SortedSet subSet(E from, E to)SortedSet headSet(E to)SortedSet tailSet(E from) 不可修改的视图 只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改 访问器方法从原始集合对象中获取值 视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如： unmodifiableCollection方法将返回一个集合，但他的equals()方法不调用底层集合的，而是调用它继承了Object类的equals()方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的 同步视图 实现多线程访问，确保集合的线程安全，例如Collections.synchronizedMap 受查视图 用来对泛型类型进行检测，例如Collections.checkedList 参阅： java核心技术 卷I：基础知识]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习笔记]]></title>
    <url>%2F2018%2F05%2F03%2FJSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、jsp简介1、jsp三大指令page指令:&lt;%@page 属性=”” %&gt;,位于jsp页面顶端，可以有多个 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" import="java.text.*"%&gt; taglib指令：标签库 includeinclude指令:&lt;%@include file=&quot;date.jsp&quot;%&gt;include动作:&lt;jsp:include page=&quot;url&quot; flush=&quot;true|false&quot;/&gt; page:要包含的页面,flush：被包含的页面是否从缓冲区读取 include指令与include动作的区别：forward动作：&lt;jsp: forward page=&quot;url&quot;/&gt;等同于：request.getRequestDispatcher(&quot;/url&quot;).forward(request,response); param动作：&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt;常与一起使用，作为其的子标签: 1234&lt;jsp:forward page="user.jsp"&gt; &lt;%--用&lt;jsp:param "&gt;&lt;/jsp:param&gt;添加参数--%&gt; &lt;jsp:param name="email" value="11111111@163.com"&gt;&lt;/jsp:param&gt;&lt;/jsp:forward&gt; 2、jsp注释 html的注释 jsp的注释&lt;%– jsp注释 –&gt;（客户端不可见） jsp脚本注释://单行/ / 多行 3、jsp脚本&lt;% java代码 %&gt; 4、jsp声明变量或方法&lt;%! java代码 %&gt; 5、jsp表达式&lt;%=表达式 %&gt; ps:不可;分号结束 6、jsp页面的生命周期 二、jsp内置对象 九大内置对象：out,request,response,session,application,Page,pageContext,exception,config out 123456789101112131415&lt;% out.println("&lt;h2&gt;静夜思&lt;/h2&gt;"); out.println("床前明月光&lt;br&gt;"); out.println("疑是地上霜&lt;br&gt;"); out.flush(); /*out.clear();会抛出异常*/ out.clearBuffer();//这里不会抛出异常 out.println("举头望明月&lt;br&gt;"); out.println("低头思故乡&lt;br&gt;"); %&gt; 缓冲区大小：&lt;%= out.getBufferSize()%&gt;byte&lt;br&gt; 缓冲区剩余大小：&lt;%= out.getRemaining()%&gt;byte&lt;br&gt; 是否自动清空缓冲区：&lt;%= out.isAutoFlush()%&gt;&lt;br&gt; request 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;% request.setCharacterEncoding("utf-8");//解决post中文乱码问题，但无法解决get，get解决需要直接Tomcat配置文件 request.setAttribute("password","123456");//设置属性密码 %&gt; 用户名：&lt;%= request.getParameter("username")%&gt;&lt;br&gt; 爱好： &lt;% if(request.getParameterValues("favorite") != null)&#123; //这里需要判断为不为空，jsp这里不能将String数组看为Boolean String[] favorites = request.getParameterValues("favorite"); for (int i = 0; i &lt; favorites.length; i++) &#123; out.println(favorites[i] + "&amp;nbsp;&amp;nbsp;&amp;nbsp;"); &#125; &#125; String realPath = request.getRealPath("requset.jsp");%&gt;&lt;br&gt; 密码： &lt;%=request.getAttribute("password")%&gt;&lt;br&gt; 请求体的MIME类型： &lt;%=request.getContentType()%&gt;&lt;br&gt; 协议类型和版本号： &lt;%=request.getProtocol()%&gt;&lt;br&gt; 服务器主机名： &lt;%=request.getServerName()%&gt;&lt;br&gt; 服务器端口号： &lt;%=request.getServerPort()%&gt;&lt;br&gt; 请求文件长度： &lt;%=request.getContentLength()%&gt;&lt;br&gt; 请求的客户端地址： &lt;%=request.getRemoteAddr()%&gt;&lt;&lt;br&gt; 请求的真实路径： &lt;%=request.getRealPath("requset.jsp")%&gt;&lt;br&gt; 请求的上下文路径： &lt;%=request.getContextPath()%&gt; response 12345678910111213141516&lt;% response.setContentType("text/html;charset=utf-8"); out.println("&lt;h1&gt;response内置对象&lt;/h1&gt;"); out.println("&lt;hr&gt;"); //out.flush(); /* 因为getWrite获得的输出流对象会先于内置对象out输出， 所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer 再输出out*/ PrintWriter outer = response.getWriter(); outer.println("大家好，我是response生成的输出流outer");// response.sendRedirect("login.jsp");//重定向// response.sendRedirect("request.jsp"); request.getRequestDispatcher("request.jsp").forward(request,response);//转发 %&gt; 请求转发和请求重定向的区别： sessionHttpSession的实例，周期：在第一个jsp页面被加载时自动创建，即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束，在服务器的几个页面之间切换，服务器应当知道这是一个客户，就可以用session对象 12345678910111213141516171819202122232425262728293031&lt;% SimpleDateFormat sdf = new SimpleDateFormat("yyyy年mm月dd日 HH:mm:ss"); Date d = new Date(session.getCreationTime()); session.setAttribute("username","pinnuli"); session.setAttribute("password","123456"); session.setAttribute("age",20);// session.setMaxInactiveInterval(10);//设置session最大生成期限，单位秒,也可在web.xml中设置session-timeout %&gt; Session创建时间： &lt;%=sdf.format(d)%&gt;&lt;br&gt; Session的ID： &lt;%=session.getId()%&gt;&lt;br&gt; Session中获取属性值： &lt;%=session.getAttribute("username")%&gt;&lt;br&gt; Session保存的属性数组： &lt;% String[] names = session.getValueNames(); for(int i=0; i&lt;names.length; i++)&#123; out.println(names[i] + "&amp;nbsp;&amp;nbsp;"); &#125;// session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session %&gt;&lt;br&gt; &lt;%--测试不同页面是否同一个session--%&gt; &lt;a href="session_page2.jsp"&gt;跳转到session_page2&lt;/a&gt; application实现用户间数据的共享，可存放全局边变量，相当于java的静态变量 12345678910111213141516&lt;% application.setAttribute("city","广州"); application.setAttribute("postcode","510000"); application.setAttribute("email","guangzhou@163.com"); %&gt; 所在城市：&lt;%=application.getAttribute("city")%&gt;&lt;br&gt; 所有属性： &lt;% Enumeration attributes = application.getAttributeNames(); while (attributes.hasMoreElements())&#123; out.println(attributes.nextElement() + "&amp;nbsp;&amp;nbsp;"); &#125; %&gt;&lt;br&gt; jsp(serviet)引擎名和版本号：&lt;%=application.getServerInfo()%&gt;&lt;br&gt; page、pageContext 123456789101112&lt;h3&gt;page:&lt;/h3&gt;当前page页面的字符串描述：&lt;%=page.toString()%&gt;&lt;br&gt;&lt;br&gt; &lt;h3&gt;pageContext:&lt;/h3&gt;用户名：从session中获取属性-&lt;%=pageContext.getSession().getAttribute("username")%&gt;&lt;br&gt; &lt;%--跳转到其他页面--%&gt; &lt;%--&lt;% pageContext.forward("out.jsp"); %&gt;--%&gt; include方法，包含其他页面: &lt;% pageContext.include("out.jsp"); %&gt; exception 123异常消息：&lt;%=exception.getMessage()%&gt;&lt;br&gt; 异常的字符串描述：&lt;%=exception.toString()%&gt; 三、jsp使用Javabean1. Javabean的设计原则 必须是公有类 必须包含无参构造方法 属性私有 用getter()和setter()进行封装 例如： 1234567891011121314151617181920212223242526public class Students&#123; private String name; private int age; public Students()&#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 2. 存取Javabean有关的jsp动作元素在jsp页面中使用Javabeans： 方法一：像使用普通java类一样，创建Javabean实例方法二：在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty &lt;jsp:useBeans&gt; 在jsp页面中实例化或者在指定范围内使用Javabean： &lt;jsp:useBeans id=&quot;标示符&quot; class=&quot;java类名&quot; scope=&quot;作用范围&quot;/&gt; scope属性：指定Javabean的作用范围page：当前页面,重定向和转发都无效request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效application:可通过application.getAttribute()取得Javabean对象，不同会话都有效 例如：123&lt;jsp:useBean id="myUsers" class="com.po.Users" scope="application"&gt;&lt;/jsp:useBean&gt;用户名：&lt;jsp:getProperty name="myUsers" property="username"&gt;&lt;/jsp:getProperty&gt;密码：&lt;jsp:getProperty name="myUsers" property="password"&gt;&lt;/jsp:getProperty&gt; 也可使用内置对象获取：12用户名：&lt;%=((Users)application.getAttribute("myUsers")).getUsername()%&gt;密码： &lt;%=((Users) application.getAttribute("myUsers")).getPassword()%&gt; &lt;jsp:setProperty&gt; 1234567891011根据表单自动匹配所有属性:&lt;jsp:setProperty name="myUsers" property="username"&gt;&lt;/jsp:setProperty&gt;根据表单匹配部分属性:&lt;jsp:setProperty name="myUsers" property="username"&gt;&lt;/jsp:setProperty&gt;与表单无关，通过手工赋值给属性:&lt;jsp:setProperty name="myUsers" property="password" value="hahahaha"&gt;&lt;/jsp:setProperty&gt;通过url传参数给属性赋值:&lt;jsp:setProperty name="myUsers" property="password" param="testparam"&gt;&lt;/jsp:setProperty&gt; &lt;jsp:getProperty&gt; 12使用getProperty获取属性值:&lt;jsp:getProperty name="myUsers" property="username"&gt;&lt;/jsp:getProperty&gt; 参阅： 慕课网：JAVA遇见HTML——JSP篇]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的使用]]></title>
    <url>%2F2018%2F04%2F30%2Fvim%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、一般模式：光标的移动、复制粘贴、搜索替换移动光标： 向左移动一个字符：h 或 ← 向右移动一个字符：l 或 → 向上移动一个字符：k 或 ↑ 向下移动一个字符：j 或 ↓ 向左移动n个字符：n + h（其他同理)，如10h向右移动这一行的n个字符(会换到下一行)：n + space,如20space屏幕向上移动一页：Ctrl + b屏幕向下移动一页：Ctrl + f屏幕向上移动半页：Ctrl + u屏幕向下移动半页：Ctrl + d移动到非空格的下一行：+移动到非空格的上一行：-移动到屏幕最上方那一行的第一个字符：H移动到屏幕最中间那一行的第一个字符：M移动到屏幕最下方那一行的第一个字符：L 移动到这个文件的最后一行：G 移动到这个文件的第n行：nG 移动到这个文件的第一行:gg 向下移动n行：n + enter,如10enter 加粗部分为常用，以下同理 搜索替换： 向光标往下搜索一个word的字符串：/word 向光标往上搜索一个word的字符串：?word 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc 删除 向前（后）删除一个字符：x(X)，相当于backspace 连续向后删除n个字符： nx,如10x 删除光标所在的一整行：dd 删除光标所在的向下n行：ndd 删除光标所在到第一行的所有数据：d1G输出光标所在到最后一行的所有数据:dG删除光标所在到该行最后一个字符：d$删除光标所在到该行第一个字符：d0 复制 复制光标所在的那一行：yy 复制光标所在的向下n行：nyy 复制光标所在行到第一行的所有数据：y1G复制光标所在行到最后一行的所有数据:yG复制光标所在到该行最后一个字符：y$复制光标所在到该行第一个字符：y0 粘贴 将已复制的数据在光标下（上）一行贴上：p(P); 将光标所在行与 下一行的数据结合成一行： J 重复删除多个数据:c，如向下删除10行：10cj 复原前一个动作：u 重复上一个动作：Ctrl + r 二、一般模式到编辑模式的切换进去输入模式 i/I 从目前光标所在处输入：i 从目前所在行的第一个非空格符处开始输入：I a/A从目前光标所在的下一个字符处开始输入:a从光标所在行的最后一个字符处开始输入:A o/O 在光标所在的下一行输入新的一行：o 在光标所在的上一行输入新的一行：O 进入取代模式 r/R 取代光标所在的那一个字符一次：r 一直取代光标所在的字符，直到按esc 三、一般模式到命令行模式的切换指令行的存储、离开等 保存编辑： :w 强制写入： :w! 退出： :q 强制退出，不保存修改： :q! 保存修改后退出： :wq 将修改后的数据另存为一个文件： :w filename 在当前编辑的数据中，读入另一个文件的数据： :r filename将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename 暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 vim环境的变更显示行号： :set nu取消显示行号： :set nonu]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用技巧]]></title>
    <url>%2F2018%2F04%2F30%2FIntelliJ-IDEA-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一、跳转快捷键窗口切换：Ctrl + alt + [ / ]文件切换：alt + -&gt; / &lt;-关闭文件：ctrl + f4最近修改文件： ctrl + tab + E最近浏览文件： ctrl + E回到上次编辑的地方 last edit location: ctrl + shift + backspace回到上次浏览的地方 back/forward: ctrl + alt + -&gt;/&lt;-利用书签跳转：bookmarks:f11bookmarks mnemonic: ctrl + f11show bookmarks: shift + f11书签跳转：Ctrl + 1（n）收藏（类或方法）：shift + alt + FemacsIDEAs 跳转：shift + j(这个是自己设的) 然后按要找单词的首字母，如p，然后选择编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n) 从文件去到编辑区：esc 二、精准搜索搜索类：ctrl + alt + N(Ctrl + N 已被vim占用）搜索文件： ctrl + shift + N搜索符号（方法和属性）：ctrl + shift + alt + N搜索字符串： ctrl + shift + F Match case :区分大小写 Words：搜索的字符串是一个单词 Regex：按照正则表达式搜索 File mask:指定文件类型 In Project：在项目下搜搜 Module：在当前模块下搜索 Directory：在指定目录下搜索 Scope：在指定范围下搜索 待补充。。。 参阅： 慕课网：IntelliJ IDEA神器使用技巧]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程并发常见问题基于信号量解决方法总结：生产者/消费者问题、读/写者问题、银行家算法、哲学家进餐]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%2F</url>
    <content type="text"><![CDATA[一、信号量 信号量是一个与队列有关的整型变量。 可以初始化成非负数； semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行； semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。 信号量原语semWait和semSignal的定义1234567891011121314151617181920strcut semaphore&#123; int count; aueueType queue;&#125;;void semWait(semaphore s) &#123; s.count--; if(s.count &lt; 0) &#123; place this process in s.queue; block this process; &#125;&#125;void semSignal(semaphore s) &#123; s.count ++; if(s.count &lt;= 0) &#123; remove a process P from s.queue; place process P on ready list; &#125;&#125; 信号量实现互斥12345678910111213const int n;semaphore s = 1;void P(int i) &#123; while(true) &#123; semWait(s); operate; semSignal(s); &#125;&#125;void main() &#123; parbegin(P(1), P(2), ...,P(n));&#125; 总结信号量 一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。 用于互斥时，S初值为1，取值为1~ - (n-1) （相当于临界区的通行证，实际上也是资源个数） S=1：临界区可用 S=0：已有一进程进入临界区 S&lt;0：临界区已被占用，|S|个进程正等待进入 用于同步时，S初值&gt;=0 S&gt;=0:表示可用资源个数 S&lt;0: 表示该资源的等待队列长度 semWait、semSignal操作 semWait(S)：请求分配一个资源。 semSignal(S)：释放一个资源。 semWait、semSignal操作必须成对出现。 用于互斥时，位于同一进程内； 用于同步时，交错出现于两个合作进程内。 多个semWait操作的次序不能颠倒，否则可能导致死锁。 多个semSignal操作的次序可任意。 二、生产者/消费者问题 问题描述： 有一个或多个生产者生产某种类型的数据，并放置在缓冲区中； 有一个消费者从缓冲区中取数据，每次取一项； 系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区; 缓存已满时，生产者不能继续添加数据； 缓存已空时，消费者不能继续移走数据。 producer: 12345678while(true) &#123; /* produce item v */ while((in + 1) % n == out) //等待缓存有空位 /* doing nothing */ b[in] = v; in = (in + 1) % n;&#125; consumer: 12345678while(true) &#123; while(in == out) //此时缓存为空，等待生产者生产放入缓存后才可消费 /* doing nothing */ w = b[out]; out = (out + 1) % n; /* consume item w */&#125; 有限缓冲区： 使用信号量解决有限缓冲区生产者消费者问题: n 表示已生产产品的数量s 用来控制互斥e 表示空闲空间数目 123456789101112131415161718192021222324semaphore n = 0, s = 1, e = buf - size;void producer() &#123; while(true) &#123; produce(); semWait(e); semWait(s); append(); semSignal(s); semSignal(e); &#125;&#125;void consumer() &#123; while(true) &#123; semWait(n); semWait(s); take(); semSignal(s); semSignal(e); consume(); &#125;&#125; 例题1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。 分析： 生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。 数据结构： semaphore dish, apple, banana; dish: 表示盘子是否为空,用于控制互斥 apple：表示盘子中是否有苹果，初始值为0 banana:表示盘子中是否有香蕉，初始值为0 123456789101112131415161718192021222324 process father() &#123; semWait(dish); put the apple in the dish; semSignal(apple);&#125;process mother() &#123; semWait(dish); put the banana in the dish; semSignal(banana);&#125;process son() &#123; semWait(banana); get the banana from the dish; semSignal(dish);&#125;process daughter() &#123; semWait(apple); get the apple from the dish; semSignal(dish);&#125; 2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。 分析： 实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系 数据结构：semaphore s1, s2; s1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0； 12345678910111213141516process p1() &#123; while(true)&#123; semWait(s1); Pick a white chessman; semSignal(s2); &#125;&#125;process p2() &#123; while(true)&#123; semWait(s2); Pick a white chessman; semSignal(s1); &#125;&#125; 3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。 分析： 实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室 数据结构： strcut { char name[10]; int number; } a[100]; //表示进入阅览室的小朋友 semaphore mutex, seatcount; mutex: 用来控制互斥，初始值为1 seatcount： 对空座位进行计数，初始值为100； 初始化入室人员信息 for(int i = 0; i &lt; 100; i++){ a[i].number = i; a[i].name = null; } 12345678910111213141516171819202122 process readeri(char readername[]) &#123; semWait(seatcount); //等待空余作为，若人数未满100，则直接进入，到达100，则等待 semWait(mutex); //控制互斥 /* 进入是登记 */ for(int i = 0; i &lt; 100; i++) if(a[i].name == null)&#123; //找到名字为空的座位 a[i].name = readername; break; &#125; reader get the seat nember i; semSiganl(mutex); go into the reading room and sit down at the seat number i. /* 离开时登记 */ semWait(mutex); a[i].name = null; semSignal(mutex); semSignal(seatcount); leave reading room;&#125; 二、读/写者问题 描述： 有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件： 任意多的读进程可以同时读文件； 一次只有一个写进程可以写文件； 如果一个写进程正在写文件，那么禁止任何读进程读文件。 读者优先 分析： 当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。 数据结构： readcount: 控制wsem的的设置 wsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。 x: 用于确保readcount被正确更新。 123456789101112131415161718192021222324252627int readcount;semphore x = 1, wsem = 1;void reader() &#123; while (true) &#123; semWait(x); readcount++; if(readcount==1) semWait(wsem); //如果是第一个读者，则要控制wsem semSignal(x); READUNIT(); semWait(x); readcount--; if(readcount==0) semSignal(wsem); semSignal(x); &#125;&#125;void writer()&#123; while (true) &#123; semWait(wsem); WRITEUNIT(); semSignal(wsem); &#125;&#125; 实例： 独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法) 数据结构： mutex1/mutex2: 用于确保count1/count2被准备更新 count1/count2: 控制wait的设置 wait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。 123456789101112131415161718192021222324252627 semaphore wait=1, mutex1=1, mutex2=1; int count1=0, count2=0; process P east()&#123; semWait(mutex1); count1++; if(count1==1) semWait(wait); semSignal(mutex1); through the singal-log bridge； semWait(mutex1); count1--; if(count1==0) semSignal(wait); semSignal(mutex1); &#125;process P west()&#123; semWait(mutex2); count2++; if(count2==1) semWait(wait); semSignal(mutex2); through the singal-log bridge； semWait(mutex2); count2--; if(count2==0) semSignal(wait); semSignal(mutex2); &#125; 待整理。。。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git多账号配置，同时使用多个代码托管平台]]></title>
    <url>%2F2018%2F04%2F09%2Fgit%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。 ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。 1 生成密钥这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空 1ssh-keygen -T rsa -C "example@qq.com" 生成github的密钥 生成osc的密钥 查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc) 1ls -a /root/.ssh 2 接下来配置多账号在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容 123456789101112#github Host github.com HostName github.com IdentityFile ~/.ssh/id_rsa_github User pinnuli#osc Host gitee.com HostName gitee.com IdentityFile ~/.ssh/id_rsa_osc User pinnuli 3 把对应的公钥放到github和osc上面 4 测试是否成功1ssh -T git@github.com 1ssh -T git@gitee.com 至此，git多账号配置完毕，需要更多账号也是一样的道理]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 配置实现端口转发]]></title>
    <url>%2F2018%2F04%2F04%2Fnginx-%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[最近在部署一个小程序的后台，但是小程序调用的接口是不能带端口号的，那么如果服务器上面80端口已经被其他程序占用，就只能采用端口转发或者虚拟目录，我采用的是端口转发，或者说当在一台主机上需要部署多个web应用，并且需要能在80端口访问这些web时，就可以采用这种方法，也可以叫做nginx反向代理用于实现负载均衡，这里记录一下遇到的一些小问题。 加入服务器域名是test.com,那么你可以通过test.com/news在80端口访问新闻应用，但是服务器上分配的是其他端口，如8081。对应的nginx配置如下： 80端口的配置： 访问test.com/news =&gt; 127.0.0.1:8081 ,这里有一个需要注意的地方是转发的url最后需要加上’/‘，这相当指定了url’/‘,如果代理服务器地址中是带有URL的，此URL会替换掉 location 所匹配的URL部分, test.com/news/api,访问的是ip:8081/api;而如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器,test.com/news/api,访问的是ip:8081/news/api; 123456789101112131415161718server &#123; listen 80; # listen [::]:80 default_server; server_name test.com root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; location /news&#123; proxy_pass http:test.com:8081/; &#125; &#125; 8081端口的配置： 与平时配置没什么差别 1234567891011121314151617181920212223242526272829 server &#123; listen 8081; server_name localhost; root /var/www/project; location / &#123; index index.php index.html index.htm; if ( !-e $request_filename)&#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125; &#125; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; #root /usr/share/ngixn/html; #&#125; #我部署的是PHP项目，这里配置PHP解析 location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include /etc/nginx/fastcgi_params; include /etc/nginx/fastcgi.conf; &#125;&#125;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsoup要点记录]]></title>
    <url>%2F2018%2F03%2F16%2Fjsoup%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[查找dom元素 getElementById: 根据id查询 getElementsByTag: 根据tag名称查询 getElementsByClass: 根据样式class名称查询 getElementsByAttribute: 根据属性名查询 getElementsByAttributeValue: 根据属性名和属性值查询 实例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //通过标签名称查询 Elements elements = doc.getElementsByTag("title"); Element element = elements.get(0); String title = element.text(); System.out.println("网页标题：" + title); //获取首个标题标签内容 Element titleElement = doc.getElementsByTag("title").first(); System.out.println("首个标题： " + titleElement.text()); //通过id查询 Element idElement = doc.getElementById("site_nav_top"); System.out.println("id查询：" + idElement.text()); //通过class样式获取查询 Elements itemElements = doc.getElementsByClass("post_item"); System.out.println("**********样式查询**********"); for(Element e: itemElements) &#123; System.out.println(e.text()); System.out.println("-------"); &#125; //属性名称查询 Elements attrElements = doc.getElementsByAttribute("width"); System.out.println("**********属性查询**********"); for(Element e: attrElements) &#123; System.out.println(e.toString()); &#125; //属性名称和属性值查询 Elements attrValueElements = doc.getElementsByAttributeValue("target", "_blank"); System.out.println("**********属性和属性值查询**********"); for(Element e: attrValueElements) &#123; System.out.println(e.toString()); &#125; &#125;&#125; 查找dom元素属性值实例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo2 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //获取带有href属性的a标签 Elements attrElements = doc.select("a[href]"); System.out.println("**********获取属性值**********"); for(Element e: attrElements) &#123; System.out.println(e.toString()); System.out.println("-------"); &#125; //查找拓展名为gif的img标签 Elements imgElements = doc.select("img[src$=.gif]"); System.out.println("**********带有拓展名查询**********"); for(Element e: imgElements) &#123; System.out.println(e.toString()); &#125; &#125;&#125; 使用选择器查询 Jsoup 支持css，jquery的选择器 实例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo03 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //通过选择器查询 Elements linkElements = doc.select(".headline ul .editor_pick a"); System.out.println("**********选择器查询**********"); for(Element e: linkElements) &#123; System.out.println(e.toString()); System.out.println("地址： " + e.attr("href")); System.out.println("-------"); &#125; Element linkElement = doc.select(".headline ul li").first(); System.out.println("文本： " + linkElement.text()); System.out.println("html: " + linkElement.html()); System.out.println("class属性值： " + linkElement.attr("class")); &#125;&#125;]]></content>
      <categories>
        <category>Jsoup</category>
      </categories>
      <tags>
        <tag>java爬虫</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支管理常用命令]]></title>
    <url>%2F2018%2F03%2F11%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建分支： git branch branch_name 切换分支： git checkout branch_name 创建并切换分支 git checkout -b branch_name 创建远程分支到本地： git checkout -b branch_name origin/branch_name 查看当前分支： git branch 获取所有分支： git fetch 合并某分支到当前分支： git merge branch_name 禁用Fast forward（快速合并）， 普通模式合并： git merge --no-ff -m &quot;merge with no-ff&quot; branch_name 这里会在合并的时候自动生成一个新的commit 删除分支： git branch -d branch_name 强制删除分支（用于为合并就删除时）： git branch -D branch_name 查看分支合并图： git log --graph 保存分支工作现场： git stash 查看保存列表： git stash list 恢复保存状态： git stash apply git stash apply stash@{x} 删除保存状态： git stash drop git stash drop stash@{x} 恢复并删除保存状态： git stash pop 推送分支到远程仓库： git push origin branch_name 建立本地分支与远程分支的关联： git branch --set-upstream branch-name origin/branch-name]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdownpad2 无法预览 显示This view has crashed!]]></title>
    <url>%2F2018%2F03%2F10%2Fmarkdownpad2-%E6%97%A0%E6%B3%95%E9%A2%84%E8%A7%88-%E6%98%BE%E7%A4%BAThis-view-has-crashed%2F</url>
    <content type="text"><![CDATA[在使用markdownpad2时，一直报错，说html渲染错误，上了官网查看解释如下，要安装 Awesomium 1.6.6 SDK，如果不行再安装DirectX最终用户运行时,不过一般只需要安装sdk就没问题了]]></content>
      <categories>
        <category>踩过的坑</category>
      </categories>
      <tags>
        <tag>markdownPad</tag>
      </tags>
  </entry>
</search>
