<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F07%2F23%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2F2018%2F07%2F23%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、注解分类源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在编译时注解（CLASS）：注解在源码和.class文件都存在运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解元注解：注解的注解 二、自定义注解定义：123456789101112//元注解@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documented//定义注解和成员变量public @interface Description&#123; String desc(); String author(); int age() default 20;&#125; @Target({ElementType.METHOD,ElementType.TYPE}) 作用域,可以包括CONSTRUCTOR(构造方法)、FIELD(字段)、LOCAL_VARIABLE(局部变量)、METHOD(方法)、PACKAGE(包)、PARAMETER(参数)、TYPE(类和接口)声明中，这里作用域为方法、类和接口 @Retention(RetentionPolicy.RUNTIME) 生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时 @Inherited 标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解 @Documented 生成javadoc包含注解信息 @interface 1.使用关键字@interface定义注解，2.成员以无参无异常方式声明，可以用default指定一个默认值3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即Description(&quot;test&quot;)5.注解可以没有成员名，叫标识注解 使用：@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)1234Description(desc="I am pinnuli",author="pinnuli",age=20)public String test()&#123; return "test";&#125; 三、解析注解 通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑 1.使用类加载器加载类1Class c = Class.forname("com.test.Student"); 2.找到类上的注解,拿到注解实例123if(c.isAnnotationPresent(Description.class))&#123; Description d = (Description)c.getAnnotation(Description.class);&#125; 3.找到方法上的注解 方法一 123456Method[] ms = c.getMethods();for(Method m:ms)&#123; if(m.isAnnotationPresent(Description.class))&#123; Description d = (Description)m.getAnnotation(Description.class); &#125;&#125; 方法二 12345678Method[] ms = c.getMethods();for(Method m:ms)&#123; for(Annotation a:as)&#123; if(a instanceof Description)&#123; Description d = (Description)a; &#125; &#125;&#125;]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2018%2F07%2F22%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Class类的使用1.类是对象，任何一个类都是java.lang.class类的实例对象，这个类，这个实例对象可以有三种表达方式，比如Student类： 任何一个类都有一个隐含的静态成员变量class 1Class c1 = Student.class; 通过getClass方法获得 1Class c2 = Student.getClass(); forName 1Class c3 = Class.forName("com.Student"); c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例—-&gt;通过c1 or c2 or c3创建Student的实例对象 1Student stu = c1.newInstance(); 动态加载类 静态加载类：编译时加载的类，通过new创建对象是静态加载类 动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题 获取方法信息和成员变量，构造函数信息 方法信息 所有的public的函数，包括父类继承而来的 1Method[] ms = c.getMethods(); 所有该类自己声明的方法，不问访问权限 1Method[] ms = c.getDeclaredMethods(); 返回值类型的类类型 1Class returnType = ms[i].getReturnType(); 参数列表的类型的类类型 1Class[] paramTypes = ms[i].getParameterTypes(); 方法的名称 1String methodName = ms[i].getName(); 成员变量 所有的public的成员变量的信息 1Field[] fs = c.getFields(); 该类自己声明的成员变量的信息 1Field[] fs = c.getDeclaredFields(); 成员变量的类型的类类型 1Class fieldType = field.getType(); 成员变量的名称 1String fieldName = field.getName(); 构造函数 所有的public构造函数 1Constructor[] cs = c.getConstructors(); 所有的构造函数 1Constructor[] cs = c.getDeclaredConstructors(); 构造函数的参数列表，得到的是参数列表的类类型 1234567891011121314151617 Class fieldType = field.getType(); ``` &gt; 更多方法看API文档#### 方法反射的基本操作 现有A类如下：```javaclass A&#123; public void print()&#123; System.out.println("helloworld"); &#125; public void print(int a,int b)&#123; System.out.println(a+b); &#125; public void print(String a,String b)&#123; System.out.println(a.toUpperCase()+","+b.toLowerCase()); &#125;&#125; 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型12A a1 = new A();Class c = a1.getClass(); 2.通过名称和参数列表来获取方法1Method m = c.getMethod("print", int.class,int.class); 3.方法的反射操作1Object o = m.invoke(a1, 10,20); 这个操作的效果等同于a1.print(10,20) 通过方法的反射，我们可以绕过编译]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Socket应用¨]]></title>
    <url>%2F2018%2F07%2F21%2FJava-Socket%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、Socket使用时应当注意的一些问题-设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时 调用setSoTimeout方法设置 12Socket s = new Socket(...);s.setSoTimeout(10000); 对构造器Socket(String host,int port)，可以先构建一个无连接的套接字，再使用超时 123Socket s = new Socket();s.connect(new InetSocketAddress(host,port),timeout);` 可中断套接字，用SocketChannel类 需要解析因特网地址时，可以用InetAddress类 为多个客户端服务时，可以用多线程解决 半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用Socket.shutdownInput/Socket.shutdownOutput二、获取Web数 URI和URL URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN 一个URI具有一下语法：[scema:]schemaSpecficPart[#fragment] I.包含schema:部分的URI成为绝对URI，否则为相对URIII.绝对URI的schemaSpecficPart不是以/揩油，则称为不透明的，如:mialto:pinnuli!hostname.comIII.所有绝对的透明URI和所有相对URI都是分层的，如：http://hostname.com/index.html，../../java/net/Socket.html#Socket()IV.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port] java中URI类的作用 解析表示福并将它分解成各种不同组成成分 标识符的相对化和解析相对标识符 使用URLCollection URLConnection类可以比URL类有更多的控制 必须严格按照以下步骤进行操作： 1.调用URL类中的openConnection方法得到URLConnection对象：URLConnection connection = url.openConnection(); 2.设置请求属性 3.调用connect方法连接远程资源:connection.connect(); 4.建立连接后，可以查询头信息 5.访问资源数据，使用getInputStream方法获取一个输入流 PS:这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能 提交表单 1.提交数据之前，需要创建一个URLConnection对象 12URL url = new URL("http;??host/script");URLConnection connection = url.openConnection(); 2.调用setDoOutput方法建立一个输出的连接 12connection.setRequestMethod("POST");connection.setDoOutput（true); 3.调用getOutputStream方法获得一个输出流，想服务器发送数据 123OutputStreamWriter osw = new OutputStreamWriter(connection.getOutputStream(), "UTF-8");osw.write(name1 + "=" + URLEncoder.eccode(value1,"UTF-8") + "&amp;);osw.write(name2 + "=" + URLEncoder.encode(value2,"UTF-8")); 4.关闭输出流 12osw.flush();osw.close(); 5.调用getInputStream方法对服务器的响应 1234567BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));StringBuffer response = new StringBuffer();String temp;while ((temp = br.readLine()) != null) &#123; response.append(temp); response.append("\n");&#125; I.设置请求方法时，必须使用大写，如POST，使用post无法识别 II.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法 InputStream err = ((HTTPURLConnection) connection).getErrorStream(); URL编码需遵循以下规则： &gt;I.保留字符A-Z、a-z、0-9 以及.-*_ II.用`+`替换所有空格 III.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字 比如发送&quot;New York, NY&quot;，可以使用New+York%2C+NY 二、基于TCP的SOcket通信1.创建ServerSocket和Socket2.打开连接到Socket的输入/输出流3.按照协议对Socket进行读/写操作4.关闭输入/输出流，关闭Socket 服务端（多线程响应多个客户端）123456789101112//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口ServerSocket serverSocket=new ServerSocket(8888);Socket socket=null;System.out.println("***服务器即将启动，等待客户端的连接***");while(true)&#123; //调用accept()方法开始监听，等待客户端的连接 socket=serverSocket.accept(); //创建一个新的线程 ServerThread serverThread=new ServerThread(socket); //启动线程 serverThread.start();&#125; ServerThread类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public class ServerThread extends Thread &#123; Socket socket = null; public ServerThread(Socket socket) &#123; this.socket = socket; &#125; //线程执行的操作，响应客户端的请求 public void run()&#123; InputStream is=null; InputStreamReader isr=null; BufferedReader br=null; OutputStream os=null; PrintWriter pw=null; try &#123; //获取输入流，并读取客户端信息 is = socket.getInputStream(); isr = new InputStreamReader(is); br = new BufferedReader(isr); String info=null; while((info=br.readLine())!=null)&#123;//循环读取客户端的信息 System.out.println("我是服务器，客户端说："+info); &#125; socket.shutdownInput();//关闭输入流，半关闭 //获取输出流，响应客户端的请求 os = socket.getOutputStream(); pw = new PrintWriter(os); pw.write("欢迎您！"); pw.flush();//调用flush()方法将缓冲输出 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; //关闭资源 try &#123; if(pw!=null) pw.close(); if(os!=null) os.close(); if(br!=null) br.close(); if(isr!=null) isr.close(); if(is!=null) is.close(); if(socket!=null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; #####客户端 123456789101112131415161718192021//1.创建客户端Socket，指定服务器地址和端口Socket socket=new Socket("localhost", 8888);//2.获取输出流，向服务器端发送信息OutputStream os=socket.getOutputStream();//字节输出流PrintWriter pw=new PrintWriter(os);//将输出流包装为打印流pw.write("用户名：alice;密码：789");pw.flush();socket.shutdownOutput();//关闭输出流//3.获取输入流，并读取服务器端的响应信息InputStream is=socket.getInputStream();BufferedReader br=new BufferedReader(new InputStreamReader(is));String info=null;while((info=br.readLine())!=null)&#123; System.out.println("我是客户端，服务器说："+info);&#125;//4.关闭资源br.close();is.close();pw.close();os.close();socket.close(); 二、基于UDP的SOcket通信1.定义发送信息2.创建DatagramPacket，包含将要发送的信息3.创建DatagramSocket4.发送数据 服务端： 接收客户端发送的数据 12345678910//1.创建服务器端DatagramSocket，指定端口DatagramSocket socket=new DatagramSocket(8800);//2.创建数据报，用于接收客户端发送的数据byte[] data =new byte[1024];//创建字节数组，指定接收的数据包的大小DatagramPacket packet=new DatagramPacket(data, data.length);//3.接收客户端发送的数据socket.receive(packet);//此方法在接收到数据报之前会一直阻塞//4.读取数据String info=new String(data, 0, packet.getLength());System.out.println("我是服务器，客户端说："+info); 向客户端响应数据 12345678910//1.定义客户端的地址、端口号、数据InetAddress address=packet.getAddress();int port=packet.getPort();byte[] data2="欢迎您!".getBytes();//2.创建数据报，包含响应的数据信息DatagramPacket packet2=new DatagramPacket(data2, data2.length, address, port);//3.响应客户端socket.send(packet2);//4.关闭资源socket.close(); 客户端： 向服务器端发送数据 12345678910//1.定义服务器的地址、端口号、数据InetAddress address=InetAddress.getByName("localhost");int port=8800;byte[] data="用户名：admin;密码：123".getBytes();//2.创建数据报，包含发送的数据信息DatagramPacket packet=new DatagramPacket(data, data.length, address, port);//3.创建DatagramSocket对象DatagramSocket socket=new DatagramSocket();//4.向服务器端发送数据报socket.send(packet); 接收服务器端响应的数据 12345678910//1.创建数据报，用于接收服务器端响应的数据byte[] data2=new byte[1024];DatagramPacket packet2=new DatagramPacket(data2, data2.length);//2.接收服务器响应的数据socket.receive(packet2);//3.读取数据String reply=new String(data2, 0, packet2.getLength());System.out.println("我是客户端，服务器说："+reply);//4.关闭资源socket.close(); 当Socket关闭时，输入输出流也就关闭了 参阅Java Socket应用—通信是这样练成的]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的XML]]></title>
    <url>%2F2018%2F07%2F20%2FJava%E4%B8%AD%E7%9A%84XML%2F</url>
    <content type="text"><![CDATA[HTML与XML的区别 HTML对大小写不敏感，XML大小写敏感 HTML结束标签可以省略，如&lt;/p&gt;，XML不能 XML只有单个标签而没有结束标签的元素必须以/结束 XML属性值必须用引号括起来 HTML属性可以没有值，XML所有属性必须有值 解析XML文档现有以下xml文档books.xml123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;bookstore&gt; &lt;book id="1"&gt; &lt;name&gt;冰与火之歌&lt;/name&gt; &lt;author&gt;乔治马丁&lt;/author&gt; &lt;year&gt;2014&lt;/year&gt; &lt;price&gt;89&lt;/price&gt; &lt;/book&gt; &lt;book id="2"&gt; &lt;name&gt;安徒生童话&lt;/name&gt; &lt;year&gt;2004&lt;/year&gt; &lt;price&gt;77&lt;/price&gt; &lt;language&gt;English&lt;/language&gt; &lt;/book&gt;&lt;/bookstore&gt; DOM解析 1、创建一个DocumentBuilder的对象 12DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); 2、调用parser方法加载books.xml文件到当前项目下 1Document document = db.parse("books.xml"); 3、进行解析 1234567891011121314151617181920 //获取所有book节点的集合NodeList bookList = document.getElementsByTagName("book"); //?????book?? for (int i = 0; i &lt; bookList.getLength(); i++) &#123; //通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始 Node book = bookList.item(i); //获取book节点的所有属性集合 NamedNodeMap attrs = book.getAttributes(); //前提：已经知道book节点有且只能有1个id属性 //将book节点进行强制类型转换，转换成Element类型 Element book = (Element) bookList.item(i); //通过getAttribute("id")方法获取属性值 String attrValue = book.getAttribute("id"); //解析book节点的子节点 NodeList childNodes = book.getChildNodes(); &#125; 更多解析方法查看API SAX解析 1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例 1SAXParserFactory factory = SAXParserFactory.newInstance(); 2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例 1SAXParser parser = factory.newSAXParser(); 3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler 12 SAXParserHandler handler = new SAXParserHandler();parser.parse("books.xml", handler); handler类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //标识解析开始@Overridepublic void startDocument() throws SAXException &#123; // TODO Auto-generated method stub super.startDocument(); System.out.println("SAX解析开始");&#125; //标识解析结束 @Overridepublic void endDocument() throws SAXException &#123; // TODO Auto-generated method stub super.endDocument(); System.out.println("SAX解析结束");&#125; //解析xml元素 @Overridepublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; //调用DefaultHandler类的startElement方法 super.startElement(uri, localName, qName, attributes); if (qName.equals("book")) &#123; //已知book元素下属性的名称，根据属性名称获取属性值 String value = attributes.getValue("id"); System.out.println("book的属性值是：" + value); &#125;else if (!qName.equals("name") &amp;&amp; !qName.equals("bookstore")) &#123; System.out.print("节点名是：" + qName + "---"); &#125;&#125;@Overridepublic void endElement(String uri, String localName, String qName) throws SAXException &#123; //调用DefaultHandler类的endElement方法 super.endElement(uri, localName, qName); //判断是否针对一本书已经遍历结束 if (qName.equals("book")) &#123; System.out.println("结束遍历某一本书的内容"); &#125;&#125;@Overridepublic void characters(char[] ch, int start, int length) throws SAXException &#123; // TODO Auto-generated method stub super.characters(ch, start, length); value = new String(ch, start, length); if (!value.trim().equals("")) &#123; System.out.println("节点值是：" + value); &#125;&#125; JDOM?? 1、创建一个SAXBuilder的对象 1SAXBuilder saxBuilder = new SAXBuilder(); 2、创建一个输入流，将xml文件加载到输入流中 1in = new FileInputStream(&quot;books.xml&quot;); 3、通过saxBuilder的build方法，将输入流加载到saxBuilder中 1Document document = saxBuilder.build(in); 4、通过document对象获取xml文件的根节点 1Element rootElement = document.getRootElement(); 5、获取根节点下的子节点的List集合 1234567891011121314List&lt;Element&gt; bookList = rootElement.getChildren();for (Element book : bookList) &#123; // 解析book的属性集合 List&lt;Attribute&gt; attrList = book.getAttributes(); //知道节点下属性名称时，获取节点值 book.getAttributeValue(&quot;id&quot;); // 对book节点的子节点的节点名以及节点值的遍历 List&lt;Element&gt; bookChilds = book.getChildren(); for (Element child : bookChilds) &#123; System.out.println(&quot;????&quot; + child.getName() + &quot;----????&quot; + child.getValue()); &#125;&#125; 如果需要设置编码可以按照以下方式设置 12 InputStreamReader isr = new InputStreamReader(in, "UTF-8");Document document = saxBuilder.build(isr); DOM4J解析 1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象 12SAXReader reader = new SAXReader();Document document = reader.read(new File("src/res/books.xml")); 2、通过document对象获取根节点 1Element bookStore = document.getRootElement(); 3、通过element对象的elementIterator方法获取迭代器 1Iterator it = bookStore.elementIterator(); 4、遍历迭代器，获取根节点中的信息 123456789101112131415while (it.hasNext()) &#123; Element book = (Element) it.next(); // 获取book的属性名以及 属性值 List&lt;Attribute&gt; bookAttrs = book.attributes(); for (Attribute attr : bookAttrs) &#123; System.out.println("????" + attr.getName() + "--????" + attr.getValue()); &#125; //遍历子节点 Iterator itt = book.elementIterator(); while (itt.hasNext()) &#123; Element bookChild = (Element) itt.next(); System.out.println("????" + bookChild.getName() + "--????" + bookChild.getStringValue()); &#125;&#125; 四种解析方式的区别 DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时 优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改 缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出 SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时 优点：内存消耗小 缺点：不易编码；很难同时访问同一个xml中的多处不同数据 JDOM：API大量使用了Collections类 DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用 生成XML文档 DOM 1、创建DocumentBuilder对象 12DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder db = dbf.newDocumentBuilder(); 2、添加节点 12345678910111213document.setXmlStandalone(true);Element bookstore = document.createElement("bookStore");//向bookstore根节点中添加子节点bookElement book = document.createElement("book");Element name = document.createElement("name");name.setTextContent("???");book.appendChild(name);book.setAttribute("id", "1");//将book节点添加到bookstore根节点中bookstore.appendChild(book);//将bookstore节点（已经包含了book）添加到dom树中document.appendChild(bookstore); 3、生成xml文件 12345TransformerFactory tff = TransformerFactory.newInstance();Transformer tf = tff.newTransformer();//设置文件tf.setOutputProperty(OutputKeys.INDENT, "yes");tf.transform(new DOMSource(document),new StreamResult(new File("books1.xml"))); SAX 1、创建一个TransformerFactory类的对象 1SAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance(); 2、通过SAXTransformerFactory对象创建一个TransformerHandler对象 1TransformerHandler handler = tff.newTransformerHandler(); 3、通过handler对象创建一个Transformer对象 1Transformer tr = handler.getTransformer(); 4、通过Transformer对象对生成的xml文件进行设置 12345678910 // 设置xml的编码 tr.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;); // 设置xml的“是否换行” tr.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);5、创建一个Result对象 ```java File f = new File(&quot;newbooks.xml&quot;); if (!f.exists()) &#123; f.createNewFile(); &#125; 6、创建Result对象，并且使其与handler关联 12Result result = new StreamResult(new FileOutputStream(f));handler.setResult(result); 7、利用handler对象进行xml文件内容的编写O 12// 打开documenthandler.startDocument(); 8、添加节点属性和节点值 12345678910111213141516171819 AttributesImpl attr = new AttributesImpl();handler.startElement("", "", "bookstore", attr); for (Book book : bookList) &#123; attr.clear(); attr.addAttribute("", "", "id", "", book.getId()); handler.startElement("", "", "book", attr); // 创建name节点 if (book.getName() != null &amp;&amp; !book.getName().trim().equals("")) &#123; attr.clear(); handler.startElement("", "", "name", attr); handler.characters(book.getName().toCharArray(), 0, book .getName().length()); handler.endElement("", "", "name"); &#125; handler.endElement("", "", "book"); &#125; handler.endElement("", "", "bookstore"); // 关闭document handler.endDocument(); JDOM 1.生成一个根节点 1Element rss = new Element("rss"); 2.为节点添加属性 1rss.setAttribute("version", "2.0"); 3.生成一个document对象 12345678910Document document = new Document(rss);Element channel = new Element("channel");rss.addContent(channel);Element title = new Element("title");title.setText("&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;");channel.addContent(title);//设置文件编码和换行Format format = Format.getCompactFormat();format.setIndent("");format.setEncoding("GBK"); 4.创建XMLOutputter的对象 1XMLOutputter outputer = new XMLOutputter(format); 5.利用outputer将document对象转换成xml文档 1outputer.output(document, new FileOutputStream(new File("rssnews.xml"))); DOM4J 使用DOM4J生成RSS文件 1.创建document对象，代表整个xml文档 1Document document = DocumentHelper.createDocument(); 2.创建根节点rss 1Element rss = document.addElement("rss"); 3.向rss节点中添加version属性 1rss.addAttribute("version", "2.0"); 4.生成子节点及节点内容 123Element channel = rss.addElement("channel");Element title = channel.addElement("title");title.setText("&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;"); 5.设置生成xml的格式 12OutputFormat format = OutputFormat.createPrettyPrint();format.setEncoding("GBK"); 6.生成xml文件 1234567File file = new File("rssnews.xml");XMLWriter writer;writer = new XMLWriter(new FileOutputStream(file), format);//设置是否转义，默认值是true，代表转义writer.setEscapeText(false);writer.write(document);writer.close(); 验证XML文档 需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema 文档类型定义 将这些规则纳入XML文档 123456789&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE configuration[ &lt;!ELEMENT configuration...&gt; ...]&gt;&lt;configuration&gt;...&lt;/configuration&gt; 这些规则被纳入到DOCTYPE声明中，代码块[…]用来限定其接线，比如configuration - SYSTEM声明，将DTD存储在外面 12&lt;!DOCTYPE configuration SYSTEM "config.dtd"&gt;&lt;!DOCTYPE configuration SYSTEM "http://myserver.com/config.dtd"&gt; - 标记PUBLIC标识符 123456789class MyEntityResolver implements EntityResolver&#123; public InputSource resolveEntity(String publicId, String systemID)&#123; if(publicID.equals(a knowx ID))&#123; return new InputSource(DTD data): &#125;else&#123; return null; &#125; &#125;&#125; &gt;PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空 XML Schema 声明Schema文件 123&lt;?xml version="1.0"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;/project&gt; 使用xsd:表示XSL Schema定义的命名空间 ref属性引用Schema中位于别处的定义&lt;xsd:element name=”style” type=StyleType”/&gt; &lt;xsd:enumeration value=&quot;PLAIN&quot;/&gt; 使用XPath定位信息 查找下列的username的值，,通过XPath表达式/configuration/database/username 123456&lt;configfuration&gt; &lt;database&gt; &lt;username id=&quot;test&quot;&gt;pinnuli&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/database&gt;&lt;/configfuration&gt; 用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式 123XPathFactory xpFactory = XPathFactory.newInstance();path = xpfactory.newXPath();String username = path.evaluate(/configuration/database/username&quot;,doc); &gt;具体的语法看文档XML的命名空间 使用xmlns给定命名空间 12345&lt;element xmlns="namespaceURI1"&gt; &lt;child xmlns="namespaceURI2"&gt; grandchildren &lt;/child&gt;&lt;/element&gt; 这里第一个子元素和孙元素都是第二个命名空间的一部分 使用xmlns:prefix=”namespaceURI”定义命名空间和前缀 1234&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt; &lt;xsd:element name=&quot;pinnuli&quot; type=&quot;haha&quot;/&gt; ...&lt;/xsd:schema&gt; 在这里xsd:schema实际上指的是命名空间http://www.w3.org/2001/XMLSchema中的schema 可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性 1factory.serNamespaceAware(true);]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java io流与文件]]></title>
    <url>%2F2018%2F07%2F19%2Fjava-io%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、流 读写字节 InputStream.read和OutpueStream.write， 组合流过滤器 某些流（如FileInputStream或者FileOutputStream）只能支持在字节级别上的读写，，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如： 123FileInputStream fin = new FileInputStream(&quot;test.txt&quot;);DataInputStream din = new DataInputStream(fin);double s = din.readDouble(); 需要使用缓冲，可以使用一下构造器： 123DataInputStream din = new DataInputStream( new BUfferInputStream( new FileInputStream(test.txt&quot;))); 需要浏览下一个字节以确定是否是想要的值时，可以： 1234567PushbackInputStream pbin = new PushbackInputStream( new BUfferInputStream( new FileInputStream(test.txt&quot;)));//预读写一个字节int b = pbin.read();//不是所期望时将其推回流中if(b != &apos;&lt;&apos;) pbin.unead(b); 二、文本输入与输出 输出：PrintWrite PrintWrite out = new PrintWrite(&quot;test.txt&quot;);等同于PrintWrite out = new PrintWrite(new FileWrite(&quot;test.txt&quot;)); 输入：Scanner 文本格式存储对象 用自己的格式依次存储各个字段，以特定字符分隔，如：PINUULI|201625010417|1997|guangdong三、读写二进制数据 读：实现DataInput接口，如DataInputStream，readInt，readBoolean等方法 写：实现DataOutput接口，如DataOutputStream，writeInt，writeBoolean等方法 随机访问文件：RandomAccessFile可以在文件中的任何位置查找或者写入数据：12RandomAccessFile in = new RandomAccessFile(&quot;test.txt&quot;,&quot;r&quot;);RandomAccessFile inOut = new RandomAccessFile(&quot;test.txt&quot;,&quot;rw&quot;); 四、ZIP文件 每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。 读：ZipInputStream 用getNextEntry方法返回文档中这些项（文件）的ZipEntry对象-ZipInputStream的read方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用closeEntry读入下一项 在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项 通读zip文件：123456789ZipInputStream zin = new ZipInputStream(new FileInputStream(&quot;test.zip&quot;));ZipEntry entry;Scanner in = new Scanner(zin);while((entry = zin.getNextEntry()) != null)&#123; while(in.hasNextLine())&#123; System.out.println(in.nextLine()); &#125; zin.closeEntry();&#125; 写：ZipOutputStream 对于想要放入到zip文件中的每一个项，都应该创建一个ZipEntry对象，并将文件名传递给ZipEntry的构造器 调用ZipOutputStream的putNextEntry方法开始写出新文件，并将数据发送到zip流中 完成时调用closeEntry方法 如：12345678910FileOutputStream fout = new FilePutputStream(&quot;test.zip&quot;);ZipOutputStream zout = new ZipOutputStream(fout);// 写一个文件ZipEntry ze = new ZipEntry(&quot;filename&quot;);zout.putNextENtry(ze);send data to zout;zout.closeEntry();zout.close(); 五、对象流与序列化 序列化:ObjectOutputStream.writeObject(), 反序列化：ObjectInputream.readObject()， 都需要实现Serializable接口 只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等 序列化算法： 对于遇到的每个对象都关联一个序列号 对于每个对象，第一次遇到时，保存其对象数据到流中 如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反 对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联 当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用 修改默认的序列化机制 一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。 可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。 当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现Serializable接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如： 1234567891011121314151617181920public class LabeledPoint implements Serializable&#123; private String label; //对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标 private transient Point2D.Double point; ··· //重写读写方法 private void writeObject(ObjectOutputStream out) throws Exception&#123; out.defaultWriteObjecy(); out.writeDouble(point.getX()); out.writeDouble(point.getY()); &#125; private void readObject(ObjectInputStream in) throws IOException&#123; in.defaultReadObject(); double x = in.readDouble(); double y = in.readDouble(); point = new Point2D.DOuble(x,y); &#125;&#125; - 当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现`Externalizable`接口，指定要保存的域 12345678910111213141516public class Student implements Externalizable&#123; private String name; private String stuId; private int age; ··· //重写读写方法 private void writeExternal(ObjectOutput out) throws IOException&#123; out.writeUTF(name); out.writeInt(age); &#125; private void readExternal(ObjectInput in) throws IOException&#123; name = in.readUTF(): age = in.readInt(); &#125;&#125; &gt; PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。 六、操作文件 Path 静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\）连接起来，返回一个Path对象，详情见API。如： 12Path absolutye = Paths.get(&quot;/home&quot;.&quot;cay&quot;);Path relative = Paths.get(&quot;myprog&quot;,&quot;conf&quot;,&quot;user.properties&quot;); 读写文件：Files类可以使得普通文件操作变得快捷 读取文件所有内容：byte[] bytes = Files.readAllBytes(path);,之后可以将其当做字符串String content = new String(bytes,charset); 向指定文件追加内容：Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND); 将一个行集合]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 Let's Encrypt用Certbot获取Https证书 部署nginx]]></title>
    <url>%2F2018%2F07%2F15%2Fcentos7-Let-s-Encrypt%E7%94%A8Certbot%E8%8E%B7%E5%8F%96Https%E8%AF%81%E4%B9%A6-%E9%83%A8%E7%BD%B2nginx%2F</url>
    <content type="text"><![CDATA[检查nginx下是否有--with-http_stub_status_module 和--with-http_ssl_module两个模块，安装之后再重新编译 nginx -V 用http克隆github上的certbot git clone https://github.com/certbot/certbot /opt/certbot-master 安装所有依赖 /opt/certbot-master/letsencrypt-auto –help 关闭nginx，检出80端口，443端口是否有开启 nginx -s stop firewall-cmd –query-port=80/tcp firewall-cmd –query-port=443/tcp 没有的话就开启 firewall-cmd –permanent –zone=public –add-port=80/tcp 获取证书 /opt/certbot-master/letsencrypt-auto –nginx -d www.pinnuli.com 配置nginx（也可选择自动配置) user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/www/pinnuli.github.io; include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } server { server_name www.pinnuli.com; # managed by Certbot root /var/www/pinnuli.github.io; include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } listen [::]:443 ssl ipv6only=on; # managed by Certbot listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } 设置自动更新（待更新）]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合框架]]></title>
    <url>%2F2018%2F07%2F11%2Fjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[1、迭代器iterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素， next()方法 逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用； java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用 用”for each”循环遍历类集的内容， remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态 对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉 2、List 有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类 ArrayList - 基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道 - 适用于需要进行随机访问时 LinkedList 基于双向链表， 对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值 适用于顺序访问 3、Set等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一 HashSet 基于散列表的集，无序 存入的元素必须定义有hashCode()，以得到散列码 可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变 可以设置装填因子来实现再散列 适用于不关心访问顺序，需要查找大容量容器时 TreeSet 基于红黑树排序，有序 存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator 每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问 适用于存储大量需要进行快速检索的排序信息的情况 BitSet 用于存放一个位序列 4、Queue 双端队列，可以同时在头部或者尾部添加或删除元素，有两个实现 LinkedList ArrayList PriorityQueue 基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序 按照任意顺序插入，却可以按照顺序进行检索 和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator 5、Map 对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。 键不存在时，get方法返回null，可以用getOrDefault返回默认值，test.get(id,0) 更新映射项，正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，counts.put(word,counts.get(word)+1),需要解决一个问题，就是键第一次出现时，这时可以有三种方法 counts.put(word,counts.getOrDefault(word,0) + 1) 先调用putIfAbsent，只有原先键存在时才会放一个值,counts.putIfAnsent(word,0) counts.put(word,counts.get(word)+1) counts.merge(word,1,Interger::sum)(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联 映射视图：集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图 键集：Set&lt;K&gt; keySet()， 值集：Collection&lt;V&gt; values()， 键/值对集：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除 散列 散列码，由对象的实例域产生的一个整数，由hashCOde()产生 散列表，用链表数组实现，每个列表称为桶 散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询 新版jdk使用红黑树和List（数据多用树，少时用List) 散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表 HashMap 比较快，适用于不需要按照排列顺序访问键时 TreeMap 按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序 WeakHashMap 使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键 如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目 适用于需要缓存时 LinkedHashMap 链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，收到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置 用于实现高速缓存的“最近最少使用”原则 6、视图与包装器 轻量级集合包装器 例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法 12Card[] cardDeck = new Card[52];List&lt;Card&gt; cardList = Arrays.asList(cardDeck); 返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小 例如Collections类的一些使用方法，nCopied(100,”KKK”),single(anObject)等，返回一个不可修改的试图对象 子范围 相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用List group2 = staff.subList(10,20);,类似于String类中获取子串 可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除 对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集， SortedSet subSet(E from, E to)SortedSet headSet(E to)SortedSet tailSet(E from) 不可修改的视图 只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改 访问器方法从原始集合对象中获取值 视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如： unmodifiableCollection方法将返回一个集合，但他的equals()方法不调用底层集合的，而是调用它继承了Object类的equals()方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的 同步视图 实现多线程访问，确保集合的线程安全，例如Collections.synchronizedMap 受查视图 用来对泛型类型进行检测，例如Collections.checkedList]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常学习笔记]]></title>
    <url>%2F2018%2F07%2F10%2Fjava%E5%BC%82%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[java异常结构 声明受查异常 子类覆盖超类的方法时，子类方法中可以抛出更特定的异常或者不抛出异常，但不能抛出更通用的异常。 如果超类方法中没有抛出异常，则子类也不能抛出异常。 如果方法中声明会抛出一个异常，而这个类是某个特定类的实例时，则方法有可能抛出这个类的异常或这个类的任意子类的异常。 捕捉多个异常时，只有异常类型彼此之间不存在子类关系时才可以合并，并且异常变量隐含为final类型，不可为其赋值。 ### 定义简单泛型类 定义泛型方法 类型变量的限定 类型擦除 定义泛型时所需要注意的一些点 不能用基本类型实例化类型参数 擦除后，泛型类含有Object类型的域，补鞥呢存储基本类型 - 运行时类型查询只适用于原始类型 - 不能创建参数化类型的数组 - 避免Varargs警告 -]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习笔记]]></title>
    <url>%2F2018%2F05%2F03%2FJSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、jsp简介1、Jsp三大指令 page指令:&lt;%@page 属性=”” %&gt;,位于jsp页面顶端，可以有多个 1&lt;%@ page contentType="text/html;charset=UTF-8" language="java" import="java.text.*"%&gt; taglib指令：标签库 include include指令: &lt;%@include file=&quot;date.jsp&quot;%&gt; include动作: page:要包含的页面 flush：被包含的页面是否从缓冲区读取 include指令与include动作的区别： - forward动作：&lt;jsp: forward page=&quot;url&quot;/&gt;, 等同于：request.getRequestDispatcher(&quot;/url&quot;).forward(request,response); - param动作：&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt; 常与&lt;jsp:forward&gt;一起使用，作为其的子标签: 1234&lt;jsp:forward page="user.jsp"&gt; &lt;%--用&lt;jsp:param "&gt;&lt;/jsp:param&gt;添加参数--%&gt; &lt;jsp:param name="email" value="11111111@163.com"&gt;&lt;/jsp:param&gt; &lt;/jsp:forward&gt; 2、jsp注释 html的注释 jsp的注释&lt;%– jsp注释 –&gt;（客户端不可见） jsp脚本注释: //单行 / / 多行 3、jsp脚本&lt;% java代码 %&gt; 4、jsp声明变量或方法&lt;%! java代码 %&gt; 5、jsp表达式&lt;%=表达式 %&gt; ps:不可;分号结束 6、jsp页面的生命周期 二、jsp内置对象 九大内置对象： out,request,response,session,application,Page,pageContext,exception,config out 123456789101112131415&lt;% out.println("&lt;h2&gt;静夜思&lt;/h2&gt;"); out.println("床前明月光&lt;br&gt;"); out.println("疑是地上霜&lt;br&gt;"); out.flush(); /*out.clear();会抛出异常*/ out.clearBuffer();//这里不会抛出异常 out.println("举头望明月&lt;br&gt;"); out.println("低头思故乡&lt;br&gt;"); %&gt; 缓冲区大小：&lt;%= out.getBufferSize()%&gt;byte&lt;br&gt; 缓冲区剩余大小：&lt;%= out.getRemaining()%&gt;byte&lt;br&gt; 是否自动清空缓冲区：&lt;%= out.isAutoFlush()%&gt;&lt;br&gt; request 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;% request.setCharacterEncoding("utf-8");//解决post中文乱码问题，但无法解决get，get解决需要直接Tomcat配置文件 request.setAttribute("password","123456");//设置属性密码 %&gt; 用户名：&lt;%= request.getParameter("username")%&gt;&lt;br&gt; 爱好： &lt;% if(request.getParameterValues("favorite") != null)&#123; //这里需要判断为不为空，jsp这里不能将String数组看为Boolean String[] favorites = request.getParameterValues("favorite"); for (int i = 0; i &lt; favorites.length; i++) &#123; out.println(favorites[i] + "&amp;nbsp;&amp;nbsp;&amp;nbsp;"); &#125; &#125; String realPath = request.getRealPath("requset.jsp");%&gt;&lt;br&gt; 密码： &lt;%=request.getAttribute("password")%&gt;&lt;br&gt; 请求体的MIME类型： &lt;%=request.getContentType()%&gt;&lt;br&gt; 协议类型和版本号： &lt;%=request.getProtocol()%&gt;&lt;br&gt; 服务器主机名： &lt;%=request.getServerName()%&gt;&lt;br&gt; 服务器端口号： &lt;%=request.getServerPort()%&gt;&lt;br&gt; 请求文件长度： &lt;%=request.getContentLength()%&gt;&lt;br&gt; 请求的客户端地址： &lt;%=request.getRemoteAddr()%&gt;&lt;&lt;br&gt; 请求的真实路径： &lt;%=request.getRealPath("requset.jsp")%&gt;&lt;br&gt; 请求的上下文路径： &lt;%=request.getContextPath()%&gt; response 12345678910111213141516&lt;% response.setContentType("text/html;charset=utf-8"); out.println("&lt;h1&gt;response内置对象&lt;/h1&gt;"); out.println("&lt;hr&gt;"); //out.flush(); /* 因为getWrite获得的输出流对象会先于内置对象out输出， 所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer 再输出out*/ PrintWriter outer = response.getWriter(); outer.println("大家好，我是response生成的输出流outer");// response.sendRedirect("login.jsp");//重定向// response.sendRedirect("request.jsp"); request.getRequestDispatcher("request.jsp").forward(request,response);//转发 %&gt; 请求转发和请求重定向： session HttpSession的实例， 周期：在第一个jsp页面被加载时自动创建， 即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束， 在服务器的几个页面之间切换，服务器应当知道这是一个客户， 就可以用session对象 12345678910111213141516171819202122232425262728293031&lt;% SimpleDateFormat sdf = new SimpleDateFormat("yyyy年mm月dd日 HH:mm:ss"); Date d = new Date(session.getCreationTime()); session.setAttribute("username","pinnuli"); session.setAttribute("password","123456"); session.setAttribute("age",20);// session.setMaxInactiveInterval(10);//设置session最大生成期限，单位秒,也可在web.xml中设置session-timeout %&gt; Session创建时间： &lt;%=sdf.format(d)%&gt;&lt;br&gt; Session的ID： &lt;%=session.getId()%&gt;&lt;br&gt; Session中获取属性值： &lt;%=session.getAttribute("username")%&gt;&lt;br&gt; Session保存的属性数组： &lt;% String[] names = session.getValueNames(); for(int i=0; i&lt;names.length; i++)&#123; out.println(names[i] + "&amp;nbsp;&amp;nbsp;"); &#125;// session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session %&gt;&lt;br&gt; &lt;%--测试不同页面是否同一个session--%&gt; &lt;a href="session_page2.jsp"&gt;跳转到session_page2&lt;/a&gt; application 实现用户间数据的共享，可存放全局边变量，相当于java的静态变量 12345678910111213141516&lt;% application.setAttribute("city","广州"); application.setAttribute("postcode","510000"); application.setAttribute("email","guangzhou@163.com"); %&gt; 所在城市：&lt;%=application.getAttribute("city")%&gt;&lt;br&gt; 所有属性： &lt;% Enumeration attributes = application.getAttributeNames(); while (attributes.hasMoreElements())&#123; out.println(attributes.nextElement() + "&amp;nbsp;&amp;nbsp;"); &#125; %&gt;&lt;br&gt; jsp(serviet)引擎名和版本号：&lt;%=application.getServerInfo()%&gt;&lt;br&gt; page、pageContext 123456789101112&lt;h3&gt;page:&lt;/h3&gt;当前page页面的字符串描述：&lt;%=page.toString()%&gt;&lt;br&gt;&lt;br&gt; &lt;h3&gt;pageContext:&lt;/h3&gt;用户名：从session中获取属性-&lt;%=pageContext.getSession().getAttribute("username")%&gt;&lt;br&gt; &lt;%--跳转到其他页面--%&gt; &lt;%--&lt;% pageContext.forward("out.jsp"); %&gt;--%&gt; include方法，包含其他页面: &lt;% pageContext.include("out.jsp"); %&gt; exception 123异常消息：&lt;%=exception.getMessage()%&gt;&lt;br&gt; 异常的字符串描述：&lt;%=exception.toString()%&gt; 三、jsp使用Javabean1. Javabean的设计原则 必须是公有类 必须包含无参构造方法 属性私有 用getter()和setter()进行封装 例如： 1234567891011121314151617181920212223242526public class Students&#123; private String name; private int age; public Students()&#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 2. 存取Javabean有关的jsp动作元素在jsp页面中使用Javabeans： 像使用普通java类一样，创建Javabean实例 在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty &lt;jsp:useBeans&gt; 在jsp页面中实例化或者在指定范围内使用Javabean： &lt;jsp:useBeans id=&quot;标示符&quot; class=&quot;java类名&quot; scope=&quot;作用范围&quot;/&gt; scope属性：指定Javabean的作用范围page：当前页面,重定向和转发都无效request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效application:可通过application.getAttribute()取得Javabean对象，不同会话都有效 例如： 123&lt;jsp:useBean id="myUsers" class="com.po.Users" scope="application"&gt;&lt;/jsp:useBean&gt;用户名：&lt;jsp:getProperty name="myUsers" property="username"&gt;&lt;/jsp:getProperty&gt;密码：&lt;jsp:getProperty name="myUsers" property="password"&gt;&lt;/jsp:getProperty&gt; 也可使用内置对象获取： 12用户名：&lt;%=((Users)application.getAttribute("myUsers")).getUsername()%&gt;密码： &lt;%=((Users) application.getAttribute("myUsers")).getPassword()%&gt; &lt;jsp:setProperty&gt; 1234567891011根据表单自动匹配所有属性:&lt;jsp:setProperty name="myUsers" property="username"&gt;&lt;/jsp:setProperty&gt;根据表单匹配部分属性: &lt;jsp:setProperty name="myUsers" property="username"&gt;&lt;/jsp:setProperty&gt;与表单无关，通过手工赋值给属性: &lt;jsp:setProperty name="myUsers" property="password" value="hahahaha"&gt;&lt;/jsp:setProperty&gt; 通过url传参数给属性赋值:&lt;jsp:setProperty name="myUsers" property="password" param="testparam"&gt;&lt;/jsp:setProperty&gt; &lt;jsp:getProperty&gt; 12使用getProperty获取属性值: &lt;jsp:getProperty name="myUsers" property="username"&gt;&lt;/jsp:getProperty&gt;]]></content>
      <categories>
        <category>JSP笔记</category>
      </categories>
      <tags>
        <tag>JSP</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的使用]]></title>
    <url>%2F2018%2F04%2F30%2Fvim%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、一般模式：光标的移动、复制粘贴、搜索替换 移动光标： 向左移动一个字符：h 或 ← 向右移动一个字符：l 或 → 向上移动一个字符：k 或 ↑ 向下移动一个字符：j 或 ↓ 向左移动n个字符：n + h（其他同理)，如10h 向右移动这一行的n个字符(会换到下一行)：n + space,如20space 屏幕向上移动一页：Ctrl + b 屏幕向下移动一页：Ctrl + f 屏幕向上移动半页：Ctrl + u 屏幕向下移动半页：Ctrl + d 移动到非空格的下一行：+ 移动到非空格的上一行：- 移动到屏幕最上方那一行的第一个字符：H 移动到屏幕最中间那一行的第一个字符：M 移动到屏幕最下方那一行的第一个字符：L 移动到这个文件的最后一行：G 移动到这个文件的第n行：nG 移动到这个文件的第一行:gg 向下移动n行：n + enter,如10enter 搜索替换： 向光标往下搜索一个word的字符串：/word 向光标往上搜索一个word的字符串：?word 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc 删除、复制与粘贴 删除 向前（后）删除一个字符：x(X)，相当于backspace 连续向后删除n个字符： nx,如10x 删除光标所在的一整行：dd 删除光标所在的向下n行：ndd 删除光标所在到第一行的所有数据：d1G 输出光标所在到最后一行的所有数据:dG 删除光标所在到该行最后一个字符：d$ 删除光标所在到该行第一个字符：d0 -复制 复制光标所在的那一行：yy 复制光标所在的向下n行：nyy 复制光标所在行到第一行的所有数据：y1G 复制光标所在行到最后一行的所有数据:yG 复制光标所在到该行最后一个字符：y$ 复制光标所在到该行第一个字符：y0 -粘贴 将已复制的数据在光标下（上）一行贴上：p(P); 将光标所在行与 下一行的数据结合成一行： J 重复删除多个数据:c，如向下删除10行：10cj 复原前一个动作：u 重复上一个动作：Ctrl + r 二、一般模式到编辑模式的切换-进去输入模式-i/I 从目前光标所在处输入：i 从目前所在行的第一个非空格符处开始输入：I -a/A 从目前光标所在的下一个字符处开始输入:a 从光标所在行的最后一个字符处开始输入:A -o/O 在光标所在的下一行输入新的一行：o 在光标所在的上一行输入新的一行：O -进入取代模式-r/R 取代光标所在的那一个字符一次：r 一直取代光标所在的字符，直到按esc 三、一般模式到命令行模式的切换 指令行的存储、离开等 保存编辑： :w 强制写入： :w! 退出： :q 强制退出，不保存修改： :q! 保存修改后退出： :wq 将修改后的数据另存为一个文件： :w filename 在当前编辑的数据中，读入另一个文件的数据： :r filename 将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename 暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 vim环境的变更 显示行号： :set nu 取消显示行号： :set nonu]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用技巧]]></title>
    <url>%2F2018%2F04%2F30%2FIntelliJ-IDEA-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一、跳转快捷键 窗口切换：Ctrl + alt + [ / ]文件切换：alt + -&gt; / &lt;-关闭文件：ctrl + f4最近修改文件： ctrl + tab + E最近浏览文件： ctrl + E回到上次编辑的地方 last edit location: ctrl + shift + backspace回到上次浏览的地方 back/forward: ctrl + alt + -&gt;/&lt;-利用书签跳转：bookmarks:f11bookmarks mnemonic: ctrl + f11show bookmarks: shift + f11书签跳转：Ctrl + 1（n） 收藏（类或方法）：shift + alt + FemacsIDEAs 跳转：shift + j(这个是自己设的) 然后按要找单词的首字母，如p，然后选择编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n) 从文件去到编辑区：esc 二、精准搜索 搜索类：ctrl + alt + N(Ctrl + N 已被vim占用） 搜索文件： ctrl + shift + N 搜索符号（方法和属性）：ctrl + shift + alt + N 搜索字符串： ctrl + shift + F Match case :区分大小写 Words：搜索的字符串是一个单词 Regex：按照正则表达式搜索 File mask:指定文件类型 In Project：在项目下搜搜 Module：在当前模块下搜索 Directory：在指定目录下搜索 Scope：在指定范围下搜索]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程并发常见问题基于信号量解决方法总结：生产者/消费者问题、读/写者问题、银行家算法、哲学家进餐]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%2F</url>
    <content type="text"><![CDATA[一、信号量 信号量是一个与队列有关的整型变量。可以初始化成非负数；semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。信号量原语semWait和semSignal的定义： 123456789101112131415161718192021strcut semaphore&#123; int count; aueueType queue;&#125;;void semWait(semaphore s) &#123; s.count--; if(s.count &lt; 0) &#123; place this process in s.queue; block this process; &#125;&#125;void semSignal(semaphore s) &#123; s.count ++; if(s.count &lt;= 0) &#123; remove a process P from s.queue; place process P on ready list; &#125;&#125; 信号量实现互斥 1234567891011121314const int n;semaphore s = 1;void P(int i) &#123; while(true) &#123; semWait(s); operate; semSignal(s); &#125;&#125;void main() &#123; parbegin(P(1), P(2), ...,P(n));&#125; 总结： 信号量： 一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。 用于互斥时，S初值为1，取值为1~ - (n-1) （相当于临界区的通行证，实际上也是资源个数） S=1：临界区可用 S=0：已有一进程进入临界区 S=0 S&gt;=0:表示可用资源个数 S&lt;0: 表示该资源的等待队列长度 semWait、semSignal操作： semWait(S)：请求分配一个资源。 semSignal(S)：释放一个资源。 semWait、semSignal操作必须成对出现。 用于互斥时，位于同一进程内； 用于同步时，交错出现于两个合作进程内。 多个semWait操作的次序不能颠倒，否则可能导致死锁。 多个semSignal操作的次序可任意。 二、生产者/消费者问题 问题描述： 有一个或多个生产者生产某种类型的数据，并放置在缓冲区中； 有一个消费者从缓冲区中取数据，每次取一项； 系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区。 缓存已满时，生产者不能继续添加数据； 缓存已空时，消费者不能继续移走数据。 producer: 12345678while(true) &#123; /* produce item v */ while((in + 1) % n == out) //等待缓存有空位 /* doing nothing */ b[in] = v; in = (in + 1) % n;&#125; consumer: 12345678while(true) &#123; while(in == out) //此时缓存为空，等待生产者生产放入缓存后才可消费 /* doing nothing */ w = b[out]; out = (out + 1) % n; /* consume item w */&#125; 有限缓冲区： 使用信号量解决有限缓冲区生产者消费者问题: n 表示已生产产品的数量s 用来控制互斥e 表示空闲空间数目 123456789101112131415161718192021222324semaphore n = 0, s = 1, e = buf - size;void producer() &#123; while(true) &#123; produce(); semWait(e); semWait(s); append(); semSignal(s); semSignal(e); &#125;&#125;void consumer() &#123; while(true) &#123; semWait(n); semWait(s); take(); semSignal(s); semSignal(e); consume(); &#125;&#125; 例题1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。 分析： 生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。 数据结构： semaphore dish, apple, banana; dish: 表示盘子是否为空,用于控制互斥 apple：表示盘子中是否有苹果，初始值为0 banana:表示盘子中是否有香蕉，初始值为0 123456789101112131415161718192021222324 process father() &#123; semWait(dish); put the apple in the dish; semSignal(apple);&#125;process mother() &#123; semWait(dish); put the banana in the dish; semSignal(banana);&#125;process son() &#123; semWait(banana); get the banana from the dish; semSignal(dish);&#125;process daughter() &#123; semWait(apple); get the apple from the dish; semSignal(dish);&#125; 2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。 分析： 实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系 数据结构：semaphore s1, s2; s1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0； 12345678910111213141516process p1() &#123; while(true)&#123; semWait(s1); Pick a white chessman; semSignal(s2); &#125;&#125;process p2() &#123; while(true)&#123; semWait(s2); Pick a white chessman; semSignal(s1); &#125;&#125; 3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。 分析： 实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室 数据结构： strcut { char name[10]; int number; } a[100]; //表示进入阅览室的小朋友 semaphore mutex, seatcount; mutex: 用来控制互斥，初始值为1 seatcount： 对空座位进行计数，初始值为100； 初始化入室人员信息 for(int i = 0; i &lt; 100; i++){ a[i].number = i; a[i].name = null; } 12345678910111213141516171819202122 process readeri(char readername[]) &#123; semWait(seatcount); //等待空余作为，若人数未满100，则直接进入，到达100，则等待 semWait(mutex); //控制互斥 /* 进入是登记 */ for(int i = 0; i &lt; 100; i++) if(a[i].name == null)&#123; //找到名字为空的座位 a[i].name = readername; break; &#125; reader get the seat nember i; semSiganl(mutex); go into the reading room and sit down at the seat number i. /* 离开时登记 */ semWait(mutex); a[i].name = null; semSignal(mutex); semSignal(seatcount); leave reading room;&#125; 二、读/写者问题 描述： 有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件： 任意多的读进程可以同时读文件； 一次只有一个写进程可以写文件； 如果一个写进程正在写文件，那么禁止任何读进程读文件。 读者优先 分析： 当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。 数据结构： readcount: 控制wsem的的设置 wsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。 x: 用于确保readcount被正确更新。 123456789101112131415161718192021222324252627int readcount;semphore x = 1, wsem = 1;void reader() &#123; while (true) &#123; semWait(x); readcount++; if(readcount==1) semWait(wsem); //如果是第一个读者，则要控制wsem semSignal(x); READUNIT(); semWait(x); readcount--; if(readcount==0) semSignal(wsem); semSignal(x); &#125;&#125;void writer()&#123; while (true) &#123; semWait(wsem); WRITEUNIT(); semSignal(wsem); &#125;&#125; 实例： 独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法) 数据结构： mutex1/mutex2: 用于确保count1/count2被准备更新 count1/count2: 控制wait的设置 wait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。 123456789101112131415161718192021222324252627 semaphore wait=1, mutex1=1, mutex2=1; int count1=0, count2=0; process P east()&#123; semWait(mutex1); count1++; if(count1==1) semWait(wait); semSignal(mutex1); through the singal-log bridge； semWait(mutex1); count1--; if(count1==0) semSignal(wait); semSignal(mutex1); &#125;process P west()&#123; semWait(mutex2); count2++; if(count2==1) semWait(wait); semSignal(mutex2); through the singal-log bridge； semWait(mutex2); count2--; if(count2==0) semSignal(wait); semSignal(mutex2); &#125;]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git多账号配置，同时使用多个代码托管平台]]></title>
    <url>%2F2018%2F04%2F09%2Fgit%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。 ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。 1 生成密钥这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空 1ssh-keygen -T rsa -C "example@qq.com" 生成github的密钥 生成osc的密钥 查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc) 1ls -a /root/.ssh 2 接下来配置多账号在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容 123456789101112#github Host github.com HostName github.com IdentityFile ~/.ssh/id_rsa_github User pinnuli#osc Host gitee.com HostName gitee.com IdentityFile ~/.ssh/id_rsa_osc User pinnuli 3 把对应的公钥放到github和osc上面 4 测试是否成功1ssh -T git@github.com 1ssh -T git@gitee.com 至此，git多账号配置完毕，需要更多账号也是一样的道理]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 配置实现端口转发]]></title>
    <url>%2F2018%2F04%2F04%2Fnginx-%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[最近在部署一个小程序的后台，但是小程序调用的接口是不能带端口号的，那么如果服务器上面80端口已经被其他程序占用，就只能采用端口转发或者虚拟目录，我采用的是端口转发，或者说当在一台主机上需要部署多个web应用，并且需要能在80端口访问这些web时，就可以采用这种方法，也可以叫做nginx反向代理用于实现负载均衡，这里记录一下遇到的一些小问题。 加入服务器域名是test.com,那么你可以通过test.com/news在80端口访问新闻应用，但是服务器上分配的是其他端口，如8081。对应的nginx配置如下： 80端口的配置： 访问test.com/news =&gt; 127.0.0.1:8081 ,这里有一个需要注意的地方是转发的url最后需要加上’/‘，这相当指定了url’/‘,如果代理服务器地址中是带有URL的，此URL会替换掉 location 所匹配的URL部分, test.com/news/api,访问的是ip:8081/api;而如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器,test.com/news/api,访问的是ip:8081/news/api; 123456789101112131415161718server &#123; listen 80; # listen [::]:80 default_server; server_name test.com root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; location /news&#123; proxy_pass http:test.com:8081/; &#125; &#125; 8081端口的配置： 与平时配置没什么差别 1234567891011121314151617181920212223242526272829 server &#123; listen 8081; server_name localhost; root /var/www/project; location / &#123; index index.php index.html index.htm; if ( !-e $request_filename)&#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125; &#125; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; #root /usr/share/ngixn/html; #&#125; #我部署的是PHP项目，这里配置PHP解析 location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include /etc/nginx/fastcgi_params; include /etc/nginx/fastcgi.conf; &#125;&#125;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 多线程]]></title>
    <url>%2F2018%2F03%2F16%2Fjava-multithead-note%2F</url>
    <content type="text"><![CDATA[一、实现多线程 继承Thread 实现Runnable接口 因为java是单继承，当一个类已经继承了一个父类时要实现多线程就只能实现Runnable 推荐使用实现Runnable接口，好处： 适合多个相同程序代码的线程去处理统一资源 可以避免由于java的单继承带来的局限 代码能够被多个线程共享，代码与数据是独立的 线程休眠 sleep 线程中断 中断线程：interrupt() 检查线程是否中断：isInterrupted():实例方法，不会改变线程的中断状态interrupted():静态方法，会清除线程的中断状态 二、线程同步 三、线程间通信四、线程的正确停止五、线程属性 优先级 默认情况下，线程继承它的父线程的优先级 通过serPriority方法设置，范围为Thread.PRIORITY(1)-Thread.MAX_PRIORITY(10) 守护线程 当进程中只有后台线程运行时，进程就会结束 唯一用途是给其他线程提供服务，如计时器滴答信号 应该永远不去访问固有资源，如文件、数据库等，因为他随时可以能中断 未捕获异常处理器 线程执行完run方法即可正常退出，如果发生了没有捕获的异常则会异常退出。大多数情况下，由于异常导致的线程退出都不是我们想要的。因此需要尽可能地捕获可以处理的异常 可以用setUncaughtExceptionHandler为线程安装一个处理器，或者用Thread的静态方法setDefaultUncaughtException安装默认处理器 如果，没有安装默认处理器，也没有独立为线程安装处理器，则此时处理器为该线程的ThreadGroup对象 hah]]></content>
      <categories>
        <category>javase笔记</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsoup要点记录]]></title>
    <url>%2F2018%2F03%2F16%2Fjsoup%E8%A6%81%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[查找dom元素 getElementById: 根据id查询 getElementsByTag: 根据tag名称查询 getElementsByClass: 根据样式class名称查询 getElementsByAttribute: 根据属性名查询 getElementsByAttributeValue: 根据属性名和属性值查询 实例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo01 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //通过标签名称查询 Elements elements = doc.getElementsByTag("title"); Element element = elements.get(0); String title = element.text(); System.out.println("网页标题：" + title); //获取首个标题标签内容 Element titleElement = doc.getElementsByTag("title").first(); System.out.println("首个标题： " + titleElement.text()); //通过id查询 Element idElement = doc.getElementById("site_nav_top"); System.out.println("id查询：" + idElement.text()); //通过class样式获取查询 Elements itemElements = doc.getElementsByClass("post_item"); System.out.println("**********样式查询**********"); for(Element e: itemElements) &#123; System.out.println(e.text()); System.out.println("-------"); &#125; //属性名称查询 Elements attrElements = doc.getElementsByAttribute("width"); System.out.println("**********属性查询**********"); for(Element e: attrElements) &#123; System.out.println(e.toString()); &#125; //属性名称和属性值查询 Elements attrValueElements = doc.getElementsByAttributeValue("target", "_blank"); System.out.println("**********属性和属性值查询**********"); for(Element e: attrValueElements) &#123; System.out.println(e.toString()); &#125; &#125;&#125; 查找dom元素属性值 实例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo2 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //获取带有href属性的a标签 Elements attrElements = doc.select("a[href]"); System.out.println("**********获取属性值**********"); for(Element e: attrElements) &#123; System.out.println(e.toString()); System.out.println("-------"); &#125; //查找拓展名为gif的img标签 Elements imgElements = doc.select("img[src$=.gif]"); System.out.println("**********带有拓展名查询**********"); for(Element e: imgElements) &#123; System.out.println(e.toString()); &#125; &#125;&#125; 使用选择器查询 Jsoup 支持css，jquery的选择器 实例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;public class Demo03 &#123; public static void main(String[] args) throws Exception &#123; /*用heepclient发起请求获取页面*/ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet httpGet = new HttpGet("https://www.cnblogs.com/"); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity entity = response.getEntity(); String content = EntityUtils.toString(entity, "utf-8"); response.close(); Document doc = Jsoup.parse(content); //用jsoup解析 //通过选择器查询 Elements linkElements = doc.select(".headline ul .editor_pick a"); System.out.println("**********选择器查询**********"); for(Element e: linkElements) &#123; System.out.println(e.toString()); System.out.println("地址： " + e.attr("href")); System.out.println("-------"); &#125; Element linkElement = doc.select(".headline ul li").first(); System.out.println("文本： " + linkElement.text()); System.out.println("html: " + linkElement.html()); System.out.println("class属性值： " + linkElement.attr("class")); &#125;&#125;]]></content>
      <categories>
        <category>Jsoup笔记</category>
      </categories>
      <tags>
        <tag>java爬虫</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支管理常用命令]]></title>
    <url>%2F2018%2F03%2F11%2Fgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建分支： git branch branch_name 切换分支： git checkout branch_name 创建并切换分支 git checkout -b branch_name 创建远程分支到本地： git checkout -b branch_name origin/branch_name 查看当前分支： git branch 获取所有分支： git fetch 合并某分支到当前分支： git merge branch_name 禁用Fast forward（快速合并）， 普通模式合并： git merge --no-ff -m &quot;merge with no-ff&quot; branch_name (这里会在合并的时候自动生成一个新的commit) 删除分支： git branch -d branch_name 强制删除分支（用于为合并就删除时）： git branch -D branch_name 查看分支合并图： git log --graph 保存分支工作现场： git stash 查看保存列表： git stash list 恢复保存状态： git stash apply git stash apply stash@{x} 删除保存状态： git stash drop git stash drop stash@{x} 恢复并删除保存状态： git stash pop 推送分支到远程仓库： git push origin branch_name 建立本地分支与远程分支的关联： git branch --set-upstream branch-name origin/branch-name]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdownpad2 无法预览 显示This view has crashed!]]></title>
    <url>%2F2018%2F03%2F10%2Fmarkdownpad2-%E6%97%A0%E6%B3%95%E9%A2%84%E8%A7%88-%E6%98%BE%E7%A4%BAThis-view-has-crashed%2F</url>
    <content type="text"><![CDATA[在使用markdownpad2时，一直报错，说html渲染错误，上了官网查看解释如下，要安装 Awesomium 1.6.6 SDK，如果不行再安装DirectX最终用户运行时,不过一般只需要安装sdk就没问题了]]></content>
      <categories>
        <category>踩过的坑</category>
      </categories>
      <tags>
        <tag>markdownPad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018要学的知识]]></title>
    <url>%2F2018%2F03%2F08%2F2018%E8%A6%81%E5%AD%A6%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[java 《java核心技术》 《servlet、jsp、spring mvc初学指南》 《Spring技术内幕》 《轻量级javaEE》 《java编程思想》 《深入理解java虚拟机》 前端入门 bootstrap写页面 jquery 数据库 《高性能mysql》 linux 《Linux私房菜基础学习》 专业基础课 计算机组成原理 操作系统 计算机网络 数据库 编译原理]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
</search>
