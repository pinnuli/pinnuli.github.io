<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PINNULI&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinnuli.github.io/"/>
  <updated>2019-02-15T13:51:38.016Z</updated>
  <id>https://pinnuli.github.io/</id>
  
  <author>
    <name>pinnuli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式的几种写法对比</title>
    <link href="https://pinnuli.github.io/2019/02/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    <id>https://pinnuli.github.io/2019/02/15/单例模式的几种写法对比/</id>
    <published>2019-02-15T12:41:28.000Z</published>
    <updated>2019-02-15T13:51:38.016Z</updated>
    
    <content type="html"><![CDATA[<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><h4 id="1-最简单的懒汉模式"><a href="#1-最简单的懒汉模式" class="headerlink" title="1. 最简单的懒汉模式"></a>1. 最简单的懒汉模式</h4><p><strong>线程不安全，不推荐</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在多线程环境下，当多个线程执行到第9行代码时，此时instance都为空，那么这些线程都会执行第10行代码，从而创建了多个对象</p></blockquote><h4 id="2-在上面的基础上给getInstance方法加上synchronized"><a href="#2-在上面的基础上给getInstance方法加上synchronized" class="headerlink" title="2. 在上面的基础上给getInstance方法加上synchronized"></a>2. 在上面的基础上给getInstance方法加上synchronized</h4><p><strong>线程安全，不推荐</strong>，加上synchronized之后，方法内的所有实现在同一时间只允许一个线程访问，可以保证线程安全，但是synchronized会带来性上很大的开销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-双重同步锁单例模式"><a href="#3-双重同步锁单例模式" class="headerlink" title="3. 双重同步锁单例模式"></a>3. 双重同步锁单例模式</h4><p><strong>线程不安全，可以改进</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        </span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于<code>instance = new Singleton();</code> 这一行代码，实际上可以看出以下三步：<br>    1、memory = allocate() 分配对象的内存空间<br>    2、ctorInstance() 初始化对象<br>    3、instance = memory 设置instance指向刚分配的内存<br>   由于第二步和第三步不能由先行发生原则到处出来，JVM和cpu优化，发生了指令重排，顺序如下：<br>    1、memory = allocate() 分配对象的内存空间<br>    3、instance = memory 设置instance指向刚分配的内存<br>    2、ctorInstance() 初始化对象<br>   那么可能存在这样一种情况，在多线程情况下，当线程A执行到第10行代码<code>instance = new Singleton();</code>的第3步<code>instance = memory 设置instance指向刚分配的内存</code>时，线程B执行到第8行代码<code>if (instance == null)</code>， 这时对象还没有初始化完毕，然而instance已经指向了分配给对象的内存，instance已经不为空，会造成对象逸出，因而线程不安全；</p></blockquote><h4 id="4-volatile-双重检测机制，禁止指令重排"><a href="#4-volatile-双重检测机制，禁止指令重排" class="headerlink" title="4. volatile + 双重检测机制，禁止指令重排"></a>4. volatile + 双重检测机制，禁止指令重排</h4><p><strong>线程安全，推荐</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测机制        </span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="饿汉模式，单例实例在类装载时进行创建"><a href="#饿汉模式，单例实例在类装载时进行创建" class="headerlink" title="饿汉模式，单例实例在类装载时进行创建"></a>饿汉模式，单例实例在类装载时进行创建</h3><p>如果构造方法中没有很多的处理，那么饿汉模式是可以接收的，但是如果构造方法中有非常多的处理，会导致类加载的时候很慢，会导致一些性能的问题。 如果只进行类的加载，而没有进行实际的调用，就会造成资源的浪费，因此使用饿汉模式的时候应该考虑两个问题：</p><ol><li>构造方法有没有过多的处理</li><li>这个类是否一定会被使用，避免装载之后没有调用造成资源浪费</li></ol><h4 id="1-普通饿汉模式"><a href="#1-普通饿汉模式" class="headerlink" title="1. 普通饿汉模式"></a>1. 普通饿汉模式</h4><p><strong>线程安全，可以改进</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-将创建对象的代码放到static块中"><a href="#2-将创建对象的代码放到static块中" class="headerlink" title="2. 将创建对象的代码放到static块中"></a>2. 将创建对象的代码放到static块中</h4><p><strong>线程安全，推荐</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h3><p><strong>最安全，推荐</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;懒汉模式&quot;&gt;&lt;a href=&quot;#懒汉模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉模式&quot;&gt;&lt;/a&gt;懒汉模式&lt;/h3&gt;&lt;h4 id=&quot;1-最简单的懒汉模式&quot;&gt;&lt;a href=&quot;#1-最简单的懒汉模式&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="设计模式" scheme="https://pinnuli.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java并发" scheme="https://pinnuli.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
      <category term="设计模式" scheme="https://pinnuli.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>实现简单的jdk动态代理</title>
    <link href="https://pinnuli.github.io/2019/01/21/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://pinnuli.github.io/2019/01/21/实现简单的jdk动态代理/</id>
    <published>2019-01-21T13:01:06.000Z</published>
    <updated>2019-01-21T13:01:40.507Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之Java内存区域</title>
    <link href="https://pinnuli.github.io/2018/12/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://pinnuli.github.io/2018/12/07/深入理解Java虚拟机之Java内存区域/</id>
    <published>2018-12-07T13:17:36.000Z</published>
    <updated>2018-12-07T13:30:28.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行时数据内存"><a href="#运行时数据内存" class="headerlink" title="运行时数据内存"></a>运行时数据内存</h3><h4 id="线程私有的内存区域"><a href="#线程私有的内存区域" class="headerlink" title="线程私有的内存区域"></a>线程私有的内存区域</h4><blockquote><p>每条线程都有，各线程之间互不影响，独立存储的一类内存区域</p></blockquote><ul><li><strong>程序计数器</strong>: 可以看成是当前线程锁执行的字节码的行号指示器</li><li><strong>Java虚拟机栈</strong>: 生命周期与线程相同，描述的是Java方法执行的内存模型：每个方法子执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li><li><strong>本地方法栈</strong>: 为虚拟机使用到的Native方法服务（而虚拟机栈为Java方法服务）<h4 id="线程共享的内存区域"><a href="#线程共享的内存区域" class="headerlink" title="线程共享的内存区域"></a>线程共享的内存区域</h4></li><li><strong>Java堆</strong>: 在虚拟机启动时创建，用于存放对象实例，可以处于物理上不连续的内存空间，主要逻辑上连续即可</li><li><strong>方法区</strong>: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，可以选择笃定大小或者可拓展外，还可以选择不实现垃圾收集</li><li><strong>运行时常量池</strong>: 方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这部分内容在类加载后进入方法区的运行时常量池存放）</li></ul><h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li>虚拟机遇到一条new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用</li><li>为新生对象分配内存</li></ol><ul><li>两种分配内存的方法：<br>  i. <strong>指针碰撞</strong>: Java堆中内存绝对规整时<br>  ii. <strong>空闲列表</strong>: Java堆中内存不规整，已使用的内存和空闲的内存相互交错时</li><li>并发情况下解决线程安全的两种方法：<br>  i. 对分配内存空间的动作进行同步<br>  ii. 把内存分配动作按照线程划分在不同的空间之中进行</li></ul><ol><li>将分配到的内存空间都初始化为零值（对象头除外）</li><li>对对象进行必要的设置（对象头）<blockquote><p>从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，还需要第5步</p></blockquote></li><li>执行<code>&lt;init&gt;</code>方法</li></ol><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><blockquote><p>对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充</p></blockquote><ul><li><strong>对象头</strong>: 包括两部分：<br>  i. 用于存储对象自身的运行时数据，如HashCode、GC分代年龄…<br>  ii. 类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例（如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据）</li><li><strong>实例数据</strong>: 对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容</li><li><strong>对齐填充</strong>: 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍）</li></ul><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><blockquote><p>取决于虚拟机的实现，主流的访问方式有两种：</p></blockquote><ul><li><strong>使用句柄</strong>: Java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息<br><img src="/images/jvm_object_reference_handle.jpg" alt=""></li><li><strong>直接指针</strong>: reference中存储的直接就是对象地址<br><img src="/images/jvm_object_reference_pointer.jpg" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;运行时数据内存&quot;&gt;&lt;a href=&quot;#运行时数据内存&quot; class=&quot;headerlink&quot; title=&quot;运行时数据内存&quot;&gt;&lt;/a&gt;运行时数据内存&lt;/h3&gt;&lt;h4 id=&quot;线程私有的内存区域&quot;&gt;&lt;a href=&quot;#线程私有的内存区域&quot; class=&quot;header
      
    
    </summary>
    
      <category term="深入理解java虚拟机笔记" scheme="https://pinnuli.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://pinnuli.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之Class类文件结构</title>
    <link href="https://pinnuli.github.io/2018/12/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BClass%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://pinnuli.github.io/2018/12/07/深入理解Java虚拟机之Class类文件结构/</id>
    <published>2018-12-07T13:17:08.000Z</published>
    <updated>2018-12-07T13:26:18.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Class文件十一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上的空间的数据项时，按照 <strong>高位在前(最高位字节在地址最低位)</strong>的方式分割成若干个8为字节进行存储</p></blockquote><p>Class文件格式：<br><img src="/images/jvm_class_file_format.jpg" alt=""></p><h3 id="1-魔数与Class文件的版本"><a href="#1-魔数与Class文件的版本" class="headerlink" title="1. 魔数与Class文件的版本"></a>1. 魔数与Class文件的版本</h3><ul><li>每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件（很多文件存储标准都是用魔数来进行身份识别，譬如图片格式等）</li><li>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件</li></ul><h3 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h3><ul><li>紧接着主次版本号之后的是常量池入口，常量池可以 理解为Class文件之中的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值，这个计数值从1开始</li><li>常量池中主要存放两大类常量：字面量和符号引用：<ul><li>字面量：比较接近于Java语言层面的常量概念</li><li>符号引用：属于编译原理方面的概念，包括了下面三类常量：<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul></li><li>常量池中每一项常量都是一个表，每个表开始的第一位都是一个u1类型的标志位，代表 当前这个常量属于那种类型常量</li></ul><p>常量池的项目类型：<br><img src="/images/jvm_class_file_finaltype.jpg" alt=""></p><h3 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3. 访问标志"></a>3. 访问标志</h3><ul><li>2个字节，用于标识一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否为abstract类型等</li></ul><h3 id="4-类索引、父类索引与接口索引集合"><a href="#4-类索引、父类索引与接口索引集合" class="headerlink" title="4. 类索引、父类索引与接口索引集合"></a>4. 类索引、父类索引与接口索引集合</h3><ul><li>Class文件中由这三项数据来确定这个类的继承关系</li><li>类索引和父类索引引用两个u2类型的索引值表示，他们各自指向一个类型为CONSTANT_Class_info的类描述常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</li><li>接口索引集合，入口第一项–u2类型的数据为接口计数器，表示索引表的容量</li></ul><h3 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5. 字段表集合"></a>5. 字段表集合</h3><ul><li>用于描述接口或者类中声明的变量</li><li>字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</li></ul><h3 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6. 方法表集合"></a>6. 方法表集合</h3><ul><li>Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式</li></ul><h3 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7. 属性表集合"></a>7. 属性表集合</h3><ul><li>在Class文件，字段表、方法表都可以携带自己的属性表集合</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Class文件十一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上的空间的数据项时，按照 &lt;strong&gt;高位在前(最高位字节在地址最低位)&lt;/strong&gt;的方式分割成若干个8为
      
    
    </summary>
    
      <category term="深入理解java虚拟机笔记" scheme="https://pinnuli.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://pinnuli.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之虚拟机字节码执行引擎</title>
    <link href="https://pinnuli.github.io/2018/12/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>https://pinnuli.github.io/2018/12/02/深入理解Java虚拟机之虚拟机字节码执行引擎/</id>
    <published>2018-12-02T13:18:09.000Z</published>
    <updated>2018-12-07T13:27:21.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>  i. 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<br>  ii. 每一个栈帧都包括了 <strong>局部变量表，操作数栈，动态连接，方法返回地址</strong>和一些额外的附加信息<br>  iii. 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程<br>  iv. 在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法</p><p>栈帧的概念结构：<br>(/images/jvm_stackframe_structure.jpg)</p><h4 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h4><blockquote><p>一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量</p></blockquote><ul><li><strong>单位</strong>:局部变量表的容量以变量槽（Slot）为最小单位</li><li><strong>虚拟机定位</strong>：虚拟机通过索引定位的方式使用局部变量表，索引值从0开始到局部变量表最大的Slot数量</li><li><strong>64位数据的访问</strong>：对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用热任何方式单独访问其中的某一个</li><li><strong>局部变量表的空间分配</strong>：<br>  i. 如果执行的是实例方法，在那局部变量表最后还给你第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。<br>  ii. 其余参数按照参数表顺序排列，占用从1开始的局部变量Slot。<br>  ii. 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用于分配其余的Slot</li><li><strong>Slot重用</strong>：如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用，但是Slot的复用会直接影响到系统的垃圾收集行为<br>实例代码一：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实例代码二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>代码一的placeholder没有被回收，而代码二的被回收了</p></blockquote><h4 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2. 操作数栈"></a>2. 操作数栈</h4><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈写入和提取内容，也就是出栈/入栈操作</p><ul><li>在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的，但大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠<br>(/images/jvm_stackframe_operandstack.jpg)</li></ul><h4 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3. 动态链接"></a>3. 动态链接</h4><p>常量池中的符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化为静态解析；另外一部分在每一次运行期间转化为直接引用，这部分称为动态连接</p><h4 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4. 方法返回地址"></a>4. 方法返回地址</h4><p>一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器值；而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息</p><h4 id="5-附加信息"><a href="#5-附加信息" class="headerlink" title="5. 附加信息"></a>5. 附加信息</h4><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息</p><hr><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程</p><p>####1. 解析<br>调用目标在程序代码写好，编译器进行编译时就必须确定下来，这类方法的调用称为解析。</p><ul><li><strong>非虚方法和虚方法</strong>:可以在解析阶段中确定唯一调用版本的方法有4类：静态方法、私有方法、实例构造器、父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为 <strong>非虚方法</strong>，其他方法称为 <strong>虚方法</strong>（除了final方法）</li><li>解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及引用全部转变为可确定的直接引用</li></ul><h4 id="2-分派"><a href="#2-分派" class="headerlink" title="2. 分派"></a>2. 分派</h4><p>解析和分派两者之间的关系不是二选一的排他关系，他们是在不同层次上筛选、确定目标方法的过程。</p><h5 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h5><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的经典应用和是方法重载。</p><h5 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h5><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h5 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h5><p>方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p><blockquote><p>Java的静态分派属于多分派类型，动态分派属于单分派类型，所以Java是一门静态多分派、动态单分派的语言</p><h5 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h5><p>最常用的“稳定优化”手段是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找,虚方法中存放着各个方法的实际入口地址<br>!(/images/jvm_method_dispatch.jpg)<br>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把类的方法表也初始化完毕</p></blockquote><hr><h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><h4 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h4><p>Java编译器完成了程序代码经过了<strong>词法分析、语法分析到抽象语法树</strong>，再遍历语法树生成线性的字节码指令流的过程。 这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的变异就是 <strong>半独立</strong>的实现。<br><img src="/images/jvm_interpret.jpg" alt=""></p><h4 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h4><p>看一个例子的执行流程基本可以了解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>字节码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">   Stack=<span class="number">2</span>, Locals=<span class="number">4</span>, Args_size=<span class="number">1</span></span><br><span class="line">   <span class="number">0</span>:   bipush <span class="number">100</span></span><br><span class="line">   <span class="number">2</span>:   istore_1</span><br><span class="line">   <span class="number">3</span>:   sipush <span class="number">200</span></span><br><span class="line">   <span class="number">6</span>:   istore_2</span><br><span class="line">   <span class="number">7</span>:   sipush <span class="number">300</span></span><br><span class="line">   <span class="number">10</span>: istore_3</span><br><span class="line">   <span class="number">11</span>: iload_1</span><br><span class="line">   <span class="number">12</span>: iload_2</span><br><span class="line">   <span class="number">13</span>: iadd</span><br><span class="line">   <span class="number">14</span>: iload_3</span><br><span class="line">   <span class="number">15</span>: imul</span><br><span class="line">   <span class="number">16</span>: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/jvm_interpret_execute_1.jpg" alt=""><br><img src="/images/jvm_interpret_execute_2.jpg" alt=""><br><img src="/images/jvm_interpret_execute_3.jpg" alt=""><br><img src="/images/jvm_interpret_execute_4.jpg" alt=""><br><img src="/images/jvm_interpret_execute_5.jpg" alt=""><br><img src="/images/jvm_interpret_execute_6.jpg" alt=""><br><img src="/images/jvm_interpret_execute_7.jpg" alt=""></p><blockquote><p>上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;运行时栈帧结构&quot;&gt;&lt;a href=&quot;#运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;运行时栈帧结构&quot;&gt;&lt;/a&gt;运行时栈帧结构&lt;/h3&gt;&lt;p&gt;  i. 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的
      
    
    </summary>
    
      <category term="深入理解java虚拟机笔记" scheme="https://pinnuli.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://pinnuli.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之垃圾收集器与内存分配策略</title>
    <link href="https://pinnuli.github.io/2018/12/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://pinnuli.github.io/2018/12/01/深入理解Java虚拟机之垃圾收集器与内存分配策略/</id>
    <published>2018-12-01T13:17:54.000Z</published>
    <updated>2018-12-07T13:32:15.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象存活判断算法"><a href="#对象存活判断算法" class="headerlink" title="对象存活判断算法"></a>对象存活判断算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>给对象添加一个引用计数器，有一个地方引用它计数值就加1，引用失效时减1，任何时刻计数器为0则不可能再被使用</p><blockquote><p>实现简单，判定效率高，但很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用这种方式管理内存</p></blockquote><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过 的路径称为引用链，当一个对象到GC Roots没有任何引用链时，证明此对象是不可用的</p><blockquote><p>Java中扩展为GC Roots的对象包括以下几种 ：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></blockquote><h4 id="对象死亡的判定"><a href="#对象死亡的判定" class="headerlink" title="对象死亡的判定"></a>对象死亡的判定</h4><p>真正宣告一个对象死亡，至少要经理两次标记过程：</p><ol><li>在进行可达性分析后发现不可达，将会被第一次标记并且进行一次筛选</li></ol><blockquote><p>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，视为“没有必要执行<br>finalize”的情况，若有必要执行finalize，则将对象放入F-Queue的队列之中，并稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行。（一个对象的finalize()方法只会被系统调用一次）</p></blockquote><ol><li>GC对F-Queue中的对象进行第二次标记</li></ol><blockquote><p>对象逃脱的唯一机会就在finalize()方法中，只要重新与引用链上的任何一个对象建立关联即可</p></blockquote><h4 id="回收方法区（即HotSpot中的永久代）"><a href="#回收方法区（即HotSpot中的永久代）" class="headerlink" title="回收方法区（即HotSpot中的永久代）"></a>回收方法区（即HotSpot中的永久代）</h4><blockquote><p>永久代的垃圾主要回收两部分的内容：废弃常量和无用的类。</p></blockquote><p>“无用的类”需要满足的三个条件：</p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.class.Class对象没有在任何地方被引用</li></ol><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li><strong>标记阶段</strong>: 标记所有需要回收的对象</li><li><strong>清除阶段</strong>: 统一回收所有被标记的对象<br><img src="/images/jvm_gc_markclean.jpg" alt=""><br>两个不足：</li><li><strong>效率问题</strong>，标记和清除的效率都不高</li><li><strong>空间问题</strong>，标记清除之后产生大量不连续的碎片</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><blockquote><p>将可用内存按<strong>容量</strong>划分为大小相等的凉快，每次之使用给一块。当这一块的内存用完时，就将还存活的对象复制到另外一块上，然后把已使用过的内存空间一次清理掉。</p></blockquote><ul><li>现在商业虚拟机用这种算法回收新生代，将内存分为一块 较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将这两块上还存活的对象一次性复制到Survivor上，最后清理掉Eden和Survivor（在HotSpot默认Eden和Survivor的大小比例为8:1）</li><li>当Survivor内存不够用时，需要依赖其他内存（这里指老年代）进行分配担保<br><img src="/images/jvm_gc_duplicate.jpg" alt=""></li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><blockquote><p>和“标记-清除算法”一样，但后续步骤是不是直接对可回收对象进行清理，而是 <strong>让所有存活的对象都向一端移动</strong></p></blockquote><p><img src="/images/jvm_gc_markarrange.jpg" alt=""></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><blockquote><p>把Java堆分为 <strong>新生代</strong>和 <strong>老年代</strong>，这样可以根据各个年代的特点采用最适当的收集算法</p></blockquote><ul><li>新生代每次垃圾收集都发现大批对象死去，只有少量存活，选用复制算法</li><li>老年代对象存活率高、没有额外空间对它进行分配担保，使用“标记清理”或者“标记整理”算法</li></ul><hr><h3 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>在HotSpot中，使用OopMap来直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些未知是应用</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><ul><li><p>HotSpot没有为每条指令都生成OopMap，只是在安全点（Safepoint）记录了这些信息</p><blockquote><p>即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</p></blockquote></li><li><p>当GC发生时让所有线程都跑到最近的安全点上停顿下来的两种方案：</p></li></ul><ol><li>抢先式中断</li><li>主动式中断： 当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志</li></ol><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>指正在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。</p><blockquote><p>当线程执行到安全区域中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM发起GC时，就不用管标识自己为Safe Region的线程了</p></blockquote><hr><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="1-对象有限在Eden分配"><a href="#1-对象有限在Eden分配" class="headerlink" title="1. 对象有限在Eden分配"></a>1. 对象有限在Eden分配</h4><ul><li>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</li><li>Minor GC期间虚拟机若发现已有的对象无法放入Survivor空间，就通过分配担保机制提前转移到老年代去</li><li>新生代GC（Minor GC）与老年代GC（Major GC/Full GC）：<br>  i. 新生代GC：Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快<br>  ii. 老年代GC：出现了Major GC经常会伴随着至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上</li></ul><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><ul><li>大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组</li><li>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，目的是避免在Eden区及两个Survivor区之间发送大量的内存复制</li></ul><h4 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h4><ul><li>虚拟机给每个对象定义了一个对象年龄计数器</li><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，对象年龄设为1</li><li><p>对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（可以用过参数-XX：MaxTenuringThreshold设置，默认为15），就将会被晋升到老年代中</p><h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4></li><li><p>虚拟机并不是永远地要求 对象的年龄必须达到了XX：MaxTenuringThreshold才能晋升老年代</p></li><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代</li></ul><h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><ul><li>发送Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可以确保是安全的</li><li>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败：<ul><li>如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小：<ul><li>如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；</li><li>如果小于，那么这时要改为进行一次Full GC</li></ul></li><li>如果不允许，那么也要改为进行一次Full GC</li></ul></li></ul><blockquote><p>JDK6 Update24之后规则变为只要老年代最大可用的连续空间大于新生代总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。（HandlePromotionFailure仍存在但不起影响）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象存活判断算法&quot;&gt;&lt;a href=&quot;#对象存活判断算法&quot; class=&quot;headerlink&quot; title=&quot;对象存活判断算法&quot;&gt;&lt;/a&gt;对象存活判断算法&lt;/h3&gt;&lt;h4 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="深入理解java虚拟机笔记" scheme="https://pinnuli.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://pinnuli.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之虚拟机类加载机制</title>
    <link href="https://pinnuli.github.io/2018/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://pinnuli.github.io/2018/11/30/深入理解Java虚拟机之虚拟机类加载机制/</id>
    <published>2018-11-30T13:18:22.000Z</published>
    <updated>2018-12-07T13:37:42.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><ul><li>类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载，其中验证、准备、解析3个部分统称为 <strong>连接</strong></li><li>加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，但是解析阶段则不一定，有些情况下可在初始化阶段之后再开始（为了支持Java语言的运行时绑定）</li><li>虚拟机规范严格规定了 <strong>有且只有</strong>5种情况必须立即对类进行“初始化”：<ul><li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时</li><li>使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化</li><li>当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li><li>使用JDK1,7的动态语言支持时，java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄</li></ul></li></ul><blockquote><p>这5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用</p></blockquote><h2 id="当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化"><a href="#当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化" class="headerlink" title="- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化"></a>- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>在加载阶段，虚拟机需要完成以下3件事：</p><pre><code>- 通过一个类的全限定名来获取定义此类的二进制字节流- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</code></pre><ul><li>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中</li><li>对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面</li></ul><h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>验证阶段大致上会完成下面4个阶段的校验动作：<strong>文件格式验证、元数据验证、字节码验证、符号引用验证</strong>:</p><ul><li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，保证输入的字节流能正确地解析并存储于方法区，格式上符合描述一个Java类型信息的要求</li><li><strong>元数据验证</strong>:对类的元数据信息语义校验，保证不存在不符合Java语言规范的元数据信息</li><li><strong>字节码验证</strong>:通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li><li><strong>符合引用验证</strong>:可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行，发生在虚拟机将符号引用转化为直接引用时<blockquote><p>如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p></blockquote></li><li>验证的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li></ul><h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>准备阶段是 <strong>正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值）</strong> 的阶段，这些变量所使用的内存都将在方法区中进行分配</p><ul><li>这里进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中</li><li>如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值</li></ul><h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h4><p>解析阶段是 <strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong> </p><ul><li><p><strong>符号引用与直接引用</strong>：</p><ul><li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li></ul></li><li><p><strong>解析发生的时间</strong>：虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它</p></li><li>除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行</li><li><strong>解析动作</strong>：<ul><li>类和接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ul></li></ul><h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h4><p>在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，可以从另外一个角度来表达：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</p><ul><li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;  <span class="comment">//  给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕</p></li><li>父类的<code>&lt;clinit&gt;()</code>方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作</li><li><code>&lt;clinit&gt;()</code>方法对于类和接口不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li><li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口菜单<code>&lt;clinit&gt;()</code>方法，只要当父接口中定义的变量使用时，父接口才会初始化</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步</li></ul><hr><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><blockquote><p>即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p></blockquote><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：<br>i. 启动类加载器，是虚拟机的一部分;<br>ii. 另一种是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader</p><ul><li><strong>启动类加载器</strong>：负责将存放在<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，开发者无法直接引用</java_home></li><li><strong>扩展类加载器</strong>：负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用</java_home></li><li><strong>应用程序类加载器</strong>：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，开发者可以直接使用</li><li><strong>双亲委派模型的工作过程</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载<blockquote><p>这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码</p></blockquote></li></ul><p><img src="/images/jvm_classloader_doubleparent.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类加载的时机&quot;&gt;&lt;a href=&quot;#类加载的时机&quot; class=&quot;headerlink&quot; title=&quot;类加载的时机&quot;&gt;&lt;/a&gt;类加载的时机&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化
      
    
    </summary>
    
      <category term="深入理解java虚拟机笔记" scheme="https://pinnuli.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://pinnuli.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>五层体系结构之运输层</title>
    <link href="https://pinnuli.github.io/2018/11/18/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://pinnuli.github.io/2018/11/18/五层体系结构之运输层/</id>
    <published>2018-11-18T06:09:37.000Z</published>
    <updated>2018-12-12T03:07:12.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h3><h4 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h4><ol><li>运输层的重要功能：复用和分用</li></ol><ul><li><strong>复用</strong>: 应用层所有的应用进程都可以通过运输层再传送到IP层</li><li><strong>分用</strong>: 运输层从IP层收到数据后必须交付给指明的应用进程</li></ul><ol><li>网络层与运输层的区别</li></ol><ul><li><strong>网络层</strong>: 为主机之间提供逻辑通信</li><li><strong>运输层</strong>: 为应用进程之间提供端到端的逻辑通信</li></ul><h4 id="运输层的端口（软件端口）"><a href="#运输层的端口（软件端口）" class="headerlink" title="运输层的端口（软件端口）"></a>运输层的端口（软件端口）</h4><blockquote><p>给应用层的每个应用进程赋予一个明确的标志</p></blockquote><ol><li>服务器端使用的端口号</li></ol><ul><li><strong>熟知端口号（系统端口号）</strong>：0~1023,指派给了TCP/IP最重要的一些应用程序</li><li><strong>登记端口号</strong>: 1024~49151</li></ul><ol><li>客户端使用的端口号</li></ol><ul><li>又叫 <strong>短暂端口号</strong> ,49152~65535，仅在客户进程运行时动态选择</li></ul><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><blockquote><p>在IP的数据服务上加了复用和分用，差错检测的功能</p></blockquote><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul><li><strong>UDP是无连接的</strong>: 发送数据之前不需要建立连接</li><li><strong>UDP使用尽最大努力交付</strong></li><li><strong>UDP是面向报文的</strong>: 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</li><li><strong>UDP没有拥塞控制</strong>: 因此网络出现的拥塞不会使源主机的发送速率降低 </li><li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong></li><li><strong>UDP的首部开销小</strong>:只要8个字节</li></ul><h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><blockquote><p>四个字段，每个字段两个字节</p></blockquote><ul><li>源端口</li><li>目的端口</li><li>长度</li><li>检验和<br><img src="/images/udp_header.png" alt="UDP header"></li></ul><hr><h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>主要特点</li></ol><ul><li><strong>TCP是面向连接的运输层协议</strong>: 使用之前，必须建立连接；数据传输完毕之后，必须释放已经建立的连接</li><li><strong>每一条TCP连接只能有两个端点</strong>: 点对点（一对一）</li><li><strong>TCP提供可靠交付的服务</strong>: 无差错、不丢失、不重复，按序到达</li><li><strong>TCP提供全双工通信</strong>: 允许通信双方的应用进程在任何时候都能发送数据。发送时，应用程序在把数据传送给TCP的缓存之后就可以做自己的事，然后TCP在合适的时候把数据发送出去；接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</li><li><strong>面向字节流</strong>: 应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流<br><img src="/images/tcp_stream.png" alt="读取流程"></li></ul><ol><li>TCP的连接</li></ol><ul><li>TCP连接的端点叫做套接字或插口</li><li>端口号拼接到IP地址构成了套接字</li><li>每一条TCP连接唯一地被通信两端的两个端点所确定</li><li>同一个IP地址可以有多个不同的TCP链接，而同一个端口号也可以出现在多个不同的TCP连接</li></ul><h4 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h4><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><blockquote><p>”停止等待“就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组</p></blockquote><ol><li><p>无差错情况<br><img src="/images/tcp_no_error.jpg" alt="tcp_no_error"></p></li><li><p>出现差错(超时重传)</p><blockquote><p>发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组</p></blockquote></li></ol><p><img src="/images/tcp_timeout_resend.jpg" alt="tcp_timeout_resend"><br>三点注意：</p><ul><li>发送方发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传时使用）,收到确认后才可以清除副本。</li><li>分组和确认分组都必须编号（才能明确是哪一个发送出去的分组收到了确认）</li><li>重传时间应当比数据在分组传输的平均往返时间更长一些</li></ul><ol><li>确认丢失和确认迟到</li></ol><ul><li><strong>确认丢失</strong>: 接收方发送的对分组的确认丢失了<br>  当接收方又收到重传的分组时（发送方没有收到确认信息会重传），采取两个行动：<br>  i. 丢弃这个重复的分组<br>  ii. 向发送方发送确认<br><img src="/images/tcp_confirm_lose.jpg" alt="tcp_confirm_lose"></li><li><strong>确认迟到</strong>: 传输过程没有差错，但接收方对分组的确认迟到了<br>  i. 发送方会收到重复的确认，收下后丢弃；<br>  ii. 接收方会收到重复的分组， 同样丢弃，并重传确认分组</li></ul><ol><li>信道利用率<br>信道利用率计算：<br><img src="/images/tcp_channel_utilization.jpg" alt="tcp_channel_utilization"></li></ol><blockquote><p>当往返时间RTT远大于分组发送时间Td时，信道的利用率会非常低，因而需要采用流水线传输</p></blockquote><h5 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h5><ul><li>发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方的确认</li><li>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置</li><li>接收方一般采用累积确认的方式，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后对按序到达的最后一个分组发送确认，这表示：到这个分组为止的素有分组都已正确收到了</li><li>优点： 容易实现，确认丢失也不必重传</li><li>缺点： 不能正确反映出接收方已经正确收到的所有分组的信息，比如5个中的第3个丢了，就只能对前两个分组发出确认，后面三个重传</li></ul><h4 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h4><blockquote><p>TCP的全部功能都体现在它首部中各字段的作用</p></blockquote><p><img src="/images/tcp_header.jpg" alt="tcp_header"></p><ul><li><strong>源端口和目的端口</strong>: </li><li><strong>序号</strong>: 范围[0, 2^32 - 1],序号增加到2^32 - 1后，下一个序号又回到0。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li><li><strong>确认号</strong>: 期望收到对方下一个报文段的第一个数据字节的序号，若确认号=N,则表明：到序号N-1为止的所有数据都已正确收到</li><li><strong>数据偏移</strong>: 单位是4个字节，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出TCP报文段的首部长度</li><li><strong>保留</strong>: 保留为今后用，目前应置为0</li><li><strong>紧急URG</strong>: 当URG=1时，表示文段中有紧急数据，发送应用进程告诉发送方的TCP有紧急数据要传送，发送方TCP就把紧急数据插入到被报文段的最前面，要与紧急指针字段配合使用</li><li><strong>确认ACK</strong>: 在TCP连接建立后所有传送的报文都必须把ACK置1</li><li><strong>推送PSH</strong>: 发送方TCP把PSH置为1时，立即创建一个报文段发送出去，接收方尽快地交付接收应用进程，不用等到缓存填满</li><li><strong>复位RST</strong>: 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li><li><strong>同步SYN</strong>: 在连接建立事用来同步序号</li><li><strong>终止FIN</strong>: 用来释放一个连接</li><li><strong>窗口</strong>: 指的是发送本报文段的一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量</li><li><strong>校验和</strong>: 计算方法和UDP一样</li><li><strong>紧急指针</strong>: 当URG=1时才有意义，指出本报文段中的紧急数据的字节数</li><li><strong>选项</strong>: 长度可变，最长达40字节</li></ul><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><p>1.以字节为单位的滑动窗口</p><ul><li>TCP的滑动窗口以字节为单位</li><li>发送窗口里面的序号表示允许发送出去的序号</li><li>如图，假定A收到B发来的确认报文段，其中窗口是20，确认窗口是31，表明B期望收到的下一个序号是31,30为止的数据已经收到了<br><img src="/images/tcp_window_send.jpg" alt=""></li><li>凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传</li><li>描述一个发送窗口的状态需要三个指针，如图：<br><img src="/images/tcp_window_state.jpg" alt=""></li><li>发送缓存用来暂时存放：<br>  i. 发送应用程序传送给发送方TCP准备发送的数据；<br>  ii. TCP已发送出但尚未收到确认的数据；<br><img src="/images/tcp_send_cahce.jpg" alt="">tcp_recieve_cahce</li><li><p>接收缓存用来暂时存放：<br>  i. 按序到达的、但尚未被接收应用程序读取的数据；<br>  ii. 未按序到达的数据；<br><img src="/images/tcp_recieve_cahce.jpg" alt=""></p></li><li><p>三点强调：<br>  i. 发送窗口并不总是和接收窗口一样大<br>  ii. 对于不按序到达的数据，先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程<br>  iii. TCP要求接收方必须有累积确认的功能 </p></li></ul><p>2.超时重传时间的选择<br>RTTs（加权平均往返时间）计算：<br><img src="/images/tcp_rtts_calculate.jpg" alt=""><br>RTTd（RTT的偏差的加权平均值）计算：<br><img src="/images/tcp_rttd_calculate.jpg" alt=""><br>RTO（超时重传时间）：<br><img src="/images/tcp_rto_calculate.jpg" alt=""></p><p>3.选择确认SACK</p><blockquote><p>用来解决只传送缺少的数据而不重传已经正确到达接收方的数据</p></blockquote><h4 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h4><blockquote><p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。</p></blockquote><ol><li>利用滑动窗口实现流量控制<blockquote><p>发送方的发送窗口不能超过接收方给出的接收窗口的数值</p></blockquote></li></ol><p><img src="/images/tcp_window_flow_control.jpg" alt=""></p><ol><li>传输效率<br>三种控制TCP报文段发送时机的机制:</li></ol><ul><li>维持一个变量，等于最大报文段长度MSS</li><li>发送方的应有进程指明要求发送报文段，即推送(push)操作</li><li>发送方的计时器期限</li></ul><h4 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h4><ol><li>拥塞控制的一般原理<br>两种方法：</li></ol><ul><li>开环控制：在设计网络时事先将有关发送拥塞的因素考虑周到，力求网络在工作时不发生拥塞，但系统运行起来中途不能改正</li><li>闭环控制：三种措施：<br>  i. 检测网络系统以便检测到拥塞何时、何处发生；<br>  ii. 把拥塞发送的信息传送到可采取行动的地方；<br>  iii. 调整网络系统的运行以解决问题；</li></ul><ol><li>四种拥塞控制方法<br><strong>慢开始和拥塞避免</strong>：发送方维持一个叫做拥塞窗口cwnd的状态变量，发送方让自己的发送窗口等于拥塞窗口；</li></ol><ul><li>慢开始：由小到大逐渐增大拥塞窗口数值（为了防止拥塞窗口cwnd增长过大引起网络拥塞，需要设置一个慢开始门限状态变量ssthresh）<br><img src="/images/tcp_slow_start.jpg" alt=""></li><li>拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间就把发送方的拥塞窗口加1（拥塞避免并非完全能够避免了拥塞）<br>慢开始和拥塞避免算法实现举例：<br><img src="/images/tcp_congestion_avoid.jpg" alt=""><br><strong>快重传和快恢复</strong>: </li><li>快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未搜到的报文段，而不必继续等待重传计时器到期<br><img src="/images/tcp_quick_resend.jpg" alt=""></li><li>快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”，把慢开始门限ssthresh减半（而不是直接设置cwnd为1），然后开始拥塞避免算法<br>快重传和快恢复算法实现举例：<br><img src="/images/tcp_quick_recovery.jpg" alt=""></li></ul><ol><li>随机早期检测RED</li></ol><ul><li>随机早期检测： 在检测到网络拥塞的早期征兆时，就以概率p随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，少量的分组被丢弃，避免发生全局性的拥塞控制</li><li>需要选择好三个参数：最小门限THmin，最大门限THmax和概率p</li><li>丢弃概率p与两个门限值的关系图：<br><img src="/images/tcp_red.jpg" alt=""></li></ul><h4 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h4><blockquote><p>运输连接有三个阶段：连接建立，数据传送，连接释放</p></blockquote><ol><li>TCP的连接建立：三次握手<br><img src="/images/tcp_build_connect.jpg" alt=""></li></ol><ul><li><p><strong>第一次握手</strong>：客户进程A创建传输控制模块TCB，向服务进程发出连接请求报文段，等待B确认，这时A进入SYN-SENT（同步已发送）状态</p><blockquote><p>报文段首部中SYN=1，同时选择一个初始序号seq=x，不携带任何数据，但要消耗一个序号</p></blockquote></li><li><p><strong>第二次握手</strong>：服务进程B收到请求报文段后，如同意建立连接，则向A发送确认，这时TCP服务进程进入SYN-RCVD（同步已发送）状态</p><blockquote><p>将SYN和ACK都置1，确认号是ack=x+1，同时也为自己选一个初始序列号seq=y</p></blockquote></li><li><p><strong>第三次握手</strong>：A收到B的确认后，要向B给出确认，这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态，当B收到A的确认后，也进入ESTABLISHED状态</p><blockquote><p>A发送的确认报文段ACK置1，确认号ack=y+1，自己的序号seq=x+1，ACK报文段可以携带数据，但不携带数据则不消耗序号。<strong>A发送一次确认是为了防止已失效的连接请求报文段突然又传到了B</strong></p></blockquote></li></ul><ol><li>TCP的连接释放:四次挥手<br><img src="/images/tcp_release_connect.jpg" alt=""></li></ol><ul><li><p><strong>第一次挥手</strong>：A向B发送释放连接报文段，A进入FIN-WAIT-1在（终止等待1）状态</p><blockquote><p>报文段首部中终止控制位FIN置1，其序号是seq=u，等于前面已传送过的数据的最后一个字节的序号加1，即使不携带任何数据，但要消耗一个序号</p></blockquote></li><li><p><strong>第二次挥手</strong>：B收到连接释放报文段后发出确认，B进入CLOSE-WAIT（关闭等待）状态，这时TCP连接处于半关闭状态，即A已经没有数据发送给B，但B若发送数据，A仍要接收。A收到确认之后，进入FIN-WAIT-2（终止等待2）状态</p><blockquote><p>确认号是ack=u+1，这个报文号自身的序号是v,等于前面已传送过的数据的最后一个字节的序号加1</p></blockquote></li><li><p><strong>第三次挥手</strong>：若B已经没有要想向A发送的数据，就通知TCP释放连接，B进入LAST-ACK（最后确认状态），等待A的确认</p><blockquote><p>B发出的报文段令FIN=1，而且必须重复上次已发送过的确认号ack=u+1</p></blockquote></li><li><p><strong>第四次挥手</strong>：A收到B的连接释放报文段后，必须对此发出确认。然后A进入TIME-WAIT（时间等待）状态</p><blockquote><p>A发送的确认报文段ACK置1，确认号ack=w+1，自身的序号是seq=u+1。<strong>注意这时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。</strong></p></blockquote></li></ul><ol><li>TCP的有限状态机<blockquote><p>粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，细线箭头表示异常变迁</p></blockquote></li></ol><p><img src="/images/tcp_limited_state_machine.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;运输层协议概述&quot;&gt;&lt;a href=&quot;#运输层协议概述&quot; class=&quot;headerlink&quot; title=&quot;运输层协议概述&quot;&gt;&lt;/a&gt;运输层协议概述&lt;/h3&gt;&lt;h4 id=&quot;进程之间的通信&quot;&gt;&lt;a href=&quot;#进程之间的通信&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="计算机网络笔记" scheme="https://pinnuli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="https://pinnuli.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="https://pinnuli.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Java并发</title>
    <link href="https://pinnuli.github.io/2018/11/15/Java%E5%B9%B6%E5%8F%91/"/>
    <id>https://pinnuli.github.io/2018/11/15/Java并发/</id>
    <published>2018-11-15T08:01:42.000Z</published>
    <updated>2018-11-22T11:23:16.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h3><h4 id="定义一个线程"><a href="#定义一个线程" class="headerlink" title="定义一个线程"></a>定义一个线程</h4><ul><li>实现Runnable接口，重写run()方法，并传递给Thread构造器</li><li>继承Thread类，重写run()方法</li></ul><blockquote><p>调用Thread.start()方法时，其实是创建一个线程，并初始化之后，再去调run()方法</p></blockquote><h4 id="使用Executor"><a href="#使用Executor" class="headerlink" title="使用Executor"></a>使用Executor</h4><blockquote><p>Executor从来管理Thread对象，在客户端和任务之间提供了一个间接层，可以管理一部任务的执行，无须显式地管理线程的生命周期。ExecutorService（具有服务生命周期的Executor）知道如何构建恰当的上下文来执行Runnable对象</p></blockquote><p>有集中不同的Executor：</p><ul><li><strong>CacheThreadPool</strong>：通常创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程（首先的Executor）</li><li><strong>FixedThreadPool</strong>：使用有限的线程集来执行所提交的任务，可以一次性预先执行代价高昂的线程分配</li><li><strong>SingleThreadPool</strong>：像是线程数量为1的FixedThreadPool，当希望在另一个线程中连续运行某事物来说很有用。当提交多个任务时，这些任务会排队。<br>示例（三种Executor都这样使用）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从任务中产生返回值"><a href="#从任务中产生返回值" class="headerlink" title="从任务中产生返回值"></a>从任务中产生返回值</h4><blockquote><p>实现Callable接口，从call（）方法中返回值，必须使用ExecutorService.submit()方法调用。submit()方法会产生Future对象。可以用isDone()方法来查询Future是否完成，完成时可以调用get()方法获取该结果，若完成就调用get()方法将阻塞到完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result of TaskWithResult "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;String&gt; fs: results) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                System.out.printLn(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exce.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="休眠-sleep"><a href="#休眠-sleep" class="headerlink" title="休眠(sleep)"></a>休眠(sleep)</h4><blockquote><p>sleep(),使任务中止执行给定的时间，但不会释放持有的锁</p></blockquote><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><blockquote><p>Java有十个优先级，但不同的操作系统有不同的优先级，不能与操作系统有很好的映射。在调整优先级时只是用MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY三个等级</p></blockquote><h4 id="让步-yield"><a href="#让步-yield" class="headerlink" title="让步(yield)"></a>让步(yield)</h4><blockquote><p>暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p></blockquote><h4 id="加入一个线-join"><a href="#加入一个线-join" class="headerlink" title="加入一个线(join)"></a>加入一个线(join)</h4><blockquote><p>某个线程在另一个线程t上个调用join()，此线程被挂起，知道目标线程t结束(即.isAlive()为假)才恢复，也可调用join()时带一个超时参数，超时便返回</p></blockquote><h4 id="后台线程-维护线程"><a href="#后台线程-维护线程" class="headerlink" title="后台线程(维护线程)"></a>后台线程(维护线程)</h4><ul><li>可以在线程启动之前调用setDaemon()方法设置为后台线程</li><li>一个后台进程创建的任何线程被自动地设置为后台线程</li><li>后台线程在不执行finally子句时就终止器run()方法 </li></ul><h4 id="编码变体"><a href="#编码变体" class="headerlink" title="编码变体"></a>编码变体</h4><blockquote><p>有时候可以使用内部类将代码隐藏在类中</p></blockquote><ul><li>继承Thread的两种写法：<br>1.扩展自Thread的匿名内部类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Inner inner;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Inner(String name) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">      start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InnerThread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    inner = <span class="keyword">new</span> Inner(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在构造器中穿件一个匿名的Thread子类，并且向上转型为Thread引用t</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread2</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> Thread t;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InnerThread2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    t = <span class="keyword">new</span> Thread(name) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现Runnable的两种写法（同上两种情况）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    Inner(String name) &#123;</span><br><span class="line">      t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    inner = <span class="keyword">new</span> Inner(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Thread t;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;, name);</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在方法内部创建线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Thread t;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadMethod</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      t = <span class="keyword">new</span> Thread(name) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          ......</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><blockquote><p>线程的本质特征使得我们態捕获从线程中逃逸的异常，而是直接向外传播到控制台，就算用try-catch语句也没有作用。因而要捕获异常，需要修改Executor产生线程的方式，为每个新创建的Thread附着一个Thread.UnCaughtExceptionHandler()，Thread.UnCaughtExceptionHandler.uncaughtException()会在线程因在线程因未捕获异常而临近死亡时被调用</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    System.out.println(<span class="string">"run() by "</span> + t);</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">"eh = "</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个uncaughtExceptionHandler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"caught "</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span> + <span class="string">" creating new Thread"</span>);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    System.out.println(<span class="string">"created "</span> + t);</span><br><span class="line">    <span class="comment">//设置uncaughtExceptionHandler</span></span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">      <span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">"eh = "</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureUncaughtException</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newCachedThreadPool(</span><br><span class="line">      <span class="keyword">new</span> HandlerThreadFactory());</span><br><span class="line">    exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码将输出：<br>  HandlerThreadFactory@de6ced creating new Thread<br>  created Thread[Thread-0,5,main]<br>  eh = MyUncaughtExceptionHandler@1fb8ee3<br>  run() by Thread[Thread-0,5,main]<br>  eh = MyUncaughtExceptionHandler@1fb8ee3<br>  caught java.lang.RuntimeException</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><blockquote><p>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。</p></blockquote><ul><li><strong>无状态对象</strong>: 无状态对象一定是线程安全的</li><li><strong>竞态条件</strong>： 由于不恰当的执行时序而出现不正确的结果的情况，大多数竞态条件的本质是———基于一种可能失效的观察结果做出判断或执行某个计算，比如“先检查后执行”操作</li><li><strong>复合操作</strong>： 包含了一组必须以原子方式执行的操作以确保线程安全性</li><li><strong>内置锁</strong>：每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁<br>i.同步代码块分为两部分：一个作为锁的对象的引用，一个作为这个锁保护的代码块<br>ii. 对象锁：用来控制实例方法之间的同步，包括用synchronized修饰的方法和代码块均是对象锁<br>iii. 类锁： 即以Class对象作为锁，用来控制静态方法之间的同步，包括静态的synchronized方法</li><li><strong>重入</strong>： 某个线程试图获得一个已经由它自己持有的锁，那么这个请求会成功</li></ul><hr><h3 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h3><h4 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h4><p>1.使用synchronized关键字<br>2.使用显式的Lock对象<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      Thread.yield(); </span><br><span class="line">      ++currentEvenValue;</span><br><span class="line">      <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EvenChecker.test(<span class="keyword">new</span> MutexEvenGenerator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对lock()的调用必须放置在finally语句中带有unlock()的try-finally语句中</li><li>return语句必须出现在try子句中，以确保unlock()不会过早发生</li><li>这里finally子句也可以同时放置其他处理，以维护系统在正确的状态，避免抛出异常</li><li><code>lock.trylock()</code>,ReentrantLock允许你尝试着获取但最终未获取锁，如果其他线程已经获取了这个锁，那可以离开去执行其他的任务</li></ul><h4 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h4><blockquote><p>一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储</p></blockquote><hr><h3 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h3><h4 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait(),notify(),notifyAll()"></a>wait(),notify(),notifyAll()</h4><blockquote><p>wait()使你将当前任务挂起，可以等待某个条件发生，而改变这个条件超出了当前方法的控制能力，通常这种条件由另一个任务来改变</p></blockquote><ul><li>调用wait()时，对象上的锁被释放，该对象上的其他synchronized方法可以在wait()期间被调用；</li><li>只有在notify()或notifyAll()发生时，调用wait()的任务才会被唤醒；</li><li>wait()，notify()，notifyAll()是Object()的一部分，所以可以把wait()放在任何同步控制方法中，不需要考虑是否继承Thread或实现Runnable;</li><li>只能在同步控制方法或同步控制块里调用wait()，notify()，notifyAll()；</li><li>为了使任务从wait()中唤醒，必须首先重新获得当它进入wait()时释放的锁；</li><li><p>有两种形式的wait()：<br>i. 接受毫秒数作为参数，可以通过notify()，notifyAll()，或者时间到期后恢复<br>ii. 不接受任何参数，通过notify()，notifyAll()恢复</p></li><li><p>使用notify()，众多等待同一个锁的任务中只有一个会被唤醒，必须保证被唤醒的任务是恰当的任务，而且所有任务必须等待相同的条件</p></li><li>notifyAll()将唤醒所有等待这个锁的任务</li></ul><hr><h3 id="新类库中的构件"><a href="#新类库中的构件" class="headerlink" title="新类库中的构件"></a>新类库中的构件</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><blockquote><p><strong>适用场景</strong>：用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成</p></blockquote><ul><li>CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()方法都将阻塞，知道这个计数值到达0；</li><li>其他任务结束时，可调用对象上的countDown()减小计数值</li><li>计数值不能被重置（需要重置计数值可以用CyclicBarrier）</li></ul><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><blockquote><p><strong>适用场景</strong>： 希望创建一组任务，他们并行地执行工作，然后在下一个步骤之前等待，直至所有任务都完成<br>与CountDownLatch的区别</p><ul><li>可以重用</li><li>可以向CyclicBarrier提供一个Runnable，当计数值到达0时自动执行</li></ul></blockquote><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><blockquote><p>一个无边界的BlockingQueue，用于放置实现了Delayed接口的对象，队列是有序的，对头对象的延迟到期的时间最长，对象只能在到期时才能取走</p></blockquote><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><blockquote><p>基础的优先级队列，具有可阻塞的读取操作</p></blockquote><h4 id="ScheduleExecutor"><a href="#ScheduleExecutor" class="headerlink" title="ScheduleExecutor"></a>ScheduleExecutor</h4><blockquote><p>解决在预定时间运行的任务，使用schedule()（运行一次）或scheduleThreadFixedRate()（每隔规定的时间重复执行任务），可以将Runnable对象设置为将来的某个时刻执行</p></blockquote><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><blockquote><p>计数信号量，允许n个任务同时访问这个资源</p></blockquote><h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><blockquote><p>应用于一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象，通过使用Exchanger，可以有更多的对象在创建的同时被消费</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本的线程机制&quot;&gt;&lt;a href=&quot;#基本的线程机制&quot; class=&quot;headerlink&quot; title=&quot;基本的线程机制&quot;&gt;&lt;/a&gt;基本的线程机制&lt;/h3&gt;&lt;h4 id=&quot;定义一个线程&quot;&gt;&lt;a href=&quot;#定义一个线程&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JavaSE笔记" scheme="https://pinnuli.github.io/categories/JavaSE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
      <category term="Java并发" scheme="https://pinnuli.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java中的锁优化</title>
    <link href="https://pinnuli.github.io/2018/11/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E4%B8%AD%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://pinnuli.github.io/2018/11/12/深入理解Java虚拟机之Java中的锁优化/</id>
    <published>2018-11-12T12:08:20.000Z</published>
    <updated>2018-12-07T13:18:53.441Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>自旋锁</strong>: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁<blockquote><p>自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统方式挂起线程</p></blockquote></li><li><p><strong>自旋适应锁</strong>: 自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><blockquote><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且尺有所 的线程正在运行中，那么自旋等待时间将会持续相对更长；如果对于某个锁，自旋很少成功获得过，拿在以后要获取这个锁时将可能省略掉自旋过程</p></blockquote></li><li><p><strong>锁消除</strong>: 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不存在共享数据竞争的锁进行消除</p></li><li><p><strong>锁粗化</strong>: 虚拟机探测到有一串零碎的操作对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.tostring();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里原先每次append操作都需要加一次锁，而虚拟机会扩展到第一个append操作之前到最后一个append操作之后，就只需要加一次锁</p></blockquote><ul><li><p><strong>轻量级锁</strong>: 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制称为“重量级”锁</p><blockquote><p>轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。</p></blockquote></li><li><p><strong>偏向锁</strong>: 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即在无精准的情况下把整个同步都消除掉</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自旋锁&lt;/strong&gt;: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁&lt;blockquote&gt;
&lt;p&gt;自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统
      
    
    </summary>
    
      <category term="深入理解java虚拟机笔记" scheme="https://pinnuli.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://pinnuli.github.io/tags/JVM/"/>
    
      <category term="多线程" scheme="https://pinnuli.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://pinnuli.github.io/2018/11/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://pinnuli.github.io/2018/11/12/深入理解Java虚拟机之Java内存模型/</id>
    <published>2018-11-12T06:31:35.000Z</published>
    <updated>2018-12-07T13:19:09.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><ul><li><strong>主内存</strong>: Java内存模型规定了所有的变量都存储在主内存中。<blockquote><p>这里的主内存与物理硬件的主内存可以类比，但这里的主内存仅是指虚拟机内存的一部分。</p></blockquote></li><li><strong>工作内存</strong>: 每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中，而不能直接读写主内存中的变量。<blockquote><p>工作内存可以与处理器的高速缓存类比</p></blockquote></li><li><strong>线程、主内存、工作内存的交互关系</strong><br><img src="/images/thread_wm_mm.png" alt=""></li></ul><hr><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><h4 id="java内存模型定义的8种操作"><a href="#java内存模型定义的8种操作" class="headerlink" title="java内存模型定义的8种操作"></a>java内存模型定义的8种操作</h4><ul><li><strong>lock(锁定)</strong>: 作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li><li><strong>unlock(解锁)</strong>: 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li><strong>read(读取)</strong>: 作用于主内存的变量，它把一个变量的值从主内存传输到线程的总做内存中，以便随后的load动作使用</li><li><strong>load(载入)</strong>: 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存给的变量副本中<blockquote><p>把一个变量从主内存复制到工作内存，那就要顺序地执行read和load，但不要求连续执行</p></blockquote></li><li><strong>use(使用)</strong>: 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时会执行这个操作</li><li><strong>assign(赋值)</strong>: 作用于工作内存的变量，它把一个从执行亲情接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li><strong>store(存储)</strong>: 作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中一遍随后的write操作使用</li><li><strong>write(写入)</strong>: 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中<blockquote><p>把一个变量从工作内存同步到主内存，那就要顺序地执行store和write，但不要求连续执行</p></blockquote></li></ul><h4 id="8种操作需要满足的规则"><a href="#8种操作需要满足的规则" class="headerlink" title="8种操作需要满足的规则"></a>8种操作需要满足的规则</h4><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须将该变化同步回主内存</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li><li>一个新的变量只能在主内存”诞生“，不允许在工作内存中直接使用一个未被初始化（load或assign）的变脸，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这变量前，，需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定住的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存。</li></ul><hr><h3 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>当一个变量定义为volatile之后，它将具备两种特性：</p><ul><li><p><strong>可见性</strong>: 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存完成</p><blockquote><p>volatile变量只能在一下两种场景保证可见性<br>  1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值<br>  2.变量不需要与其他的状态变量共同参与不变约束</p></blockquote></li><li><p><strong>禁止指令重排序优化</strong>: 普通变量仅仅会保证在该方法的执行过程中所有依赋值结果的地方都能获取到正确的结果，而不能保证变量复制的顺序与程序代码中的执行顺序一致。</p></li></ul><h4 id="volatile与锁之间的区别"><a href="#volatile与锁之间的区别" class="headerlink" title="volatile与锁之间的区别"></a>volatile与锁之间的区别</h4><blockquote><p>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，<strong>不过大多数场景volatile的总开销仍然要比锁低，我们在volatile与锁之间的选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求</strong></p></blockquote><h4 id="volatile变量的特殊规则"><a href="#volatile变量的特殊规则" class="headerlink" title="volatile变量的特殊规则"></a>volatile变量的特殊规则</h4><blockquote><p>假设T表示一个线程，V和W分别表示两个volatile变量，在进行read、load、use、assign、store和write操作时需要满足如下规则：</p></blockquote><ul><li>线程T对变量V的use动作可以认为是和线程T对变量的load、read动作的相关联，必须连续一起出现（即在工作内存中，每次使用V之前必须先从主内存刷新最新的值）</li><li>线程T对变量V的assign动作可以认为是和线程T对变量的store、write动作的相关联，必须连续一起出现（即在工作内存中，每次修改V之后必须立刻同步回主内存中）</li><li>假设A是T对V的use或assign动作，F是和A相关联的load或store动作，P是和F相关联的read或write动作；类似的B是T对W实施的use或assign动作，G是和B相关联的load或store动作，Q是和G相关联的read或write动作。 <strong>如果A先于B，那么P先于Q</strong>（这要求volatile变量不会被指令重排序优化）</li></ul><hr><h3 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul><li>基本数据类型的访问读写是具备原子性的（long和double除外）</li><li>synchronized可以满足更大范围的原子性保证<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</p></blockquote></li><li><strong>volatile</strong>： 保证多线程操作时变量的可见性而普通变量不可以</li><li><strong>synchronized</strong>： 对一个变量执行unlock之前，必须先把此变量同步回主内存</li><li><p><strong>final</strong>： 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递，拿在其他线程中就能看见final字段的值</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>如果在本线程内管程，所有的操作都是有序的（线程内表现为串行）， 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序，工作内存与主内存同步延迟）</p></blockquote></li><li><p>volatile关键字本身包含了禁止指令重排序的语义</p></li><li>synchronized决定了持有用一个锁的同步快只能串行地进行</li></ul><hr><h3 id="“天然的“先行发生关系"><a href="#“天然的“先行发生关系" class="headerlink" title="“天然的“先行发生关系"></a>“天然的“先行发生关系</h3><ul><li><strong>程序次序规则</strong>: 在一个线程内，按照控制流顺序发生</li><li><strong>管程锁定规则</strong>: 一个unlock操作先行发生于后面对同一个锁的lock操作</li><li><strong>volatile变量规则</strong>: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li><li><strong>线程启动规则</strong>: Thread对象的start（）方法先行发生于此线程的每一个动作</li><li><strong>线程中止规则</strong>: 线程中的所有操作都先行发生于对此线程的终止检测</li><li><strong>线程中断规则</strong>: 对线程interrupt（）方法的调动先行发生于被中断线程的代码检测到中断事件的发生</li><li><strong>对象终结规则</strong>: 一个对象的初始化完成先行发生于他的finalize（）方法的开始</li><li><strong>传递性</strong>: A先行发生于B，B先行发生于C，则A先行发生于C</li></ul><blockquote><p>这些先行发生关系无须任何同步协助就已经存在，可以直接使用</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主内存与工作内存&quot;&gt;&lt;a href=&quot;#主内存与工作内存&quot; class=&quot;headerlink&quot; title=&quot;主内存与工作内存&quot;&gt;&lt;/a&gt;主内存与工作内存&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;: Java内存模型规定了所有的变量都存
      
    
    </summary>
    
      <category term="深入理解java虚拟机笔记" scheme="https://pinnuli.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JVM" scheme="https://pinnuli.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务管理</title>
    <link href="https://pinnuli.github.io/2018/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://pinnuli.github.io/2018/11/05/数据库事务管理/</id>
    <published>2018-11-05T07:42:40.000Z</published>
    <updated>2019-02-23T14:14:32.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ul><li><p><strong>原子性</strong>: 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。</p></li><li><p><strong>一致性</strong>: 隔离执行事务时（即不考虑其他事务并发执行）保持数据库的一致性。 在数据库系统中由恢复系统负责。</p></li><li><p><strong>隔离性</strong>: 尽管多个事务可能并发执行，但系统保证对于多个事务，如T1和T2，对于T1来说，T1要么在T2开始之前已经完成执行，要么在T2完成之后开始执行。确保隔离性在数据库系统中由并发控制系统部件负责。</p></li><li><p><strong>持久性</strong>: 一旦事务成功完成后，它对数据库的更新必须是永久的，即使出现系统故障，在数据库系统中由恢复系统负责。 可以通过一下两条中的其中任何一条来确保持久性。</p></li></ul><ol><li>事务做的更新在事务结束前已经给写入磁盘</li><li>有关事务已执行的更新信息已写到磁盘上，并且此类信息必须充分，能让数据库在系统出现故障后重新启动时重新构造更新</li></ol><hr><h3 id="数据库并发事务存在的问题"><a href="#数据库并发事务存在的问题" class="headerlink" title="数据库并发事务存在的问题"></a>数据库并发事务存在的问题</h3><ul><li><p><strong>脏读</strong>：一个事务读取了另一个事物改写但还未提交的数据，如果这些数据回滚，则读到的数据是无效的</p></li><li><p><strong>不可重复读</strong>：在同一个事物中，多次读取同一数据返回的结果有所不同</p></li><li><p><strong>幻读</strong>：一个事务读取了几行记录后，另一个事物插入一些记录，幻读就发生了。在后来的查询中，第一个事物就会发现有些原来没有的记录</p></li></ul><h3 id="事务原子性和持久性"><a href="#事务原子性和持久性" class="headerlink" title="事务原子性和持久性"></a>事务原子性和持久性</h3><h4 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h4><p>可以为事务建立一个简单的抽象事务类型，分为五种状态，事务必须处于以下状态之一</p><ul><li><strong>活动的</strong>： 初始状态，事务正在执行时处于此状态</li><li><strong>部分提交的</strong>： 最后一条语句执行后</li><li><strong>失败的</strong>： 发现正常的执行不能继续后</li><li><strong>中止的</strong>： 事务回滚并且数据库已恢复到事务开始执行前的状态后</li><li><strong>提交的</strong>： 成功完成后</li></ul><p><img src="/images/database_transaction_state.png" alt="事务管理状态"></p><h4 id="中止状态事务回滚的两种选择"><a href="#中止状态事务回滚的两种选择" class="headerlink" title="中止状态事务回滚的两种选择"></a>中止状态事务回滚的两种选择</h4><ul><li><strong>重启事务</strong>，但仅当引起事务中止的是硬件错误而不是有事务内部逻辑所产生的软件错误。</li><li><strong>杀死事务</strong>, 这样做通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正</li></ul><hr><h3 id="事务隔离性"><a href="#事务隔离性" class="headerlink" title="事务隔离性"></a>事务隔离性</h3><h4 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h4><ul><li><strong>冲突</strong>: 假设I和J是不同事务在在相同数据项上的操作，并且其中至少有一个是write指令时，I与J是冲突的</li><li><strong>冲突等价</strong>: 调度S经过一系列非冲突指令交换转换成S’，S与S’冲突等价</li><li><strong>冲突可串行化</strong>: 一个调度S与另一个串行调度冲突等价，则称调度S是冲突可串行化的</li></ul><h4 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h4><ul><li><strong>可恢复调度</strong>: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1先于T2提交</li><li><strong>无级联调度</strong>: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1必须在T2这一读操作前提交</li></ul><h4 id="事务隔离性级别"><a href="#事务隔离性级别" class="headerlink" title="事务隔离性级别"></a>事务隔离性级别</h4><ul><li><strong>可串行化</strong>: 通常保证可串行化调度，（完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读）</li><li><strong>可重复读</strong>: 只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据，但该事务不要求与其他事务可串行化。（可防止脏、不可重复读，但幻读依然有可能发生）</li><li><strong>已提交读</strong>: 只允许读取已提交数据，但不要求可重复读功能。（可防止脏读，但幻读和不可重复读依然有可能发生）</li><li><strong>未提交读</strong>: 允许读未提交数据。（可能导致脏、幻、不可重复读）</li></ul><hr><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="基于锁的协议"><a href="#基于锁的协议" class="headerlink" title="基于锁的协议"></a>基于锁的协议</h4><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><ul><li><strong>共享锁（S)</strong>: 如果事务T1获得了数据项Q上的共享型锁（记为S），则T1可读但不能写</li><li><strong>排他锁(X)</strong>: 如果事务T1获得了数据项Q上的排他型锁（记为X），则T1既可读又可写Q</li><li><strong>相容的锁</strong>: 数据项Q上存在B类型锁，如果事务T可以立即获得数据项Q上的A类型锁，则说A类型锁与B类型锁是相容的，即comp(A,B)=true</li></ul><h5 id="锁的授予"><a href="#锁的授予" class="headerlink" title="锁的授予"></a>锁的授予</h5><ul><li><strong>避免饿死</strong>: 可以通过在数据项Q上加M型锁，加锁条件如下：<br>  1.不存在在数据项Q上持有与M型锁冲突的锁的事务<br>  2.不存在等待对数据项Q上先于T申请枷锁的事务</li></ul><h5 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h5><ul><li><strong>增长阶段</strong>: 事务可以获得锁，但不能释放锁</li><li><strong>缩减阶段</strong>: 事务可以释放锁，但不能获得新锁</li><li><strong>严格两阶段封锁协议</strong>: 事务持有的所有排他锁必须在事务提交后方可释放</li><li><strong>强两阶段封锁协议</strong>: 事务提交之前不得释放任何锁</li></ul><h5 id="多粒度"><a href="#多粒度" class="headerlink" title="多粒度"></a>多粒度</h5><ul><li><strong>多级粒度机制</strong>: 通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大力度数据项中来实现。这种层次结构可以图形化地表示为树</li><li><strong>意向锁</strong>: 如果一个结点佳航了意向锁，则意味着要在树的叫底层进行显式加锁，在一个结点显式加锁前，该结点的的全部祖先结点都加上了意向锁。 这样子可以避免了需要从头遍历结点才能发现子结点已经加锁</li><li><strong>共享意向锁(IS)</strong>: 一个结点加上了共享意向锁，树的较低层进行显式封锁，但只能加共享锁。</li><li><strong>排他意向锁(IX)</strong>: 一个结点加上了排他意向锁，树的较低层进行显式封锁，可以加共享锁或排他锁。</li><li><strong>共享排他意向锁(SIX)</strong>: 一个结点加上了共享排他意向锁，则以该结点为根的子树显式地加上了共享锁，并且将在数的更低层显式地加排他锁。</li><li><strong>各种锁类型相容函数</strong>：<br><img src="/images/database_lock_types_comp.png" alt="各种锁类型相容函数"></li></ul><h4 id="基于时间戳的协议"><a href="#基于时间戳的协议" class="headerlink" title="基于时间戳的协议"></a>基于时间戳的协议</h4><p>对于系统中的每个事务T，把一个唯一的固定时间戳与他联系起来，此时间戳记为TS(T)。该时间戳是在事务T开始执行前由数据库系统赋予的。实现这种机制可以用以下两种方法：</p><ul><li>使用系统始终的值作为时间戳，即事务的时间戳等于该事务进入系统时的时钟值。</li><li>使用逻辑计数器，没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值。</li></ul><p>每个数据项需要与两个时间戳相关联：</p><ul><li>W-timestamp（Q）表示成功执行write（Q）的所有事务的最大时间戳</li><li>R-timestamp（Q）表示成功执行read（Q）的所有事务的最大时间戳</li></ul><p>协议运作方式如下：<br>1.假设事务T发出read（Q）<br>&emsp; a.若TS（T）&lt; W-timestamp（Q），则T需要读入的Q值已被覆盖。因此read操作被拒绝，T回滚；<br>&emsp; b.若TS（T）&gt;= W-timestamp（Q），则执行read操作，R-timestamp（Q）被设置为R-timestamp（Q）与TS(T)两者的最大值<br>2.假设事务T发出write（Q）<br>&emsp; a.若TS（T）&lt; R-timestamp（Q），则T产生的Q值是先前所需要的值，且系统已假定该值不会在产生，因此write被拒绝，T回滚<br>&emsp; b.若TS（T）&lt; W-timestamp（Q），则T试图写入的Q值已过时，write操作被拒绝，T回滚<br>&emsp; c.其他情况，系统执行write操作，将W-timestamp（Q）设置为TS（T）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务的ACID特性&quot;&gt;&lt;a href=&quot;#事务的ACID特性&quot; class=&quot;headerlink&quot; title=&quot;事务的ACID特性&quot;&gt;&lt;/a&gt;事务的ACID特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;: 事务的所有操作在数据库
      
    
    </summary>
    
      <category term="数据库" scheme="https://pinnuli.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="计算机基础" scheme="https://pinnuli.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML之与HTML的区别验证，定位信息，命名空间</title>
    <link href="https://pinnuli.github.io/2018/07/30/Java%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%AE%9A%E4%BD%8D%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://pinnuli.github.io/2018/07/30/Java中的XML之与HTML的区别验证，定位信息，命名空间/</id>
    <published>2018-07-30T04:19:45.000Z</published>
    <updated>2018-11-13T06:13:14.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML与XML的区别"><a href="#HTML与XML的区别" class="headerlink" title="HTML与XML的区别"></a>HTML与XML的区别</h3><ul><li>HTML对大小写不敏感，XML大小写敏感</li><li>HTML结束标签可以省略，如<code>&lt;/p&gt;</code>，XML不能</li><li>XML只有单个标签而没有结束标签的元素必须以<code>/</code>结束</li><li>XML属性值必须用引号括起来</li><li>HTML属性可以没有值，XML所有属性必须有值    </li></ul><hr><h3 id="验证XML文档"><a href="#验证XML文档" class="headerlink" title="验证XML文档"></a>验证XML文档</h3><p>需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema</p><h4 id="文档类型定义"><a href="#文档类型定义" class="headerlink" title="文档类型定义"></a>文档类型定义</h4><ul><li>将这些规则纳入XML文档</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration[</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    &lt;!ELEMENT configuration...&gt;</span></span><br><span class="line"><span class="meta">    ...</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这些规则被纳入到DOCTYPE声明中，代码块[…]用来限定其界限，比如configuration</p></blockquote><ul><li>SYSTEM声明，将DTD存储在外面</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE configuration SYSTEM "config.dtd"&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration SYSTEM "http://myserver.com/config.dtd"&gt;</span></span><br></pre></td></tr></table></figure><ul><li>标记PUBLIC标识符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEntityResolver</span> <span class="keyword">implements</span> <span class="title">EntityResolver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, String systemID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(publicID.equals(a knowx ID))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InputSource(DTD data):</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空</p></blockquote><h4 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h4><ul><li><p>声明Schema文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用xsd:表示XSL Schema定义的命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">- ref属性引用Schema中位于别处的定义</span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">ref</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"style"</span> <span class="attr">type</span>=<span class="string">StyleType</span>"/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">"PLAIN"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="使用XPath定位信息"><a href="#使用XPath定位信息" class="headerlink" title="使用XPath定位信息"></a>使用XPath定位信息</h3><ul><li><p>查找下列的username的值，,通过XPath表达式/configuration/database/username</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configfuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">database</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>pinnuli<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configfuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XPathFactory xpFactory = XPathFactory.newInstance();</span><br><span class="line">path = xpfactory.newXPath();</span><br><span class="line">String username = path.evaluate(/configuration/database/username",doc);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>具体的语法看文档</p></blockquote><hr><h3 id="XML的命名空间"><a href="#XML的命名空间" class="headerlink" title="XML的命名空间"></a>XML的命名空间</h3><ul><li><p>使用xmlns给定命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">xmlns</span>=<span class="string">"namespaceURI1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">xmlns</span>=<span class="string">"namespaceURI2"</span>&gt;</span></span><br><span class="line">        grandchildren</span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里第一个子元素和孙元素都是第二个命名空间的一部分</p></blockquote></li><li><p>使用xmlns:prefix=”namespaceURI”定义命名空间和前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</span><br><span class="line">    &lt;xsd:element name=&quot;pinnuli&quot; type=&quot;haha&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/xsd:schema&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这里xsd:schema实际上指的是命名空间<code>http://www.w3.org/2001/XMLSchema</code>中的<code>schema</code></p></blockquote></li><li>可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factory.serNamespaceAware(true);</span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/171" target="_blank" rel="noopener">慕课网：Java眼中的XML—文件读取</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML与XML的区别&quot;&gt;&lt;a href=&quot;#HTML与XML的区别&quot; class=&quot;headerlink&quot; title=&quot;HTML与XML的区别&quot;&gt;&lt;/a&gt;HTML与XML的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTML对大小写不敏感，XML大小写敏感&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="JavaSE笔记" scheme="https://pinnuli.github.io/categories/JavaSE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
      <category term="XML" scheme="https://pinnuli.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J</title>
    <link href="https://pinnuli.github.io/2018/07/30/Java%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J/"/>
    <id>https://pinnuli.github.io/2018/07/30/Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J/</id>
    <published>2018-07-30T04:17:44.000Z</published>
    <updated>2018-11-13T06:13:12.492Z</updated>
    
    <content type="html"><![CDATA[<p>现有以下XML文档books.xml,下面的示例生成此文档部分内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>冰与火之歌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>乔治马丁<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2014<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>89<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>安徒生童话<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2004<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>77<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">language</span>&gt;</span>English<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>1、创建DocumentBuilder对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p><p>2、添加节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">document.setXmlStandalone(<span class="keyword">true</span>);</span><br><span class="line">Element bookstore = document.createElement(<span class="string">"bookStore"</span>);</span><br><span class="line"><span class="comment">//向bookstore根节点中添加子节点book</span></span><br><span class="line">Element book = document.createElement(<span class="string">"book"</span>);</span><br><span class="line">Element name = document.createElement(<span class="string">"name"</span>);</span><br><span class="line">name.setTextContent(<span class="string">"???"</span>);</span><br><span class="line"></span><br><span class="line">book.appendChild(name);</span><br><span class="line">book.setAttribute(<span class="string">"id"</span>, <span class="string">"1"</span>);</span><br><span class="line"><span class="comment">//将book节点添加到bookstore根节点中</span></span><br><span class="line">bookstore.appendChild(book);</span><br><span class="line"><span class="comment">//将bookstore节点（已经包含了book）添加到dom树中</span></span><br><span class="line">document.appendChild(bookstore);</span><br></pre></td></tr></table></figure></p><p>3、生成xml文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory tff = TransformerFactory.newInstance();</span><br><span class="line">Transformer tf = tff.newTransformer();</span><br><span class="line"><span class="comment">//设置文件</span></span><br><span class="line">tf.setOutputProperty(OutputKeys.INDENT, <span class="string">"yes"</span>);</span><br><span class="line">tf.transform(<span class="keyword">new</span> DOMSource(document),<span class="keyword">new</span> StreamResult(<span class="keyword">new</span> File(<span class="string">"books1.xml"</span>)));</span><br></pre></td></tr></table></figure></p><hr><h3 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h3><p>1、创建一个TransformerFactory类的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance();</span><br></pre></td></tr></table></figure></p><p>2、通过SAXTransformerFactory对象创建一个TransformerHandler对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransformerHandler handler = tff.newTransformerHandler();</span><br></pre></td></tr></table></figure></p><p>3、通过handler对象创建一个Transformer对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer tr = handler.getTransformer();</span><br></pre></td></tr></table></figure></p><p>4、通过Transformer对象对生成的xml文件进行设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设置xml的编码</span><br><span class="line">tr.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span><br><span class="line">// 设置xml的“是否换行”</span><br><span class="line">tr.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class="line">5、创建一个Result对象</span><br><span class="line">```java</span><br><span class="line">File f = new File(&quot;newbooks.xml&quot;);</span><br><span class="line">if (!f.exists()) &#123;</span><br><span class="line">    f.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、创建Result对象，并且使其与handler关联<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result result = <span class="keyword">new</span> StreamResult(<span class="keyword">new</span> FileOutputStream(f));</span><br><span class="line">handler.setResult(result);</span><br></pre></td></tr></table></figure></p><p>7、利用handler对象进行xml文件内容的编写O<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开document</span></span><br><span class="line">handler.startDocument();</span><br></pre></td></tr></table></figure></p><p>8、添加节点属性和节点值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">AttributesImpl attr = <span class="keyword">new</span> AttributesImpl();</span><br><span class="line">handler.startElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"bookstore"</span>, attr);</span><br><span class="line"><span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">    attr.clear();</span><br><span class="line">    attr.addAttribute(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"id"</span>, <span class="string">""</span>, book.getId());</span><br><span class="line">    handler.startElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"book"</span>, attr);</span><br><span class="line">    <span class="comment">// 创建name节点</span></span><br><span class="line">    <span class="keyword">if</span> (book.getName() != <span class="keyword">null</span> &amp;&amp; !book.getName().trim().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        attr.clear();</span><br><span class="line">        handler.startElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"name"</span>, attr);</span><br><span class="line">        handler.characters(book.getName().toCharArray(), <span class="number">0</span>, book</span><br><span class="line">                .getName().length());</span><br><span class="line">        handler.endElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    handler.endElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"book"</span>);</span><br><span class="line">&#125;</span><br><span class="line">handler.endElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"bookstore"</span>);</span><br><span class="line"><span class="comment">// 关闭document</span></span><br><span class="line">handler.endDocument();</span><br></pre></td></tr></table></figure></p><hr><h3 id="JDOM"><a href="#JDOM" class="headerlink" title="JDOM"></a>JDOM</h3><p>1.生成一个根节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rss = <span class="keyword">new</span> Element(<span class="string">"rss"</span>);</span><br></pre></td></tr></table></figure></p><p>2.为节点添加属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss.setAttribute(<span class="string">"version"</span>, <span class="string">"2.0"</span>);</span><br></pre></td></tr></table></figure></p><p>3.生成一个document对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Document document = <span class="keyword">new</span> Document(rss);</span><br><span class="line">Element channel = <span class="keyword">new</span> Element(<span class="string">"channel"</span>);</span><br><span class="line">rss.addContent(channel);</span><br><span class="line">Element title = <span class="keyword">new</span> Element(<span class="string">"title"</span>);</span><br><span class="line">title.setText(<span class="string">"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;"</span>);</span><br><span class="line">channel.addContent(title);</span><br><span class="line"><span class="comment">//设置文件编码和换行</span></span><br><span class="line">Format format = Format.getCompactFormat();</span><br><span class="line">format.setIndent(<span class="string">""</span>);</span><br><span class="line">format.setEncoding(<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure></p><p>4.创建XMLOutputter的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLOutputter outputer = <span class="keyword">new</span> XMLOutputter(format);</span><br></pre></td></tr></table></figure></p><p>5.利用outputer将document对象转换成xml文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputer.output(document, <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"rssnews.xml"</span>)));</span><br></pre></td></tr></table></figure></p><hr><h3 id="DOM4J"><a href="#DOM4J" class="headerlink" title="DOM4J"></a>DOM4J</h3><blockquote><p>使用DOM4J生成RSS文件</p></blockquote><p>1.创建document对象，代表整个xml文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document document = DocumentHelper.createDocument();</span><br></pre></td></tr></table></figure></p><p>2.创建根节点rss<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rss = document.addElement(<span class="string">"rss"</span>);</span><br></pre></td></tr></table></figure></p><p>3.向rss节点中添加version属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss.addAttribute(<span class="string">"version"</span>, <span class="string">"2.0"</span>);</span><br></pre></td></tr></table></figure></p><p>4.生成子节点及节点内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Element channel = rss.addElement(<span class="string">"channel"</span>);</span><br><span class="line">Element title = channel.addElement(<span class="string">"title"</span>);</span><br><span class="line">title.setText(<span class="string">"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;"</span>);</span><br></pre></td></tr></table></figure></p><p>5.设置生成xml的格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">format.setEncoding(<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure></p><p>6.生成xml文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"rssnews.xml"</span>);</span><br><span class="line">XMLWriter writer;</span><br><span class="line">writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileOutputStream(file), format);</span><br><span class="line"><span class="comment">//设置是否转义，默认值是true，代表转义</span></span><br><span class="line">writer.setEscapeText(<span class="keyword">false</span>);</span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></p><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/171" target="_blank" rel="noopener">慕课网：Java眼中的XML—文件读取</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现有以下XML文档books.xml,下面的示例生成此文档部分内容&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="JavaSE笔记" scheme="https://pinnuli.github.io/categories/JavaSE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
      <category term="XML" scheme="https://pinnuli.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J</title>
    <link href="https://pinnuli.github.io/2018/07/30/Java%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J/"/>
    <id>https://pinnuli.github.io/2018/07/30/Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J/</id>
    <published>2018-07-30T04:17:35.000Z</published>
    <updated>2018-11-13T06:13:07.092Z</updated>
    
    <content type="html"><![CDATA[<p>现有以下XML文档books.xml,下面的解析示例解析此文档部分内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>冰与火之歌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>乔治马丁<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2014<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>89<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>安徒生童话<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2004<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>77<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">language</span>&gt;</span>English<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h3><p>1、创建一个DocumentBuilder的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p><p>2、调用parser方法加载books.xml文件到当前项目下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document document = db.parse(<span class="string">"books.xml"</span>);</span><br></pre></td></tr></table></figure></p><p>3、进行解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有book节点的集合</span></span><br><span class="line">NodeList bookList = document.getElementsByTagName(<span class="string">"book"</span>);</span><br><span class="line"><span class="comment">//?????book??</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.getLength(); i++) &#123;</span><br><span class="line">    <span class="comment">//通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始</span></span><br><span class="line">    Node book = bookList.item(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取book节点的所有属性集合</span></span><br><span class="line">    NamedNodeMap attrs = book.getAttributes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前提：已经知道book节点有且只能有1个id属性</span></span><br><span class="line">    <span class="comment">//将book节点进行强制类型转换，转换成Element类型</span></span><br><span class="line">    Element book = (Element) bookList.item(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过getAttribute("id")方法获取属性值</span></span><br><span class="line">    String attrValue = book.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析book节点的子节点</span></span><br><span class="line">    NodeList childNodes = book.getChildNodes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>更多解析方法查看API</p></blockquote><hr><h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p>1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory factory = SAXParserFactory.newInstance();</span><br></pre></td></tr></table></figure></p><p>2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXParser parser = factory.newSAXParser();</span><br></pre></td></tr></table></figure></p><p>3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXParserHandler handler = <span class="keyword">new</span> SAXParserHandler();</span><br><span class="line">parser.parse(<span class="string">"books.xml"</span>, handler);</span><br></pre></td></tr></table></figure></p><p>handler类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识解析开始</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">super</span>.startDocument();</span><br><span class="line">    System.out.println(<span class="string">"SAX解析开始"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标识解析结束</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">super</span>.endDocument();</span><br><span class="line">    System.out.println(<span class="string">"SAX解析结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析xml元素</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName,</span></span></span><br><span class="line"><span class="function"><span class="params">        Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">//调用DefaultHandler类的startElement方法</span></span><br><span class="line">    <span class="keyword">super</span>.startElement(uri, localName, qName, attributes);</span><br><span class="line">    <span class="keyword">if</span> (qName.equals(<span class="string">"book"</span>)) &#123;</span><br><span class="line">        <span class="comment">//已知book元素下属性的名称，根据属性名称获取属性值</span></span><br><span class="line">        String value = attributes.getValue(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(<span class="string">"book的属性值是："</span> + value);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!qName.equals(<span class="string">"name"</span>) &amp;&amp; !qName.equals(<span class="string">"bookstore"</span>)) &#123;</span><br><span class="line">        System.out.print(<span class="string">"节点名是："</span> + qName + <span class="string">"---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">//调用DefaultHandler类的endElement方法</span></span><br><span class="line">    <span class="keyword">super</span>.endElement(uri, localName, qName);</span><br><span class="line">    <span class="comment">//判断是否针对一本书已经遍历结束</span></span><br><span class="line">    <span class="keyword">if</span> (qName.equals(<span class="string">"book"</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"结束遍历某一本书的内容"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">super</span>.characters(ch, start, length);</span><br><span class="line">    value = <span class="keyword">new</span> String(ch, start, length);</span><br><span class="line">    <span class="keyword">if</span> (!value.trim().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"节点值是："</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="JDOM解析"><a href="#JDOM解析" class="headerlink" title="JDOM解析"></a>JDOM解析</h3><p>1、创建一个SAXBuilder的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder saxBuilder = new SAXBuilder();</span><br></pre></td></tr></table></figure></p><p>2、创建一个输入流，将xml文件加载到输入流中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in = new FileInputStream(&quot;books.xml&quot;);</span><br></pre></td></tr></table></figure></p><p>3、通过saxBuilder的build方法，将输入流加载到saxBuilder中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document document = saxBuilder.build(in);</span><br></pre></td></tr></table></figure></p><p>4、通过document对象获取xml文件的根节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rootElement = document.getRootElement();</span><br></pre></td></tr></table></figure></p><p>5、获取根节点下的子节点的List集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; bookList = rootElement.getChildren();</span><br><span class="line">for (Element book : bookList) &#123;</span><br><span class="line">    // 解析book的属性集合</span><br><span class="line">    List&lt;Attribute&gt; attrList = book.getAttributes();</span><br><span class="line">    //知道节点下属性名称时，获取节点值</span><br><span class="line">    book.getAttributeValue(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">    // 对book节点的子节点的节点名以及节点值的遍历</span><br><span class="line">    List&lt;Element&gt; bookChilds = book.getChildren();</span><br><span class="line">    for (Element child : bookChilds) &#123;</span><br><span class="line">        System.out.println(&quot;????&quot; + child.getName() + &quot;----????&quot;</span><br><span class="line">                + child.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果需要设置编码可以按照以下方式设置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in, <span class="string">"UTF-8"</span>);</span><br><span class="line">Document document = saxBuilder.build(isr);</span><br></pre></td></tr></table></figure><hr><h3 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h3><p>1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document document = reader.read(<span class="keyword">new</span> File(<span class="string">"src/res/books.xml"</span>));</span><br></pre></td></tr></table></figure></p><p>2、通过document对象获取根节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element bookStore = document.getRootElement();</span><br></pre></td></tr></table></figure></p><p>3、通过element对象的elementIterator方法获取迭代器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookStore.elementIterator();</span><br></pre></td></tr></table></figure></p><p>4、遍历迭代器，获取根节点中的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Element book = (Element) it.next();</span><br><span class="line">    <span class="comment">// 获取book的属性名以及 属性值</span></span><br><span class="line">    List&lt;Attribute&gt; bookAttrs = book.attributes();</span><br><span class="line">    <span class="keyword">for</span> (Attribute attr : bookAttrs) &#123;</span><br><span class="line">        System.out.println(<span class="string">"????"</span> + attr.getName() + <span class="string">"--????"</span></span><br><span class="line">                + attr.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历子节点</span></span><br><span class="line">    Iterator itt = book.elementIterator();</span><br><span class="line">    <span class="keyword">while</span> (itt.hasNext()) &#123;</span><br><span class="line">        Element bookChild = (Element) itt.next();</span><br><span class="line">        System.out.println(<span class="string">"????"</span> + bookChild.getName() + <span class="string">"--????"</span> + bookChild.getStringValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="四种解析方式的区别"><a href="#四种解析方式的区别" class="headerlink" title="四种解析方式的区别"></a>四种解析方式的区别</h3><ul><li>DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时<blockquote><p>优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改<br>  缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出</p></blockquote></li><li>SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时<blockquote><p>优点：内存消耗小<br>  缺点：不易编码；很难同时访问同一个xml中的多处不同数据</p></blockquote></li><li>JDOM：API大量使用了Collections类</li><li>DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用</li></ul><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/171" target="_blank" rel="noopener">慕课网：Java眼中的XML—文件读取</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现有以下XML文档books.xml,下面的解析示例解析此文档部分内容&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="JavaSE笔记" scheme="https://pinnuli.github.io/categories/JavaSE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
      <category term="XML" scheme="https://pinnuli.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean装配之基于Java的容器注解 </title>
    <link href="https://pinnuli.github.io/2018/07/29/Spring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://pinnuli.github.io/2018/07/29/Spring-Bean装配之基于Java的容器注解/</id>
    <published>2018-07-29T09:13:43.000Z</published>
    <updated>2018-11-12T13:01:24.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的<bean>，通常和<code>@Configuration</code>配合使用</bean></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"store"</span>,initMethod = <span class="string">"init"</span>,destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanStore <span class="title">beanStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于以下XML配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"store"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.beanannotation.BeanStore"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>如果<code>@Bean</code>没有指定名称，则默认为方法名，这里即是beanStore。<br><br>如果需要指定范围，即XML配置时的属性<code>scope</code>，那么可以用<code>@Scop</code>e注解，且可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value=<span class="string">"prototype"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure><hr><h3 id="ImportResource-Value"><a href="#ImportResource-Value" class="headerlink" title="@ImportResource,@Value"></a>@ImportResource,@Value</h3><blockquote><p>通过<code>@ImportResource</code>加载资源文件,<code>@Value</code>获取属性值，比如有文件<code>config.properties</code>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.username=root</span><br><span class="line">password=root</span><br><span class="line">url=127.0.0.1</span><br></pre></td></tr></table></figure></p></blockquote><p>则可以通过将此内容配置到XML文件，如<code>config.xml</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/config.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后在定义<code>bean</code>时，通过<code>@ImportResource</code>加载文件，通过<code>@Value</code>获取属性的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:config.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyDriverManager <span class="title">myDriverManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyDriverManager(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：这里的用户名字段如果直接为<code>username</code>，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如<code>jdbc.username</code>,<code>jdbc.password</code>等</p></blockquote><hr><h3 id="基于泛型的自动装配"><a href="#基于泛型的自动装配" class="headerlink" title="基于泛型的自动装配"></a>基于泛型的自动装配</h3><p>比如现有如下接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Store</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>IntegerStore</code>和<code>StringStore</code>是他的两个实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerStore</span> <span class="keyword">implements</span> <span class="title">Store</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringStore</span> <span class="keyword">implements</span> <span class="title">Store</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在定义<code>bean</code>时可以按照如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>那么<code>s1</code>将会自动装配到<code>StringStore</code>，<code>s2</code>将会是<code>IntegerStore</code></p></blockquote><hr><h3 id="JSR支持"><a href="#JSR支持" class="headerlink" title="JSR支持"></a>JSR支持</h3><h4 id="JSR250的支持"><a href="#JSR250的支持" class="headerlink" title="JSR250的支持"></a>JSR250的支持</h4><p>1.@Resource<br>注解变量或方法，且有一个name属性值，默认<code>Spring</code>解释改值为被注入<code>bea</code>n的名称，若没有指定<code>name</code>,那么名称从方法名或者属性名得出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsrServie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> JsrDAO jsrDAO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJsrDAO</span><span class="params">(@Named(<span class="string">"jsrDAO"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jsrDAO = jsrDAO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.@PostConstruct和@PreDestroy<br><code>@PostConstruct</code>,初始化，相当于<code>init-Method</code>属性<br><code>@PreDestroy</code>，销毁，相当于<code>destroy-Method</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="JSR330的支持"><a href="#JSR330的支持" class="headerlink" title="JSR330的支持"></a>JSR330的支持</h4><blockquote><p>需要依赖<code>javax.injet</code>包</p></blockquote><p>1.@Inject<br>与<code>@Autowired</code>等效，可以使用于类，属性，方法，构造器<br>2.@Named<br>使用特定名称进行依赖注入，与<code>@Component</code>等效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsrServie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="keyword">private</span> JsrDAO jsrDAO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJsrDAO</span><span class="params">(@Named(<span class="string">"jsrDAO"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jsrDAO = jsrDAO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参阅:<br>  <a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">慕课网：Spring入门篇</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Bean&quot;&gt;&lt;a href=&quot;#Bean&quot; class=&quot;headerlink&quot; title=&quot;@Bean&quot;&gt;&lt;/a&gt;@Bean&lt;/h3&gt;&lt;p&gt;用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的&lt;bean&gt;，通常和&lt;code&gt;@
      
    
    </summary>
    
      <category term="Spring笔记" scheme="https://pinnuli.github.io/categories/Spring%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="https://pinnuli.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean装配之Autowired注解</title>
    <link href="https://pinnuli.github.io/2018/07/28/Spring-Bean%E8%A3%85%E9%85%8D%E4%B9%8BAutowired%E6%B3%A8%E8%A7%A3/"/>
    <id>https://pinnuli.github.io/2018/07/28/Spring-Bean装配之Autowired注解/</id>
    <published>2018-07-28T14:36:17.000Z</published>
    <updated>2018-11-12T13:00:24.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-可以将-Autowired注解为setter方法"><a href="#1-可以将-Autowired注解为setter方法" class="headerlink" title="1.可以将@Autowired注解为setter方法"></a>1.可以将@Autowired注解为setter方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-可以用于构造器或成员变量"><a href="#2-可以用于构造器或成员变量" class="headerlink" title="2.可以用于构造器或成员变量"></a>2.可以用于构造器或成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，如果因找不到合适的<code>bean</code>将会导致<code>autowiring</code>失败抛出异常，可以通过将其<code>required</code>设置为false表示并非必须，每个类只能有一个构造器标记为<code>required=true</code>,也就是只能有一个构造器为必须，这种情况下建议使用<code>@Required</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Required</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@Required</code>表示标记的<code>bean</code>属性在<code>bean</code>装配时必须被填充，通过在<code>bean</code>定义或者自动装配一个明确的属性值</p></blockquote><hr><h3 id="3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等"><a href="#3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等" class="headerlink" title="3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等"></a>3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanSutowired</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean"><a href="#4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean" class="headerlink" title="4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean"></a>4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean</h3><p>下面的示例中，<code>list</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，假如有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时<code>list</code>中将包含有<code>BeanimplOne</code>和<code>BeanimplTwo</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInvoker</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"list..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (BeanInterface bean : list) &#123;</span><br><span class="line">            System.out.println(bean.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果希望数组有序，可以使用<code>@Order</code>注解或者实现<code>org.springframework.core.Ordered</code>接口，但是对<code>map</code>无效</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanimplTwo</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-用于装配key为String的Map"><a href="#5-用于装配key为String的Map" class="headerlink" title="5.用于装配key为String的Map"></a>5.用于装配key为String的Map</h3><p>下面的示例中，<code>map</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，加入有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时map中将包含有键为<code>bean</code>名称和值为<code>bean</code>的两个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInvoker</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanInterface&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"map..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanInterface&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"      "</span> + entry.getValue().getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="6-Qualifier"><a href="#6-Qualifier" class="headerlink" title="6.@Qualifier"></a>6.@Qualifier</h3><ul><li>按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"beanImplTwo"</span>)</span><br><span class="line"><span class="keyword">private</span> BeanInterface beanInterface;</span><br></pre></td></tr></table></figure><ul><li>用于指定单独的构造器参数或方法参数</li><li>用于注解集合类型变量</li></ul><p>可以在bean的定义中使用<code>@Qualifier</code>注解给他限定一个范围，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"beanImpl"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanImplTwo</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在注入时，使用<code>@Qualifier</code>限定，则下面的<code>list</code>将会匹配到所有<code>@Qualifier(&quot;beanImp&quot;)</code>的<code>bean</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"beanImpl"</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br></pre></td></tr></table></figure></p><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">慕课网：Spring入门篇</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-可以将-Autowired注解为setter方法&quot;&gt;&lt;a href=&quot;#1-可以将-Autowired注解为setter方法&quot; class=&quot;headerlink&quot; title=&quot;1.可以将@Autowired注解为setter方法&quot;&gt;&lt;/a&gt;1.可以将@Au
      
    
    </summary>
    
      <category term="Spring笔记" scheme="https://pinnuli.github.io/categories/Spring%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="https://pinnuli.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean装配之各装配项 XML实现和注解实现</title>
    <link href="https://pinnuli.github.io/2018/07/27/Spring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%90%84%E8%A3%85%E9%85%8D%E9%A1%B9-XML%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0/"/>
    <id>https://pinnuli.github.io/2018/07/27/Spring-Bean装配之各装配项-XML实现和注解实现/</id>
    <published>2018-07-27T10:56:18.000Z</published>
    <updated>2018-11-12T13:01:22.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Bean管理的XML配置实现"><a href="#一、Bean管理的XML配置实现" class="headerlink" title="一、Bean管理的XML配置实现"></a>一、Bean管理的XML配置实现</h3><h4 id="1-Bean的配置项"><a href="#1-Bean的配置项" class="headerlink" title="1.Bean的配置项"></a>1.Bean的配置项</h4><ul><li><code>Id</code>:Bean的唯一标识</li><li><code>Class</code>：对应实现的类</li><li><code>Scope</code>：范围</li><li><code>Constructor arguments</code>：构造器参数</li><li><code>Properties</code>：属性</li><li><code>Autowiring mode</code>：自动装配模式 </li><li><code>lazy-initialization mode</code>：懒加载模式</li><li><code>Initialization/destruction method</code>：初始化/销毁方法</li></ul><h4 id="2-Bean的定义"><a href="#2-Bean的定义" class="headerlink" title="2.Bean的定义"></a>2.Bean的定义</h4><p>这里以<code>InjectionImpl</code>中包含<code>InjectionDAO</code>成员变量为例，说明设置注入和构造注入,<code>InjectionImpl</code>类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionServiceImpl</span> <span class="keyword">implements</span> <span class="title">InjectionService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InjectionDAO injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式一：设置注入"><a href="#方式一：设置注入" class="headerlink" title="方式一：设置注入"></a>方式一：设置注入</h5><p><code>bean</code>的XML配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionService"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"injectionDAO"</span> <span class="attr">ref</span>=<span class="string">"injectionDAO"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionDAO"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>InjectionIml</code>中setter方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：构造注入"><a href="#方式二：构造注入" class="headerlink" title="方式二：构造注入"></a>方式二：构造注入</h5><p>bean的XML配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionService"</span> <span class="attr">class</span>=<span class="string">"com.imooc.ioc.injection.service.InjectionServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"injectionDAO"</span> <span class="attr">ref</span>=<span class="string">"injectionDAO"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionDAO"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>InjectionIml</code>中构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InjectionServiceImpl</span><span class="params">(InjectionDAOImpl injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Bean的作用域"><a href="#2-Bean的作用域" class="headerlink" title="2.Bean的作用域"></a>2.Bean的作用域</h4><ul><li><code>singleton</code>:单例，一个Bean容器中指存在一份（默认情况下为singleton)</li><li><code>prototype</code>：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效</li><li><code>request</code>：每次http请求创建一个实例且仅在当前request内有效</li><li><code>session</code>：同上，每次http请求创建，当前session有效</li><li><code>global session</code>：给予portel的web中有效，如果是在web中，则同session</li></ul><p>XML文件中的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanScope"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.bean.BeanScope"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="3-Bean的生命周期"><a href="#3-Bean的生命周期" class="headerlink" title="3.Bean的生命周期"></a>3.Bean的生命周期</h4><blockquote><p>定义 &rArr; 初始化 &rArr;    使用 &rArr; 销毁</p></blockquote><p><strong>初始化</strong></p><h5 id="方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法"><a href="#方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法" class="headerlink" title="方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法"></a>方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInitializingBean</span> <span class="keyword">implements</span> <span class="title">InitialingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：配置init-method"><a href="#方式二：配置init-method" class="headerlink" title="方式二：配置init-method"></a>方式二：配置init-method</h5><p>XML文件中的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"example.Example"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>对应实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>销毁:</strong></p><h5 id="方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法"><a href="#方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法" class="headerlink" title="方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法"></a>方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInitializingBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：配置destory-method"><a href="#方式二：配置destory-method" class="headerlink" title="方式二：配置destory-method"></a>方式二：配置destory-method</h5><p>XML文件中的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"example.Example"</span> <span class="attr">init-method</span>=<span class="string">"destroy"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>destory</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="配置全局默认初始化、销毁方法"><a href="#配置全局默认初始化、销毁方法" class="headerlink" title="配置全局默认初始化、销毁方法"></a>配置全局默认初始化、销毁方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-init-method</span>=<span class="string">"init"</span> <span class="attr">default-destroy-mothod</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效；<br>  ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错；<br>  iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。</p></blockquote><h4 id="4-Bean的自动装配"><a href="#4-Bean的自动装配" class="headerlink" title="4.Bean的自动装配"></a>4.Bean的自动装配</h4><ul><li><code>No</code>：什么都不操作</li><li><code>byname</code>：即<bean>中的<code>id</code>，根据属性名自动装配，</bean></li><li><code>byType</code>：即<bean>中的<code>class</code></bean></li></ul><blockquote><p>i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；<br>ii.如果存在多个该类型的bean，则抛出异常，并指出不能使用<code>byType</code>方式进行自动装配<br>iii.如果没有找到匹配的bean，则不进行任何操作<br>以上两种情况bean的XML配置如下：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byType"</span>/"<span class="attr">byName</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoWiringService"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.autowiring.AutoWiringService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoWiringDAO"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.autowiring.AutoWiringDAO"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>Constructor</code>: 应用于构造器参数，与<code>byType</code>类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常</li></ul><blockquote><p>对应的类中的构造方法和setter方法与设置注入或构造注入一致</p></blockquote><hr><h3 id="二、Bean管理的注解实现"><a href="#二、Bean管理的注解实现" class="headerlink" title="二、Bean管理的注解实现"></a>二、Bean管理的注解实现</h3><h4 id="1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类："><a href="#1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类：" class="headerlink" title="1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类："></a>1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span> &gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;context:annotation-config/&gt;</code><br>仅会查找同一个<code>applicat context</code>中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解<br>通过在基于XML的Spring配置如下标签</li></ul><ul><li><code>&lt;context:component-scan&gt;</code>会扫描所有有bean注解的类，并注册到IOC容器，包含了<code>&lt;context:annotation-config&gt;</code>的全部功能，因而通常只需要使用前者，而不用后者</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>base-package表示扫描包下的所有类</p></blockquote><h4 id="2-使用过滤器进行自定义扫描"><a href="#2-使用过滤器进行自定义扫描" class="headerlink" title="2.使用过滤器进行自定义扫描"></a>2.使用过滤器进行自定义扫描</h4><p>默认情况下，类被自动发现并注册bean的条件是：使用了<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>注解，或者使用@<code>Component</code>的自定义注解，可以通过过滤器修改上述的行为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">".*Stub.*Respository"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Repository"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>还可以使用<code>use-default-filters=&quot;false&quot;</code>禁用自动发现与注册</p></blockquote><h4 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h4><p>Bean名称是由<code>BeannameGenerator</code>生成的，默认情况下为类名的首字母变为小写</p><blockquote><p><code>@Component</code>，<code>@Repository</code>，<code>@Service</code>,<code>@Controller</code>都有一个那么属性用于显示设置Bean的名称,如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"beanName"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanAnnotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>也可自定义命名策略,实现<code>BeanNameGenerator</code>接口，并一定要包含一个无参构造器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">name-generator</span>=<span class="string">"org.example.MyNameGenerator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>通常情况下启动查找的Spring组件，其scope是<code>singleton</code>，可用<code>@Scope</code>表示scope,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br></pre></td></tr></table></figure></p><p>也可自定义scope策略，实现实现<code>ScopeMetadataResolver</code>接口，并一定要包含一个无参构造器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">name-generator</span>=<span class="string">"org.example.MyScopeResolver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>对于自动装配注解，参见<a href="/2018/07/28/Spring-Bean装配之Autowired注解/#more">Spring Bean装配之Autowired注解</a></p></blockquote><h4 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a>代理方式</h4><p>有三个值可选：<code>no</code>,<code>interfaces</code>,<code>targetClass</code>，默认情况下为no</p><p>可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value=<span class="string">"prototype"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure></p><p>可以在XML文件中使用<code>scope-proxy</code>属性指定代理<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">scope-proxy</span>=<span class="string">"interfaces"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="三、Resource-amp-ResourceLoader"><a href="#三、Resource-amp-ResourceLoader" class="headerlink" title="三、Resource&amp;ResourceLoader"></a>三、Resource&amp;ResourceLoader</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>针对资源文件的统一入口，用于Spring加载资源文件</p><ul><li>UrlResource:URL对应的资源，根据一个URL地址即可构建</li><li>ClassPathResource：获取类路径下的资源文件</li><li>FileSystemResource：获取文件系统里面的资源</li><li>ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源</li><li>InputStreamResource：针对于输入流封装的资源</li><li>ByArrayResource：针对于字节数组封装的资源</li></ul><h4 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h4><blockquote><p>i.所有的application contexts都实现了<code>ResourceLoader</code>接口，即可以通过<code>ApplicationContext</code>获得Resource实例<br>ii.使用参数的前缀说明获取资源的类型</p></blockquote><h5 id="1-类路径下的资源文件"><a href="#1-类路径下的资源文件" class="headerlink" title="1.类路径下的资源文件"></a>1.类路径下的资源文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"classpath:config.txt"</span>);</span><br></pre></td></tr></table></figure><h5 id="2-文件系统中的资源"><a href="#2-文件系统中的资源" class="headerlink" title="2.文件系统中的资源"></a>2.文件系统中的资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"file:/var/SpringDemo/src/main/resources/config.txt"</span>);</span><br></pre></td></tr></table></figure><h5 id="3-URL对应的资源"><a href="#3-URL对应的资源" class="headerlink" title="3.URL对应的资源"></a>3.URL对应的资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"url:httpS://www.pinnuli.com/index.html"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>没有前缀时，取决于<code>ApplicationContext</code>的路径（之后再添加解释）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"config.txt"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">慕课网：Spring入门篇</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Bean管理的XML配置实现&quot;&gt;&lt;a href=&quot;#一、Bean管理的XML配置实现&quot; class=&quot;headerlink&quot; title=&quot;一、Bean管理的XML配置实现&quot;&gt;&lt;/a&gt;一、Bean管理的XML配置实现&lt;/h3&gt;&lt;h4 id=&quot;1-Bean的配置
      
    
    </summary>
    
      <category term="Spring笔记" scheme="https://pinnuli.github.io/categories/Spring%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="https://pinnuli.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 监听器</title>
    <link href="https://pinnuli.github.io/2018/07/25/Java-Web-%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://pinnuli.github.io/2018/07/25/Java-Web-监听器/</id>
    <published>2018-07-25T11:50:55.000Z</published>
    <updated>2018-11-12T13:01:16.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="按监听的对象划分"><a href="#按监听的对象划分" class="headerlink" title="按监听的对象划分"></a>按监听的对象划分</h3><h4 id="1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口"><a href="#1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口" class="headerlink" title="1.用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口"></a>1.用于监听应用程序环境对象（<code>ServletContext</code>）的事件监听器，实现<code>ServletContextListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class="line">String initParam = servletcontextevent.getServletContext().getInitParameter(<span class="string">"initParam"</span>);</span><br><span class="line">System.out.println(<span class="string">"contextInitialized : initParam = "</span>+initParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"contextDestroyed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口"><a href="#2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口" class="headerlink" title="2.用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口"></a>2.用于监听用户会话对象（<code>HttpSession</code>）的事件监听器，实现<code>HttpSessionListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpSessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionCreated"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionDestroyed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口"><a href="#3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口" class="headerlink" title="3.用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口"></a>3.用于监听请求消息对象（<code>ServletRequest</code>）的事件监听器，实现<code>ServletRequestListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletRequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"requestDestroyed "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class="line">String name = servletrequestevent.getServletRequest().getParameter(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(<span class="string">"requestInitialized name:"</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="按监听的事件划分"><a href="#按监听的事件划分" class="headerlink" title="按监听的事件划分"></a>按监听的事件划分</h3><h4 id="1-监听域对象自身的创建和销毁的事件监听器"><a href="#1-监听域对象自身的创建和销毁的事件监听器" class="headerlink" title="1.监听域对象自身的创建和销毁的事件监听器"></a>1.监听域对象自身的创建和销毁的事件监听器</h4><blockquote><p>即按监听对象划分的那几种</p></blockquote><h4 id="2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口"><a href="#2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口" class="headerlink" title="2.监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener 或 ServletRequestAttributeListener接口"></a>2.监听域对象的属性的增加和删除的事件监听器，实现<code>ServletContextAttributeListener</code>，<code>HttpSessionAttributeListener</code> 或 <code>ServletRequestAttributeListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextAttributeListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ServletContext_attributeAdded:"</span>+servletcontextattributeevent.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ServletContext_attributeRemoved:"</span>+servletcontextattributeevent.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ServletContext_attributeReplaced:"</span>+servletcontextattributeevent.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>HttpSession</code> 和 <code>ServletRequest</code> 同理，只是方法参数类型不同</p></blockquote><h4 id="3-监听绑定到HttpSession域中的某个对象的状态的事件监听器"><a href="#3-监听绑定到HttpSession域中的某个对象的状态的事件监听器" class="headerlink" title="3.监听绑定到HttpSession域中的某个对象的状态的事件监听器"></a>3.监听绑定到<code>HttpSession</code>域中的某个对象的状态的事件监听器</h4><blockquote><p>这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">HttpSessionBindingListener</span>,<span class="title">HttpSessionActivationListener</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueBound</span><span class="params">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"valueBound Name:"</span>+httpsessionbindingevent.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueUnbound</span><span class="params">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"valueUnbound Name:"</span>+httpsessionbindingevent.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//钝化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionWillPassivate</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionWillPassivate "</span>+httpsessionevent.getSource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//活化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDidActivate</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionDidActivate "</span>+httpsessionevent.getSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定和解除绑定：实现<code>HttpSessionBindingListener</code>接口<br>钝化和活化：实现<code>HttpSessionActivationListener</code>和<code>Serializable</code>接口</p><blockquote><p>实现<code>Serializable</code>接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化</p><p>参阅：<br>  <a href="https://www.imooc.com/learn/271" target="_blank" rel="noopener">慕课网：JAVA Web开发技术应用——监听器</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;按监听的对象划分&quot;&gt;&lt;a href=&quot;#按监听的对象划分&quot; class=&quot;headerlink&quot; title=&quot;按监听的对象划分&quot;&gt;&lt;/a&gt;按监听的对象划分&lt;/h3&gt;&lt;h4 id=&quot;1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现Se
      
    
    </summary>
    
      <category term="JavaWeb笔记" scheme="https://pinnuli.github.io/categories/JavaWeb%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java Web 过滤器</title>
    <link href="https://pinnuli.github.io/2018/07/25/Java-Web-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://pinnuli.github.io/2018/07/25/Java-Web-过滤器/</id>
    <published>2018-07-25T06:36:41.000Z</published>
    <updated>2018-11-12T13:01:09.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器的工作原理"><a href="#过滤器的工作原理" class="headerlink" title="过滤器的工作原理"></a>过滤器的工作原理</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/filter_work_principle.png" alt="filetr_work_principle"></h2><h3 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/images/filter_lifecycle.png" alt=" filetr_lifecycle"></h2><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>Web项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？</p><p>过滤器链：<br><img src="/images/filter_chain.png" alt="filter_chain.png"><br>过滤器链执行过程:</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/images/filter_chain_process.png" alt="filter_chain_process.png"></h2><h3 id="过滤器分类"><a href="#过滤器分类" class="headerlink" title="过滤器分类"></a>过滤器分类</h3><p><img src="/images/filter_classify.png" alt="filter_classify"></p><blockquote><p><code>@WebFilter</code>,在servlet3中，可以使用<code>@WebFilter</code>注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置</p><p>参阅：<br>  <a href="https://www.imooc.com/learn/213" target="_blank" rel="noopener">慕课网：Java Web开发技术应用——过滤器</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;过滤器的工作原理&quot;&gt;&lt;a href=&quot;#过滤器的工作原理&quot; class=&quot;headerlink&quot; title=&quot;过滤器的工作原理&quot;&gt;&lt;/a&gt;过滤器的工作原理&lt;/h3&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;
      
    
    </summary>
    
      <category term="JavaWeb笔记" scheme="https://pinnuli.github.io/categories/JavaWeb%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
  </entry>
  
</feed>
