<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PINNULI&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinnuli.github.io/"/>
  <updated>2018-10-26T04:42:38.411Z</updated>
  <id>https://pinnuli.github.io/</id>
  
  <author>
    <name>pinnuli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的XML之与HTML的区别验证，定位信息，命名空间</title>
    <link href="https://pinnuli.github.io/2018/07/30/Java%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E4%B8%8EHTML%E7%9A%84%E5%8C%BA%E5%88%AB%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%AE%9A%E4%BD%8D%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://pinnuli.github.io/2018/07/30/Java中的XML之与HTML的区别验证，定位信息，命名空间/</id>
    <published>2018-07-30T04:19:45.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML与XML的区别"><a href="#HTML与XML的区别" class="headerlink" title="HTML与XML的区别"></a>HTML与XML的区别</h3><ul><li>HTML对大小写不敏感，XML大小写敏感</li><li>HTML结束标签可以省略，如<code>&lt;/p&gt;</code>，XML不能</li><li>XML只有单个标签而没有结束标签的元素必须以<code>/</code>结束</li><li>XML属性值必须用引号括起来</li><li>HTML属性可以没有值，XML所有属性必须有值    </li></ul><hr><h3 id="验证XML文档"><a href="#验证XML文档" class="headerlink" title="验证XML文档"></a>验证XML文档</h3><p>需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema</p><h4 id="文档类型定义"><a href="#文档类型定义" class="headerlink" title="文档类型定义"></a>文档类型定义</h4><ul><li>将这些规则纳入XML文档</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration[</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    &lt;!ELEMENT configuration...&gt;</span></span><br><span class="line"><span class="meta">    ...</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这些规则被纳入到DOCTYPE声明中，代码块[…]用来限定其界限，比如configuration</p></blockquote><ul><li>SYSTEM声明，将DTD存储在外面</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE configuration SYSTEM "config.dtd"&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration SYSTEM "http://myserver.com/config.dtd"&gt;</span></span><br></pre></td></tr></table></figure><ul><li>标记PUBLIC标识符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEntityResolver</span> <span class="keyword">implements</span> <span class="title">EntityResolver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputSource <span class="title">resolveEntity</span><span class="params">(String publicId, String systemID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(publicID.equals(a knowx ID))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InputSource(DTD data):</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空</p></blockquote><h4 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h4><ul><li><p>声明Schema文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用xsd:表示XSL Schema定义的命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">- ref属性引用Schema中位于别处的定义</span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">ref</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"style"</span> <span class="attr">type</span>=<span class="string">StyleType</span>"/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">"PLAIN"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="使用XPath定位信息"><a href="#使用XPath定位信息" class="headerlink" title="使用XPath定位信息"></a>使用XPath定位信息</h3><ul><li><p>查找下列的username的值，,通过XPath表达式/configuration/database/username</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configfuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">database</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>pinnuli<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configfuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XPathFactory xpFactory = XPathFactory.newInstance();</span><br><span class="line">path = xpfactory.newXPath();</span><br><span class="line">String username = path.evaluate(/configuration/database/username",doc);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>具体的语法看文档</p></blockquote><hr><h3 id="XML的命名空间"><a href="#XML的命名空间" class="headerlink" title="XML的命名空间"></a>XML的命名空间</h3><ul><li><p>使用xmlns给定命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">xmlns</span>=<span class="string">"namespaceURI1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">xmlns</span>=<span class="string">"namespaceURI2"</span>&gt;</span></span><br><span class="line">        grandchildren</span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里第一个子元素和孙元素都是第二个命名空间的一部分</p></blockquote></li><li><p>使用xmlns:prefix=”namespaceURI”定义命名空间和前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</span><br><span class="line">    &lt;xsd:element name=&quot;pinnuli&quot; type=&quot;haha&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/xsd:schema&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在这里xsd:schema实际上指的是命名空间<code>http://www.w3.org/2001/XMLSchema</code>中的<code>schema</code></p></blockquote></li><li>可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factory.serNamespaceAware(true);</span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/171" target="_blank" rel="noopener">慕课网：Java眼中的XML—文件读取</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML与XML的区别&quot;&gt;&lt;a href=&quot;#HTML与XML的区别&quot; class=&quot;headerlink&quot; title=&quot;HTML与XML的区别&quot;&gt;&lt;/a&gt;HTML与XML的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HTML对大小写不敏感，XML大小写敏感&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
      <category term="XML" scheme="https://pinnuli.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J</title>
    <link href="https://pinnuli.github.io/2018/07/30/Java%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%94%9F%E6%88%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J/"/>
    <id>https://pinnuli.github.io/2018/07/30/Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J/</id>
    <published>2018-07-30T04:17:44.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<p>现有以下XML文档books.xml,下面的示例生成此文档部分内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>冰与火之歌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>乔治马丁<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2014<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>89<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>安徒生童话<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2004<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>77<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">language</span>&gt;</span>English<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>1、创建DocumentBuilder对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p><p>2、添加节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">document.setXmlStandalone(<span class="keyword">true</span>);</span><br><span class="line">Element bookstore = document.createElement(<span class="string">"bookStore"</span>);</span><br><span class="line"><span class="comment">//向bookstore根节点中添加子节点book</span></span><br><span class="line">Element book = document.createElement(<span class="string">"book"</span>);</span><br><span class="line">Element name = document.createElement(<span class="string">"name"</span>);</span><br><span class="line">name.setTextContent(<span class="string">"???"</span>);</span><br><span class="line"></span><br><span class="line">book.appendChild(name);</span><br><span class="line">book.setAttribute(<span class="string">"id"</span>, <span class="string">"1"</span>);</span><br><span class="line"><span class="comment">//将book节点添加到bookstore根节点中</span></span><br><span class="line">bookstore.appendChild(book);</span><br><span class="line"><span class="comment">//将bookstore节点（已经包含了book）添加到dom树中</span></span><br><span class="line">document.appendChild(bookstore);</span><br></pre></td></tr></table></figure></p><p>3、生成xml文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory tff = TransformerFactory.newInstance();</span><br><span class="line">Transformer tf = tff.newTransformer();</span><br><span class="line"><span class="comment">//设置文件</span></span><br><span class="line">tf.setOutputProperty(OutputKeys.INDENT, <span class="string">"yes"</span>);</span><br><span class="line">tf.transform(<span class="keyword">new</span> DOMSource(document),<span class="keyword">new</span> StreamResult(<span class="keyword">new</span> File(<span class="string">"books1.xml"</span>)));</span><br></pre></td></tr></table></figure></p><hr><h3 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h3><p>1、创建一个TransformerFactory类的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance();</span><br></pre></td></tr></table></figure></p><p>2、通过SAXTransformerFactory对象创建一个TransformerHandler对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransformerHandler handler = tff.newTransformerHandler();</span><br></pre></td></tr></table></figure></p><p>3、通过handler对象创建一个Transformer对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transformer tr = handler.getTransformer();</span><br></pre></td></tr></table></figure></p><p>4、通过Transformer对象对生成的xml文件进行设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设置xml的编码</span><br><span class="line">tr.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span><br><span class="line">// 设置xml的“是否换行”</span><br><span class="line">tr.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class="line">5、创建一个Result对象</span><br><span class="line">```java</span><br><span class="line">File f = new File(&quot;newbooks.xml&quot;);</span><br><span class="line">if (!f.exists()) &#123;</span><br><span class="line">    f.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、创建Result对象，并且使其与handler关联<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Result result = <span class="keyword">new</span> StreamResult(<span class="keyword">new</span> FileOutputStream(f));</span><br><span class="line">handler.setResult(result);</span><br></pre></td></tr></table></figure></p><p>7、利用handler对象进行xml文件内容的编写O<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开document</span></span><br><span class="line">handler.startDocument();</span><br></pre></td></tr></table></figure></p><p>8、添加节点属性和节点值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">AttributesImpl attr = <span class="keyword">new</span> AttributesImpl();</span><br><span class="line">handler.startElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"bookstore"</span>, attr);</span><br><span class="line"><span class="keyword">for</span> (Book book : bookList) &#123;</span><br><span class="line">    attr.clear();</span><br><span class="line">    attr.addAttribute(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"id"</span>, <span class="string">""</span>, book.getId());</span><br><span class="line">    handler.startElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"book"</span>, attr);</span><br><span class="line">    <span class="comment">// 创建name节点</span></span><br><span class="line">    <span class="keyword">if</span> (book.getName() != <span class="keyword">null</span> &amp;&amp; !book.getName().trim().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        attr.clear();</span><br><span class="line">        handler.startElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"name"</span>, attr);</span><br><span class="line">        handler.characters(book.getName().toCharArray(), <span class="number">0</span>, book</span><br><span class="line">                .getName().length());</span><br><span class="line">        handler.endElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    handler.endElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"book"</span>);</span><br><span class="line">&#125;</span><br><span class="line">handler.endElement(<span class="string">""</span>, <span class="string">""</span>, <span class="string">"bookstore"</span>);</span><br><span class="line"><span class="comment">// 关闭document</span></span><br><span class="line">handler.endDocument();</span><br></pre></td></tr></table></figure></p><hr><h3 id="JDOM"><a href="#JDOM" class="headerlink" title="JDOM"></a>JDOM</h3><p>1.生成一个根节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rss = <span class="keyword">new</span> Element(<span class="string">"rss"</span>);</span><br></pre></td></tr></table></figure></p><p>2.为节点添加属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss.setAttribute(<span class="string">"version"</span>, <span class="string">"2.0"</span>);</span><br></pre></td></tr></table></figure></p><p>3.生成一个document对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Document document = <span class="keyword">new</span> Document(rss);</span><br><span class="line">Element channel = <span class="keyword">new</span> Element(<span class="string">"channel"</span>);</span><br><span class="line">rss.addContent(channel);</span><br><span class="line">Element title = <span class="keyword">new</span> Element(<span class="string">"title"</span>);</span><br><span class="line">title.setText(<span class="string">"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;"</span>);</span><br><span class="line">channel.addContent(title);</span><br><span class="line"><span class="comment">//设置文件编码和换行</span></span><br><span class="line">Format format = Format.getCompactFormat();</span><br><span class="line">format.setIndent(<span class="string">""</span>);</span><br><span class="line">format.setEncoding(<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure></p><p>4.创建XMLOutputter的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLOutputter outputer = <span class="keyword">new</span> XMLOutputter(format);</span><br></pre></td></tr></table></figure></p><p>5.利用outputer将document对象转换成xml文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputer.output(document, <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"rssnews.xml"</span>)));</span><br></pre></td></tr></table></figure></p><hr><h3 id="DOM4J"><a href="#DOM4J" class="headerlink" title="DOM4J"></a>DOM4J</h3><blockquote><p>使用DOM4J生成RSS文件</p></blockquote><p>1.创建document对象，代表整个xml文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document document = DocumentHelper.createDocument();</span><br></pre></td></tr></table></figure></p><p>2.创建根节点rss<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rss = document.addElement(<span class="string">"rss"</span>);</span><br></pre></td></tr></table></figure></p><p>3.向rss节点中添加version属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss.addAttribute(<span class="string">"version"</span>, <span class="string">"2.0"</span>);</span><br></pre></td></tr></table></figure></p><p>4.生成子节点及节点内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Element channel = rss.addElement(<span class="string">"channel"</span>);</span><br><span class="line">Element title = channel.addElement(<span class="string">"title"</span>);</span><br><span class="line">title.setText(<span class="string">"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;"</span>);</span><br></pre></td></tr></table></figure></p><p>5.设置生成xml的格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">format.setEncoding(<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure></p><p>6.生成xml文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"rssnews.xml"</span>);</span><br><span class="line">XMLWriter writer;</span><br><span class="line">writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileOutputStream(file), format);</span><br><span class="line"><span class="comment">//设置是否转义，默认值是true，代表转义</span></span><br><span class="line">writer.setEscapeText(<span class="keyword">false</span>);</span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></p><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/171" target="_blank" rel="noopener">慕课网：Java眼中的XML—文件读取</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现有以下XML文档books.xml,下面的示例生成此文档部分内容&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
      <category term="XML" scheme="https://pinnuli.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J</title>
    <link href="https://pinnuli.github.io/2018/07/30/Java%E4%B8%AD%E7%9A%84XML%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%A7%A3%E6%9E%90XML%E6%96%87%E6%A1%A3%EF%BC%9ADOM%EF%BC%8CSAX%EF%BC%8CJDOM%EF%BC%8CDOM4J/"/>
    <id>https://pinnuli.github.io/2018/07/30/Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J/</id>
    <published>2018-07-30T04:17:35.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<p>现有以下XML文档books.xml,下面的解析示例解析此文档部分内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>冰与火之歌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>乔治马丁<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2014<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>89<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>安徒生童话<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">year</span>&gt;</span>2004<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>77<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">language</span>&gt;</span>English<span class="tag">&lt;/<span class="name">language</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h3><p>1、创建一个DocumentBuilder的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p><p>2、调用parser方法加载books.xml文件到当前项目下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document document = db.parse(<span class="string">"books.xml"</span>);</span><br></pre></td></tr></table></figure></p><p>3、进行解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有book节点的集合</span></span><br><span class="line">NodeList bookList = document.getElementsByTagName(<span class="string">"book"</span>);</span><br><span class="line"><span class="comment">//?????book??</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookList.getLength(); i++) &#123;</span><br><span class="line">    <span class="comment">//通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始</span></span><br><span class="line">    Node book = bookList.item(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取book节点的所有属性集合</span></span><br><span class="line">    NamedNodeMap attrs = book.getAttributes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前提：已经知道book节点有且只能有1个id属性</span></span><br><span class="line">    <span class="comment">//将book节点进行强制类型转换，转换成Element类型</span></span><br><span class="line">    Element book = (Element) bookList.item(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过getAttribute("id")方法获取属性值</span></span><br><span class="line">    String attrValue = book.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析book节点的子节点</span></span><br><span class="line">    NodeList childNodes = book.getChildNodes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>更多解析方法查看API</p></blockquote><hr><h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p>1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory factory = SAXParserFactory.newInstance();</span><br></pre></td></tr></table></figure></p><p>2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXParser parser = factory.newSAXParser();</span><br></pre></td></tr></table></figure></p><p>3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXParserHandler handler = <span class="keyword">new</span> SAXParserHandler();</span><br><span class="line">parser.parse(<span class="string">"books.xml"</span>, handler);</span><br></pre></td></tr></table></figure></p><p>handler类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识解析开始</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">super</span>.startDocument();</span><br><span class="line">    System.out.println(<span class="string">"SAX解析开始"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标识解析结束</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">super</span>.endDocument();</span><br><span class="line">    System.out.println(<span class="string">"SAX解析结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析xml元素</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName,</span></span></span><br><span class="line"><span class="function"><span class="params">        Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">//调用DefaultHandler类的startElement方法</span></span><br><span class="line">    <span class="keyword">super</span>.startElement(uri, localName, qName, attributes);</span><br><span class="line">    <span class="keyword">if</span> (qName.equals(<span class="string">"book"</span>)) &#123;</span><br><span class="line">        <span class="comment">//已知book元素下属性的名称，根据属性名称获取属性值</span></span><br><span class="line">        String value = attributes.getValue(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(<span class="string">"book的属性值是："</span> + value);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!qName.equals(<span class="string">"name"</span>) &amp;&amp; !qName.equals(<span class="string">"bookstore"</span>)) &#123;</span><br><span class="line">        System.out.print(<span class="string">"节点名是："</span> + qName + <span class="string">"---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">//调用DefaultHandler类的endElement方法</span></span><br><span class="line">    <span class="keyword">super</span>.endElement(uri, localName, qName);</span><br><span class="line">    <span class="comment">//判断是否针对一本书已经遍历结束</span></span><br><span class="line">    <span class="keyword">if</span> (qName.equals(<span class="string">"book"</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"结束遍历某一本书的内容"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">super</span>.characters(ch, start, length);</span><br><span class="line">    value = <span class="keyword">new</span> String(ch, start, length);</span><br><span class="line">    <span class="keyword">if</span> (!value.trim().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"节点值是："</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="JDOM解析"><a href="#JDOM解析" class="headerlink" title="JDOM解析"></a>JDOM解析</h3><p>1、创建一个SAXBuilder的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder saxBuilder = new SAXBuilder();</span><br></pre></td></tr></table></figure></p><p>2、创建一个输入流，将xml文件加载到输入流中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in = new FileInputStream(&quot;books.xml&quot;);</span><br></pre></td></tr></table></figure></p><p>3、通过saxBuilder的build方法，将输入流加载到saxBuilder中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document document = saxBuilder.build(in);</span><br></pre></td></tr></table></figure></p><p>4、通过document对象获取xml文件的根节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element rootElement = document.getRootElement();</span><br></pre></td></tr></table></figure></p><p>5、获取根节点下的子节点的List集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; bookList = rootElement.getChildren();</span><br><span class="line">for (Element book : bookList) &#123;</span><br><span class="line">    // 解析book的属性集合</span><br><span class="line">    List&lt;Attribute&gt; attrList = book.getAttributes();</span><br><span class="line">    //知道节点下属性名称时，获取节点值</span><br><span class="line">    book.getAttributeValue(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">    // 对book节点的子节点的节点名以及节点值的遍历</span><br><span class="line">    List&lt;Element&gt; bookChilds = book.getChildren();</span><br><span class="line">    for (Element child : bookChilds) &#123;</span><br><span class="line">        System.out.println(&quot;????&quot; + child.getName() + &quot;----????&quot;</span><br><span class="line">                + child.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果需要设置编码可以按照以下方式设置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in, <span class="string">"UTF-8"</span>);</span><br><span class="line">Document document = saxBuilder.build(isr);</span><br></pre></td></tr></table></figure><hr><h3 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h3><p>1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document document = reader.read(<span class="keyword">new</span> File(<span class="string">"src/res/books.xml"</span>));</span><br></pre></td></tr></table></figure></p><p>2、通过document对象获取根节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element bookStore = document.getRootElement();</span><br></pre></td></tr></table></figure></p><p>3、通过element对象的elementIterator方法获取迭代器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookStore.elementIterator();</span><br></pre></td></tr></table></figure></p><p>4、遍历迭代器，获取根节点中的信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Element book = (Element) it.next();</span><br><span class="line">    <span class="comment">// 获取book的属性名以及 属性值</span></span><br><span class="line">    List&lt;Attribute&gt; bookAttrs = book.attributes();</span><br><span class="line">    <span class="keyword">for</span> (Attribute attr : bookAttrs) &#123;</span><br><span class="line">        System.out.println(<span class="string">"????"</span> + attr.getName() + <span class="string">"--????"</span></span><br><span class="line">                + attr.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历子节点</span></span><br><span class="line">    Iterator itt = book.elementIterator();</span><br><span class="line">    <span class="keyword">while</span> (itt.hasNext()) &#123;</span><br><span class="line">        Element bookChild = (Element) itt.next();</span><br><span class="line">        System.out.println(<span class="string">"????"</span> + bookChild.getName() + <span class="string">"--????"</span> + bookChild.getStringValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="四种解析方式的区别"><a href="#四种解析方式的区别" class="headerlink" title="四种解析方式的区别"></a>四种解析方式的区别</h3><ul><li>DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时<blockquote><p>优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改<br>  缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出</p></blockquote></li><li>SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时<blockquote><p>优点：内存消耗小<br>  缺点：不易编码；很难同时访问同一个xml中的多处不同数据</p></blockquote></li><li>JDOM：API大量使用了Collections类</li><li>DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用</li></ul><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/171" target="_blank" rel="noopener">慕课网：Java眼中的XML—文件读取</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现有以下XML文档books.xml,下面的解析示例解析此文档部分内容&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
      <category term="XML" scheme="https://pinnuli.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean装配之基于Java的容器注解 </title>
    <link href="https://pinnuli.github.io/2018/07/29/Spring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://pinnuli.github.io/2018/07/29/Spring-Bean装配之基于Java的容器注解/</id>
    <published>2018-07-29T09:13:43.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的<bean>，通常和<code>@Configuration</code>配合使用</bean></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"store"</span>,initMethod = <span class="string">"init"</span>,destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanStore <span class="title">beanStore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于以下XML配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"store"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.beanannotation.BeanStore"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>如果<code>@Bean</code>没有指定名称，则默认为方法名，这里即是beanStore。<br><br>如果需要指定范围，即XML配置时的属性<code>scope</code>，那么可以用<code>@Scop</code>e注解，且可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value=<span class="string">"prototype"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure><hr><h3 id="ImportResource-Value"><a href="#ImportResource-Value" class="headerlink" title="@ImportResource,@Value"></a>@ImportResource,@Value</h3><blockquote><p>通过<code>@ImportResource</code>加载资源文件,<code>@Value</code>获取属性值，比如有文件<code>config.properties</code>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.username=root</span><br><span class="line">password=root</span><br><span class="line">url=127.0.0.1</span><br></pre></td></tr></table></figure></p></blockquote><p>则可以通过将此内容配置到XML文件，如<code>config.xml</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/config.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后在定义<code>bean</code>时，通过<code>@ImportResource</code>加载文件，通过<code>@Value</code>获取属性的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:config.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyDriverManager <span class="title">myDriverManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyDriverManager(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：这里的用户名字段如果直接为<code>username</code>，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如<code>jdbc.username</code>,<code>jdbc.password</code>等</p></blockquote><hr><h3 id="基于泛型的自动装配"><a href="#基于泛型的自动装配" class="headerlink" title="基于泛型的自动装配"></a>基于泛型的自动装配</h3><p>比如现有如下接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Store</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>IntegerStore</code>和<code>StringStore</code>是他的两个实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerStore</span> <span class="keyword">implements</span> <span class="title">Store</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringStore</span> <span class="keyword">implements</span> <span class="title">Store</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在定义<code>bean</code>时可以按照如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>那么<code>s1</code>将会自动装配到<code>StringStore</code>，<code>s2</code>将会是<code>IntegerStore</code></p></blockquote><hr><h3 id="JSR支持"><a href="#JSR支持" class="headerlink" title="JSR支持"></a>JSR支持</h3><h4 id="JSR250的支持"><a href="#JSR250的支持" class="headerlink" title="JSR250的支持"></a>JSR250的支持</h4><p>1.@Resource<br>注解变量或方法，且有一个name属性值，默认<code>Spring</code>解释改值为被注入<code>bea</code>n的名称，若没有指定<code>name</code>,那么名称从方法名或者属性名得出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsrServie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> JsrDAO jsrDAO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJsrDAO</span><span class="params">(@Named(<span class="string">"jsrDAO"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jsrDAO = jsrDAO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.@PostConstruct和@PreDestroy<br><code>@PostConstruct</code>,初始化，相当于<code>init-Method</code>属性<br><code>@PreDestroy</code>，销毁，相当于<code>destroy-Method</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="JSR330的支持"><a href="#JSR330的支持" class="headerlink" title="JSR330的支持"></a>JSR330的支持</h4><blockquote><p>需要依赖<code>javax.injet</code>包</p></blockquote><p>1.@Inject<br>与<code>@Autowired</code>等效，可以使用于类，属性，方法，构造器<br>2.@Named<br>使用特定名称进行依赖注入，与<code>@Component</code>等效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsrServie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="keyword">private</span> JsrDAO jsrDAO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJsrDAO</span><span class="params">(@Named(<span class="string">"jsrDAO"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jsrDAO = jsrDAO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参阅:<br>  <a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">慕课网：Spring入门篇</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Bean&quot;&gt;&lt;a href=&quot;#Bean&quot; class=&quot;headerlink&quot; title=&quot;@Bean&quot;&gt;&lt;/a&gt;@Bean&lt;/h3&gt;&lt;p&gt;用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的&lt;bean&gt;，通常和&lt;code&gt;@
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="https://pinnuli.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean装配之Autowired注解</title>
    <link href="https://pinnuli.github.io/2018/07/28/Spring-Bean%E8%A3%85%E9%85%8D%E4%B9%8BAutowired%E6%B3%A8%E8%A7%A3/"/>
    <id>https://pinnuli.github.io/2018/07/28/Spring-Bean装配之Autowired注解/</id>
    <published>2018-07-28T14:36:17.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-可以将-Autowired注解为setter方法"><a href="#1-可以将-Autowired注解为setter方法" class="headerlink" title="1.可以将@Autowired注解为setter方法"></a>1.可以将@Autowired注解为setter方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-可以用于构造器或成员变量"><a href="#2-可以用于构造器或成员变量" class="headerlink" title="2.可以用于构造器或成员变量"></a>2.可以用于构造器或成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>(required=<span class="keyword">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，如果因找不到合适的<code>bean</code>将会导致<code>autowiring</code>失败抛出异常，可以通过将其<code>required</code>设置为false表示并非必须，每个类只能有一个构造器标记为<code>required=true</code>,也就是只能有一个构造器为必须，这种情况下建议使用<code>@Required</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Required</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@Required</code>表示标记的<code>bean</code>属性在<code>bean</code>装配时必须被填充，通过在<code>bean</code>定义或者自动装配一个明确的属性值</p></blockquote><hr><h3 id="3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等"><a href="#3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等" class="headerlink" title="3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等"></a>3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanSutowired</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean"><a href="#4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean" class="headerlink" title="4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean"></a>4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean</h3><p>下面的示例中，<code>list</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，假如有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时<code>list</code>中将包含有<code>BeanimplOne</code>和<code>BeanimplTwo</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInvoker</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"list..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (BeanInterface bean : list) &#123;</span><br><span class="line">            System.out.println(bean.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果希望数组有序，可以使用<code>@Order</code>注解或者实现<code>org.springframework.core.Ordered</code>接口，但是对<code>map</code>无效</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanimplTwo</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-用于装配key为String的Map"><a href="#5-用于装配key为String的Map" class="headerlink" title="5.用于装配key为String的Map"></a>5.用于装配key为String的Map</h3><p>下面的示例中，<code>map</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，加入有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时map中将包含有键为<code>bean</code>名称和值为<code>bean</code>的两个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInvoker</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanInterface&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"map..."</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanInterface&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"      "</span> + entry.getValue().getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="6-Qualifier"><a href="#6-Qualifier" class="headerlink" title="6.@Qualifier"></a>6.@Qualifier</h3><ul><li>按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"beanImplTwo"</span>)</span><br><span class="line"><span class="keyword">private</span> BeanInterface beanInterface;</span><br></pre></td></tr></table></figure><ul><li>用于指定单独的构造器参数或方法参数</li><li>用于注解集合类型变量</li></ul><p>可以在bean的定义中使用<code>@Qualifier</code>注解给他限定一个范围，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"beanImpl"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanImplTwo</span> <span class="keyword">implements</span> <span class="title">BeanInterface</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在注入时，使用<code>@Qualifier</code>限定，则下面的<code>list</code>将会匹配到所有<code>@Qualifier(&quot;beanImp&quot;)</code>的<code>bean</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"beanImpl"</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;BeanInterface&gt; list;</span><br></pre></td></tr></table></figure></p><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">慕课网：Spring入门篇</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-可以将-Autowired注解为setter方法&quot;&gt;&lt;a href=&quot;#1-可以将-Autowired注解为setter方法&quot; class=&quot;headerlink&quot; title=&quot;1.可以将@Autowired注解为setter方法&quot;&gt;&lt;/a&gt;1.可以将@Au
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="https://pinnuli.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean装配之各装配项 XML实现和注解实现</title>
    <link href="https://pinnuli.github.io/2018/07/27/Spring-Bean%E8%A3%85%E9%85%8D%E4%B9%8B%E5%90%84%E8%A3%85%E9%85%8D%E9%A1%B9-XML%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0/"/>
    <id>https://pinnuli.github.io/2018/07/27/Spring-Bean装配之各装配项-XML实现和注解实现/</id>
    <published>2018-07-27T10:56:18.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Bean管理的XML配置实现"><a href="#一、Bean管理的XML配置实现" class="headerlink" title="一、Bean管理的XML配置实现"></a>一、Bean管理的XML配置实现</h3><h4 id="1-Bean的配置项"><a href="#1-Bean的配置项" class="headerlink" title="1.Bean的配置项"></a>1.Bean的配置项</h4><ul><li><code>Id</code>:Bean的唯一标识</li><li><code>Class</code>：对应实现的类</li><li><code>Scope</code>：范围</li><li><code>Constructor arguments</code>：构造器参数</li><li><code>Properties</code>：属性</li><li><code>Autowiring mode</code>：自动装配模式 </li><li><code>lazy-initialization mode</code>：懒加载模式</li><li><code>Initialization/destruction method</code>：初始化/销毁方法</li></ul><h4 id="2-Bean的定义"><a href="#2-Bean的定义" class="headerlink" title="2.Bean的定义"></a>2.Bean的定义</h4><p>这里以<code>InjectionImpl</code>中包含<code>InjectionDAO</code>成员变量为例，说明设置注入和构造注入,<code>InjectionImpl</code>类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionServiceImpl</span> <span class="keyword">implements</span> <span class="title">InjectionService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InjectionDAO injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式一：设置注入"><a href="#方式一：设置注入" class="headerlink" title="方式一：设置注入"></a>方式一：设置注入</h5><p><code>bean</code>的XML配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionService"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"injectionDAO"</span> <span class="attr">ref</span>=<span class="string">"injectionDAO"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionDAO"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>InjectionIml</code>中setter方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectionDAO</span><span class="params">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：构造注入"><a href="#方式二：构造注入" class="headerlink" title="方式二：构造注入"></a>方式二：构造注入</h5><p>bean的XML配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionService"</span> <span class="attr">class</span>=<span class="string">"com.imooc.ioc.injection.service.InjectionServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"injectionDAO"</span> <span class="attr">ref</span>=<span class="string">"injectionDAO"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"injectionDAO"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>InjectionIml</code>中构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InjectionServiceImpl</span><span class="params">(InjectionDAOImpl injectionDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.injectionDAO = injectionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Bean的作用域"><a href="#2-Bean的作用域" class="headerlink" title="2.Bean的作用域"></a>2.Bean的作用域</h4><ul><li><code>singleton</code>:单例，一个Bean容器中指存在一份（默认情况下为singleton)</li><li><code>prototype</code>：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效</li><li><code>request</code>：每次http请求创建一个实例且仅在当前request内有效</li><li><code>session</code>：同上，每次http请求创建，当前session有效</li><li><code>global session</code>：给予portel的web中有效，如果是在web中，则同session</li></ul><p>XML文件中的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanScope"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.bean.BeanScope"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="3-Bean的生命周期"><a href="#3-Bean的生命周期" class="headerlink" title="3.Bean的生命周期"></a>3.Bean的生命周期</h4><blockquote><p>定义 &rArr; 初始化 &rArr;    使用 &rArr; 销毁</p></blockquote><p><strong>初始化</strong></p><h5 id="方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法"><a href="#方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法" class="headerlink" title="方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法"></a>方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInitializingBean</span> <span class="keyword">implements</span> <span class="title">InitialingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：配置init-method"><a href="#方式二：配置init-method" class="headerlink" title="方式二：配置init-method"></a>方式二：配置init-method</h5><p>XML文件中的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"example.Example"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>对应实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>销毁:</strong></p><h5 id="方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法"><a href="#方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法" class="headerlink" title="方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法"></a>方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleInitializingBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二：配置destory-method"><a href="#方式二：配置destory-method" class="headerlink" title="方式二：配置destory-method"></a>方式二：配置destory-method</h5><p>XML文件中的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"example.Example"</span> <span class="attr">init-method</span>=<span class="string">"destroy"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>destory</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="配置全局默认初始化、销毁方法"><a href="#配置全局默认初始化、销毁方法" class="headerlink" title="配置全局默认初始化、销毁方法"></a>配置全局默认初始化、销毁方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-init-method</span>=<span class="string">"init"</span> <span class="attr">default-destroy-mothod</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效；<br>  ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错；<br>  iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。</p></blockquote><h4 id="4-Bean的自动装配"><a href="#4-Bean的自动装配" class="headerlink" title="4.Bean的自动装配"></a>4.Bean的自动装配</h4><ul><li><code>No</code>：什么都不操作</li><li><code>byname</code>：即<bean>中的<code>id</code>，根据属性名自动装配，</bean></li><li><code>byType</code>：即<bean>中的<code>class</code></bean></li></ul><blockquote><p>i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；<br>ii.如果存在多个该类型的bean，则抛出异常，并指出不能使用<code>byType</code>方式进行自动装配<br>iii.如果没有找到匹配的bean，则不进行任何操作<br>以上两种情况bean的XML配置如下：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byType"</span>/"<span class="attr">byName</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoWiringService"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.autowiring.AutoWiringService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"autoWiringDAO"</span> <span class="attr">class</span>=<span class="string">"com.pinnuli.spring.ioc.autowiring.AutoWiringDAO"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>Constructor</code>: 应用于构造器参数，与<code>byType</code>类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常</li></ul><blockquote><p>对应的类中的构造方法和setter方法与设置注入或构造注入一致</p></blockquote><hr><h3 id="二、Bean管理的注解实现"><a href="#二、Bean管理的注解实现" class="headerlink" title="二、Bean管理的注解实现"></a>二、Bean管理的注解实现</h3><h4 id="1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类："><a href="#1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类：" class="headerlink" title="1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类："></a>1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span> &gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;context:annotation-config/&gt;</code><br>仅会查找同一个<code>applicat context</code>中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解<br>通过在基于XML的Spring配置如下标签</li></ul><ul><li><code>&lt;context:component-scan&gt;</code>会扫描所有有bean注解的类，并注册到IOC容器，包含了<code>&lt;context:annotation-config&gt;</code>的全部功能，因而通常只需要使用前者，而不用后者</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>base-package表示扫描包下的所有类</p></blockquote><h4 id="2-使用过滤器进行自定义扫描"><a href="#2-使用过滤器进行自定义扫描" class="headerlink" title="2.使用过滤器进行自定义扫描"></a>2.使用过滤器进行自定义扫描</h4><p>默认情况下，类被自动发现并注册bean的条件是：使用了<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>注解，或者使用@<code>Component</code>的自定义注解，可以通过过滤器修改上述的行为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"regex"</span> <span class="attr">expression</span>=<span class="string">".*Stub.*Respository"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Repository"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>还可以使用<code>use-default-filters=&quot;false&quot;</code>禁用自动发现与注册</p></blockquote><h4 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h4><p>Bean名称是由<code>BeannameGenerator</code>生成的，默认情况下为类名的首字母变为小写</p><blockquote><p><code>@Component</code>，<code>@Repository</code>，<code>@Service</code>,<code>@Controller</code>都有一个那么属性用于显示设置Bean的名称,如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"beanName"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanAnnotation</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>也可自定义命名策略,实现<code>BeanNameGenerator</code>接口，并一定要包含一个无参构造器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">name-generator</span>=<span class="string">"org.example.MyNameGenerator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>通常情况下启动查找的Spring组件，其scope是<code>singleton</code>，可用<code>@Scope</code>表示scope,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br></pre></td></tr></table></figure></p><p>也可自定义scope策略，实现实现<code>ScopeMetadataResolver</code>接口，并一定要包含一个无参构造器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">name-generator</span>=<span class="string">"org.example.MyScopeResolver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>对于自动装配注解，参见<a href="/2018/07/28/Spring-Bean装配之Autowired注解/#more">Spring Bean装配之Autowired注解</a></p></blockquote><h4 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a>代理方式</h4><p>有三个值可选：<code>no</code>,<code>interfaces</code>,<code>targetClass</code>，默认情况下为no</p><p>可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value=<span class="string">"prototype"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure></p><p>可以在XML文件中使用<code>scope-proxy</code>属性指定代理<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span> <span class="attr">scope-proxy</span>=<span class="string">"interfaces"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="三、Resource-amp-ResourceLoader"><a href="#三、Resource-amp-ResourceLoader" class="headerlink" title="三、Resource&amp;ResourceLoader"></a>三、Resource&amp;ResourceLoader</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>针对资源文件的统一入口，用于Spring加载资源文件</p><ul><li>UrlResource:URL对应的资源，根据一个URL地址即可构建</li><li>ClassPathResource：获取类路径下的资源文件</li><li>FileSystemResource：获取文件系统里面的资源</li><li>ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源</li><li>InputStreamResource：针对于输入流封装的资源</li><li>ByArrayResource：针对于字节数组封装的资源</li></ul><h4 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h4><blockquote><p>i.所有的application contexts都实现了<code>ResourceLoader</code>接口，即可以通过<code>ApplicationContext</code>获得Resource实例<br>ii.使用参数的前缀说明获取资源的类型</p></blockquote><h5 id="1-类路径下的资源文件"><a href="#1-类路径下的资源文件" class="headerlink" title="1.类路径下的资源文件"></a>1.类路径下的资源文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"classpath:config.txt"</span>);</span><br></pre></td></tr></table></figure><h5 id="2-文件系统中的资源"><a href="#2-文件系统中的资源" class="headerlink" title="2.文件系统中的资源"></a>2.文件系统中的资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"file:/var/SpringDemo/src/main/resources/config.txt"</span>);</span><br></pre></td></tr></table></figure><h5 id="3-URL对应的资源"><a href="#3-URL对应的资源" class="headerlink" title="3.URL对应的资源"></a>3.URL对应的资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"url:httpS://www.pinnuli.com/index.html"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>没有前缀时，取决于<code>ApplicationContext</code>的路径（之后再添加解释）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = applicationContext.getResource(<span class="string">"config.txt"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/196" target="_blank" rel="noopener">慕课网：Spring入门篇</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Bean管理的XML配置实现&quot;&gt;&lt;a href=&quot;#一、Bean管理的XML配置实现&quot; class=&quot;headerlink&quot; title=&quot;一、Bean管理的XML配置实现&quot;&gt;&lt;/a&gt;一、Bean管理的XML配置实现&lt;/h3&gt;&lt;h4 id=&quot;1-Bean的配置
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="https://pinnuli.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 监听器</title>
    <link href="https://pinnuli.github.io/2018/07/25/Java-Web-%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://pinnuli.github.io/2018/07/25/Java-Web-监听器/</id>
    <published>2018-07-25T11:50:55.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="按监听的对象划分"><a href="#按监听的对象划分" class="headerlink" title="按监听的对象划分"></a>按监听的对象划分</h3><h4 id="1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口"><a href="#1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口" class="headerlink" title="1.用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口"></a>1.用于监听应用程序环境对象（<code>ServletContext</code>）的事件监听器，实现<code>ServletContextListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class="line">String initParam = servletcontextevent.getServletContext().getInitParameter(<span class="string">"initParam"</span>);</span><br><span class="line">System.out.println(<span class="string">"contextInitialized : initParam = "</span>+initParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"contextDestroyed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口"><a href="#2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口" class="headerlink" title="2.用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口"></a>2.用于监听用户会话对象（<code>HttpSession</code>）的事件监听器，实现<code>HttpSessionListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpSessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionCreated"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionDestroyed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口"><a href="#3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口" class="headerlink" title="3.用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口"></a>3.用于监听请求消息对象（<code>ServletRequest</code>）的事件监听器，实现<code>ServletRequestListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletRequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"requestDestroyed "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class="line">String name = servletrequestevent.getServletRequest().getParameter(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(<span class="string">"requestInitialized name:"</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="按监听的事件划分"><a href="#按监听的事件划分" class="headerlink" title="按监听的事件划分"></a>按监听的事件划分</h3><h4 id="1-监听域对象自身的创建和销毁的事件监听器"><a href="#1-监听域对象自身的创建和销毁的事件监听器" class="headerlink" title="1.监听域对象自身的创建和销毁的事件监听器"></a>1.监听域对象自身的创建和销毁的事件监听器</h4><blockquote><p>即按监听对象划分的那几种</p></blockquote><h4 id="2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口"><a href="#2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口" class="headerlink" title="2.监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener 或 ServletRequestAttributeListener接口"></a>2.监听域对象的属性的增加和删除的事件监听器，实现<code>ServletContextAttributeListener</code>，<code>HttpSessionAttributeListener</code> 或 <code>ServletRequestAttributeListener</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextAttributeListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ServletContext_attributeAdded:"</span>+servletcontextattributeevent.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ServletContext_attributeRemoved:"</span>+servletcontextattributeevent.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ServletContext_attributeReplaced:"</span>+servletcontextattributeevent.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>HttpSession</code> 和 <code>ServletRequest</code> 同理，只是方法参数类型不同</p></blockquote><h4 id="3-监听绑定到HttpSession域中的某个对象的状态的事件监听器"><a href="#3-监听绑定到HttpSession域中的某个对象的状态的事件监听器" class="headerlink" title="3.监听绑定到HttpSession域中的某个对象的状态的事件监听器"></a>3.监听绑定到<code>HttpSession</code>域中的某个对象的状态的事件监听器</h4><blockquote><p>这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">HttpSessionBindingListener</span>,<span class="title">HttpSessionActivationListener</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueBound</span><span class="params">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"valueBound Name:"</span>+httpsessionbindingevent.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueUnbound</span><span class="params">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"valueUnbound Name:"</span>+httpsessionbindingevent.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//钝化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionWillPassivate</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionWillPassivate "</span>+httpsessionevent.getSource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//活化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDidActivate</span><span class="params">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"sessionDidActivate "</span>+httpsessionevent.getSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定和解除绑定：实现<code>HttpSessionBindingListener</code>接口<br>钝化和活化：实现<code>HttpSessionActivationListener</code>和<code>Serializable</code>接口</p><blockquote><p>实现<code>Serializable</code>接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化</p><p>参阅：<br>  <a href="https://www.imooc.com/learn/271" target="_blank" rel="noopener">慕课网：JAVA Web开发技术应用——监听器</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;按监听的对象划分&quot;&gt;&lt;a href=&quot;#按监听的对象划分&quot; class=&quot;headerlink&quot; title=&quot;按监听的对象划分&quot;&gt;&lt;/a&gt;按监听的对象划分&lt;/h3&gt;&lt;h4 id=&quot;1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现Se
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java Web 过滤器</title>
    <link href="https://pinnuli.github.io/2018/07/25/Java-Web-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://pinnuli.github.io/2018/07/25/Java-Web-过滤器/</id>
    <published>2018-07-25T06:36:41.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器的工作原理"><a href="#过滤器的工作原理" class="headerlink" title="过滤器的工作原理"></a>过滤器的工作原理</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/filter_work_principle.png" alt="filetr_work_principle"></h2><h3 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/images/filter_lifecycle.png" alt=" filetr_lifecycle"></h2><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>Web项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？</p><p>过滤器链：<br><img src="/images/filter_chain.png" alt="filter_chain.png"><br>过滤器链执行过程:</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/images/filter_chain_process.png" alt="filter_chain_process.png"></h2><h3 id="过滤器分类"><a href="#过滤器分类" class="headerlink" title="过滤器分类"></a>过滤器分类</h3><p><img src="/images/filter_classify.png" alt="filter_classify"></p><blockquote><p><code>@WebFilter</code>,在servlet3中，可以使用<code>@WebFilter</code>注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置</p><p>参阅：<br>  <a href="https://www.imooc.com/learn/213" target="_blank" rel="noopener">慕课网：Java Web开发技术应用——过滤器</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;过滤器的工作原理&quot;&gt;&lt;a href=&quot;#过滤器的工作原理&quot; class=&quot;headerlink&quot; title=&quot;过滤器的工作原理&quot;&gt;&lt;/a&gt;过滤器的工作原理&lt;/h3&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>servlet</title>
    <link href="https://pinnuli.github.io/2018/07/23/servlet%E7%AC%94%E8%AE%B0/"/>
    <id>https://pinnuli.github.io/2018/07/23/servlet笔记/</id>
    <published>2018-07-23T13:48:35.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h3><p>1.初始化，调用<code>init()</code>方法，生成<code>Servlet</code>实例<br>2.响应客户请求，调用<code>service()</code>方法，由<code>service()</code>方法根据提交方式悬着执行<code>doGet()</code>或者<code>doPost()</code>方法<br>3.终止，调用<code>destroy()</code>方法<br><img src="/images/servlet_life_cycle.png" alt="servlet life cycle"></p><h3 id="tomcat装载servlet的三种情况"><a href="#tomcat装载servlet的三种情况" class="headerlink" title="tomcat装载servlet的三种情况"></a>tomcat装载servlet的三种情况</h3><p>1.Servlet容器启动时自动装载某些Servlet，需要在web.xml文件中的<code>&lt;Servlet&gt;&lt;/Servlet&gt;</code>之间添加<code>&lt;loadon-startup&gt;1&lt;load-sartup&gt;</code></p><blockquote><p>数字越小优先级越高<br>2.在Servlet容器启动后，客户首次向Servlet发送请求<br>3.Servlet类文件被修改时，重新装载Servlet</p></blockquote><h3 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h3><p>在web.xml中配置<code>Servle时可以配置初始化参数，通过</code><init-param>`配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>pinnuli<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></init-param></p><p>在Servlet类中可以通过<code>getInitParameter()</code>获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = <span class="keyword">this</span>.getInitParameter(<span class="string">"username"</span>);</span><br></pre></td></tr></table></figure></p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;servlet生命周期&quot;&gt;&lt;a href=&quot;#servlet生命周期&quot; class=&quot;headerlink&quot; title=&quot;servlet生命周期&quot;&gt;&lt;/a&gt;servlet生命周期&lt;/h3&gt;&lt;p&gt;1.初始化，调用&lt;code&gt;init()&lt;/code&gt;方法，生成&lt;c
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
      <category term="servlet" scheme="https://pinnuli.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>java注解</title>
    <link href="https://pinnuli.github.io/2018/07/23/java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://pinnuli.github.io/2018/07/23/java注解/</id>
    <published>2018-07-23T04:39:36.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、注解分类"><a href="#一、注解分类" class="headerlink" title="一、注解分类"></a>一、注解分类</h3><ul><li>源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在</li><li>编译时注解（CLASS）：注解在源码和.class文件都存在</li><li>运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解</li><li>元注解：注解的注解</li></ul><hr><h3 id="二、自定义注解"><a href="#二、自定义注解" class="headerlink" title="二、自定义注解"></a>二、自定义注解</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元注解</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义注解和成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description&#123;</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Target({ElementType.METHOD,ElementType.TYPE})</code></li></ul><blockquote><p>作用域,可以包括<code>CONSTRUCTOR</code>(构造方法)、<code>FIELD</code>(字段)、<code>LOCAL_VARIABLE</code>(局部变量)、<code>METHOD</code>(方法)、<code>PACKAGE</code>(包)、<code>PARAMETER</code>(参数)、<code>TYPE</code>(类和接口)声明中，这里作用域为方法、类和接口</p></blockquote><ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code></li></ul><blockquote><p>生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时</p></blockquote><ul><li><code>@Inherited</code></li></ul><blockquote><p>标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解</p></blockquote><ul><li><code>@Documented</code></li></ul><blockquote><p>生成javadoc包含注解信息</p></blockquote><ul><li><code>@interface</code></li></ul><blockquote><p>1.使用关键字<code>@interface</code>定义注解，<br>2.成员以无参无异常方式声明，可以用default指定一个默认值<br>3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration<br>4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即<code>Description(&quot;test&quot;)</code><br>5.注解可以没有成员名，叫标识注解</p></blockquote><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Description(desc=<span class="string">"I am pinnuli"</span>,author=<span class="string">"pinnuli"</span>,age=<span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="三、解析注解"><a href="#三、解析注解" class="headerlink" title="三、解析注解"></a>三、解析注解</h3><blockquote><p>通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑</p></blockquote><p>1.使用类加载器加载类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forname(<span class="string">"com.test.Student"</span>);</span><br></pre></td></tr></table></figure></p><p>2.找到类上的注解,拿到注解实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(c.isAnnotationPresent(Description.class))&#123;</span><br><span class="line">    Description d = (Description)c.getAnnotation(Description.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.找到方法上的注解</p><ul><li>方法一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method[] ms = c.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.isAnnotationPresent(Description.class))&#123;</span><br><span class="line">        Description d = (Description)m.getAnnotation(Description.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method[] ms = c.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">    <span class="keyword">for</span>(Annotation a:as)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Description)&#123;</span><br><span class="line">            Description d = (Description)a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/456" target="_blank" rel="noopener">慕课网：全面解析Java注解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、注解分类&quot;&gt;&lt;a href=&quot;#一、注解分类&quot; class=&quot;headerlink&quot; title=&quot;一、注解分类&quot;&gt;&lt;/a&gt;一、注解分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>java反射</title>
    <link href="https://pinnuli.github.io/2018/07/22/java%E5%8F%8D%E5%B0%84/"/>
    <id>https://pinnuli.github.io/2018/07/22/java反射/</id>
    <published>2018-07-22T05:30:00.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Class类的使用"><a href="#一、Class类的使用" class="headerlink" title="一、Class类的使用"></a>一、Class类的使用</h3><p>类是对象，任何一个类都是<code>java.lang.class</code>类的实例对象，这个类，这个实例对象可以有三种表达方式，比如<code>Student</code>类：</p><ul><li>任何一个类都有一个隐含的静态成员变量class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Student.class;</span><br></pre></td></tr></table></figure><ul><li>通过getClass方法获得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = Student.getClass();</span><br></pre></td></tr></table></figure><ul><li>forName</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">"com.Student"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例—-&gt;通过c1 or c2 or c3创建Student的实例对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu = c1.newInstance();</span><br></pre></td></tr></table></figure></p></blockquote><hr><h3 id="二、动态加载类"><a href="#二、动态加载类" class="headerlink" title="二、动态加载类"></a>二、动态加载类</h3><ul><li>静态加载类：编译时加载的类，通过new创建对象是静态加载类</li><li>动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题</li></ul><hr><h3 id="三、获取方法信息和成员变量，构造函数信息"><a href="#三、获取方法信息和成员变量，构造函数信息" class="headerlink" title="三、获取方法信息和成员变量，构造函数信息"></a>三、获取方法信息和成员变量，构造函数信息</h3><h4 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h4><ul><li>所有的public的函数，包括父类继承而来的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] ms = c.getMethods();</span><br></pre></td></tr></table></figure><ul><li>所有该类自己声明的方法，不问访问权限</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] ms = c.getDeclaredMethods();</span><br></pre></td></tr></table></figure><ul><li>返回值类型的类类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class returnType = ms[i].getReturnType();</span><br></pre></td></tr></table></figure><ul><li>参数列表的类型的类类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class[] paramTypes = ms[i].getParameterTypes();</span><br></pre></td></tr></table></figure><ul><li>方法的名称</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String methodName = ms[i].getName();</span><br></pre></td></tr></table></figure><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><ul><li>所有的public的成员变量的信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fs = c.getFields();</span><br></pre></td></tr></table></figure><ul><li>该类自己声明的成员变量的信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fs = c.getDeclaredFields();</span><br></pre></td></tr></table></figure><ul><li>成员变量的类型的类类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class fieldType = field.getType();</span><br></pre></td></tr></table></figure><ul><li>成员变量的名称</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fieldName = field.getName();</span><br></pre></td></tr></table></figure><ul><li>构造函数</li><li>所有的public构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] cs = c.getConstructors();</span><br></pre></td></tr></table></figure><ul><li>所有的构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] cs = c.getDeclaredConstructors();</span><br></pre></td></tr></table></figure><ul><li>构造函数的参数列表，得到的是参数列表的类类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class fieldType = field.getType();</span><br></pre></td></tr></table></figure><blockquote><p>更多方法看API文档</p></blockquote><hr><h3 id="四、方法反射的基本操作"><a href="#四、方法反射的基本操作" class="headerlink" title="四、方法反射的基本操作"></a>四、方法反射的基本操作</h3><p>现有A类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"helloworld"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">    System.out.println(a.toUpperCase()+<span class="string">","</span>+b.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="keyword">new</span> A();</span><br><span class="line">Class c = a1.getClass();</span><br></pre></td></tr></table></figure></p><p>2.通过名称和参数列表来获取方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method m = c.getMethod(<span class="string">"print"</span>, <span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br></pre></td></tr></table></figure></p><p>3.方法的反射操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = m.invoke(a1, <span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>这个操作的效果等同于<code>a1.print(10,20)</code></p><p>通过方法的反射，我们可以绕过编译</p><p>参阅：<br>  <a href="https://www.imooc.com/learn/199" target="_blank" rel="noopener">慕课网：反射——Java高级开发必须懂的</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Class类的使用&quot;&gt;&lt;a href=&quot;#一、Class类的使用&quot; class=&quot;headerlink&quot; title=&quot;一、Class类的使用&quot;&gt;&lt;/a&gt;一、Class类的使用&lt;/h3&gt;&lt;p&gt;类是对象，任何一个类都是&lt;code&gt;java.lang.class&lt;
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>java Socket应用</title>
    <link href="https://pinnuli.github.io/2018/07/21/Java-Socket%E5%BA%94%E7%94%A8/"/>
    <id>https://pinnuli.github.io/2018/07/21/Java-Socket应用/</id>
    <published>2018-07-21T07:09:14.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Socket使用时应当注意的一些问题"><a href="#一、Socket使用时应当注意的一些问题" class="headerlink" title="一、Socket使用时应当注意的一些问题"></a>一、Socket使用时应当注意的一些问题</h3><p>1.设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时</p><blockquote><p>调用<code>setSoTimeout</code>方法设置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket(...);</span><br><span class="line">s.setSoTimeout(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>对构造器<code>Socket(String host,int port)</code>，可以先构建一个无连接的套接字，再使用超时</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line">s.connect(<span class="keyword">new</span> InetSocketAddress(host,port),timeout);</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>2.可中断套接字，用<code>SocketChannel</code>类<br>3.需要解析因特网地址时，可以用<code>InetAddress</code>类<br>4.为多个客户端服务时，可以用多线程解决<br>5.半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用<code>Socket.shutdownInput</code>或<code>Socket.shutdownOutput</code></p><hr><h3 id="二、获取Web数"><a href="#二、获取Web数" class="headerlink" title="二、获取Web数"></a>二、获取Web数</h3><h4 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h4><ul><li>URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN</li><li>一个URI具有一下语法：<code>[scema:]schemaSpecficPart[#fragment]</code></li></ul><blockquote><p>i.包含schema:部分的URI成为绝对URI，否则为相对URI<br>ii.绝对URI的schemaSpecficPart不是以<code>/</code>揩油，则称为不透明的，如:<code>mialto:pinnuli!hostname.com</code><br>iii.所有绝对的透明URI和所有相对URI都是分层的，如：<code>http://hostname.com/index.html</code>，<code>../../java/net/Socket.html#Socket()</code><br>iv.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port]</p></blockquote><ul><li>java中URI类的作用<ul><li>解析表示福并将它分解成各种不同组成成分</li><li>标识符的相对化和解析相对标识符</li></ul></li></ul><h4 id="使用URLCollection"><a href="#使用URLCollection" class="headerlink" title="使用URLCollection"></a>使用URLCollection</h4><pre><code>&gt; URLConnection类可以比URL类有更多的控制</code></pre><p>必须严格按照以下步骤进行操作：<br>1.调用URL类中的openConnection方法得到URLConnection对象：<code>URLConnection connection = url.openConnection();</code><br>2.设置请求属性<br>3.调用connect方法连接远程资源:connection.connect();<br>4.建立连接后，可以查询头信息<br>5.访问资源数据，使用getInputStream方法获取一个输入流</p><blockquote><p>这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能</p></blockquote><hr><h3 id="三、提交表单"><a href="#三、提交表单" class="headerlink" title="三、提交表单"></a>三、提交表单</h3><p>1.提交数据之前，需要创建一个URLConnection对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http;??host/script"</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br></pre></td></tr></table></figure></p><p>2.调用setDoOutput方法建立一个输出的连接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">connection.setDoOutput（<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>3.调用getOutputStream方法获得一个输出流，想服务器发送数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(connection.getOutputStream(), <span class="string">"UTF-8"</span>);</span><br><span class="line">osw.write(name1 + <span class="string">"="</span> + URLEncoder.eccode(value1,<span class="string">"UTF-8"</span>) + <span class="string">"&amp;);</span></span><br><span class="line"><span class="string">osw.write(name2 + "</span>=<span class="string">" + URLEncoder.encode(value2,"</span>UTF-<span class="number">8</span><span class="string">"));</span></span><br></pre></td></tr></table></figure></p><p>4.关闭输出流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">osw.flush();</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure></p><p>5.调用getInputStream方法对服务器的响应<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(connection.getInputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">StringBuffer response = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">String temp;</span><br><span class="line"><span class="keyword">while</span> ((temp = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    response.append(temp);</span><br><span class="line">    response.append(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>i.设置请求方法时，必须使用大写，如POST，使用post无法识别<br>ii.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法<br><code>InputStream err = ((HTTPURLConnection) connection).getErrorStream();</code></p></blockquote><p>URL编码需遵循以下规则：</p><blockquote><p>i.保留字符A-Z、a-z、0-9 以及.-*_<br>ii.用<code>+</code>替换所有空格<br>iii.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字<br>比如发送”New York, NY”，可以使用New+York%2C+NY</p></blockquote><hr><h4 id="四、基于TCP的Socket通信"><a href="#四、基于TCP的Socket通信" class="headerlink" title="四、基于TCP的Socket通信"></a>四、基于TCP的Socket通信</h4><p>1.创建ServerSocket和Socket<br>2.打开连接到Socket的输入/输出流<br>3.按照协议对Socket进行读/写操作<br>4.关闭输入/输出流，关闭Socket<br><strong>服务端</strong>（多线程响应多个客户端）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口</span></span><br><span class="line">ServerSocket serverSocket=<span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">Socket socket=<span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">"***服务器即将启动，等待客户端的连接***"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="comment">//调用accept()方法开始监听，等待客户端的连接</span></span><br><span class="line">    socket=serverSocket.accept();</span><br><span class="line">    <span class="comment">//创建一个新的线程</span></span><br><span class="line">    ServerThread serverThread=<span class="keyword">new</span> ServerThread(socket);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    serverThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerThread类</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行的操作，响应客户端的请求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">InputStream is=<span class="keyword">null</span>;</span><br><span class="line">InputStreamReader isr=<span class="keyword">null</span>;</span><br><span class="line">BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">PrintWriter pw=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取输入流，并读取客户端信息</span></span><br><span class="line">is = socket.getInputStream();</span><br><span class="line">isr = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String info=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((info=br.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//循环读取客户端的信息</span></span><br><span class="line">System.out.println(<span class="string">"我是服务器，客户端说："</span>+info);</span><br><span class="line">&#125;</span><br><span class="line">socket.shutdownInput();<span class="comment">//关闭输入流，半关闭</span></span><br><span class="line"><span class="comment">//获取输出流，响应客户端的请求</span></span><br><span class="line">os = socket.getOutputStream();</span><br><span class="line">pw = <span class="keyword">new</span> PrintWriter(os);</span><br><span class="line">pw.write(<span class="string">"欢迎您！"</span>);</span><br><span class="line">pw.flush();<span class="comment">//调用flush()方法将缓冲输出</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(pw!=<span class="keyword">null</span>)</span><br><span class="line">pw.close();</span><br><span class="line"><span class="keyword">if</span>(os!=<span class="keyword">null</span>)</span><br><span class="line">os.close();</span><br><span class="line"><span class="keyword">if</span>(br!=<span class="keyword">null</span>)</span><br><span class="line">br.close();</span><br><span class="line"><span class="keyword">if</span>(isr!=<span class="keyword">null</span>)</span><br><span class="line">isr.close();</span><br><span class="line"><span class="keyword">if</span>(is!=<span class="keyword">null</span>)</span><br><span class="line">is.close();</span><br><span class="line"><span class="keyword">if</span>(socket!=<span class="keyword">null</span>)</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><strong>客户端</strong></p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建客户端Socket，指定服务器地址和端口</span></span><br><span class="line">Socket socket=<span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8888</span>);</span><br><span class="line"><span class="comment">//2.获取输出流，向服务器端发送信息</span></span><br><span class="line">OutputStream os=socket.getOutputStream();<span class="comment">//字节输出流</span></span><br><span class="line">PrintWriter pw=<span class="keyword">new</span> PrintWriter(os);<span class="comment">//将输出流包装为打印流</span></span><br><span class="line">pw.write(<span class="string">"用户名：alice;密码：789"</span>);</span><br><span class="line">pw.flush();</span><br><span class="line">socket.shutdownOutput();<span class="comment">//关闭输出流</span></span><br><span class="line"><span class="comment">//3.获取输入流，并读取服务器端的响应信息</span></span><br><span class="line">InputStream is=socket.getInputStream();</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">String info=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((info=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是客户端，服务器说："</span>+info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">br.close();</span><br><span class="line">is.close();</span><br><span class="line">pw.close();</span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure></code></pre><hr><h3 id="五、基于UDP的SOcket通信"><a href="#五、基于UDP的SOcket通信" class="headerlink" title="五、基于UDP的SOcket通信"></a>五、基于UDP的SOcket通信</h3><p>1.定义发送信息<br>2.创建DatagramPacket，包含将要发送的信息<br>3.创建DatagramSocket<br>4.发送数据<br><strong>服务端</strong></p><ul><li>接收客户端发送的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建服务器端DatagramSocket，指定端口</span></span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">8800</span>);</span><br><span class="line"><span class="comment">//2.创建数据报，用于接收客户端发送的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//创建字节数组，指定接收的数据包的大小</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data, data.length);</span><br><span class="line"><span class="comment">//3.接收客户端发送的数据</span></span><br><span class="line">socket.receive(packet);<span class="comment">//此方法在接收到数据报之前会一直阻塞</span></span><br><span class="line"><span class="comment">//4.读取数据</span></span><br><span class="line">String info=<span class="keyword">new</span> String(data, <span class="number">0</span>, packet.getLength());</span><br><span class="line">System.out.println(<span class="string">"我是服务器，客户端说："</span>+info);</span><br></pre></td></tr></table></figure><ul><li>向客户端响应数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义客户端的地址、端口号、数据</span></span><br><span class="line">InetAddress address=packet.getAddress();</span><br><span class="line"><span class="keyword">int</span> port=packet.getPort();</span><br><span class="line"><span class="keyword">byte</span>[] data2=<span class="string">"欢迎您!"</span>.getBytes();</span><br><span class="line"><span class="comment">//2.创建数据报，包含响应的数据信息</span></span><br><span class="line">DatagramPacket packet2=<span class="keyword">new</span> DatagramPacket(data2, data2.length, address, port);</span><br><span class="line"><span class="comment">//3.响应客户端</span></span><br><span class="line">socket.send(packet2);</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p><strong>客户端</strong></p><ul><li>向服务器端发送数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义服务器的地址、端口号、数据</span></span><br><span class="line">InetAddress address=InetAddress.getByName(<span class="string">"localhost"</span>);</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">8800</span>;</span><br><span class="line"><span class="keyword">byte</span>[] data=<span class="string">"用户名：admin;密码：123"</span>.getBytes();</span><br><span class="line"><span class="comment">//2.创建数据报，包含发送的数据信息</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class="line"><span class="comment">//3.创建DatagramSocket对象</span></span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">//4.向服务器端发送数据报</span></span><br><span class="line">socket.send(packet);</span><br></pre></td></tr></table></figure><ul><li>接收服务器端响应的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建数据报，用于接收服务器端响应的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket packet2=<span class="keyword">new</span> DatagramPacket(data2, data2.length);</span><br><span class="line"><span class="comment">//2.接收服务器响应的数据</span></span><br><span class="line">socket.receive(packet2);</span><br><span class="line"><span class="comment">//3.读取数据</span></span><br><span class="line">String reply=<span class="keyword">new</span> String(data2, <span class="number">0</span>, packet2.getLength());</span><br><span class="line">System.out.println(<span class="string">"我是客户端，服务器说："</span>+reply);</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><blockquote><p>当Socket关闭时，输入输出流也就关闭了</p><p>参阅：<br>  <a href="https://www.imooc.com/learn/161" target="_blank" rel="noopener">慕课网：Java Socket应用—通信是这样练成的</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Socket使用时应当注意的一些问题&quot;&gt;&lt;a href=&quot;#一、Socket使用时应当注意的一些问题&quot; class=&quot;headerlink&quot; title=&quot;一、Socket使用时应当注意的一些问题&quot;&gt;&lt;/a&gt;一、Socket使用时应当注意的一些问题&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>java io流与文件</title>
    <link href="https://pinnuli.github.io/2018/07/19/java-io%E6%B5%81%E4%B8%8E%E6%96%87%E4%BB%B6/"/>
    <id>https://pinnuli.github.io/2018/07/19/java-io流与文件/</id>
    <published>2018-07-18T22:27:55.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、流"><a href="#一、流" class="headerlink" title="一、流"></a>一、流</h3><p><strong>读写字节</strong><br><code>InputStream.read和OutpueStream.write</code><br><strong>组合流过滤器</strong></p><ul><li>某些流（如<code>FileInputStream</code>或者<code>FileOutputStream</code>）只能支持在字节级别上的读写，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如：    </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(fin);</span><br><span class="line"><span class="keyword">double</span> s = din.readDouble();</span><br></pre></td></tr></table></figure><ul><li>需要使用缓冲，可以使用一下构造器：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(</span><br><span class="line"><span class="keyword">new</span> BUfferInputStream(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(test.txt<span class="string">")));</span></span><br></pre></td></tr></table></figure><ul><li>需要浏览下一个字节以确定是否是想要的值时，可以：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PushbackInputStream pbin = <span class="keyword">new</span> PushbackInputStream(</span><br><span class="line"><span class="keyword">new</span> BUfferInputStream(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(test.txt<span class="string">")));</span></span><br><span class="line"><span class="string">//预读写一个字节</span></span><br><span class="line"><span class="string">int b = pbin.read();</span></span><br><span class="line"><span class="string">//不是所期望时将其推回流中</span></span><br><span class="line"><span class="string">if(b != '&lt;') pbin.unead(b);</span></span><br></pre></td></tr></table></figure><hr><h3 id="二、文本输入与输出"><a href="#二、文本输入与输出" class="headerlink" title="二、文本输入与输出"></a>二、文本输入与输出</h3><p><strong>输出：<code>PrintWrite</code></strong><br><code>PrintWrite out = new PrintWrite(&quot;test.txt&quot;);</code>等同于<code>PrintWrite out = new PrintWrite(new FileWrite(&quot;test.txt&quot;));</code><br><strong>输入：<code>Scanner</code></strong><br><strong>文本格式存储对象</strong><br>用自己的格式依次存储各个字段，以特定字符分隔，如：<code>PINUULI|201625010417|1997|guangdong</code></p><hr><h3 id="三、读写二进制数据"><a href="#三、读写二进制数据" class="headerlink" title="三、读写二进制数据"></a>三、读写二进制数据</h3><p><strong>读</strong>：实现<code>DataInput</code>接口，如<code>DataInputStream，readInt，readBoolean</code>等方法<br><strong>写</strong>：实现<code>DataOutpu</code>t接口，如<code>DataOutputStream，writeInt，writeBoolean</code>等方法<br><strong>随机访问文件</strong>：<code>RandomAccessFile</code><br>可以在文件中的任何位置查找或者写入数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile in = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">RandomAccessFile inOut = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>,<span class="string">"rw"</span>);</span><br></pre></td></tr></table></figure></p><hr><h3 id="四、ZIP文件"><a href="#四、ZIP文件" class="headerlink" title="四、ZIP文件"></a>四、ZIP文件</h3><p>每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。<br><strong>读</strong>：<code>ZipInputStream</code></p><ul><li>用<code>getNextEntry</code>方法返回文档中这些项（文件）的<code>ZipEntry</code>对象</li><li><code>ZipInputStream</code>的<code>read</code>方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用<code>closeEntry</code>读入下一项</li><li>在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项</li><li>通读zip文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZipInputStream zin = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.zip"</span>));</span><br><span class="line">ZipEntry entry;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(zin);</span><br><span class="line"><span class="keyword">while</span>((entry = zin.getNextEntry()) != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">System.out.println(in.nextLine());</span><br><span class="line">&#125;</span><br><span class="line">zin.closeEntry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写</strong>：<code>ZipOutputStream</code></p><ul><li>对于想要放入到zip文件中的每一个项，都应该创建一个<code>ZipEntry</code>对象，并将文件名传递给ZipEntry的构造器</li><li>调用<code>ZipOutputStream</code>的<code>putNextEntry</code>方法开始写出新文件，并将数据发送到zip流中</li><li>完成时调用<code>closeEntry</code>方法,如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fout = <span class="keyword">new</span> FilePutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">ZipOutputStream zout = <span class="keyword">new</span> ZipOutputStream(fout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个文件</span></span><br><span class="line">ZipEntry ze = <span class="keyword">new</span> ZipEntry(<span class="string">"filename"</span>);</span><br><span class="line">zout.putNextENtry(ze);</span><br><span class="line">send data to zout;</span><br><span class="line">zout.closeEntry();</span><br><span class="line"></span><br><span class="line">zout.close();</span><br></pre></td></tr></table></figure><hr><h3 id="五、对象流与序列化"><a href="#五、对象流与序列化" class="headerlink" title="五、对象流与序列化"></a>五、对象流与序列化</h3><ul><li>序列化:<code>ObjectOutputStream.writeObject()</code>,</li><li>反序列化：<code>ObjectInputream.readObject()</code>，</li><li>都需要实现<code>Serializable</code>接口</li><li>只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等</li><li>序列化算法：<ul><li>对于遇到的每个对象都关联一个序列号</li><li>对于每个对象，第一次遇到时，保存其对象数据到流中</li><li>如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反</li><li>对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联</li><li>当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用</li></ul></li><li>修改默认的序列化机制</li></ul><blockquote><p>一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。<br>可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。</p></blockquote><p>当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现<code>Serializable</code>接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LabeledPoint</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Point2D.Double point;</span><br><span class="line">···</span><br><span class="line"><span class="comment">//重写读写方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">out.defaultWriteObjecy();</span><br><span class="line">out.writeDouble(point.getX());</span><br><span class="line">out.writeDouble(point.getY());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">in.defaultReadObject();</span><br><span class="line"><span class="keyword">double</span> x = in.readDouble();</span><br><span class="line"><span class="keyword">double</span> y = in.readDouble();</span><br><span class="line">point = <span class="keyword">new</span> Point2D.DOuble(x,y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现<code>Externalizable</code>接口，指定要保存的域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String stuId;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">···</span><br><span class="line"><span class="comment">//重写读写方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">out.writeUTF(name);</span><br><span class="line">out.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">name = in.readUTF():</span><br><span class="line">age = in.readInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>&gt; PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。</code></pre><hr><h3 id="六、操作文件"><a href="#六、操作文件" class="headerlink" title="六、操作文件"></a>六、操作文件</h3><p><strong>Path</strong></p><ul><li>静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\）连接起来，返回一个Path对象，详情见API。如</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path absolutye = Paths.get(<span class="string">"/home"</span>.<span class="string">"cay"</span>);</span><br><span class="line">Path relative = Paths.get(<span class="string">"myprog"</span>,<span class="string">"conf"</span>,<span class="string">"user.properties"</span>);</span><br></pre></td></tr></table></figure><p><strong>读写文件</strong>：Files类可以使得普通文件操作变得快捷</p><ul><li>读取文件所有内容：<code>byte[] bytes = Files.readAllBytes(path);</code>,之后可以将其当做字符串<code>String content = new String(bytes,charset);</code></li><li>向指定文件追加内容：<code>Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND);</code></li></ul><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/123" target="_blank" rel="noopener">慕课网：文件传输基础——Java IO流</a><br>  <a href="http://product.dangdang.com/25171892.html" target="_blank" rel="noopener">java核心技术 卷II：高级特性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、流&quot;&gt;&lt;a href=&quot;#一、流&quot; class=&quot;headerlink&quot; title=&quot;一、流&quot;&gt;&lt;/a&gt;一、流&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;读写字节&lt;/strong&gt;&lt;br&gt;&lt;code&gt;InputStream.read和OutpueStream.write
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>centos7 Let&#39;s Encrypt用Certbot获取Https证书 部署nginx</title>
    <link href="https://pinnuli.github.io/2018/07/15/centos7-Let-s-Encrypt%E7%94%A8Certbot%E8%8E%B7%E5%8F%96Https%E8%AF%81%E4%B9%A6-%E9%83%A8%E7%BD%B2nginx/"/>
    <id>https://pinnuli.github.io/2018/07/15/centos7-Let-s-Encrypt用Certbot获取Https证书-部署nginx/</id>
    <published>2018-07-15T09:24:42.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<p>1.检查nginx下是否有<code>--with-http_stub_status_module</code> 和<code>--with-http_ssl_module</code>两个模块，安装之后再重新编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure></p><p>2.用http克隆github上的certbot<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/certbot/certbot /opt/certbot-master</span><br></pre></td></tr></table></figure></p><p>3.安装所有依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/certbot-master/letsencrypt-auto --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p><p>4.关闭nginx，检出80端口，443端口是否有开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=80/tcp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=443/tcp</span><br></pre></td></tr></table></figure><p>没有的话就开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=80/tcp</span><br></pre></td></tr></table></figure></p><p>5.获取证书<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/certbot-master/letsencrypt-auto --nginx -d www.pinnuli.com</span><br></pre></td></tr></table></figure></p><p>6.配置nginx（也可选择自动配置)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/<span class="built_in">log</span>/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" </span></span><br><span class="line"><span class="string">'</span><span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="string">"<span class="variable">$http_referer</span>"</span> <span class="string">'</span></span><br><span class="line"><span class="string">'</span><span class="string">"<span class="variable">$http_user_agent</span>"</span> <span class="string">"<span class="variable">$http_x_forwarded_for</span>"</span><span class="string">';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">access_log  /var/log/nginx/access.log  main;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sendfile            on;</span></span><br><span class="line"><span class="string">tcp_nopush          on;</span></span><br><span class="line"><span class="string">tcp_nodelay         on;</span></span><br><span class="line"><span class="string">keepalive_timeout   65;</span></span><br><span class="line"><span class="string">types_hash_max_size 2048;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">include             /etc/nginx/mime.types;</span></span><br><span class="line"><span class="string">default_type        application/octet-stream;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server &#123;</span></span><br><span class="line"><span class="string">listen       80 default_server;</span></span><br><span class="line"><span class="string">listen       [::]:80 default_server;</span></span><br><span class="line"><span class="string">server_name  _;</span></span><br><span class="line"><span class="string">root        /var/www/pinnuli.github.io;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">location / &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_page 404 /404.html;</span></span><br><span class="line"><span class="string">location = /40x.html &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="string">location = /50x.html &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">server &#123;</span></span><br><span class="line"><span class="string">server_name www.pinnuli.com; # managed by Certbot</span></span><br><span class="line"><span class="string">root        /var/www/pinnuli.github.io;</span></span><br><span class="line"><span class="string">include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="string">location / &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">error_page 404 /404.html;</span></span><br><span class="line"><span class="string">location = /40x.html &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="string">location = /50x.html &#123;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">listen [::]:443 ssl ipv6only=on; # managed by Certbot</span></span><br><span class="line"><span class="string">listen 443 ssl; # managed by Certbot</span></span><br><span class="line"><span class="string">ssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot</span></span><br><span class="line"><span class="string">ssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot</span></span><br><span class="line"><span class="string">include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span></span><br><span class="line"><span class="string">ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>7.设置自动更新</p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.检查nginx下是否有&lt;code&gt;--with-http_stub_status_module&lt;/code&gt; 和&lt;code&gt;--with-http_ssl_module&lt;/code&gt;两个模块，安装之后再重新编译&lt;br&gt;&lt;figure class=&quot;highlight b
      
    
    </summary>
    
      <category term="服务器" scheme="https://pinnuli.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="https://pinnuli.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java集合框架</title>
    <link href="https://pinnuli.github.io/2018/07/11/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://pinnuli.github.io/2018/07/11/java集合框架/</id>
    <published>2018-07-10T23:02:56.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、迭代器"><a href="#一、迭代器" class="headerlink" title="一、迭代器"></a>一、迭代器</h3><p>iterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素，</p><ul><li>next()方法<ul><li>逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用；</li><li>java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用</li></ul></li><li>用”for each”循环遍历类集的内容，</li><li>remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态</li><li>对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉</li></ul><hr><h3 id="二、List"><a href="#二、List" class="headerlink" title="二、List"></a>二、List</h3><p>有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类</p><p><strong>ArrayList</strong></p><ul><li><p>基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道</p></li><li><p>适用于需要进行随机访问时</p></li></ul><p><strong>LinkedList</strong></p><ul><li>基于双向链表，</li><li>对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值</li><li>适用于顺序访问</li></ul><hr><h3 id="三、Set"><a href="#三、Set" class="headerlink" title="三、Set"></a>三、Set</h3><p>等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一</p><p><strong>HashSet</strong></p><ul><li>基于散列表的集，无序</li><li>存入的元素必须定义有hashCode()，以得到散列码</li><li>可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变</li><li>可以设置装填因子来实现再散列</li><li>适用于不关心访问顺序，需要查找大容量容器时</li></ul><p><strong>TreeSet</strong></p><ul><li>基于红黑树排序，有序</li><li>存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator</li><li>每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问</li><li>适用于存储大量需要进行快速检索的排序信息的情况</li></ul><p><strong>BitSet</strong></p><ul><li>用于存放一个位序列</li></ul><hr><h3 id="四、Queue"><a href="#四、Queue" class="headerlink" title="四、Queue"></a>四、Queue</h3><p><strong>双端队列</strong><br>可以同时在头部或者尾部添加或删除元素，有两个实现</p><ul><li>inkedList</li><li>ArrayList</li></ul><p><strong>PriorityQueue</strong></p><ul><li>基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序</li><li>按照任意顺序插入，却可以按照顺序进行检索</li><li>和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator</li></ul><hr><h3 id="五、Map"><a href="#五、Map" class="headerlink" title="五、Map"></a>五、Map</h3><p>对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。<br><strong>键不存在时</strong><br>get方法返回null，可以用getOrDefault返回默认值，test.get(id,0)<br><strong>更新映射项</strong><br>正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，<code>counts.put(word,counts.get(word)+1)</code>,需要解决一个问题，就是键第一次出现时，这时可以有三种方法</p><ul><li><code>counts.put(word,counts.getOrDefault(word,0) + 1)</code></li><li>先调用putIfAbsent，只有原先键存在时才会放一个值,<code>counts.putIfAnsent(word,0)</code><br>  <code>counts.put(word,counts.get(word)+1)</code>            </li><li><code>counts.merge(word,1,Interger::sum)</code>(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联</li></ul><p><strong>映射视图</strong><br>集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图</p><ul><li>键集：<code>Set&lt;K&gt; keySet()</code>，</li><li>值集：<code>Collection&lt;V&gt; values()</code>，</li><li>键/值对集：<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></li><li>这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除</li></ul><p><strong>散列</strong></p><ul><li>散列码，由对象的实例域产生的一个整数，由hashCOde()产生</li><li>散列表，用链表数组实现，每个列表称为桶</li><li><p>散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询</p><blockquote><p>新版jdk使用红黑树和List（数据多用树，少时用List)</p></blockquote></li><li><p>散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表</p></li></ul><p><strong>HashMap</strong></p><ul><li>比较快，适用于不需要按照排列顺序访问键时</li></ul><p><strong>TreeMap</strong></p><ul><li>按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序</li></ul><p><strong>WeakHashMap</strong></p><ul><li>使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键</li><li>如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目</li><li>适用于需要缓存时</li></ul><p><strong>LinkedHashMap</strong></p><ul><li>链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，收到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置</li><li>用于实现高速缓存的“最近最少使用”原则</li></ul><hr><h3 id="六、视图与包装器"><a href="#六、视图与包装器" class="headerlink" title="六、视图与包装器"></a>六、视图与包装器</h3><p><strong>轻量级集合包装器</strong><br>例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</span><br></pre></td></tr></table></figure></p><blockquote><p>返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小,例如Collections类的一些使用方法，<code>nCopied(100,&quot;KKK&quot;)</code>,<code>single(anObject)</code>等，返回一个不可修改的试图对象</p></blockquote><p><strong>子范围</strong></p><ul><li>相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用<code>List group2 = staff.subList(10,20);</code>,类似于String类中获取子串</li><li>可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除</li><li>对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集，<blockquote><p>SortedSet<e> subSet(E from, E to)<br>SortedSet<e> headSet(E to)<br>SortedSet<e> tailSet(E from)</e></e></e></p></blockquote></li></ul><p><strong>不可修改的视图</strong></p><ul><li>只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改</li><li>访问器方法从原始集合对象中获取值</li><li>视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如：<blockquote><p><code>unmodifiableCollection</code>方法将返回一个集合，但他的<code>equals()</code>方法不调用底层集合的，而是调用它继承了<code>Object类的equals()</code>方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的</p></blockquote></li></ul><p><strong>同步视图</strong></p><ul><li>实现多线程访问，确保集合的线程安全，例如<code>Collections.synchronizedMap</code></li></ul><p><strong>受查视图</strong></p><ul><li>用来对泛型类型进行检测，例如<code>Collections.checkedList</code></li></ul><blockquote><p>参阅：<br>  <a href="http://product.dangdang.com/24035306.html" target="_blank" rel="noopener">java核心技术 卷I：基础知识</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、迭代器&quot;&gt;&lt;a href=&quot;#一、迭代器&quot; class=&quot;headerlink&quot; title=&quot;一、迭代器&quot;&gt;&lt;/a&gt;一、迭代器&lt;/h3&gt;&lt;p&gt;iterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的
      
    
    </summary>
    
      <category term="javase笔记" scheme="https://pinnuli.github.io/categories/javase%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaSE" scheme="https://pinnuli.github.io/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JSP学习笔记</title>
    <link href="https://pinnuli.github.io/2018/05/03/JSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://pinnuli.github.io/2018/05/03/JSP学习笔记/</id>
    <published>2018-05-03T13:17:47.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、jsp简介"><a href="#一、jsp简介" class="headerlink" title="一、jsp简介"></a>一、jsp简介</h3><h4 id="1、jsp三大指令"><a href="#1、jsp三大指令" class="headerlink" title="1、jsp三大指令"></a>1、jsp三大指令</h4><p><strong>page指令</strong>:&lt;%@page 属性=”” %&gt;,位于jsp页面顶端，可以有多个</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.text.*"</span>%&gt;</span><br></pre></td></tr></table></figure><p><strong>taglib指令</strong>：标签库</p><p><strong>include</strong><br>include指令:<code>&lt;%@include file=&quot;date.jsp&quot;%&gt;</code><br>include动作:<code>&lt;jsp:include page=&quot;url&quot; flush=&quot;true|false&quot;/&gt;</code></p><blockquote><p>page:要包含的页面,<br>flush：被包含的页面是否从缓冲区读取</p></blockquote><p><strong>include指令与include动作的区别：</strong><br><img src="https://i.imgur.com/YyHsnwD.png" alt="diff_between_includeCommand_includeAction"></p><p><strong>forward动作</strong>：<code>&lt;jsp: forward page=&quot;url&quot;/&gt;</code><br>等同于：<code>request.getRequestDispatcher(&quot;/url&quot;).forward(request,response);</code></p><p><strong>param动作</strong>：<code>&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt;</code><br>常与<jsp:forward>一起使用，作为其的子标签:</jsp:forward></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">"user.jsp"</span>&gt;</span><br><span class="line">&lt;%--用&lt;jsp:param <span class="string">"&gt;&lt;/jsp:param&gt;添加参数--%&gt;</span></span><br><span class="line"><span class="string">&lt;jsp:param name="</span>email<span class="string">" value="</span><span class="number">11111111</span>@<span class="number">163</span>.com<span class="string">"&gt;&lt;/jsp:param&gt;</span></span><br><span class="line"><span class="string">&lt;/jsp:forward&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、jsp注释"><a href="#2、jsp注释" class="headerlink" title="2、jsp注释"></a>2、jsp注释</h4><ul><li>html的注释  <!-- html注释 --></li><li>jsp的注释<br>&lt;%– jsp注释 –&gt;（客户端不可见）</li><li>jsp脚本注释:<br>//单行<br>/<em> </em>/ 多行</li></ul><h4 id="3、jsp脚本"><a href="#3、jsp脚本" class="headerlink" title="3、jsp脚本"></a>3、jsp脚本</h4><p>&lt;% java代码 %&gt;</p><h4 id="4、jsp声明变量或方法"><a href="#4、jsp声明变量或方法" class="headerlink" title="4、jsp声明变量或方法"></a>4、jsp声明变量或方法</h4><p>&lt;%! java代码 %&gt;</p><h4 id="5、jsp表达式"><a href="#5、jsp表达式" class="headerlink" title="5、jsp表达式"></a>5、jsp表达式</h4><p>&lt;%=表达式 %&gt;  ps:不可;分号结束</p><h4 id="6、jsp页面的生命周期"><a href="#6、jsp页面的生命周期" class="headerlink" title="6、jsp页面的生命周期"></a>6、jsp页面的生命周期</h4><p><img src="https://i.imgur.com/U27ljB4.png" alt="jsp_life_cycle.png"> </p><h3 id="二、jsp内置对象"><a href="#二、jsp内置对象" class="headerlink" title="二、jsp内置对象"></a>二、jsp内置对象</h3><p><strong> 九大内置对象：</strong><code>out</code>,<code>request</code>,<code>response</code>,<code>session</code>,<code>application</code>,<code>Page</code>,<code>pageContext</code>,<code>exception</code>,<code>config</code></p><p><strong>out</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line">   out.println("&lt;h2&gt;静夜思&lt;/h2&gt;");</span><br><span class="line">   out.println("床前明月光<span class="tag">&lt;<span class="name">br</span>&gt;</span>");</span><br><span class="line">   out.println("疑是地上霜<span class="tag">&lt;<span class="name">br</span>&gt;</span>");</span><br><span class="line">   out.flush();</span><br><span class="line">  /*out.clear();会抛出异常*/</span><br><span class="line">   out.clearBuffer();//这里不会抛出异常</span><br><span class="line">   out.println("举头望明月<span class="tag">&lt;<span class="name">br</span>&gt;</span>");</span><br><span class="line">   out.println("低头思故乡<span class="tag">&lt;<span class="name">br</span>&gt;</span>");</span><br><span class="line">   %&gt;</span><br><span class="line"></span><br><span class="line">   缓冲区大小：<span class="tag">&lt;<span class="name">%=</span> <span class="attr">out.getBufferSize</span>()%&gt;</span>byte<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   缓冲区剩余大小：<span class="tag">&lt;<span class="name">%=</span> <span class="attr">out.getRemaining</span>()%&gt;</span>byte<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   是否自动清空缓冲区：<span class="tag">&lt;<span class="name">%=</span> <span class="attr">out.isAutoFlush</span>()%&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>request</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">       <span class="attr">request.setCharacterEncoding</span>("<span class="attr">utf-8</span>");//解决<span class="attr">post</span>中文乱码问题，但无法解决<span class="attr">get</span>，<span class="attr">get</span>解决需要直接<span class="attr">Tomcat</span>配置文件</span></span><br><span class="line"><span class="tag">       <span class="attr">request.setAttribute</span>("<span class="attr">password</span>","<span class="attr">123456</span>");//设置属性密码</span></span><br><span class="line"><span class="tag">   %&gt;</span></span><br><span class="line">   用户名：<span class="tag">&lt;<span class="name">%=</span> <span class="attr">request.getParameter</span>("<span class="attr">username</span>")%&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   爱好：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">       <span class="attr">if</span>(<span class="attr">request.getParameterValues</span>("<span class="attr">favorite</span>") != <span class="string">null)&#123;</span>  //这里需要判断为不为空，<span class="attr">jsp</span>这里不能将<span class="attr">String</span>数组看为<span class="attr">Boolean</span></span></span><br><span class="line"><span class="tag">           <span class="attr">String</span>[] <span class="attr">favorites</span> = <span class="string">request.getParameterValues(</span>"<span class="attr">favorite</span>");</span></span><br><span class="line">           for (int i = 0; i &lt; favorites.length; i++) &#123;</span><br><span class="line">               out.println(favorites[i] + "&amp;nbsp;&amp;nbsp;&amp;nbsp;");</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       String realPath = request.getRealPath("requset.jsp");%&gt;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   密码：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getAttribute("password")%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   请求体的MIME类型：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getContentType()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   协议类型和版本号：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getProtocol()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   服务器主机名：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getServerName()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   服务器端口号：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getServerPort()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   请求文件长度：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getContentLength()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   请求的客户端地址：</span><br><span class="line">   &lt;%=request.getRemoteAddr()%&gt;&lt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">   请求的真实路径：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getRealPath("requset.jsp")%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   请求的上下文路径：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=request.getContextPath()%</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>response</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">       <span class="attr">response.setContentType</span>("<span class="attr">text</span>/<span class="attr">html</span>;<span class="attr">charset</span>=<span class="string">utf-8</span>");</span></span><br><span class="line">       out.println("&lt;h1&gt;response内置对象&lt;/h1&gt;");</span><br><span class="line">       out.println("<span class="tag">&lt;<span class="name">hr</span>&gt;</span>");</span><br><span class="line">       //out.flush();</span><br><span class="line">       /* 因为getWrite获得的输出流对象会先于内置对象out输出，</span><br><span class="line">       所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer</span><br><span class="line">       再输出out*/</span><br><span class="line"></span><br><span class="line">       PrintWriter outer = response.getWriter();</span><br><span class="line">       outer.println("大家好，我是response生成的输出流outer");</span><br><span class="line">//  response.sendRedirect("login.jsp");//重定向</span><br><span class="line">//  response.sendRedirect("request.jsp");</span><br><span class="line">       request.getRequestDispatcher("request.jsp").forward(request,response);//转发</span><br><span class="line">   %&gt;</span><br></pre></td></tr></table></figure><p><strong>请求转发和请求重定向的区别：</strong></p><p><img src="https://i.imgur.com/wWWpmzd.png" alt="redirectAndTransmit.PNG"></p><p><strong>session</strong><br>HttpSession的实例，周期：在第一个jsp页面被加载时自动创建，即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束，在服务器的几个页面之间切换，服务器应当知道这是一个客户，就可以用session对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">       <span class="attr">SimpleDateFormat</span> <span class="attr">sdf</span> = <span class="string">new</span> <span class="attr">SimpleDateFormat</span>("<span class="attr">yyyy</span>年<span class="attr">mm</span>月<span class="attr">dd</span>日 <span class="attr">HH:mm:ss</span>");</span></span><br><span class="line"><span class="tag">       <span class="attr">Date</span> <span class="attr">d</span> = <span class="string">new</span> <span class="attr">Date</span>(<span class="attr">session.getCreationTime</span>());</span></span><br><span class="line"><span class="tag">       <span class="attr">session.setAttribute</span>("<span class="attr">username</span>","<span class="attr">pinnuli</span>");</span></span><br><span class="line"><span class="tag">       <span class="attr">session.setAttribute</span>("<span class="attr">password</span>","<span class="attr">123456</span>");</span></span><br><span class="line"><span class="tag">       <span class="attr">session.setAttribute</span>("<span class="attr">age</span>",<span class="attr">20</span>);</span></span><br><span class="line"><span class="tag">//  <span class="attr">session.setMaxInactiveInterval</span>(<span class="attr">10</span>);</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">//设置<span class="attr">session</span>最大生成期限，单位秒,也可在<span class="attr">web.xml</span>中设置<span class="attr">session-timeout</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">   %&gt;</span></span><br><span class="line">   Session创建时间：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=sdf.format(d)%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   Session的ID：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=session.getId()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   Session中获取属性值：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%=session.getAttribute("username")%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   Session保存的属性数组：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">       <span class="attr">String</span>[] <span class="attr">names</span> = <span class="string">session.getValueNames();</span></span></span><br><span class="line">       for(int i=0; i&lt;names.length; i++)&#123;</span><br><span class="line">           out.println(names[i] + "&amp;nbsp;&amp;nbsp;");</span><br><span class="line">       &#125;</span><br><span class="line">//        session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session</span><br><span class="line">   %&gt;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">%--测试不同页面是否同一个session--%</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"session_page2.jsp"</span>&gt;</span>跳转到session_page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>application</strong><br>实现用户间数据的共享，可存放全局边变量，相当于java的静态变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">       <span class="attr">application.setAttribute</span>("<span class="attr">city</span>","广州");</span></span><br><span class="line"><span class="tag">       <span class="attr">application.setAttribute</span>("<span class="attr">postcode</span>","<span class="attr">510000</span>");</span></span><br><span class="line"><span class="tag">       <span class="attr">application.setAttribute</span>("<span class="attr">email</span>","<span class="attr">guangzhou</span>@<span class="attr">163.com</span>");</span></span><br><span class="line"><span class="tag">   %&gt;</span></span><br><span class="line">   所在城市：<span class="tag">&lt;<span class="name">%=application.getAttribute("city")%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   所有属性：</span><br><span class="line">   <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">       <span class="attr">Enumeration</span> <span class="attr">attributes</span> = <span class="string">application.getAttributeNames();</span></span></span><br><span class="line"><span class="tag">       <span class="attr">while</span> (<span class="attr">attributes.hasMoreElements</span>())&#123;</span></span><br><span class="line"><span class="tag">           <span class="attr">out.println</span>(<span class="attr">attributes.nextElement</span>() + "&amp;<span class="attr">nbsp</span>;&amp;<span class="attr">nbsp</span>;");</span></span><br><span class="line"><span class="tag">       &#125;</span></span><br><span class="line"><span class="tag">   %&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   jsp(serviet)引擎名和版本号：<span class="tag">&lt;<span class="name">%=application.getServerInfo()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>page、pageContext</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>page:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>当前page页面的字符串描述：<span class="tag">&lt;<span class="name">%=page.toString()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>pageContext:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>用户名：从session中获取属性-<span class="tag">&lt;<span class="name">%=pageContext.getSession().getAttribute("username")%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">%--跳转到其他页面--%</span>&gt;</span></span><br><span class="line">  &lt;%--&lt;%</span><br><span class="line">      pageContext.forward("out.jsp");</span><br><span class="line">  %&gt;--%&gt;</span><br><span class="line">   include方法，包含其他页面:</span><br><span class="line">       <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">           <span class="attr">pageContext.include</span>("<span class="attr">out.jsp</span>");</span></span><br><span class="line"><span class="tag">       %&gt;</span></span><br></pre></td></tr></table></figure><p><strong>exception</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">异常消息：<span class="tag">&lt;<span class="name">%=exception.getMessage()%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   异常的字符串描述：<span class="tag">&lt;<span class="name">%=exception.toString()%</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、jsp使用Javabean"><a href="#三、jsp使用Javabean" class="headerlink" title="三、jsp使用Javabean"></a>三、jsp使用Javabean</h3><h4 id="1-Javabean的设计原则"><a href="#1-Javabean的设计原则" class="headerlink" title="1. Javabean的设计原则"></a>1. Javabean的设计原则</h4><ul><li>必须是公有类</li><li>必须包含无参构造方法</li><li>属性私有</li><li>用getter()和setter()进行封装</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Students</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">Students</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-存取Javabean有关的jsp动作元素"><a href="#2-存取Javabean有关的jsp动作元素" class="headerlink" title="2. 存取Javabean有关的jsp动作元素"></a>2. 存取Javabean有关的jsp动作元素</h4><p><strong>在jsp页面中使用Javabeans：</strong></p><p>方法一：像使用普通java类一样，创建Javabean实例<br>方法二：在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty</p><ul><li><code>&lt;jsp:useBeans&gt;</code></li></ul><p>在jsp页面中实例化或者在指定范围内使用Javabean：</p><p><code>&lt;jsp:useBeans id=&quot;标示符&quot; class=&quot;java类名&quot; scope=&quot;作用范围&quot;/&gt;</code></p><blockquote><p>scope属性：指定Javabean的作用范围<br>page：当前页面,重定向和转发都无效<br>request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效<br>session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效<br>application:可通过application.getAttribute()取得Javabean对象，不同会话都有效</p></blockquote><p>例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:useBean</span> <span class="attr">id</span>=<span class="string">"myUsers"</span> <span class="attr">class</span>=<span class="string">"com.po.Users"</span> <span class="attr">scope</span>=<span class="string">"application"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:useBean</span>&gt;</span></span><br><span class="line">用户名：<span class="tag">&lt;<span class="name">jsp:getProperty</span> <span class="attr">name</span>=<span class="string">"myUsers"</span> <span class="attr">property</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:getProperty</span>&gt;</span></span><br><span class="line">密码：<span class="tag">&lt;<span class="name">jsp:getProperty</span> <span class="attr">name</span>=<span class="string">"myUsers"</span> <span class="attr">property</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:getProperty</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>也可使用内置对象获取：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：<span class="tag">&lt;<span class="name">%=((Users)application.getAttribute("myUsers")).getUsername()%</span>&gt;</span></span><br><span class="line">密码： <span class="tag">&lt;<span class="name">%=((Users)</span> <span class="attr">application.getAttribute</span>("<span class="attr">myUsers</span>"))<span class="attr">.getPassword</span>()%&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li><code>&lt;jsp:setProperty&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">根据表单自动匹配所有属性:</span><br><span class="line"><span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span>=<span class="string">"myUsers"</span> <span class="attr">property</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:setProperty</span>&gt;</span></span><br><span class="line"></span><br><span class="line">根据表单匹配部分属性:</span><br><span class="line"><span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span>=<span class="string">"myUsers"</span> <span class="attr">property</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:setProperty</span>&gt;</span></span><br><span class="line"></span><br><span class="line">与表单无关，通过手工赋值给属性:</span><br><span class="line"><span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span>=<span class="string">"myUsers"</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"hahahaha"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:setProperty</span>&gt;</span></span><br><span class="line"></span><br><span class="line">通过url传参数给属性赋值:</span><br><span class="line"><span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span>=<span class="string">"myUsers"</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">param</span>=<span class="string">"testparam"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:setProperty</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;jsp:getProperty&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用getProperty获取属性值:</span><br><span class="line"><span class="tag">&lt;<span class="name">jsp:getProperty</span> <span class="attr">name</span>=<span class="string">"myUsers"</span> <span class="attr">property</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">jsp:getProperty</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/166" target="_blank" rel="noopener">慕课网：JAVA遇见HTML——JSP篇</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、jsp简介&quot;&gt;&lt;a href=&quot;#一、jsp简介&quot; class=&quot;headerlink&quot; title=&quot;一、jsp简介&quot;&gt;&lt;/a&gt;一、jsp简介&lt;/h3&gt;&lt;h4 id=&quot;1、jsp三大指令&quot;&gt;&lt;a href=&quot;#1、jsp三大指令&quot; class=&quot;header
      
    
    </summary>
    
      <category term="JSP笔记" scheme="https://pinnuli.github.io/categories/JSP%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JSP" scheme="https://pinnuli.github.io/tags/JSP/"/>
    
      <category term="JavaWeb" scheme="https://pinnuli.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>vim的使用</title>
    <link href="https://pinnuli.github.io/2018/04/30/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://pinnuli.github.io/2018/04/30/vim的使用/</id>
    <published>2018-04-30T11:42:21.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、一般模式：光标的移动、复制粘贴、搜索替换"><a href="#一、一般模式：光标的移动、复制粘贴、搜索替换" class="headerlink" title="一、一般模式：光标的移动、复制粘贴、搜索替换"></a>一、一般模式：光标的移动、复制粘贴、搜索替换</h3><h4 id="移动光标："><a href="#移动光标：" class="headerlink" title="移动光标："></a>移动光标：</h4><p><strong> 向左移动一个字符：h 或 ← </strong><br><strong> 向右移动一个字符：l 或 → </strong><br><strong> 向上移动一个字符：k 或 ↑ </strong><br><strong> 向下移动一个字符：j 或 ↓ </strong><br>向左移动n个字符：n + h（其他同理)，如10h<br>向右移动这一行的n个字符(会换到下一行)：n + space,如20space<br>屏幕向上移动一页：Ctrl + b<br>屏幕向下移动一页：Ctrl + f<br>屏幕向上移动半页：Ctrl + u<br>屏幕向下移动半页：Ctrl + d<br>移动到非空格的下一行：+<br>移动到非空格的上一行：-<br>移动到屏幕最上方那一行的第一个字符：H<br>移动到屏幕最中间那一行的第一个字符：M<br>移动到屏幕最下方那一行的第一个字符：L<br><strong> 移动到这个文件的最后一行：G </strong><br>移动到这个文件的第n行：nG<br><strong> 移动到这个文件的第一行:gg </strong><br><strong> 向下移动n行：n + enter,如10enter </strong></p><blockquote><p>加粗部分为常用，以下同理</p></blockquote><h4 id="搜索替换："><a href="#搜索替换：" class="headerlink" title="搜索替换："></a>搜索替换：</h4><p><strong> 向光标往下搜索一个word的字符串：/word </strong><br><strong> 向光标往上搜索一个word的字符串：?word </strong><br><strong> 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 </strong><br><strong> 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g </strong><br><strong> 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g </strong><br><strong> 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc </strong></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong> 向前（后）删除一个字符：x(X)，相当于backspace </strong><br><strong> 连续向后删除n个字符： nx,如10x </strong><br><strong> 删除光标所在的一整行：dd </strong><br><strong> 删除光标所在的向下n行：ndd </strong><br>删除光标所在到第一行的所有数据：d1G<br>输出光标所在到最后一行的所有数据:dG<br>删除光标所在到该行最后一个字符：d$<br>删除光标所在到该行第一个字符：d0</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><strong> 复制光标所在的那一行：yy </strong><br><strong> 复制光标所在的向下n行：nyy </strong><br>复制光标所在行到第一行的所有数据：y1G<br>复制光标所在行到最后一行的所有数据:yG<br>复制光标所在到该行最后一个字符：y$<br>复制光标所在到该行第一个字符：y0</p><h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><p><strong> 将已复制的数据在光标下（上）一行贴上：p(P); </strong><br><strong> 将光标所在行与 下一行的数据结合成一行： J </strong><br>重复删除多个数据:c，如向下删除10行：10cj<br><strong> 复原前一个动作：u </strong><br><strong> 重复上一个动作：Ctrl + r </strong></p><h3 id="二、一般模式到编辑模式的切换"><a href="#二、一般模式到编辑模式的切换" class="headerlink" title="二、一般模式到编辑模式的切换"></a>二、一般模式到编辑模式的切换</h3><h4 id="进去输入模式"><a href="#进去输入模式" class="headerlink" title="进去输入模式"></a>进去输入模式</h4><ul><li><p>i/I<br><strong> 从目前光标所在处输入：i </strong><br><strong> 从目前所在行的第一个非空格符处开始输入：I </strong></p></li><li><p>a/A<br>从目前光标所在的下一个字符处开始输入:a<br>从光标所在行的最后一个字符处开始输入:A</p></li><li><p>o/O<br><strong> 在光标所在的下一行输入新的一行：o </strong><br><strong> 在光标所在的上一行输入新的一行：O </strong></p></li></ul><h4 id="进入取代模式"><a href="#进入取代模式" class="headerlink" title="进入取代模式"></a>进入取代模式</h4><ul><li>r/R<br><strong> 取代光标所在的那一个字符一次：r </strong><br><strong> 一直取代光标所在的字符，直到按esc </strong></li></ul><h3 id="三、一般模式到命令行模式的切换"><a href="#三、一般模式到命令行模式的切换" class="headerlink" title="三、一般模式到命令行模式的切换"></a>三、一般模式到命令行模式的切换</h3><h4 id="指令行的存储、离开等"><a href="#指令行的存储、离开等" class="headerlink" title="指令行的存储、离开等"></a>指令行的存储、离开等</h4><p><strong> 保存编辑： :w </strong><br><strong> 强制写入： :w! </strong><br><strong> 退出： :q </strong><br><strong> 强制退出，不保存修改： :q! </strong><br><strong> 保存修改后退出： :wq </strong><br><strong> 将修改后的数据另存为一个文件： :w filename </strong><br>在当前编辑的数据中，读入另一个文件的数据： :r filename<br>将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename<br><strong>     暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 </strong></p><h4 id="vim环境的变更"><a href="#vim环境的变更" class="headerlink" title="vim环境的变更"></a>vim环境的变更</h4><p>显示行号： :set nu<br>取消显示行号： :set nonu</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、一般模式：光标的移动、复制粘贴、搜索替换&quot;&gt;&lt;a href=&quot;#一、一般模式：光标的移动、复制粘贴、搜索替换&quot; class=&quot;headerlink&quot; title=&quot;一、一般模式：光标的移动、复制粘贴、搜索替换&quot;&gt;&lt;/a&gt;一、一般模式：光标的移动、复制粘贴、搜索
      
    
    </summary>
    
      <category term="编辑器" scheme="https://pinnuli.github.io/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="vim" scheme="https://pinnuli.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA 使用技巧</title>
    <link href="https://pinnuli.github.io/2018/04/30/IntelliJ-IDEA-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://pinnuli.github.io/2018/04/30/IntelliJ-IDEA-使用技巧/</id>
    <published>2018-04-30T02:18:35.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、跳转快捷键"><a href="#一、跳转快捷键" class="headerlink" title="一、跳转快捷键"></a>一、跳转快捷键</h3><p>窗口切换：Ctrl + alt + [ / ]<br>文件切换：alt + -&gt; / &lt;-<br>关闭文件：ctrl + f4<br>最近修改文件： ctrl + tab + E<br>最近浏览文件： ctrl + E<br>回到上次编辑的地方 last edit location: ctrl + shift + backspace<br>回到上次浏览的地方 back/forward: ctrl + alt + -&gt;/&lt;-<br>利用书签跳转：<br>bookmarks:f11<br>bookmarks mnemonic: ctrl + f11<br>show bookmarks: shift + f11<br>书签跳转：Ctrl + 1（n）<br>收藏（类或方法）：shift + alt + F<br>emacsIDEAs 跳转：shift + j(这个是自己设的)  然后按要找单词的首字母，如p，然后选择<br>编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n)<br>                   从文件去到编辑区：esc</p><h3 id="二、精准搜索"><a href="#二、精准搜索" class="headerlink" title="二、精准搜索"></a>二、精准搜索</h3><p>搜索类：ctrl + alt + N(Ctrl + N 已被vim占用）<br>搜索文件： ctrl + shift + N<br>搜索符号（方法和属性）：ctrl + shift + alt + N<br>搜索字符串： ctrl + shift + F<br>        Match case :区分大小写<br>        Words：搜索的字符串是一个单词<br>        Regex：按照正则表达式搜索<br>        File mask:指定文件类型<br>        In Project：在项目下搜搜<br>        Module：在当前模块下搜索<br>        Directory：在指定目录下搜索<br>        Scope：在指定范围下搜索</p><p>待补充。。。</p><blockquote><p>参阅：<br>  <a href="https://www.imooc.com/learn/924" target="_blank" rel="noopener">慕课网：IntelliJ IDEA神器使用技巧</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、跳转快捷键&quot;&gt;&lt;a href=&quot;#一、跳转快捷键&quot; class=&quot;headerlink&quot; title=&quot;一、跳转快捷键&quot;&gt;&lt;/a&gt;一、跳转快捷键&lt;/h3&gt;&lt;p&gt;窗口切换：Ctrl + alt + [ / ]&lt;br&gt;文件切换：alt + -&amp;gt; / &amp;lt;
      
    
    </summary>
    
      <category term="编辑器" scheme="https://pinnuli.github.io/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="IDEA" scheme="https://pinnuli.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>进程并发常见问题基于信号量解决方法总结：生产者/消费者问题、读/写者问题、银行家算法、哲学家进餐</title>
    <link href="https://pinnuli.github.io/2018/04/16/%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90/"/>
    <id>https://pinnuli.github.io/2018/04/16/进程并发常见问题基于信号量解决方法总结：生产者消费者问题、读写者问题、银行家算法、哲学家进餐/</id>
    <published>2018-04-16T11:07:43.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、信号量"><a href="#一、信号量" class="headerlink" title="一、信号量"></a>一、信号量</h3><ul><li>信号量是一个与队列有关的整型变量。</li><li>可以初始化成非负数；</li><li>semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；</li><li>semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。</li></ul><h4 id="信号量原语semWait和semSignal的定义"><a href="#信号量原语semWait和semSignal的定义" class="headerlink" title="信号量原语semWait和semSignal的定义"></a>信号量原语semWait和semSignal的定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">strcut semaphore&#123;</span><br><span class="line">int count;</span><br><span class="line">aueueType queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void semWait(semaphore s) &#123;</span><br><span class="line">s.count--;</span><br><span class="line"><span class="keyword">if</span>(s.count &lt; 0) &#123;</span><br><span class="line">place this process <span class="keyword">in</span> s.queue;</span><br><span class="line">block this process;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void semSignal(semaphore s) &#123;</span><br><span class="line">s.count ++;</span><br><span class="line"><span class="keyword">if</span>(s.count &lt;= 0) &#123;</span><br><span class="line">remove a process P from s.queue;</span><br><span class="line">place process P on ready list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量实现互斥"><a href="#信号量实现互斥" class="headerlink" title="信号量实现互斥"></a>信号量实现互斥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const int n;</span><br><span class="line">semaphore s = 1;</span><br><span class="line">void P(int i) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">semWait(s);</span><br><span class="line">operate;</span><br><span class="line">semSignal(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">parbegin(P(1), P(2), ...,P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>信号量</strong></p><ul><li>一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。</li><li>用于互斥时，S初值为1，取值为1~ - (n-1)        （相当于临界区的通行证，实际上也是资源个数）<br>  S=1：临界区可用<br>  S=0：已有一进程进入临界区<br>  S&lt;0：临界区已被占用，|S|个进程正等待进入</li><li>用于同步时，S初值&gt;=0<br>  S&gt;=0:表示可用资源个数<br>  S&lt;0: 表示该资源的等待队列长度</li></ul><p><strong>semWait、semSignal操作</strong></p><ul><li>semWait(S)：请求分配一个资源。</li><li>semSignal(S)：释放一个资源。</li><li>semWait、semSignal操作必须成对出现。</li><li>用于互斥时，位于同一进程内；</li><li>用于同步时，交错出现于两个合作进程内。</li><li>多个semWait操作的次序不能颠倒，否则可能导致死锁。 </li><li>多个semSignal操作的次序可任意。</li></ul><p>二、生产者/消费者问题</p><p><strong>问题描述：</strong><br>    有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；<br>    有一个消费者从缓冲区中取数据，每次取一项；<br>    系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区;<br>    缓存已满时，生产者不能继续添加数据；<br>    缓存已空时，消费者不能继续移走数据。</p><p><strong>producer:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">/* produce item v */</span><br><span class="line"><span class="keyword">while</span>((<span class="keyword">in</span> + 1) % n == out) //等待缓存有空位</span><br><span class="line">/* doing nothing */</span><br><span class="line">b[<span class="keyword">in</span>] = v;</span><br><span class="line"><span class="keyword">in</span> = (<span class="keyword">in</span> + 1) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>consumer:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">in</span> == out) //此时缓存为空，等待生产者生产放入缓存后才可消费</span><br><span class="line">/* doing nothing */</span><br><span class="line">w = b[out];</span><br><span class="line">out = (out + 1) % n;</span><br><span class="line">/* consume item w */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有限缓冲区：</strong></p><p><img src="/images/process_concurrent_finite_buffer.png" alt="process_concurrent_finite_buffer"></p><p><strong>使用信号量解决有限缓冲区生产者消费者问题:</strong></p><blockquote><p>n 表示已生产产品的数量<br>s 用来控制互斥<br>e 表示空闲空间数目</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">semaphore n = 0, s = 1, e = buf - size;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">producer</span></span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">produce();</span><br><span class="line">semWait(e);</span><br><span class="line">semWait(s);</span><br><span class="line">append();</span><br><span class="line">semSignal(s);</span><br><span class="line">semSignal(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">consumer</span></span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">semWait(n);</span><br><span class="line">semWait(s);</span><br><span class="line">take();</span><br><span class="line">semSignal(s);</span><br><span class="line">semSignal(e);</span><br><span class="line">consume();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题<br>1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。</p><p>分析：<br>    生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。</p><p>数据结构： semaphore dish, apple, banana;<br>    dish: 表示盘子是否为空,用于控制互斥<br>    apple：表示盘子中是否有苹果，初始值为0<br>    banana:表示盘子中是否有香蕉，初始值为0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">process <span class="function"><span class="title">father</span></span>() &#123;</span><br><span class="line">semWait(dish);</span><br><span class="line">put the apple <span class="keyword">in</span> the dish;</span><br><span class="line">semSignal(apple);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process <span class="function"><span class="title">mother</span></span>() &#123;</span><br><span class="line">semWait(dish);</span><br><span class="line">put the banana <span class="keyword">in</span> the dish;</span><br><span class="line">semSignal(banana);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process <span class="function"><span class="title">son</span></span>() &#123;</span><br><span class="line">semWait(banana);</span><br><span class="line">get the banana from the dish;</span><br><span class="line">semSignal(dish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process <span class="function"><span class="title">daughter</span></span>() &#123;</span><br><span class="line">semWait(apple);</span><br><span class="line">get the apple from the dish;</span><br><span class="line">semSignal(dish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。</p><p>分析：<br>    实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系</p><p>数据结构：semaphore s1, s2;<br>    s1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0；</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">process <span class="function"><span class="title">p1</span></span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">semWait(s1);</span><br><span class="line">Pick a white chessman;</span><br><span class="line">semSignal(s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process <span class="function"><span class="title">p2</span></span>() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">semWait(s2);</span><br><span class="line">Pick a white chessman;</span><br><span class="line">semSignal(s1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。</p><p>分析：<br>    实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室</p><p>数据结构：<br>    strcut {<br>        char name[10];<br>        int number;<br>    } a[100]; //表示进入阅览室的小朋友<br>    semaphore mutex, seatcount;<br>        mutex: 用来控制互斥，初始值为1<br>        seatcount： 对空座位进行计数，初始值为100；</p><pre><code>初始化入室人员信息for(int i = 0; i &lt; 100; i++){    a[i].number = i;    a[i].name = null;}</code></pre> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">process readeri(char readername[]) &#123;</span><br><span class="line">semWait(seatcount);  //等待空余作为，若人数未满100，则直接进入，到达100，则等待</span><br><span class="line">semWait(mutex); //控制互斥</span><br><span class="line"></span><br><span class="line">/* 进入是登记 */</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; 100; i++)</span><br><span class="line"><span class="keyword">if</span>(a[i].name == null)&#123;//找到名字为空的座位</span><br><span class="line">a[i].name = readername;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">reader get the seat nember i;</span><br><span class="line">semSiganl(mutex);</span><br><span class="line">go into the reading room and sit down at the seat number i.</span><br><span class="line"></span><br><span class="line">/* 离开时登记 */</span><br><span class="line">semWait(mutex);</span><br><span class="line">a[i].name = null;  </span><br><span class="line">semSignal(mutex);</span><br><span class="line">semSignal(seatcount);</span><br><span class="line">leave reading room;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、读/写者问题<br>    描述：<br>    有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件：<br>    任意多的读进程可以同时读文件；<br>    一次只有一个写进程可以写文件；<br>    如果一个写进程正在写文件，那么禁止任何读进程读文件。</p><p>读者优先</p><p>分析：<br>    当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。    </p><p>数据结构：<br>    readcount: 控制wsem的的设置<br>    wsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。<br>    x: 用于确保readcount被正确更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int readcount;</span><br><span class="line">semphore x = 1, wsem = 1;</span><br><span class="line">void <span class="function"><span class="title">reader</span></span>() &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> semWait(x);</span><br><span class="line">  readcount++;</span><br><span class="line">  <span class="keyword">if</span>(readcount==1)</span><br><span class="line">     semWait(wsem);  //如果是第一个读者，则要控制wsem</span><br><span class="line">  semSignal(x);</span><br><span class="line">  READUNIT();   </span><br><span class="line">semWait(x);</span><br><span class="line">readcount--;</span><br><span class="line"><span class="keyword">if</span>(readcount==0)</span><br><span class="line">  semSignal(wsem);</span><br><span class="line">semSignal(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">writer</span></span>()&#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> semWait(wsem);</span><br><span class="line">  WRITEUNIT();</span><br><span class="line">  semSignal(wsem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：<br>    独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法)</p><p>数据结构：</p><pre><code>mutex1/mutex2: 用于确保count1/count2被准备更新count1/count2: 控制wait的设置wait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">semaphore <span class="built_in">wait</span>=1, mutex1=1, mutex2=1;</span><br><span class="line">int count1=0, count2=0; </span><br><span class="line"></span><br><span class="line">process P <span class="function"><span class="title">east</span></span>()&#123;</span><br><span class="line">   semWait(mutex1);</span><br><span class="line">     count1++;</span><br><span class="line">     <span class="keyword">if</span>(count1==1)   semWait(<span class="built_in">wait</span>);</span><br><span class="line">     semSignal(mutex1);</span><br><span class="line">      through the singal-log bridge；</span><br><span class="line">     semWait(mutex1);</span><br><span class="line">     count1--;</span><br><span class="line">     <span class="keyword">if</span>(count1==0)   semSignal(<span class="built_in">wait</span>);</span><br><span class="line">     semSignal(mutex1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">process P <span class="function"><span class="title">west</span></span>()&#123;</span><br><span class="line">   semWait(mutex2);</span><br><span class="line">     count2++;</span><br><span class="line">     <span class="keyword">if</span>(count2==1)   semWait(<span class="built_in">wait</span>);</span><br><span class="line">     semSignal(mutex2);</span><br><span class="line">       through the singal-log bridge；</span><br><span class="line">     semWait(mutex2);</span><br><span class="line">     count2--;</span><br><span class="line">     <span class="keyword">if</span>(count2==0)   semSignal(<span class="built_in">wait</span>);</span><br><span class="line">     semSignal(mutex2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>待整理。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、信号量&quot;&gt;&lt;a href=&quot;#一、信号量&quot; class=&quot;headerlink&quot; title=&quot;一、信号量&quot;&gt;&lt;/a&gt;一、信号量&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;信号量是一个与队列有关的整型变量。&lt;/li&gt;
&lt;li&gt;可以初始化成非负数；&lt;/li&gt;
&lt;li&gt;semWa
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://pinnuli.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="OS" scheme="https://pinnuli.github.io/tags/OS/"/>
    
      <category term="计算机基础" scheme="https://pinnuli.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>git多账号配置，同时使用多个代码托管平台</title>
    <link href="https://pinnuli.github.io/2018/04/09/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/"/>
    <id>https://pinnuli.github.io/2018/04/09/git多账号配置，同时使用多个代码托管平台/</id>
    <published>2018-04-09T13:01:52.000Z</published>
    <updated>2018-10-26T04:42:38.411Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。</p><blockquote><p>ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。</p></blockquote><h3 id="1-生成密钥"><a href="#1-生成密钥" class="headerlink" title="1 生成密钥"></a>1 生成密钥</h3><p>这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -T rsa -C <span class="string">"example@qq.com"</span></span><br></pre></td></tr></table></figure><p>生成github的密钥<img src="/images/git_multiaccount_ssh_github.jpg" alt="git_multi_account_ssh_github"></p><p>生成osc的密钥<img src="/images/git_multiaccount_ssh_osc.jpg" alt="git_multi_account_ssh_osc"></p><p>查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a /root/.ssh</span><br></pre></td></tr></table></figure><p><img src="/images/git_multiaccount_ssh_file.png" alt="git_multi_account_ssh_file"></p><h3 id="2-接下来配置多账号"><a href="#2-接下来配置多账号" class="headerlink" title="2 接下来配置多账号"></a>2 接下来配置多账号</h3><p>在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#github</span></span><br><span class="line">       Host github.com    </span><br><span class="line">       HostName github.com</span><br><span class="line">       IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line">       User pinnuli</span><br><span class="line"></span><br><span class="line"><span class="comment">#osc</span></span><br><span class="line">       Host gitee.com</span><br><span class="line">       HostName gitee.com</span><br><span class="line">       IdentityFile ~/.ssh/id_rsa_osc</span><br><span class="line">       User pinnuli</span><br></pre></td></tr></table></figure><p><img src="/images/git_multiaccount_config.png" alt="git_multiaccount_config"></p><h3 id="3-把对应的公钥放到github和osc上面"><a href="#3-把对应的公钥放到github和osc上面" class="headerlink" title="3 把对应的公钥放到github和osc上面"></a>3 把对应的公钥放到github和osc上面</h3><p><img src="/images/git_multiaccount_pub_github.png" alt="git_multiaccount_pub_github"></p><p><img src="/images/git_multiaccount_pub_osc.png" alt="git_multiaccount_pub_osc"></p><h3 id="4-测试是否成功"><a href="#4-测试是否成功" class="headerlink" title="4 测试是否成功"></a>4 测试是否成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="/images/git_multiaccount_connect_github.png" alt="git_multiaccount_connect_github"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure><p><img src="/images/git_multiaccount_connect_osc.png" alt="git_multiaccount_connect_osc"></p><p>至此，git多账号配置完毕，需要更多账号也是一样的道理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps:这里是在centos7.2下操作，不过其他操作系统
      
    
    </summary>
    
      <category term="git" scheme="https://pinnuli.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://pinnuli.github.io/tags/git/"/>
    
  </entry>
  
</feed>
