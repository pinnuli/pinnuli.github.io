{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/database_transaction_state.png","path":"images/database_transaction_state.png","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_config.png","path":"images/git_multiaccount_config.png","modified":0,"renderable":0},{"_id":"source/images/filter_chain.png","path":"images/filter_chain.png","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_connect_github.png","path":"images/git_multiaccount_connect_github.png","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_connect_osc.png","path":"images/git_multiaccount_connect_osc.png","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_pub_github.png","path":"images/git_multiaccount_pub_github.png","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_ssh_github.jpg","path":"images/git_multiaccount_ssh_github.jpg","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_ssh_osc.jpg","path":"images/git_multiaccount_ssh_osc.jpg","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_pub_osc.png","path":"images/git_multiaccount_pub_osc.png","modified":0,"renderable":0},{"_id":"source/images/git_multiaccount_ssh_file.png","path":"images/git_multiaccount_ssh_file.png","modified":0,"renderable":0},{"_id":"source/images/jvm_class_file_format.jpg","path":"images/jvm_class_file_format.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_classloader_doubleparent.jpg","path":"images/jvm_classloader_doubleparent.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_gc_duplicate.jpg","path":"images/jvm_gc_duplicate.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_gc_markarrange.jpg","path":"images/jvm_gc_markarrange.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret.jpg","path":"images/jvm_interpret.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret_execute_1.jpg","path":"images/jvm_interpret_execute_1.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_gc_markclean.jpg","path":"images/jvm_gc_markclean.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret_execute_2.jpg","path":"images/jvm_interpret_execute_2.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret_execute_3.jpg","path":"images/jvm_interpret_execute_3.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret_execute_5.jpg","path":"images/jvm_interpret_execute_5.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret_execute_7.jpg","path":"images/jvm_interpret_execute_7.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret_execute_6.jpg","path":"images/jvm_interpret_execute_6.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_interpret_execute_4.jpg","path":"images/jvm_interpret_execute_4.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_object_reference_handle.jpg","path":"images/jvm_object_reference_handle.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_method_dispatch.jpg","path":"images/jvm_method_dispatch.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_stackframe_operandstack.jpg","path":"images/jvm_stackframe_operandstack.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_stackframe_structure.jpg","path":"images/jvm_stackframe_structure.jpg","modified":0,"renderable":0},{"_id":"source/images/markdownpad2.png","path":"images/markdownpad2.png","modified":0,"renderable":0},{"_id":"source/images/process_concurrent_finite_buffer.png","path":"images/process_concurrent_finite_buffer.png","modified":0,"renderable":0},{"_id":"source/images/servlet_life_cycle.png","path":"images/servlet_life_cycle.png","modified":0,"renderable":0},{"_id":"source/images/tcp_channel_utilization.jpg","path":"images/tcp_channel_utilization.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_build_connect.jpg","path":"images/tcp_build_connect.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_confirm_lose.jpg","path":"images/tcp_confirm_lose.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_object_reference_pointer.jpg","path":"images/jvm_object_reference_pointer.jpg","modified":0,"renderable":0},{"_id":"source/images/jvm_thread_wm_mm.png","path":"images/jvm_thread_wm_mm.png","modified":0,"renderable":0},{"_id":"source/images/tcp_no_error.jpg","path":"images/tcp_no_error.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_header.jpg","path":"images/tcp_header.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_congestion_avoid.jpg","path":"images/tcp_congestion_avoid.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_quick_recovery.jpg","path":"images/tcp_quick_recovery.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_quick_resend.jpg","path":"images/tcp_quick_resend.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_red.jpg","path":"images/tcp_red.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_confirm_late.jpg","path":"images/tcp_confirm_late.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_recieve_cahce.jpg","path":"images/tcp_recieve_cahce.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_release_connect.jpg","path":"images/tcp_release_connect.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_rto_calculate.jpg","path":"images/tcp_rto_calculate.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_limited_state_machine.jpg","path":"images/tcp_limited_state_machine.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_rtts_calculate.jpg","path":"images/tcp_rtts_calculate.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_send_cahce.jpg","path":"images/tcp_send_cahce.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_rttd_calculate.jpg","path":"images/tcp_rttd_calculate.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_slow_start.jpg","path":"images/tcp_slow_start.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_stream.png","path":"images/tcp_stream.png","modified":0,"renderable":0},{"_id":"source/images/tcp_window_state.jpg","path":"images/tcp_window_state.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_window_flow_control.jpg","path":"images/tcp_window_flow_control.jpg","modified":0,"renderable":0},{"_id":"source/images/tcp_window_send.jpg","path":"images/tcp_window_send.jpg","modified":0,"renderable":0},{"_id":"source/images/udp_header.png","path":"images/udp_header.png","modified":0,"renderable":0},{"_id":"source/images/filter_chain_process.png","path":"images/filter_chain_process.png","modified":0,"renderable":0},{"_id":"source/images/YyHsnwD.png","path":"images/YyHsnwD.png","modified":0,"renderable":0},{"_id":"source/images/filter_lifecycle.png","path":"images/filter_lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/filter_work_principle.png","path":"images/filter_work_principle.png","modified":0,"renderable":0},{"_id":"source/images/jsp_life_cycle.png","path":"images/jsp_life_cycle.png","modified":0,"renderable":0},{"_id":"source/images/jsp_diff_between_includeCommand_includeAction.PNG","path":"images/jsp_diff_between_includeCommand_includeAction.PNG","modified":0,"renderable":0},{"_id":"source/images/jvm_class_file_finaltype.jpg","path":"images/jvm_class_file_finaltype.jpg","modified":0,"renderable":0},{"_id":"source/images/jsp_diff_dispatch_redirect.png","path":"images/jsp_diff_dispatch_redirect.png","modified":0,"renderable":0},{"_id":"source/images/redirectAndTransmit.PNG","path":"images/redirectAndTransmit.PNG","modified":0,"renderable":0},{"_id":"source/images/database_lock_types_comp.png","path":"images/database_lock_types_comp.png","modified":0,"renderable":0},{"_id":"source/images/tcp_timeout_resend.jpg","path":"images/tcp_timeout_resend.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/20180223220057.png","path":"images/20180223220057.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"source/images/filter_classify.png","path":"images/filter_classify.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1540528958427},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1540528958427},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1540528958427},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1540528958427},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1540528958427},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1540528958427},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1540528958427},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1540528958427},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1540528958427},{"_id":"themes/next/README.cn.md","hash":"5d8af3d8de8d3926126a738519e97c8442b0effe","modified":1540528958427},{"_id":"themes/next/_config.yml","hash":"effc026e0b375ccb2028a7cdc6e3a03bb7d760b4","modified":1540528958427},{"_id":"themes/next/README.md","hash":"44b28d995681a7c48bfe3d0577d6203812d07e59","modified":1540528958427},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1540528958427},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1540528958427},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1540528958431},{"_id":"source/_posts/2018要学的知识.md","hash":"18b241f1ec3e0a00744efaad7f1423577b844903","modified":1540528958411},{"_id":"source/_posts/Java-Socket应用.md","hash":"4d30b6dc98c8dbc53892ade3e69ca5bfd686e754","modified":1542537753579},{"_id":"source/_posts/IntelliJ-IDEA-使用技巧.md","hash":"b45f3964f68110d66909cc635ebc3b385c56715e","modified":1540528958411},{"_id":"source/.vscode/settings.json","hash":"2978e14530291b98156c1a339a673c6ebb7c8a76","modified":1540528958411},{"_id":"source/_posts/Java-Web-过滤器.md","hash":"6e8ca0648f828565594e8579b404b8fcc332c2a7","modified":1542027669376},{"_id":"source/_posts/JSP学习笔记.md","hash":"a0e26364c181acd9cd5346eb26fa7c00d3b3ffb9","modified":1543156607787},{"_id":"source/_posts/Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J.md","hash":"9f78b8f77dfa74c763ef468f53dd3071caa13e53","modified":1542089587092},{"_id":"source/_posts/Java并发.md","hash":"dfd67058a4be5cd68f698c56c251e062f78b6268","modified":1542885796458},{"_id":"source/_posts/Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J.md","hash":"a3c40c8c76e9b6b7ff263855bcb1eddffb21947a","modified":1542089592492},{"_id":"source/_posts/Spring-Bean装配之各装配项-XML实现和注解实现.md","hash":"f3fa189862f893cbe6052d5477e48a1a5b859511","modified":1542027682415},{"_id":"source/_posts/Spring-Bean装配之基于Java的容器注解.md","hash":"e3d12f5e6f035aa47d4169438888ae8a3e2484f4","modified":1542027684391},{"_id":"source/_posts/centos7-Let-s-Encrypt用Certbot获取Https证书-部署nginx.md","hash":"9d679dcad46af5b3f27e106aa985774fb5f94871","modified":1540528958411},{"_id":"source/_posts/Spring-Bean装配之Autowired注解.md","hash":"4dea1bd17f7f2e87822651cf2cf5a73ab7270544","modified":1542027624281},{"_id":"source/_posts/Java-Web-监听器.md","hash":"f5de0a037e553a439052bd5ac35f92dac04f1330","modified":1542027676167},{"_id":"source/_posts/Java中的XML之与HTML的区别验证，定位信息，命名空间.md","hash":"c6e2b3c275f3b2c6c5f3deb1db80a569412b589c","modified":1542089594048},{"_id":"source/_posts/java反射.md","hash":"c8bc845fcf552ef296b705e399592c2b5aa50057","modified":1548059172674},{"_id":"source/_posts/java注解.md","hash":"e1799cc8d1d30a036f9b3b658e39c5b5cfb94e32","modified":1542089581276},{"_id":"source/_posts/java集合框架.md","hash":"5ca3f7b6a2634a33517d13f964bde96b17560dff","modified":1544497827824},{"_id":"source/_posts/git分支管理.md","hash":"bca8dd32d8dd5287d5d35705488ef9479c34de2d","modified":1540528958411},{"_id":"source/_posts/git多账号配置，同时使用多个代码托管平台.md","hash":"9b8ce25d16aca75de71f35d92f128e118c45cf8d","modified":1540528958411},{"_id":"source/_posts/jsoup要点记录.md","hash":"fdf47ceba4a8af270d268157c6757ac049517b8e","modified":1540528958411},{"_id":"source/_posts/markdownpad2-无法预览-显示This-view-has-crashed.md","hash":"6460914d8ec32ef9c6e380460a66f641abef64e0","modified":1540528958411},{"_id":"source/_posts/nginx-配置实现端口转发.md","hash":"0b9c25a6a395ff425f0272398c94bdaf8d3acdc6","modified":1540528958411},{"_id":"source/_posts/五层体系结构之运输层.md","hash":"c27b6767e4db8d7ee750949bc1f4bee65b16e6f2","modified":1544584032934},{"_id":"source/_posts/单例模式的几种写法对比.md","hash":"d0217018ff79380b88696d56ff5b1a806d22cfa0","modified":1550238313669},{"_id":"source/_posts/实现简单的jdk动态代理.md","hash":"48ab4f2229ccf0d0bb8b18dfc0e99a515e602b2d","modified":1548075700507},{"_id":"source/_posts/数据库事务管理.md","hash":"55cbbc62b370f3d81946621405f0262c39b42cb0","modified":1541487968873},{"_id":"source/_posts/vim的使用.md","hash":"096b16acf544bc83507cb4117cab3fb82176a7fb","modified":1540528958411},{"_id":"source/_posts/深入理解Java虚拟机之Java中的锁优化.md","hash":"25b380bda1a5b32c85e8dc34656759eb5bc770e1","modified":1544188733441},{"_id":"source/_posts/java-io流与文件.md","hash":"4625aee8f7309e7fd5b942f1e66f6ea9193a37ae","modified":1542089597032},{"_id":"source/_posts/深入理解Java虚拟机之Class类文件结构.md","hash":"2ee23c72d7ccf8fd5e4f11f3351e0adfb4149c20","modified":1544189178351},{"_id":"source/_posts/深入理解Java虚拟机之垃圾收集器与内存分配策略.md","hash":"5dd8a636cf91b4e4d36a41a3647b02bd07402ecd","modified":1544189535376},{"_id":"source/_posts/深入理解Java虚拟机之Java内存模型.md","hash":"b661063aa2ac0cf2bc35d6e59dba28ec138f48a0","modified":1544188749001},{"_id":"source/_posts/深入理解Java虚拟机之虚拟机类加载机制.md","hash":"365adcb47c5ae84c750105cc9f498f6fa5da105c","modified":1544189862460},{"_id":"source/_posts/进程并发常见问题基于信号量解决方法总结：生产者消费者问题、读写者问题、银行家算法、哲学家进餐.md","hash":"58525f4e2c77b99dd35169d20f30c4ac83b19a2d","modified":1540528958411},{"_id":"source/_posts/深入理解Java虚拟机之Java内存区域.md","hash":"bc897f5bd9b1520a9c6395f36dad3ef101574e0f","modified":1544189428050},{"_id":"source/tags/index.md","hash":"f8e35eaf7e71dbe226de4cec2392567709c67d11","modified":1540528958419},{"_id":"source/_posts/servlet笔记.md","hash":"32880f37736d07e7ee4701791992908942dcb145","modified":1542027655684},{"_id":"source/_posts/深入理解Java虚拟机之虚拟机字节码执行引擎.md","hash":"2829406bafddba0741fa9334bb0475a94845cefc","modified":1544189241272},{"_id":"source/images/database_transaction_state.png","hash":"d9253494df9df5c5b257d1ca988b259893d2cf34","modified":1543156761418},{"_id":"source/images/git_multiaccount_config.png","hash":"b40be9d9dfa3e3b2df554f395a9d80ca75497285","modified":1540528958415},{"_id":"source/images/filter_chain.png","hash":"ccb428df36e1254b93ab4921eba5c7acb3cf922f","modified":1540528958411},{"_id":"source/images/git_multiaccount_connect_github.png","hash":"4c405a77309aa6b578c9fb3039151b95a0f455f8","modified":1540528958415},{"_id":"source/images/git_multiaccount_connect_osc.png","hash":"496278ad1e3cf95e31b5cacb054171c870aa796a","modified":1540528958415},{"_id":"source/images/git_multiaccount_pub_github.png","hash":"26e1c350b93edd773e3530ac74209f4ccc1355fd","modified":1540528958415},{"_id":"source/images/git_multiaccount_ssh_github.jpg","hash":"fab9289abda553c1e9699afc010139d6f9991379","modified":1540528958415},{"_id":"source/images/git_multiaccount_ssh_osc.jpg","hash":"b1dc1acaf0675a47944e635c260b9794c86e959b","modified":1540528958415},{"_id":"source/images/git_multiaccount_pub_osc.png","hash":"0d94b413269fd3e868b7e515a169586f1fa03384","modified":1540528958415},{"_id":"source/images/git_multiaccount_ssh_file.png","hash":"5905566a116c6146fff368a079874694d89cc392","modified":1540528958415},{"_id":"source/images/jvm_class_file_format.jpg","hash":"4483ea0d1527d4f7e5b86fb324c1509c37b49414","modified":1544189147486},{"_id":"source/images/jvm_classloader_doubleparent.jpg","hash":"57fea97f338c6b92addf9b2ae66d5ea48e8c2a60","modified":1544189147486},{"_id":"source/images/jvm_gc_duplicate.jpg","hash":"b77c29edbf97209e9dcb04a3807d4ab3ae3f30e0","modified":1544189147486},{"_id":"source/images/jvm_gc_markarrange.jpg","hash":"45dded66f3e15b98308a0c6fd4f131d05470a6f2","modified":1544189147486},{"_id":"source/images/jvm_interpret.jpg","hash":"21cecf80b042c45baa31ebf9d184bc0890935143","modified":1544189147486},{"_id":"source/images/jvm_interpret_execute_1.jpg","hash":"558a4c0a273d6416ac88ab40bec826e79e539a85","modified":1544189147486},{"_id":"source/images/jvm_gc_markclean.jpg","hash":"398e9952745a4fa80d471cf188c8a57ea9961f68","modified":1544189147486},{"_id":"source/images/jvm_interpret_execute_2.jpg","hash":"a85c414901be75c8a6108eff60362d8e6aae8902","modified":1544189147486},{"_id":"source/images/jvm_interpret_execute_3.jpg","hash":"337bbc31bf035e7b5cf7fe189c8ccf434168d8aa","modified":1544189147486},{"_id":"source/images/jvm_interpret_execute_5.jpg","hash":"4a8f45ea3ce56df9f6b4e91a83c1c399ce61c245","modified":1544189147486},{"_id":"source/images/jvm_interpret_execute_7.jpg","hash":"ec6bf3689f06aca978ab006a15fcf972b029302e","modified":1544189147486},{"_id":"source/images/jvm_interpret_execute_6.jpg","hash":"8e78f8ee9b3b82e96e59f6a0dab7ad293225c28a","modified":1544189147486},{"_id":"source/images/jvm_interpret_execute_4.jpg","hash":"2b39190560112fa1aa1a523c6902052c1923ccf0","modified":1544189147486},{"_id":"source/images/jvm_object_reference_handle.jpg","hash":"54fec1d8845c707a38f1ea12d36b918890df8c09","modified":1544189147830},{"_id":"source/images/jvm_method_dispatch.jpg","hash":"8199397e9947af51408e8826c2416fc05ea2bc31","modified":1544189147486},{"_id":"source/images/jvm_stackframe_operandstack.jpg","hash":"301db8b9523f5a6566e6c166776e67ed2a7bf3e6","modified":1544189147830},{"_id":"source/images/jvm_stackframe_structure.jpg","hash":"dc3a785d19f0c7dd4365866d0b97e825460f3eed","modified":1544189147486},{"_id":"source/images/markdownpad2.png","hash":"bb926b53eb2991743d47ca56b3c919b27752d779","modified":1540528958415},{"_id":"source/images/process_concurrent_finite_buffer.png","hash":"0b66e4b263d59c6f3bda92d00d35e8bca215bc8c","modified":1540528958415},{"_id":"source/images/servlet_life_cycle.png","hash":"69db0647ea38ae6d54e1fb35594ba7ba85da1a14","modified":1540528958419},{"_id":"source/images/tcp_channel_utilization.jpg","hash":"9021c9837fa639c10fb3d9453668387027791d7f","modified":1542545529688},{"_id":"source/images/tcp_build_connect.jpg","hash":"529bb90e439aa6abdbe5ebe4bf8ca1d9fb2b5fe1","modified":1542892115296},{"_id":"source/images/tcp_confirm_lose.jpg","hash":"e5f154afe4828f43ed2983041b2f79e152672ac5","modified":1542545126594},{"_id":"source/images/jvm_object_reference_pointer.jpg","hash":"c0b349a7be9e6b18067b0dd3ef88b880467cbaf4","modified":1544189147830},{"_id":"source/images/jvm_thread_wm_mm.png","hash":"d5cd8c8f16736ddde240166db0b7b7e70deeca43","modified":1543156898990},{"_id":"source/images/tcp_no_error.jpg","hash":"79f055114f07f0163695260847b315ff4f1fe384","modified":1542540801086},{"_id":"source/images/tcp_header.jpg","hash":"c94753e6387e45f6127dbfbc53a0d937bac46e5b","modified":1542546144315},{"_id":"source/images/tcp_congestion_avoid.jpg","hash":"0519ad7208bf680d159af73297ddccb4a92d1c70","modified":1542809527699},{"_id":"source/images/tcp_quick_recovery.jpg","hash":"daa0673a3ecaaa31526e7fc787352db26166ecc0","modified":1542810317424},{"_id":"source/images/tcp_quick_resend.jpg","hash":"8105791a4d213f8f205f2dc36834d1a14ce74b43","modified":1542810303002},{"_id":"source/images/tcp_red.jpg","hash":"e32de3bf50637a2dcf7655f0a0b1ed2040130384","modified":1542810826477},{"_id":"source/images/tcp_confirm_late.jpg","hash":"6019dcec943af9a35166d0d4441e3fdc26398654","modified":1542545140630},{"_id":"source/images/tcp_recieve_cahce.jpg","hash":"ac528363361a54cafda2836074057c26a30b1bc2","modified":1542634592016},{"_id":"source/images/tcp_release_connect.jpg","hash":"6b10b1e8cbd8e9e28433e89dc17fde4bb6c7e9cb","modified":1542892100321},{"_id":"source/images/tcp_rto_calculate.jpg","hash":"9f34ba51caf1cd36dc45a0b960c2838bb3195719","modified":1542637035192},{"_id":"source/images/tcp_limited_state_machine.jpg","hash":"d5cb228484342fac8b1f14c9c840cfa5dd88bc4e","modified":1542892171348},{"_id":"source/images/tcp_rtts_calculate.jpg","hash":"1946177983b24fa2cadaa61f53f9f8ddaebd4e09","modified":1542636960567},{"_id":"source/images/tcp_send_cahce.jpg","hash":"3edc54a6fa510d3e3bb01e754a834e03d245c85f","modified":1542634568984},{"_id":"source/images/tcp_rttd_calculate.jpg","hash":"a333f89fdbd3be65302be023863ed1c2c7e486d9","modified":1542637203877},{"_id":"source/images/tcp_slow_start.jpg","hash":"538fa7091e5dee498c580449609dd0ccc5edd0bb","modified":1542809536652},{"_id":"source/images/tcp_stream.png","hash":"f393aab6ef44c484f889502c313767a21113347a","modified":1542540809238},{"_id":"source/images/tcp_window_state.jpg","hash":"1214c63100280b455c08b4c3f0992e73e1418ae9","modified":1542634291052},{"_id":"source/images/tcp_window_flow_control.jpg","hash":"3f35ae7d4252253744415fd3f8abd2d2641b1f97","modified":1542808539917},{"_id":"source/categories/index.md","hash":"9cfe8d4f3aff77de521dbf318bdbab59445ee537","modified":1540528958411},{"_id":"source/images/tcp_window_send.jpg","hash":"be0895477a5dee556f363c12a04298d864d0592f","modified":1542634096284},{"_id":"source/archives/index.md","hash":"e07726b13cb858f0d979f1da08cee4927e55d63f","modified":1540528958411},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1540528958427},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1540528958427},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1540528958427},{"_id":"source/images/udp_header.png","hash":"06801d3856934719867bfc7915a3265ce695a530","modified":1542540820184},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1540528958427},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1540528958427},{"_id":"themes/next/.vscode/settings.json","hash":"2978e14530291b98156c1a339a673c6ebb7c8a76","modified":1540528958427},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1540528958427},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1540528958427},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1540528958427},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1540528958427},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1540528958427},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1540528958427},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1540528958427},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1540528958427},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1540528958427},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1540528958427},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1540528958427},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1540528958427},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1540528958427},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1540528958431},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1540528958427},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1540528958431},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1540528958431},{"_id":"themes/next/layout/_layout.swig","hash":"c3c6368e848067aaeb6ae6936cdd126a2323b867","modified":1540528958427},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1540528958431},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1540528958431},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1540528958431},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1540528958431},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1540528958431},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1540528958431},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1540528958427},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1540528958451},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1540528958451},{"_id":"source/images/filter_chain_process.png","hash":"3aabd8d9e6d24a5fb9063e240b50e8f597b69ca5","modified":1540528958411},{"_id":"source/images/YyHsnwD.png","hash":"b0363dc7f0892529032e4e268db16c53549d010c","modified":1543155462622},{"_id":"source/images/filter_lifecycle.png","hash":"abce4700d4a3c934d4f4afc8ea92ddd9da978452","modified":1540528958415},{"_id":"source/images/filter_work_principle.png","hash":"c898a106a2ba619d85f993848f8a86f03975d7b1","modified":1540528958415},{"_id":"source/images/jsp_life_cycle.png","hash":"6f0f4c95ef25646d3778bcfe1da94a1599f1172b","modified":1540528958415},{"_id":"source/images/jsp_diff_between_includeCommand_includeAction.PNG","hash":"274efbafe356c3a03ca84bc577048348d936721b","modified":1543155505989},{"_id":"source/images/jvm_class_file_finaltype.jpg","hash":"7c73d420ef080fa33369980dbbb56ce8bc357a7c","modified":1544189147486},{"_id":"source/images/jsp_diff_dispatch_redirect.png","hash":"6f2c80cadb8f2ee6df34277413d89e1bb313825d","modified":1543155816948},{"_id":"source/images/redirectAndTransmit.PNG","hash":"dcf82f3672e71c4f4685a20a855d3e22a1fd9898","modified":1540528958419},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958431},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1540528958451},{"_id":"source/images/database_lock_types_comp.png","hash":"615156423e86f7940faca0ad09537c6a44bf5985","modified":1543156790819},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1540528958427},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1540528958427},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1540528958427},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1540528958427},{"_id":"themes/next/layout/_partials/head.swig","hash":"fd10ccd8e971f54dc48af173ffa6f255358ea8f2","modified":1540528958427},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1540528958427},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1540528958427},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1540528958427},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1540528958427},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"89c49d739624dc7ed41adfa76b4f07c742072588","modified":1540528958427},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"e47e2aabf6e856014c8150cfdeea9aabcec752aa","modified":1540528958427},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1540528958427},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1540528958427},{"_id":"themes/next/layout/_macro/post.swig","hash":"0bcf157cbaa4e796de1b1faddcb6df707d64aef6","modified":1540528958427},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1540528958427},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1540528958427},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1540528958427},{"_id":"source/images/tcp_timeout_resend.jpg","hash":"f869fbd061ee039b7bfebf14011c63ddda936e52","modified":1542540979363},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1540528958427},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1540528958427},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1540528958427},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1540528958427},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1540528958427},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1540528958427},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1540528958427},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1540528958427},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1540528958427},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1540528958427},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1540528958431},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1540528958431},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1540528958431},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1540528958431},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1540528958431},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1540528958431},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1540528958431},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1540528958431},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1540528958431},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1540528958431},{"_id":"themes/next/source/images/20180223220057.png","hash":"5cff05ddc220dfa1dd1184b27fdf3a33d080266c","modified":1540528958431},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1540528958431},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1540528958431},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1540528958431},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1540528958435},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1540528958435},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1540528958435},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1540528958435},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1540528958435},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1540528958435},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1540528958435},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1540528958435},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1540528958435},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1540528958435},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1540528958435},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1540528958435},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1540528958435},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958427},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958427},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958431},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958431},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958431},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958431},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540528958431},{"_id":"themes/next/source/images/avatar.jpeg","hash":"7aaee8d8dfe03395e53e70f955f0d50e3eae5bd6","modified":1540528958435},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1540528958435},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1540528958435},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1540528958427},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1540528958427},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1540528958427},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1540528958427},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1540528958427},{"_id":"source/images/filter_classify.png","hash":"4370df59e960ed2738764f770ba59ddda08493bb","modified":1540528958415},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1540528958427},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1540528958427},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1540528958427},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"b227e2afde017a598e4f7aa02ebe64bc9df5d9ab","modified":1540528958427},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1540528958427},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1540528958427},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1540528958427},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1540528958427},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1540528958427},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1540528958431},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1540528958431},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1540528958431},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"33e3ed6ad8cd0cafaeea91046b4be2fdc07b4b8d","modified":1540528958431},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1540528958431},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1540528958431},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1540528958431},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1540528958431},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1540528958431},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1540528958431},{"_id":"themes/next/source/css/_variables/base.styl","hash":"c01ae2e4235083b6730f9e4a72752bd27376460f","modified":1540528958431},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1540528958435},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1540528958431},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1540528958435},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1540528958435},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1540528958435},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1540528958435},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1540528958435},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1540528958435},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1540528958435},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1540528958435},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1540528958435},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1540528958435},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1540528958439},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1540528958439},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1540528958435},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1540528958439},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1540528958439},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1540528958439},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1540528958439},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1540528958443},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1540528958443},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1540528958443},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1540528958443},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1540528958443},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1540528958443},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1540528958443},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1540528958443},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1540528958443},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1540528958443},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1540528958447},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1540528958447},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1540528958447},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1540528958447},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1540528958447},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1540528958447},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1540528958447},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1540528958451},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1540528958451},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1540528958451},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1540528958443},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1540528958443},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1540528958427},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1540528958427},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1540528958431},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1540528958431},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1540528958431},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1540528958431},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1540528958431},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1540528958431},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"6a614edb72d3c20c56019da465f57d6751ce0cf0","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"378ef303f8307d7b9759c3f2eacc6a9ff00acaa5","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1540528958431},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1540528958435},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1540528958435},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1540528958431},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1540528958439},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1540528958435},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1540528958435},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1540528958439},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1540528958439},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1540528958439},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1540528958447},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1540528958447},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1540528958443},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1540528958443},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1540528958451},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1540528958435},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"64dbd5fc947387feefd60b52f24878a445a8c039","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"52ec6ecbe55f9fda3c5c5136a6ac431fd2cdc83e","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"180c6b9c84827d3dc71cd1f7af903a4d32988308","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1540528958431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"80ae9f732a3a56e6c0f660370ecd0f818b620fe8","modified":1540528958431},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1540528958435},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1540528958435},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1540528958435},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1540528958435},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1540528958435},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1540528958431},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1540528958431},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1540528958439},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1540528958443},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1540528958439},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1540528958439},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1540528958439},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1540528958447},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1540528958443},{"_id":"public/atom.xml","hash":"16ca16e9ebaef68ff169b24e916e0db432557dde","modified":1550238611705},{"_id":"public/search.xml","hash":"d165c983845674a93a59e01880a8b6e5928a2010","modified":1550238611738},{"_id":"public/sitemap.xml","hash":"344880b12187b675a9a058552e2861d42a1f0fa5","modified":1550238611738},{"_id":"public/tags/index.html","hash":"8a721252bc0e507bc5bbfd7c6d012fa28165d240","modified":1550238612158},{"_id":"public/categories/index.html","hash":"727a8fd8e0fdc56fc639587b299600b462e89ccc","modified":1550238612161},{"_id":"public/archives/index.html","hash":"c6b11bb004c85f862424c742d3a82edd872c35ae","modified":1550238612161},{"_id":"public/2018/12/07/深入理解Java虚拟机之Java内存区域/index.html","hash":"fc9864e22491fc4dd47d78ce8b1ff94b23bf9819","modified":1550238612161},{"_id":"public/2018/12/07/深入理解Java虚拟机之Class类文件结构/index.html","hash":"e8dd9ffead50a084b3a53d40abcd624f23bce713","modified":1550238612161},{"_id":"public/2018/12/02/深入理解Java虚拟机之虚拟机字节码执行引擎/index.html","hash":"3005c99d0778ecab0f25d9cfbd561f5be2db7421","modified":1550238612161},{"_id":"public/2018/12/01/深入理解Java虚拟机之垃圾收集器与内存分配策略/index.html","hash":"a5b4b8508d7cfe972a574516155894547ebc69f8","modified":1550238612161},{"_id":"public/2018/11/30/深入理解Java虚拟机之虚拟机类加载机制/index.html","hash":"9f5b2792a80888395b652452bf42568c12e34454","modified":1550238612162},{"_id":"public/2018/11/18/五层体系结构之运输层/index.html","hash":"53bd04db959213cddc12d15bbb34acee4339a65e","modified":1550238612162},{"_id":"public/2018/11/15/Java并发/index.html","hash":"5a0322cba00b8adaa6ddafec5c8864ff56017f27","modified":1550238612162},{"_id":"public/2018/11/12/深入理解Java虚拟机之Java中的锁优化/index.html","hash":"b3f2e90e2c034266f0affeff4b75b4406352f05a","modified":1550238612162},{"_id":"public/2018/11/12/深入理解Java虚拟机之Java内存模型/index.html","hash":"5ec1f567b17cc29efe50d6f084421c6b4c81c1c8","modified":1550238612162},{"_id":"public/2018/11/05/数据库事务管理/index.html","hash":"36210e0db44ce85a434c24a0d0676119e192681b","modified":1550238612162},{"_id":"public/2018/07/30/Java中的XML之与HTML的区别验证，定位信息，命名空间/index.html","hash":"440508c6ffa8456b0d7090a67ff6e6978b8b0f8e","modified":1550238612162},{"_id":"public/2018/07/30/Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J/index.html","hash":"5fef2b068e2db6a7ec4f1fbf48e3064f7e3553d4","modified":1550238612162},{"_id":"public/2018/07/30/Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J/index.html","hash":"ef454524aab814d619501a80853a25f91068332d","modified":1550238612162},{"_id":"public/2018/07/29/Spring-Bean装配之基于Java的容器注解/index.html","hash":"28399fa525d5156b492557414234396ad1dc0d17","modified":1550238612163},{"_id":"public/2018/07/28/Spring-Bean装配之Autowired注解/index.html","hash":"1f81a1e3e9413bc2b4758f9e810285a33e0ec6a1","modified":1550238612163},{"_id":"public/2018/07/27/Spring-Bean装配之各装配项-XML实现和注解实现/index.html","hash":"2c0841f90cdcfd686caac9a2721d659bded9a5b1","modified":1550238612163},{"_id":"public/2018/07/25/Java-Web-监听器/index.html","hash":"2603b8e96b1bfe0cbffc7095d5b96f0ca78b833c","modified":1550238612163},{"_id":"public/2018/07/25/Java-Web-过滤器/index.html","hash":"b150303490442c8b3ce1b2d3612fad62d4f81df5","modified":1550238612163},{"_id":"public/2018/07/23/servlet笔记/index.html","hash":"4332b40cb6dbd53eb989ae0070e75bcb0197e09d","modified":1550238612163},{"_id":"public/2018/07/23/java注解/index.html","hash":"75cc075f4f5e7894489b39a5e546e9973821536c","modified":1550238612163},{"_id":"public/2018/07/22/java反射/index.html","hash":"028efb01963ac3efa3951e1db3f0a33d2104dfc8","modified":1550238612163},{"_id":"public/2018/07/21/Java-Socket应用/index.html","hash":"8f68cc8d5bc31715a5412eeff8afccb4ef67d2fd","modified":1550238612163},{"_id":"public/2018/07/19/java-io流与文件/index.html","hash":"e0806d3efc8b734d6f98ea0956c180e5a713b563","modified":1550238612163},{"_id":"public/2018/07/15/centos7-Let-s-Encrypt用Certbot获取Https证书-部署nginx/index.html","hash":"b9fcc961a5e565a6ce3b20ddae8b2241337cff90","modified":1550238612164},{"_id":"public/2018/07/11/java集合框架/index.html","hash":"e28eb16df15e2c44a119dd45b6d0bad1542f0346","modified":1550238612164},{"_id":"public/2018/05/03/JSP学习笔记/index.html","hash":"5dc131f3594ff1cafa27cb6653ed3439d3a05219","modified":1550238612164},{"_id":"public/2018/04/30/vim的使用/index.html","hash":"ac5e167e876056fc68aeb9a9c62b03ac7093ef09","modified":1550238612164},{"_id":"public/2018/04/30/IntelliJ-IDEA-使用技巧/index.html","hash":"7d588b0a1b1a17caacd01412f14a7371171238af","modified":1550238612164},{"_id":"public/2018/04/16/进程并发常见问题基于信号量解决方法总结：生产者消费者问题、读写者问题、银行家算法、哲学家进餐/index.html","hash":"13e056b4a54f8ff9c1ac5815722bf9966a2c49a8","modified":1550238612164},{"_id":"public/2018/04/09/git多账号配置，同时使用多个代码托管平台/index.html","hash":"6cc06cd333dc0a5ac1cf91c7781a1f9c5c7c024c","modified":1550238612164},{"_id":"public/2018/04/04/nginx-配置实现端口转发/index.html","hash":"7a7a66761595480edb78fcffa1a6caf30ba0106f","modified":1550238612164},{"_id":"public/2018/03/16/jsoup要点记录/index.html","hash":"60f56a6f9662ef0c8fa549756af2e794911039ed","modified":1550238612164},{"_id":"public/2018/03/11/git分支管理/index.html","hash":"8fa227e597ed827a497ab4aabc9829d38174112d","modified":1550238612164},{"_id":"public/2018/03/10/markdownpad2-无法预览-显示This-view-has-crashed/index.html","hash":"2493638b1401e1b5717107b980938289d21ab80c","modified":1550238612164},{"_id":"public/2018/03/08/2018要学的知识/index.html","hash":"4feb96872e0813c31b0dd52e0f401b8a890f06bb","modified":1550238612165},{"_id":"public/archives/page/2/index.html","hash":"6c5663227ee4ceb96c24f136ea7a42b778ec0c4d","modified":1550238612165},{"_id":"public/archives/page/3/index.html","hash":"e7cfb9252cae6c048a6ff651445346f20a3d8db9","modified":1550238612165},{"_id":"public/archives/page/4/index.html","hash":"c6d5fff8e13bc63cba1edcfe32ffc0da5ae522f5","modified":1550238612165},{"_id":"public/archives/2018/index.html","hash":"51b3eefabca18e386c937310d328107e8c58c256","modified":1550238612165},{"_id":"public/archives/2018/page/2/index.html","hash":"f7f62b219edc5c6b87397c3286d5e52f486a1958","modified":1550238612165},{"_id":"public/archives/2018/page/3/index.html","hash":"b9f856ca9054d7f46dd924c3f226a9e470e032bd","modified":1550238612165},{"_id":"public/archives/2018/page/4/index.html","hash":"cbcc87cb4372c90525f946e7cd6fdfadefd0d373","modified":1550238612165},{"_id":"public/archives/2018/03/index.html","hash":"7f96af60f18cfd6a0bd22be3aac554978a4492c0","modified":1550238612165},{"_id":"public/archives/2018/04/index.html","hash":"26f9a4d9c79af326f848bb735feaddf9324e0d5d","modified":1550238612165},{"_id":"public/archives/2018/05/index.html","hash":"8f50b2a9148f60163c72d366d361ec07e744a25a","modified":1550238612165},{"_id":"public/archives/2018/07/index.html","hash":"797a3d9d9096a5545966db43a0b096542e362eb9","modified":1550238612165},{"_id":"public/archives/2018/07/page/2/index.html","hash":"fdd33442554f8149169e88f8f3f499d9bfa6698c","modified":1550238612166},{"_id":"public/archives/2018/11/index.html","hash":"0f8886342d6376eeb34a0393f20bb9780ce01698","modified":1550238612166},{"_id":"public/archives/2018/12/index.html","hash":"2c49d3cfaf44e484fe5505de4a370183599eeab7","modified":1550238612166},{"_id":"public/categories/计划/index.html","hash":"3bde13db5b66a954ca6874b10d0de71ba741b043","modified":1550238612166},{"_id":"public/categories/JavaSE笔记/index.html","hash":"cbe4180cc1eeb05a7b896aaea575ccef62af9ad3","modified":1550238612166},{"_id":"public/categories/编辑器/index.html","hash":"54755935eabbf93672c10e52f5ac7873921736b4","modified":1550238612166},{"_id":"public/categories/JavaWeb笔记/index.html","hash":"352eecf92043ad9d576743788b17e741d5e99a8d","modified":1550238612166},{"_id":"public/categories/Jsp笔记/index.html","hash":"844829e30fe4da4278990c9c143195d01506bc82","modified":1550238612166},{"_id":"public/categories/Spring笔记/index.html","hash":"517ca38821b31938a2e1bff5900adaea5ffeb26c","modified":1550238612166},{"_id":"public/categories/服务器/index.html","hash":"31e0667e4fc5ee3019fde9eed7aee18ad0fa8c38","modified":1550238612166},{"_id":"public/categories/git/index.html","hash":"467ff3cfe708de7fadc98e89dbeb55d096ec1c3d","modified":1550238612166},{"_id":"public/categories/Jsoup笔记/index.html","hash":"91be704c04d1b6c1dc7c2bc18d4c2eb17d21649d","modified":1550238612166},{"_id":"public/categories/踩过的坑/index.html","hash":"2b326274e086b1c611923af8d01eac431cb56437","modified":1550238612166},{"_id":"public/categories/计算机网络笔记/index.html","hash":"2ea9bb2f8273f19f0720bb2c74c6b9015e4cef3f","modified":1550238612167},{"_id":"public/categories/数据库/index.html","hash":"b1859deed18a48ed575289ffdc385bd0eba4c2c2","modified":1550238612167},{"_id":"public/categories/深入理解java虚拟机笔记/index.html","hash":"05f9accb4699e570fd5693a86c351d0c47cb6123","modified":1550238612167},{"_id":"public/categories/计算机基础/index.html","hash":"610af9777f6d11ff00dc94c68b0a4a1afac02ad4","modified":1550238612167},{"_id":"public/index.html","hash":"7694ed68bb5921596e1cd6f40eef894877b01336","modified":1550238612167},{"_id":"public/page/2/index.html","hash":"b6837706538f1434a2702588dc73184fe83104c9","modified":1550238612167},{"_id":"public/page/3/index.html","hash":"4deb07056911d1c8bd0392196b16d87c5f12078c","modified":1550238612167},{"_id":"public/page/4/index.html","hash":"33b1cf309f1ac9e277dfbad50e02d0ef893c5788","modified":1550238612167},{"_id":"public/tags/计划/index.html","hash":"bfd0e6de4983a35ce5a6c957129d343e8143e121","modified":1550238612167},{"_id":"public/tags/JavaSE/index.html","hash":"bbc5ea3de667ff6d81d88e1e7e006d01f6a28682","modified":1550238612167},{"_id":"public/tags/IDEA/index.html","hash":"78d5de236e64b55b83e14398f6a2795ef02226d9","modified":1550238612167},{"_id":"public/tags/JavaWeb/index.html","hash":"ede8e59885bb427453669b04b53c22094f5676c5","modified":1550238612167},{"_id":"public/tags/Jsp/index.html","hash":"6adf5404cfb6ae22f7f7dc76ae3dfbf3b3370570","modified":1550238612168},{"_id":"public/tags/XML/index.html","hash":"2e47eeb7e97cd20bc73b6db3187d76d5ca79f380","modified":1550238612168},{"_id":"public/tags/Java并发/index.html","hash":"bbc7fb8066ee9d0579afa79e9b8ff0bba7d18d20","modified":1550238612168},{"_id":"public/tags/Spring/index.html","hash":"2cf60eb6ebeb01124553eb32e1bd382f827e7b6e","modified":1550238612169},{"_id":"public/tags/服务器/index.html","hash":"81923cebcd683235d2da90cb9699da267aedc389","modified":1550238612169},{"_id":"public/tags/git/index.html","hash":"6b33539d3f55774aea4a1d1dd3ce29bd062193a5","modified":1550238612169},{"_id":"public/tags/java爬虫/index.html","hash":"37fde8e7d92716e4f660c2973c53dd991a8c83c2","modified":1550238612169},{"_id":"public/tags/Jsoup/index.html","hash":"056b1d4b61c8133082fefd0bda6cffd152a62792","modified":1550238612169},{"_id":"public/tags/markdownPad/index.html","hash":"e8bcb89d943cb4a2365f826823702d6df40fb5a7","modified":1550238612169},{"_id":"public/tags/nginx/index.html","hash":"9be89105422853a44e6f9cd108b707a9754abd70","modified":1550238612169},{"_id":"public/tags/计算机网络/index.html","hash":"d94f2422d2cb76701001df43b922f56441197bf7","modified":1550238612169},{"_id":"public/tags/TCP/index.html","hash":"785c5f86ffba3271d50464d81061631a1c15a323","modified":1550238612169},{"_id":"public/tags/计算机基础/index.html","hash":"7887d8b05fe2c94cef87a46fa29f29b5fa7572bd","modified":1550238612169},{"_id":"public/tags/vim/index.html","hash":"4c34f2a584e6f9ab2d66db3adbe692f80f4733f8","modified":1550238612169},{"_id":"public/tags/JVM/index.html","hash":"65728578b488992e6cd86cdcdb88e305d6d98ba2","modified":1550238612170},{"_id":"public/tags/多线程/index.html","hash":"42ad83a0e53959225bd2a5ae3fc900e9b35bd429","modified":1550238612170},{"_id":"public/tags/OS/index.html","hash":"db51c728399c7666d910ff15fa183551dbd4eea1","modified":1550238612170},{"_id":"public/tags/servlet/index.html","hash":"2ed4876753f3d49dfe77ed99883b280a3d11e2a1","modified":1550238612170},{"_id":"public/2019/02/15/单例模式的几种写法对比/index.html","hash":"e29015616bce185d374c95073e2d461fac2e6fb6","modified":1550238612188},{"_id":"public/2019/01/21/实现简单的jdk动态代理/index.html","hash":"971942751fa17f8850d04f56e669b62d26587cf4","modified":1550238612188},{"_id":"public/archives/2019/index.html","hash":"20b1651be8644b4d98b2eada5c75bd0c2f35aed7","modified":1550238612188},{"_id":"public/archives/2019/01/index.html","hash":"a65d61ef4baf6c9d5e462c2bb576773330277f6b","modified":1550238612188},{"_id":"public/archives/2019/02/index.html","hash":"a577f64a46d6ca6b9dbd746881b1a4cbdd72e77f","modified":1550238612188},{"_id":"public/categories/设计模式/index.html","hash":"348dee3cca3087592a5e6ca82617a70af2b213c1","modified":1550238612188},{"_id":"public/tags/设计模式/index.html","hash":"1040fbaeb10a15081e51594f0dea06d031b65419","modified":1550238612188},{"_id":"public/images/database_transaction_state.png","hash":"d9253494df9df5c5b257d1ca988b259893d2cf34","modified":1550238612203},{"_id":"public/images/git_multiaccount_config.png","hash":"b40be9d9dfa3e3b2df554f395a9d80ca75497285","modified":1550238612203},{"_id":"public/images/filter_chain.png","hash":"ccb428df36e1254b93ab4921eba5c7acb3cf922f","modified":1550238612204},{"_id":"public/images/git_multiaccount_connect_github.png","hash":"4c405a77309aa6b578c9fb3039151b95a0f455f8","modified":1550238612204},{"_id":"public/images/git_multiaccount_connect_osc.png","hash":"496278ad1e3cf95e31b5cacb054171c870aa796a","modified":1550238612204},{"_id":"public/images/git_multiaccount_pub_github.png","hash":"26e1c350b93edd773e3530ac74209f4ccc1355fd","modified":1550238612204},{"_id":"public/images/git_multiaccount_ssh_github.jpg","hash":"fab9289abda553c1e9699afc010139d6f9991379","modified":1550238612204},{"_id":"public/images/git_multiaccount_ssh_osc.jpg","hash":"b1dc1acaf0675a47944e635c260b9794c86e959b","modified":1550238612204},{"_id":"public/images/git_multiaccount_pub_osc.png","hash":"0d94b413269fd3e868b7e515a169586f1fa03384","modified":1550238612204},{"_id":"public/images/git_multiaccount_ssh_file.png","hash":"5905566a116c6146fff368a079874694d89cc392","modified":1550238612204},{"_id":"public/images/jvm_class_file_format.jpg","hash":"4483ea0d1527d4f7e5b86fb324c1509c37b49414","modified":1550238612204},{"_id":"public/images/jvm_classloader_doubleparent.jpg","hash":"57fea97f338c6b92addf9b2ae66d5ea48e8c2a60","modified":1550238612205},{"_id":"public/images/jvm_gc_duplicate.jpg","hash":"b77c29edbf97209e9dcb04a3807d4ab3ae3f30e0","modified":1550238612205},{"_id":"public/images/jvm_gc_markarrange.jpg","hash":"45dded66f3e15b98308a0c6fd4f131d05470a6f2","modified":1550238612205},{"_id":"public/images/jvm_interpret.jpg","hash":"21cecf80b042c45baa31ebf9d184bc0890935143","modified":1550238612205},{"_id":"public/images/jvm_interpret_execute_1.jpg","hash":"558a4c0a273d6416ac88ab40bec826e79e539a85","modified":1550238612205},{"_id":"public/images/jvm_gc_markclean.jpg","hash":"398e9952745a4fa80d471cf188c8a57ea9961f68","modified":1550238612205},{"_id":"public/images/jvm_interpret_execute_2.jpg","hash":"a85c414901be75c8a6108eff60362d8e6aae8902","modified":1550238612205},{"_id":"public/images/jvm_interpret_execute_3.jpg","hash":"337bbc31bf035e7b5cf7fe189c8ccf434168d8aa","modified":1550238612205},{"_id":"public/images/jvm_interpret_execute_5.jpg","hash":"4a8f45ea3ce56df9f6b4e91a83c1c399ce61c245","modified":1550238612205},{"_id":"public/images/jvm_interpret_execute_7.jpg","hash":"ec6bf3689f06aca978ab006a15fcf972b029302e","modified":1550238612205},{"_id":"public/images/jvm_interpret_execute_6.jpg","hash":"8e78f8ee9b3b82e96e59f6a0dab7ad293225c28a","modified":1550238612205},{"_id":"public/images/jvm_interpret_execute_4.jpg","hash":"2b39190560112fa1aa1a523c6902052c1923ccf0","modified":1550238612206},{"_id":"public/images/jvm_object_reference_handle.jpg","hash":"54fec1d8845c707a38f1ea12d36b918890df8c09","modified":1550238612206},{"_id":"public/images/jvm_method_dispatch.jpg","hash":"8199397e9947af51408e8826c2416fc05ea2bc31","modified":1550238612206},{"_id":"public/images/jvm_stackframe_operandstack.jpg","hash":"301db8b9523f5a6566e6c166776e67ed2a7bf3e6","modified":1550238612206},{"_id":"public/images/jvm_stackframe_structure.jpg","hash":"dc3a785d19f0c7dd4365866d0b97e825460f3eed","modified":1550238612206},{"_id":"public/images/markdownpad2.png","hash":"bb926b53eb2991743d47ca56b3c919b27752d779","modified":1550238612206},{"_id":"public/images/process_concurrent_finite_buffer.png","hash":"0b66e4b263d59c6f3bda92d00d35e8bca215bc8c","modified":1550238612206},{"_id":"public/images/servlet_life_cycle.png","hash":"69db0647ea38ae6d54e1fb35594ba7ba85da1a14","modified":1550238612206},{"_id":"public/images/tcp_channel_utilization.jpg","hash":"9021c9837fa639c10fb3d9453668387027791d7f","modified":1550238612206},{"_id":"public/images/tcp_build_connect.jpg","hash":"529bb90e439aa6abdbe5ebe4bf8ca1d9fb2b5fe1","modified":1550238612206},{"_id":"public/images/tcp_confirm_lose.jpg","hash":"e5f154afe4828f43ed2983041b2f79e152672ac5","modified":1550238612207},{"_id":"public/images/jvm_object_reference_pointer.jpg","hash":"c0b349a7be9e6b18067b0dd3ef88b880467cbaf4","modified":1550238612208},{"_id":"public/images/tcp_no_error.jpg","hash":"79f055114f07f0163695260847b315ff4f1fe384","modified":1550238612208},{"_id":"public/images/jvm_thread_wm_mm.png","hash":"d5cd8c8f16736ddde240166db0b7b7e70deeca43","modified":1550238612208},{"_id":"public/images/tcp_header.jpg","hash":"c94753e6387e45f6127dbfbc53a0d937bac46e5b","modified":1550238612208},{"_id":"public/images/tcp_congestion_avoid.jpg","hash":"0519ad7208bf680d159af73297ddccb4a92d1c70","modified":1550238612208},{"_id":"public/images/tcp_quick_recovery.jpg","hash":"daa0673a3ecaaa31526e7fc787352db26166ecc0","modified":1550238612208},{"_id":"public/images/tcp_quick_resend.jpg","hash":"8105791a4d213f8f205f2dc36834d1a14ce74b43","modified":1550238612208},{"_id":"public/images/tcp_red.jpg","hash":"e32de3bf50637a2dcf7655f0a0b1ed2040130384","modified":1550238612208},{"_id":"public/images/tcp_confirm_late.jpg","hash":"6019dcec943af9a35166d0d4441e3fdc26398654","modified":1550238612208},{"_id":"public/images/tcp_recieve_cahce.jpg","hash":"ac528363361a54cafda2836074057c26a30b1bc2","modified":1550238612209},{"_id":"public/images/tcp_release_connect.jpg","hash":"6b10b1e8cbd8e9e28433e89dc17fde4bb6c7e9cb","modified":1550238612209},{"_id":"public/images/tcp_rto_calculate.jpg","hash":"9f34ba51caf1cd36dc45a0b960c2838bb3195719","modified":1550238612209},{"_id":"public/images/tcp_limited_state_machine.jpg","hash":"d5cb228484342fac8b1f14c9c840cfa5dd88bc4e","modified":1550238612209},{"_id":"public/images/tcp_rtts_calculate.jpg","hash":"1946177983b24fa2cadaa61f53f9f8ddaebd4e09","modified":1550238612209},{"_id":"public/images/tcp_send_cahce.jpg","hash":"3edc54a6fa510d3e3bb01e754a834e03d245c85f","modified":1550238612209},{"_id":"public/images/tcp_rttd_calculate.jpg","hash":"a333f89fdbd3be65302be023863ed1c2c7e486d9","modified":1550238612209},{"_id":"public/images/tcp_slow_start.jpg","hash":"538fa7091e5dee498c580449609dd0ccc5edd0bb","modified":1550238612209},{"_id":"public/images/tcp_stream.png","hash":"f393aab6ef44c484f889502c313767a21113347a","modified":1550238612209},{"_id":"public/images/tcp_window_state.jpg","hash":"1214c63100280b455c08b4c3f0992e73e1418ae9","modified":1550238612209},{"_id":"public/images/tcp_window_flow_control.jpg","hash":"3f35ae7d4252253744415fd3f8abd2d2641b1f97","modified":1550238612209},{"_id":"public/images/tcp_window_send.jpg","hash":"be0895477a5dee556f363c12a04298d864d0592f","modified":1550238612209},{"_id":"public/images/udp_header.png","hash":"06801d3856934719867bfc7915a3265ce695a530","modified":1550238612209},{"_id":"public/images/tcp_timeout_resend.jpg","hash":"f869fbd061ee039b7bfebf14011c63ddda936e52","modified":1550238612209},{"_id":"public/images/20180223220057.png","hash":"5cff05ddc220dfa1dd1184b27fdf3a33d080266c","modified":1550238612209},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550238612210},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550238612210},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1550238612210},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1550238612210},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1550238612210},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1550238612210},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1550238612210},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1550238612210},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1550238612210},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550238612210},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1550238612210},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550238612210},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1550238612210},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550238612210},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550238612210},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550238612210},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1550238612210},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1550238612210},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1550238612210},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1550238612210},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550238612210},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550238612210},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550238612210},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550238612211},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550238612211},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550238612211},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1550238612211},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1550238612211},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1550238612211},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1550238612211},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1550238612211},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1550238612211},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550238612211},{"_id":"public/images/filter_chain_process.png","hash":"3aabd8d9e6d24a5fb9063e240b50e8f597b69ca5","modified":1550238613064},{"_id":"public/images/YyHsnwD.png","hash":"b0363dc7f0892529032e4e268db16c53549d010c","modified":1550238613064},{"_id":"public/images/filter_lifecycle.png","hash":"abce4700d4a3c934d4f4afc8ea92ddd9da978452","modified":1550238613074},{"_id":"public/images/filter_work_principle.png","hash":"c898a106a2ba619d85f993848f8a86f03975d7b1","modified":1550238613074},{"_id":"public/images/jsp_life_cycle.png","hash":"6f0f4c95ef25646d3778bcfe1da94a1599f1172b","modified":1550238613074},{"_id":"public/images/jsp_diff_between_includeCommand_includeAction.PNG","hash":"274efbafe356c3a03ca84bc577048348d936721b","modified":1550238613074},{"_id":"public/images/jvm_class_file_finaltype.jpg","hash":"7c73d420ef080fa33369980dbbb56ce8bc357a7c","modified":1550238613074},{"_id":"public/images/jsp_diff_dispatch_redirect.png","hash":"6f2c80cadb8f2ee6df34277413d89e1bb313825d","modified":1550238613074},{"_id":"public/images/redirectAndTransmit.PNG","hash":"dcf82f3672e71c4f4685a20a855d3e22a1fd9898","modified":1550238613074},{"_id":"public/images/avatar.jpeg","hash":"7aaee8d8dfe03395e53e70f955f0d50e3eae5bd6","modified":1550238613074},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550238613074},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550238613075},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1550238613087},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1550238613087},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1550238613087},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1550238613087},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1550238613087},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1550238613087},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1550238613087},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1550238613087},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1550238613087},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1550238613088},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1550238613088},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1550238613088},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1550238613088},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1550238613088},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1550238613088},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1550238613088},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1550238613088},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1550238613088},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1550238613088},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1550238613088},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1550238613088},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1550238613089},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1550238613089},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1550238613090},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1550238613090},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1550238613090},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1550238613090},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1550238613090},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1550238613090},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1550238613090},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1550238613090},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1550238613090},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1550238613090},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1550238613090},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1550238613090},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1550238613090},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1550238613090},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1550238613090},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1550238613090},{"_id":"public/css/main.css","hash":"2d9d52260b15914ecd1b9c01c086b190936bead6","modified":1550238613091},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1550238613091},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1550238613091},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1550238613091},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1550238613091},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1550238613091},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1550238613091},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1550238613091},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1550238613091},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550238613091},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1550238613091},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1550238613091},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1550238613092},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1550238613092},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1550238613092},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1550238613092},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1550238613092},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1550238613093},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1550238613093},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1550238613093},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1550238613093},{"_id":"public/images/database_lock_types_comp.png","hash":"615156423e86f7940faca0ad09537c6a44bf5985","modified":1550238613093},{"_id":"public/images/filter_classify.png","hash":"4370df59e960ed2738764f770ba59ddda08493bb","modified":1550238613094},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1550238613094},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550238613094},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550238613094},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1550238613123}],"Category":[{"name":"计划","_id":"cjs641fcj0003u7yjdvi9472e"},{"name":"JavaSE笔记","_id":"cjs641fcp0008u7yj9y5wtcin"},{"name":"编辑器","_id":"cjs641fcu000eu7yj2z7dloar"},{"name":"JavaWeb笔记","_id":"cjs641fcz000ku7yjvi7ksab5"},{"name":"Jsp笔记","_id":"cjs641fd2000ru7yj3id7qsuo"},{"name":"Spring笔记","_id":"cjs641fd60010u7yj8itxm0h4"},{"name":"服务器","_id":"cjs641fde001eu7yj0pq8ksjc"},{"name":"git","_id":"cjs641fdk001uu7yj3mapgg2a"},{"name":"Jsoup笔记","_id":"cjs641fds002bu7yja7i5khi3"},{"name":"踩过的坑","_id":"cjs641fdw002lu7yjks5o3nuz"},{"name":"计算机网络笔记","_id":"cjs641fe0002tu7yjshagc74d"},{"name":"设计模式","_id":"cjs641fe50031u7yjoqom69i9"},{"name":"数据库","_id":"cjs641fe80038u7yj8xa0wj66"},{"name":"深入理解java虚拟机笔记","_id":"cjs641fec003fu7yjwes1h2mu"},{"name":"计算机基础","_id":"cjs641fej003yu7yj850dmca1"}],"Data":[],"Page":[{"title":"tags","date":"2018-02-23T14:18:06.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-02-23 22:18:06\ntype: \"tags\"\n---\n","updated":"2018-10-26T04:42:38.419Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjs641fch0001u7yjafmoxws2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-02-23T14:18:47.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-02-23 22:18:47\ntype: \"categories\"\n---\n","updated":"2018-10-26T04:42:38.411Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjs641fjs0057u7yj0ebz8g2j","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"archives","date":"2018-02-23T14:19:04.000Z","type":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2018-02-23 22:19:04\ntype: \"archives\"\n---\n","updated":"2018-10-26T04:42:38.411Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cjs641fju0058u7yjjz86602m","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018要学的知识","date":"2018-03-08T04:29:55.000Z","_content":"\n#### <font color = #1E90FF size = 5 face = \"黑体\">  java </font>\n - **<font size = 4 face = \"宋体\">  《java核心技术》 </font>**\n - **<font size = 4 face = \"宋体\">  《servlet、jsp、spring mvc初学指南》 </font>**\n - **<font size = 4 face = \"宋体\">  《Spring技术内幕》 </font>**\n - **<font size = 4 face = \"宋体\">  《轻量级javaEE》 </font>**\n - **<font size = 4 face = \"宋体\">  《java编程思想》 </font>**\n - **<font size = 4 face = \"宋体\">  《深入理解java虚拟机》 </font>**\n \n#### <font color = #1E90FF size = 5 face = \"黑体\">  前端入门 </font>\n - **<font size = 4 face = \"宋体\">  bootstrap写页面 </font>**\n - **<font size = 4 face = \"宋体\">  jquery </font>**\n\n#### <font color = #1E90FF size = 5 face = \"黑体\">  数据库</font>\n - **<font size = 4 face = \"宋体\">  《高性能mysql》</font>**\n\n#### <font color = #1E90FF size = 5 face = \"黑体\">  linux</font>\n - **<font size = 4 face = \"宋体\">  《Linux私房菜基础学习》</font>**\n \n#### <font color = #1E90FF size = 5 face = \"黑体\">  专业基础课</font>\n - **<font size = 4 face = \"宋体\">  计算机组成原理 </font>**\n - **<font size = 4 face = \"宋体\">  操作系统 </font>** \n - **<font size = 4 face = \"宋体\">  计算机网络</font>**\n - **<font size = 4 face = \"宋体\">  数据库 </font>**\n - **<font size = 4 face = \"宋体\">  编译原理 </font>**","source":"_posts/2018要学的知识.md","raw":"---\ntitle: 2018要学的知识\ndate: 2018-03-08 12:29:55\ncategories: \"计划\" \ntags:\n    - 计划\n---\n\n#### <font color = #1E90FF size = 5 face = \"黑体\">  java </font>\n - **<font size = 4 face = \"宋体\">  《java核心技术》 </font>**\n - **<font size = 4 face = \"宋体\">  《servlet、jsp、spring mvc初学指南》 </font>**\n - **<font size = 4 face = \"宋体\">  《Spring技术内幕》 </font>**\n - **<font size = 4 face = \"宋体\">  《轻量级javaEE》 </font>**\n - **<font size = 4 face = \"宋体\">  《java编程思想》 </font>**\n - **<font size = 4 face = \"宋体\">  《深入理解java虚拟机》 </font>**\n \n#### <font color = #1E90FF size = 5 face = \"黑体\">  前端入门 </font>\n - **<font size = 4 face = \"宋体\">  bootstrap写页面 </font>**\n - **<font size = 4 face = \"宋体\">  jquery </font>**\n\n#### <font color = #1E90FF size = 5 face = \"黑体\">  数据库</font>\n - **<font size = 4 face = \"宋体\">  《高性能mysql》</font>**\n\n#### <font color = #1E90FF size = 5 face = \"黑体\">  linux</font>\n - **<font size = 4 face = \"宋体\">  《Linux私房菜基础学习》</font>**\n \n#### <font color = #1E90FF size = 5 face = \"黑体\">  专业基础课</font>\n - **<font size = 4 face = \"宋体\">  计算机组成原理 </font>**\n - **<font size = 4 face = \"宋体\">  操作系统 </font>** \n - **<font size = 4 face = \"宋体\">  计算机网络</font>**\n - **<font size = 4 face = \"宋体\">  数据库 </font>**\n - **<font size = 4 face = \"宋体\">  编译原理 </font>**","slug":"2018要学的知识","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcb0000u7yj6p922obh","content":"<h4 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"  java \"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  java </font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  《java核心技术》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《servlet、jsp、spring mvc初学指南》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《Spring技术内幕》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《轻量级javaEE》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《java编程思想》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《深入理解java虚拟机》 </font></strong></li>\n</ul>\n<h4 id=\"前端入门\"><a href=\"#前端入门\" class=\"headerlink\" title=\"  前端入门 \"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  前端入门 </font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  bootstrap写页面 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  jquery </font></strong></li>\n</ul>\n<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"  数据库\"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  数据库</font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  《高性能mysql》</font></strong></li>\n</ul>\n<h4 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"  linux\"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  linux</font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  《Linux私房菜基础学习》</font></strong></li>\n</ul>\n<h4 id=\"专业基础课\"><a href=\"#专业基础课\" class=\"headerlink\" title=\"  专业基础课\"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  专业基础课</font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  计算机组成原理 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  操作系统 </font></strong> </li>\n<li><strong><font size=\"4\" face=\"宋体\">  计算机网络</font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  数据库 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  编译原理 </font></strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"  java \"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  java </font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  《java核心技术》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《servlet、jsp、spring mvc初学指南》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《Spring技术内幕》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《轻量级javaEE》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《java编程思想》 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  《深入理解java虚拟机》 </font></strong></li>\n</ul>\n<h4 id=\"前端入门\"><a href=\"#前端入门\" class=\"headerlink\" title=\"  前端入门 \"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  前端入门 </font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  bootstrap写页面 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  jquery </font></strong></li>\n</ul>\n<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"  数据库\"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  数据库</font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  《高性能mysql》</font></strong></li>\n</ul>\n<h4 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"  linux\"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  linux</font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  《Linux私房菜基础学习》</font></strong></li>\n</ul>\n<h4 id=\"专业基础课\"><a href=\"#专业基础课\" class=\"headerlink\" title=\"  专业基础课\"></a><font color=\"#1E90FF\" size=\"5\" face=\"黑体\">  专业基础课</font></h4><ul>\n<li><strong><font size=\"4\" face=\"宋体\">  计算机组成原理 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  操作系统 </font></strong> </li>\n<li><strong><font size=\"4\" face=\"宋体\">  计算机网络</font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  数据库 </font></strong></li>\n<li><strong><font size=\"4\" face=\"宋体\">  编译原理 </font></strong></li>\n</ul>\n"},{"title":"java Socket应用","date":"2018-07-21T07:09:14.000Z","_content":"###  一、Socket使用时应当注意的一些问题\n1.设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时\n\n> 调用`setSoTimeout`方法设置\n\n```JAVA\nSocket s = new Socket(...);\ns.setSoTimeout(10000);\n```\n> 对构造器`Socket(String host,int port)`，可以先构建一个无连接的套接字，再使用超时\n\n```java\nSocket s = new Socket();\ns.connect(new InetSocketAddress(host,port),timeout);\n````\n\n2.可中断套接字，用`SocketChannel`类\n3.需要解析因特网地址时，可以用`InetAddress`类\n4.为多个客户端服务时，可以用多线程解决\n5.半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用`Socket.shutdownInput`或`Socket.shutdownOutput`\n\n----\n### 二、获取Web数\n#### URI和URL\n- URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN\n- 一个URI具有一下语法：`[scema:]schemaSpecficPart[#fragment]`\n\n> i.包含schema:部分的URI成为绝对URI，否则为相对URI\nii.绝对URI的schemaSpecficPart不是以`/`揩油，则称为不透明的，如:`mialto:pinnuli!hostname.com`\niii.所有绝对的透明URI和所有相对URI都是分层的，如：`http://hostname.com/index.html`，`../../java/net/Socket.html#Socket()`\niv.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port]\n\n- java中URI类的作用\n    - 解析表示福并将它分解成各种不同组成成分\n    - 标识符的相对化和解析相对标识符\n    \n#### 使用URLCollection\n    > URLConnection类可以比URL类有更多的控制\n    \n必须严格按照以下步骤进行操作：\n1.调用URL类中的openConnection方法得到URLConnection对象：`URLConnection connection = url.openConnection();`\n2.设置请求属性\n3.调用connect方法连接远程资源:connection.connect();\n4.建立连接后，可以查询头信息\n5.访问资源数据，使用getInputStream方法获取一个输入流\n\n> 这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能\n\n----\n### 三、提交表单\n1.提交数据之前，需要创建一个URLConnection对象\n```java\nURL url = new URL(\"http;??host/script\");\nURLConnection connection = url.openConnection();\n```\n2.调用setDoOutput方法建立一个输出的连接\n```java\nconnection.setRequestMethod(\"POST\");\nconnection.setDoOutput（true);\n```\n3.调用getOutputStream方法获得一个输出流，想服务器发送数据\n```java\nOutputStreamWriter osw = new OutputStreamWriter(connection.getOutputStream(), \"UTF-8\");\nosw.write(name1 + \"=\" + URLEncoder.eccode(value1,\"UTF-8\") + \"&);\nosw.write(name2 + \"=\" + URLEncoder.encode(value2,\"UTF-8\"));\n    ```\n4.关闭输出流\n```java\nosw.flush();\nosw.close();\n```\n5.调用getInputStream方法对服务器的响应\n```java\nBufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\nStringBuffer response = new StringBuffer();\nString temp;\nwhile ((temp = br.readLine()) != null) {\n    response.append(temp);\n    response.append(\"\\n\");\n}\n```\n>i.设置请求方法时，必须使用大写，如POST，使用post无法识别\nii.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法\n`InputStream err = ((HTTPURLConnection) connection).getErrorStream();`\n\n\nURL编码需遵循以下规则：\n> i.保留字符A-Z、a-z、0-9 以及.-*_\nii.用`+`替换所有空格\niii.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字\n比如发送\"New York, NY\"，可以使用New+York%2C+NY\n\n----\n#### 四、基于TCP的Socket通信\n1.创建ServerSocket和Socket\n2.打开连接到Socket的输入/输出流\n3.按照协议对Socket进行读/写操作\n4.关闭输入/输出流，关闭Socket\n**服务端**（多线程响应多个客户端）\n\n```java\n//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口\nServerSocket serverSocket=new ServerSocket(8888);\nSocket socket=null;\nSystem.out.println(\"***服务器即将启动，等待客户端的连接***\");\nwhile(true){\n    //调用accept()方法开始监听，等待客户端的连接\n    socket=serverSocket.accept();\n    //创建一个新的线程\n    ServerThread serverThread=new ServerThread(socket);\n    //启动线程\n    serverThread.start();\n}\n```\n\nServerThread类\n\n    ```java\n    public class ServerThread extends Thread {\n\tSocket socket = null;\n\tpublic ServerThread(Socket socket) {\n\t\tthis.socket = socket;\n\t}\n\t\n\t//线程执行的操作，响应客户端的请求\n\tpublic void run(){\n\t\tInputStream is=null;\n\t\tInputStreamReader isr=null;\n\t\tBufferedReader br=null;\n\t\tOutputStream os=null;\n\t\tPrintWriter pw=null;\n\t\ttry {\n\t\t\t//获取输入流，并读取客户端信息\n\t\t\tis = socket.getInputStream();\n\t\t\tisr = new InputStreamReader(is);\n\t\t\tbr = new BufferedReader(isr);\n\t\t\tString info=null;\n\t\t\twhile((info=br.readLine())!=null){//循环读取客户端的信息\n\t\t\t\tSystem.out.println(\"我是服务器，客户端说：\"+info);\n\t\t\t}\n\t\t\tsocket.shutdownInput();//关闭输入流，半关闭\n\t\t\t//获取输出流，响应客户端的请求\n\t\t\tos = socket.getOutputStream();\n\t\t\tpw = new PrintWriter(os);\n\t\t\tpw.write(\"欢迎您！\");\n\t\t\tpw.flush();//调用flush()方法将缓冲输出\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} finally{\n\t\t\t//关闭资源\n\t\t\ttry {\n\t\t\t\tif(pw!=null)\n\t\t\t\t\tpw.close();\n\t\t\t\tif(os!=null)\n\t\t\t\t\tos.close();\n\t\t\t\tif(br!=null)\n\t\t\t\t\tbr.close();\n\t\t\t\tif(isr!=null)\n\t\t\t\t\tisr.close();\n\t\t\t\tif(is!=null)\n\t\t\t\t\tis.close();\n\t\t\t\tif(socket!=null)\n\t\t\t\t\tsocket.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n    ```\n\n**客户端**\n\n    ```java\n    //1.创建客户端Socket，指定服务器地址和端口\n    Socket socket=new Socket(\"localhost\", 8888);\n    //2.获取输出流，向服务器端发送信息\n    OutputStream os=socket.getOutputStream();//字节输出流\n    PrintWriter pw=new PrintWriter(os);//将输出流包装为打印流\n    pw.write(\"用户名：alice;密码：789\");\n    pw.flush();\n    socket.shutdownOutput();//关闭输出流\n    //3.获取输入流，并读取服务器端的响应信息\n    InputStream is=socket.getInputStream();\n    BufferedReader br=new BufferedReader(new InputStreamReader(is));\n    String info=null;\n    while((info=br.readLine())!=null){\n        System.out.println(\"我是客户端，服务器说：\"+info);\n    }\n    //4.关闭资源\n    br.close();\n    is.close();\n    pw.close();\n    os.close();\n    socket.close();\n    ```\n\n----\n### 五、基于UDP的SOcket通信\n1.定义发送信息\n2.创建DatagramPacket，包含将要发送的信息\n3.创建DatagramSocket\n4.发送数据\n**服务端**\n- 接收客户端发送的数据\n\n```java\n//1.创建服务器端DatagramSocket，指定端口\nDatagramSocket socket=new DatagramSocket(8800);\n//2.创建数据报，用于接收客户端发送的数据\nbyte[] data =new byte[1024];//创建字节数组，指定接收的数据包的大小\nDatagramPacket packet=new DatagramPacket(data, data.length);\n//3.接收客户端发送的数据\nsocket.receive(packet);//此方法在接收到数据报之前会一直阻塞\n//4.读取数据\nString info=new String(data, 0, packet.getLength());\nSystem.out.println(\"我是服务器，客户端说：\"+info);\n```\n- 向客户端响应数据\n\n```java\n//1.定义客户端的地址、端口号、数据\nInetAddress address=packet.getAddress();\nint port=packet.getPort();\nbyte[] data2=\"欢迎您!\".getBytes();\n//2.创建数据报，包含响应的数据信息\nDatagramPacket packet2=new DatagramPacket(data2, data2.length, address, port);\n//3.响应客户端\nsocket.send(packet2);\n//4.关闭资源\nsocket.close();\n```\n**客户端**\n- 向服务器端发送数据\n\n```java\n//1.定义服务器的地址、端口号、数据\nInetAddress address=InetAddress.getByName(\"localhost\");\nint port=8800;\nbyte[] data=\"用户名：admin;密码：123\".getBytes();\n//2.创建数据报，包含发送的数据信息\nDatagramPacket packet=new DatagramPacket(data, data.length, address, port);\n//3.创建DatagramSocket对象\nDatagramSocket socket=new DatagramSocket();\n//4.向服务器端发送数据报\nsocket.send(packet);\n```\n\n- 接收服务器端响应的数据\n\n```java\n//1.创建数据报，用于接收服务器端响应的数据\nbyte[] data2=new byte[1024];\nDatagramPacket packet2=new DatagramPacket(data2, data2.length);\n//2.接收服务器响应的数据\nsocket.receive(packet2);\n//3.读取数据\nString reply=new String(data2, 0, packet2.getLength());\nSystem.out.println(\"我是客户端，服务器说：\"+reply);\n//4.关闭资源\nsocket.close();\n```\n\n> 当Socket关闭时，输入输出流也就关闭了\n\n> 参阅：\n  [慕课网：Java Socket应用---通信是这样练成的](https://www.imooc.com/learn/161)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)\n","source":"_posts/Java-Socket应用.md","raw":"---\ntitle: java Socket应用\ndate: 2018-07-21 15:09:14\ncategories: \"JavaSE笔记\" \ntags:\n    - JavaSE\n---\n###  一、Socket使用时应当注意的一些问题\n1.设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时\n\n> 调用`setSoTimeout`方法设置\n\n```JAVA\nSocket s = new Socket(...);\ns.setSoTimeout(10000);\n```\n> 对构造器`Socket(String host,int port)`，可以先构建一个无连接的套接字，再使用超时\n\n```java\nSocket s = new Socket();\ns.connect(new InetSocketAddress(host,port),timeout);\n````\n\n2.可中断套接字，用`SocketChannel`类\n3.需要解析因特网地址时，可以用`InetAddress`类\n4.为多个客户端服务时，可以用多线程解决\n5.半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用`Socket.shutdownInput`或`Socket.shutdownOutput`\n\n----\n### 二、获取Web数\n#### URI和URL\n- URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN\n- 一个URI具有一下语法：`[scema:]schemaSpecficPart[#fragment]`\n\n> i.包含schema:部分的URI成为绝对URI，否则为相对URI\nii.绝对URI的schemaSpecficPart不是以`/`揩油，则称为不透明的，如:`mialto:pinnuli!hostname.com`\niii.所有绝对的透明URI和所有相对URI都是分层的，如：`http://hostname.com/index.html`，`../../java/net/Socket.html#Socket()`\niv.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port]\n\n- java中URI类的作用\n    - 解析表示福并将它分解成各种不同组成成分\n    - 标识符的相对化和解析相对标识符\n    \n#### 使用URLCollection\n    > URLConnection类可以比URL类有更多的控制\n    \n必须严格按照以下步骤进行操作：\n1.调用URL类中的openConnection方法得到URLConnection对象：`URLConnection connection = url.openConnection();`\n2.设置请求属性\n3.调用connect方法连接远程资源:connection.connect();\n4.建立连接后，可以查询头信息\n5.访问资源数据，使用getInputStream方法获取一个输入流\n\n> 这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能\n\n----\n### 三、提交表单\n1.提交数据之前，需要创建一个URLConnection对象\n```java\nURL url = new URL(\"http;??host/script\");\nURLConnection connection = url.openConnection();\n```\n2.调用setDoOutput方法建立一个输出的连接\n```java\nconnection.setRequestMethod(\"POST\");\nconnection.setDoOutput（true);\n```\n3.调用getOutputStream方法获得一个输出流，想服务器发送数据\n```java\nOutputStreamWriter osw = new OutputStreamWriter(connection.getOutputStream(), \"UTF-8\");\nosw.write(name1 + \"=\" + URLEncoder.eccode(value1,\"UTF-8\") + \"&);\nosw.write(name2 + \"=\" + URLEncoder.encode(value2,\"UTF-8\"));\n    ```\n4.关闭输出流\n```java\nosw.flush();\nosw.close();\n```\n5.调用getInputStream方法对服务器的响应\n```java\nBufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\nStringBuffer response = new StringBuffer();\nString temp;\nwhile ((temp = br.readLine()) != null) {\n    response.append(temp);\n    response.append(\"\\n\");\n}\n```\n>i.设置请求方法时，必须使用大写，如POST，使用post无法识别\nii.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法\n`InputStream err = ((HTTPURLConnection) connection).getErrorStream();`\n\n\nURL编码需遵循以下规则：\n> i.保留字符A-Z、a-z、0-9 以及.-*_\nii.用`+`替换所有空格\niii.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字\n比如发送\"New York, NY\"，可以使用New+York%2C+NY\n\n----\n#### 四、基于TCP的Socket通信\n1.创建ServerSocket和Socket\n2.打开连接到Socket的输入/输出流\n3.按照协议对Socket进行读/写操作\n4.关闭输入/输出流，关闭Socket\n**服务端**（多线程响应多个客户端）\n\n```java\n//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口\nServerSocket serverSocket=new ServerSocket(8888);\nSocket socket=null;\nSystem.out.println(\"***服务器即将启动，等待客户端的连接***\");\nwhile(true){\n    //调用accept()方法开始监听，等待客户端的连接\n    socket=serverSocket.accept();\n    //创建一个新的线程\n    ServerThread serverThread=new ServerThread(socket);\n    //启动线程\n    serverThread.start();\n}\n```\n\nServerThread类\n\n    ```java\n    public class ServerThread extends Thread {\n\tSocket socket = null;\n\tpublic ServerThread(Socket socket) {\n\t\tthis.socket = socket;\n\t}\n\t\n\t//线程执行的操作，响应客户端的请求\n\tpublic void run(){\n\t\tInputStream is=null;\n\t\tInputStreamReader isr=null;\n\t\tBufferedReader br=null;\n\t\tOutputStream os=null;\n\t\tPrintWriter pw=null;\n\t\ttry {\n\t\t\t//获取输入流，并读取客户端信息\n\t\t\tis = socket.getInputStream();\n\t\t\tisr = new InputStreamReader(is);\n\t\t\tbr = new BufferedReader(isr);\n\t\t\tString info=null;\n\t\t\twhile((info=br.readLine())!=null){//循环读取客户端的信息\n\t\t\t\tSystem.out.println(\"我是服务器，客户端说：\"+info);\n\t\t\t}\n\t\t\tsocket.shutdownInput();//关闭输入流，半关闭\n\t\t\t//获取输出流，响应客户端的请求\n\t\t\tos = socket.getOutputStream();\n\t\t\tpw = new PrintWriter(os);\n\t\t\tpw.write(\"欢迎您！\");\n\t\t\tpw.flush();//调用flush()方法将缓冲输出\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} finally{\n\t\t\t//关闭资源\n\t\t\ttry {\n\t\t\t\tif(pw!=null)\n\t\t\t\t\tpw.close();\n\t\t\t\tif(os!=null)\n\t\t\t\t\tos.close();\n\t\t\t\tif(br!=null)\n\t\t\t\t\tbr.close();\n\t\t\t\tif(isr!=null)\n\t\t\t\t\tisr.close();\n\t\t\t\tif(is!=null)\n\t\t\t\t\tis.close();\n\t\t\t\tif(socket!=null)\n\t\t\t\t\tsocket.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n    ```\n\n**客户端**\n\n    ```java\n    //1.创建客户端Socket，指定服务器地址和端口\n    Socket socket=new Socket(\"localhost\", 8888);\n    //2.获取输出流，向服务器端发送信息\n    OutputStream os=socket.getOutputStream();//字节输出流\n    PrintWriter pw=new PrintWriter(os);//将输出流包装为打印流\n    pw.write(\"用户名：alice;密码：789\");\n    pw.flush();\n    socket.shutdownOutput();//关闭输出流\n    //3.获取输入流，并读取服务器端的响应信息\n    InputStream is=socket.getInputStream();\n    BufferedReader br=new BufferedReader(new InputStreamReader(is));\n    String info=null;\n    while((info=br.readLine())!=null){\n        System.out.println(\"我是客户端，服务器说：\"+info);\n    }\n    //4.关闭资源\n    br.close();\n    is.close();\n    pw.close();\n    os.close();\n    socket.close();\n    ```\n\n----\n### 五、基于UDP的SOcket通信\n1.定义发送信息\n2.创建DatagramPacket，包含将要发送的信息\n3.创建DatagramSocket\n4.发送数据\n**服务端**\n- 接收客户端发送的数据\n\n```java\n//1.创建服务器端DatagramSocket，指定端口\nDatagramSocket socket=new DatagramSocket(8800);\n//2.创建数据报，用于接收客户端发送的数据\nbyte[] data =new byte[1024];//创建字节数组，指定接收的数据包的大小\nDatagramPacket packet=new DatagramPacket(data, data.length);\n//3.接收客户端发送的数据\nsocket.receive(packet);//此方法在接收到数据报之前会一直阻塞\n//4.读取数据\nString info=new String(data, 0, packet.getLength());\nSystem.out.println(\"我是服务器，客户端说：\"+info);\n```\n- 向客户端响应数据\n\n```java\n//1.定义客户端的地址、端口号、数据\nInetAddress address=packet.getAddress();\nint port=packet.getPort();\nbyte[] data2=\"欢迎您!\".getBytes();\n//2.创建数据报，包含响应的数据信息\nDatagramPacket packet2=new DatagramPacket(data2, data2.length, address, port);\n//3.响应客户端\nsocket.send(packet2);\n//4.关闭资源\nsocket.close();\n```\n**客户端**\n- 向服务器端发送数据\n\n```java\n//1.定义服务器的地址、端口号、数据\nInetAddress address=InetAddress.getByName(\"localhost\");\nint port=8800;\nbyte[] data=\"用户名：admin;密码：123\".getBytes();\n//2.创建数据报，包含发送的数据信息\nDatagramPacket packet=new DatagramPacket(data, data.length, address, port);\n//3.创建DatagramSocket对象\nDatagramSocket socket=new DatagramSocket();\n//4.向服务器端发送数据报\nsocket.send(packet);\n```\n\n- 接收服务器端响应的数据\n\n```java\n//1.创建数据报，用于接收服务器端响应的数据\nbyte[] data2=new byte[1024];\nDatagramPacket packet2=new DatagramPacket(data2, data2.length);\n//2.接收服务器响应的数据\nsocket.receive(packet2);\n//3.读取数据\nString reply=new String(data2, 0, packet2.getLength());\nSystem.out.println(\"我是客户端，服务器说：\"+reply);\n//4.关闭资源\nsocket.close();\n```\n\n> 当Socket关闭时，输入输出流也就关闭了\n\n> 参阅：\n  [慕课网：Java Socket应用---通信是这样练成的](https://www.imooc.com/learn/161)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)\n","slug":"Java-Socket应用","published":1,"updated":"2018-11-18T10:42:33.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fch0002u7yj7tte9eqs","content":"<h3 id=\"一、Socket使用时应当注意的一些问题\"><a href=\"#一、Socket使用时应当注意的一些问题\" class=\"headerlink\" title=\"一、Socket使用时应当注意的一些问题\"></a>一、Socket使用时应当注意的一些问题</h3><p>1.设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时</p>\n<blockquote>\n<p>调用<code>setSoTimeout</code>方法设置</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Socket s = <span class=\"keyword\">new</span> Socket(...);</span><br><span class=\"line\">s.setSoTimeout(<span class=\"number\">10000</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对构造器<code>Socket(String host,int port)</code>，可以先构建一个无连接的套接字，再使用超时</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Socket s = <span class=\"keyword\">new</span> Socket();</span><br><span class=\"line\">s.connect(<span class=\"keyword\">new</span> InetSocketAddress(host,port),timeout);</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>2.可中断套接字，用<code>SocketChannel</code>类<br>3.需要解析因特网地址时，可以用<code>InetAddress</code>类<br>4.为多个客户端服务时，可以用多线程解决<br>5.半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用<code>Socket.shutdownInput</code>或<code>Socket.shutdownOutput</code></p>\n<hr>\n<h3 id=\"二、获取Web数\"><a href=\"#二、获取Web数\" class=\"headerlink\" title=\"二、获取Web数\"></a>二、获取Web数</h3><h4 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h4><ul>\n<li>URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN</li>\n<li>一个URI具有一下语法：<code>[scema:]schemaSpecficPart[#fragment]</code></li>\n</ul>\n<blockquote>\n<p>i.包含schema:部分的URI成为绝对URI，否则为相对URI<br>ii.绝对URI的schemaSpecficPart不是以<code>/</code>揩油，则称为不透明的，如:<code>mialto:pinnuli!hostname.com</code><br>iii.所有绝对的透明URI和所有相对URI都是分层的，如：<code>http://hostname.com/index.html</code>，<code>../../java/net/Socket.html#Socket()</code><br>iv.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port]</p>\n</blockquote>\n<ul>\n<li>java中URI类的作用<ul>\n<li>解析表示福并将它分解成各种不同组成成分</li>\n<li>标识符的相对化和解析相对标识符</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"使用URLCollection\"><a href=\"#使用URLCollection\" class=\"headerlink\" title=\"使用URLCollection\"></a>使用URLCollection</h4><pre><code>&gt; URLConnection类可以比URL类有更多的控制\n</code></pre><p>必须严格按照以下步骤进行操作：<br>1.调用URL类中的openConnection方法得到URLConnection对象：<code>URLConnection connection = url.openConnection();</code><br>2.设置请求属性<br>3.调用connect方法连接远程资源:connection.connect();<br>4.建立连接后，可以查询头信息<br>5.访问资源数据，使用getInputStream方法获取一个输入流</p>\n<blockquote>\n<p>这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能</p>\n</blockquote>\n<hr>\n<h3 id=\"三、提交表单\"><a href=\"#三、提交表单\" class=\"headerlink\" title=\"三、提交表单\"></a>三、提交表单</h3><p>1.提交数据之前，需要创建一个URLConnection对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"http;??host/script\"</span>);</span><br><span class=\"line\">URLConnection connection = url.openConnection();</span><br></pre></td></tr></table></figure></p>\n<p>2.调用setDoOutput方法建立一个输出的连接<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.setRequestMethod(<span class=\"string\">\"POST\"</span>);</span><br><span class=\"line\">connection.setDoOutput（<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3.调用getOutputStream方法获得一个输出流，想服务器发送数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter osw = <span class=\"keyword\">new</span> OutputStreamWriter(connection.getOutputStream(), <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">osw.write(name1 + <span class=\"string\">\"=\"</span> + URLEncoder.eccode(value1,<span class=\"string\">\"UTF-8\"</span>) + <span class=\"string\">\"&amp;);</span></span><br><span class=\"line\"><span class=\"string\">osw.write(name2 + \"</span>=<span class=\"string\">\" + URLEncoder.encode(value2,\"</span>UTF-<span class=\"number\">8</span><span class=\"string\">\"));</span></span><br></pre></td></tr></table></figure></p>\n<p>4.关闭输出流<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osw.flush();</span><br><span class=\"line\">osw.close();</span><br></pre></td></tr></table></figure></p>\n<p>5.调用getInputStream方法对服务器的响应<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(connection.getInputStream(), <span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">StringBuffer response = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">String temp;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((temp = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    response.append(temp);</span><br><span class=\"line\">    response.append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>i.设置请求方法时，必须使用大写，如POST，使用post无法识别<br>ii.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法<br><code>InputStream err = ((HTTPURLConnection) connection).getErrorStream();</code></p>\n</blockquote>\n<p>URL编码需遵循以下规则：</p>\n<blockquote>\n<p>i.保留字符A-Z、a-z、0-9 以及.-*_<br>ii.用<code>+</code>替换所有空格<br>iii.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字<br>比如发送”New York, NY”，可以使用New+York%2C+NY</p>\n</blockquote>\n<hr>\n<h4 id=\"四、基于TCP的Socket通信\"><a href=\"#四、基于TCP的Socket通信\" class=\"headerlink\" title=\"四、基于TCP的Socket通信\"></a>四、基于TCP的Socket通信</h4><p>1.创建ServerSocket和Socket<br>2.打开连接到Socket的输入/输出流<br>3.按照协议对Socket进行读/写操作<br>4.关闭输入/输出流，关闭Socket<br><strong>服务端</strong>（多线程响应多个客户端）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口</span></span><br><span class=\"line\">ServerSocket serverSocket=<span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">Socket socket=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"***服务器即将启动，等待客户端的连接***\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用accept()方法开始监听，等待客户端的连接</span></span><br><span class=\"line\">    socket=serverSocket.accept();</span><br><span class=\"line\">    <span class=\"comment\">//创建一个新的线程</span></span><br><span class=\"line\">    ServerThread serverThread=<span class=\"keyword\">new</span> ServerThread(socket);</span><br><span class=\"line\">    <span class=\"comment\">//启动线程</span></span><br><span class=\"line\">    serverThread.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ServerThread类</p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\tSocket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerThread</span><span class=\"params\">(Socket socket)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.socket = socket;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//线程执行的操作，响应客户端的请求</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tInputStream is=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tInputStreamReader isr=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tBufferedReader br=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tOutputStream os=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tPrintWriter pw=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//获取输入流，并读取客户端信息</span></span><br><span class=\"line\">\t\t\tis = socket.getInputStream();</span><br><span class=\"line\">\t\t\tisr = <span class=\"keyword\">new</span> InputStreamReader(is);</span><br><span class=\"line\">\t\t\tbr = <span class=\"keyword\">new</span> BufferedReader(isr);</span><br><span class=\"line\">\t\t\tString info=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>((info=br.readLine())!=<span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//循环读取客户端的信息</span></span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"我是服务器，客户端说：\"</span>+info);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tsocket.shutdownInput();<span class=\"comment\">//关闭输入流，半关闭</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//获取输出流，响应客户端的请求</span></span><br><span class=\"line\">\t\t\tos = socket.getOutputStream();</span><br><span class=\"line\">\t\t\tpw = <span class=\"keyword\">new</span> PrintWriter(os);</span><br><span class=\"line\">\t\t\tpw.write(<span class=\"string\">\"欢迎您！\"</span>);</span><br><span class=\"line\">\t\t\tpw.flush();<span class=\"comment\">//调用flush()方法将缓冲输出</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//关闭资源</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(pw!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tpw.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(os!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tos.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(br!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tbr.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(isr!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tisr.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(is!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tis.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(socket!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tsocket.close();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>客户端</strong></p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建客户端Socket，指定服务器地址和端口</span></span><br><span class=\"line\">Socket socket=<span class=\"keyword\">new</span> Socket(<span class=\"string\">\"localhost\"</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\"><span class=\"comment\">//2.获取输出流，向服务器端发送信息</span></span><br><span class=\"line\">OutputStream os=socket.getOutputStream();<span class=\"comment\">//字节输出流</span></span><br><span class=\"line\">PrintWriter pw=<span class=\"keyword\">new</span> PrintWriter(os);<span class=\"comment\">//将输出流包装为打印流</span></span><br><span class=\"line\">pw.write(<span class=\"string\">\"用户名：alice;密码：789\"</span>);</span><br><span class=\"line\">pw.flush();</span><br><span class=\"line\">socket.shutdownOutput();<span class=\"comment\">//关闭输出流</span></span><br><span class=\"line\"><span class=\"comment\">//3.获取输入流，并读取服务器端的响应信息</span></span><br><span class=\"line\">InputStream is=socket.getInputStream();</span><br><span class=\"line\">BufferedReader br=<span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(is));</span><br><span class=\"line\">String info=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>((info=br.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"我是客户端，服务器说：\"</span>+info);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//4.关闭资源</span></span><br><span class=\"line\">br.close();</span><br><span class=\"line\">is.close();</span><br><span class=\"line\">pw.close();</span><br><span class=\"line\">os.close();</span><br><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure>\n</code></pre><hr>\n<h3 id=\"五、基于UDP的SOcket通信\"><a href=\"#五、基于UDP的SOcket通信\" class=\"headerlink\" title=\"五、基于UDP的SOcket通信\"></a>五、基于UDP的SOcket通信</h3><p>1.定义发送信息<br>2.创建DatagramPacket，包含将要发送的信息<br>3.创建DatagramSocket<br>4.发送数据<br><strong>服务端</strong></p>\n<ul>\n<li>接收客户端发送的数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建服务器端DatagramSocket，指定端口</span></span><br><span class=\"line\">DatagramSocket socket=<span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">8800</span>);</span><br><span class=\"line\"><span class=\"comment\">//2.创建数据报，用于接收客户端发送的数据</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data =<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">//创建字节数组，指定接收的数据包的大小</span></span><br><span class=\"line\">DatagramPacket packet=<span class=\"keyword\">new</span> DatagramPacket(data, data.length);</span><br><span class=\"line\"><span class=\"comment\">//3.接收客户端发送的数据</span></span><br><span class=\"line\">socket.receive(packet);<span class=\"comment\">//此方法在接收到数据报之前会一直阻塞</span></span><br><span class=\"line\"><span class=\"comment\">//4.读取数据</span></span><br><span class=\"line\">String info=<span class=\"keyword\">new</span> String(data, <span class=\"number\">0</span>, packet.getLength());</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"我是服务器，客户端说：\"</span>+info);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>向客户端响应数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.定义客户端的地址、端口号、数据</span></span><br><span class=\"line\">InetAddress address=packet.getAddress();</span><br><span class=\"line\"><span class=\"keyword\">int</span> port=packet.getPort();</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data2=<span class=\"string\">\"欢迎您!\"</span>.getBytes();</span><br><span class=\"line\"><span class=\"comment\">//2.创建数据报，包含响应的数据信息</span></span><br><span class=\"line\">DatagramPacket packet2=<span class=\"keyword\">new</span> DatagramPacket(data2, data2.length, address, port);</span><br><span class=\"line\"><span class=\"comment\">//3.响应客户端</span></span><br><span class=\"line\">socket.send(packet2);</span><br><span class=\"line\"><span class=\"comment\">//4.关闭资源</span></span><br><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure>\n<p><strong>客户端</strong></p>\n<ul>\n<li>向服务器端发送数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.定义服务器的地址、端口号、数据</span></span><br><span class=\"line\">InetAddress address=InetAddress.getByName(<span class=\"string\">\"localhost\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> port=<span class=\"number\">8800</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data=<span class=\"string\">\"用户名：admin;密码：123\"</span>.getBytes();</span><br><span class=\"line\"><span class=\"comment\">//2.创建数据报，包含发送的数据信息</span></span><br><span class=\"line\">DatagramPacket packet=<span class=\"keyword\">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class=\"line\"><span class=\"comment\">//3.创建DatagramSocket对象</span></span><br><span class=\"line\">DatagramSocket socket=<span class=\"keyword\">new</span> DatagramSocket();</span><br><span class=\"line\"><span class=\"comment\">//4.向服务器端发送数据报</span></span><br><span class=\"line\">socket.send(packet);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>接收服务器端响应的数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建数据报，用于接收服务器端响应的数据</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data2=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">DatagramPacket packet2=<span class=\"keyword\">new</span> DatagramPacket(data2, data2.length);</span><br><span class=\"line\"><span class=\"comment\">//2.接收服务器响应的数据</span></span><br><span class=\"line\">socket.receive(packet2);</span><br><span class=\"line\"><span class=\"comment\">//3.读取数据</span></span><br><span class=\"line\">String reply=<span class=\"keyword\">new</span> String(data2, <span class=\"number\">0</span>, packet2.getLength());</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"我是客户端，服务器说：\"</span>+reply);</span><br><span class=\"line\"><span class=\"comment\">//4.关闭资源</span></span><br><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当Socket关闭时，输入输出流也就关闭了</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/161\" target=\"_blank\" rel=\"noopener\">慕课网：Java Socket应用—通信是这样练成的</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、Socket使用时应当注意的一些问题\"><a href=\"#一、Socket使用时应当注意的一些问题\" class=\"headerlink\" title=\"一、Socket使用时应当注意的一些问题\"></a>一、Socket使用时应当注意的一些问题</h3><p>1.设置超时，从套接字读取信息时，在有数据可供访问之前，读操作会被阻塞，如果此时主机不可达，那么程序将会等待很长时间，并因为系统操作系统的限制最终导致超时</p>\n<blockquote>\n<p>调用<code>setSoTimeout</code>方法设置</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Socket s = <span class=\"keyword\">new</span> Socket(...);</span><br><span class=\"line\">s.setSoTimeout(<span class=\"number\">10000</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对构造器<code>Socket(String host,int port)</code>，可以先构建一个无连接的套接字，再使用超时</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Socket s = <span class=\"keyword\">new</span> Socket();</span><br><span class=\"line\">s.connect(<span class=\"keyword\">new</span> InetSocketAddress(host,port),timeout);</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>2.可中断套接字，用<code>SocketChannel</code>类<br>3.需要解析因特网地址时，可以用<code>InetAddress</code>类<br>4.为多个客户端服务时，可以用多线程解决<br>5.半关闭：套接字连接的一段UN可以终止其输出，同时仍可以接受来自另一端的数据，反过来也一样，调用<code>Socket.shutdownInput</code>或<code>Socket.shutdownOutput</code></p>\n<hr>\n<h3 id=\"二、获取Web数\"><a href=\"#二、获取Web数\" class=\"headerlink\" title=\"二、获取Web数\"></a>二、获取Web数</h3><h4 id=\"URI和URL\"><a href=\"#URI和URL\" class=\"headerlink\" title=\"URI和URL\"></a>URI和URL</h4><ul>\n<li>URL是URI的一个特例，URI是个纯粹的语法结构，包含用来点位Web资源的字符串和各种组成功哪部分，URL包含了用于定位Web资源的足够信息，其他无法定位任何数据的URI，称之为URN</li>\n<li>一个URI具有一下语法：<code>[scema:]schemaSpecficPart[#fragment]</code></li>\n</ul>\n<blockquote>\n<p>i.包含schema:部分的URI成为绝对URI，否则为相对URI<br>ii.绝对URI的schemaSpecficPart不是以<code>/</code>揩油，则称为不透明的，如:<code>mialto:pinnuli!hostname.com</code><br>iii.所有绝对的透明URI和所有相对URI都是分层的，如：<code>http://hostname.com/index.html</code>，<code>../../java/net/Socket.html#Socket()</code><br>iv.一个分层URI的URI的schemaSpecficPart具有一下结构：[//authority][path][?query],基于服务器的URI，authority具有一下形式:[user-info@]host[:port]</p>\n</blockquote>\n<ul>\n<li>java中URI类的作用<ul>\n<li>解析表示福并将它分解成各种不同组成成分</li>\n<li>标识符的相对化和解析相对标识符</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"使用URLCollection\"><a href=\"#使用URLCollection\" class=\"headerlink\" title=\"使用URLCollection\"></a>使用URLCollection</h4><pre><code>&gt; URLConnection类可以比URL类有更多的控制\n</code></pre><p>必须严格按照以下步骤进行操作：<br>1.调用URL类中的openConnection方法得到URLConnection对象：<code>URLConnection connection = url.openConnection();</code><br>2.设置请求属性<br>3.调用connect方法连接远程资源:connection.connect();<br>4.建立连接后，可以查询头信息<br>5.访问资源数据，使用getInputStream方法获取一个输入流</p>\n<blockquote>\n<p>这里的getInputStream/getOutputStream与Socket类的又很大的不同，这里具有很多处理请求和响应消息头时的强大功能</p>\n</blockquote>\n<hr>\n<h3 id=\"三、提交表单\"><a href=\"#三、提交表单\" class=\"headerlink\" title=\"三、提交表单\"></a>三、提交表单</h3><p>1.提交数据之前，需要创建一个URLConnection对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"http;??host/script\"</span>);</span><br><span class=\"line\">URLConnection connection = url.openConnection();</span><br></pre></td></tr></table></figure></p>\n<p>2.调用setDoOutput方法建立一个输出的连接<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.setRequestMethod(<span class=\"string\">\"POST\"</span>);</span><br><span class=\"line\">connection.setDoOutput（<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3.调用getOutputStream方法获得一个输出流，想服务器发送数据<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter osw = <span class=\"keyword\">new</span> OutputStreamWriter(connection.getOutputStream(), <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">osw.write(name1 + <span class=\"string\">\"=\"</span> + URLEncoder.eccode(value1,<span class=\"string\">\"UTF-8\"</span>) + <span class=\"string\">\"&amp;);</span></span><br><span class=\"line\"><span class=\"string\">osw.write(name2 + \"</span>=<span class=\"string\">\" + URLEncoder.encode(value2,\"</span>UTF-<span class=\"number\">8</span><span class=\"string\">\"));</span></span><br></pre></td></tr></table></figure></p>\n<p>4.关闭输出流<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">osw.flush();</span><br><span class=\"line\">osw.close();</span><br></pre></td></tr></table></figure></p>\n<p>5.调用getInputStream方法对服务器的响应<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(connection.getInputStream(), <span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">StringBuffer response = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">String temp;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((temp = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    response.append(temp);</span><br><span class=\"line\">    response.append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>i.设置请求方法时，必须使用大写，如POST，使用post无法识别<br>ii.如果想要获取错误页面，可以将URLConnection转型为HTTPURLConnection类并调用getErrorStream方法<br><code>InputStream err = ((HTTPURLConnection) connection).getErrorStream();</code></p>\n</blockquote>\n<p>URL编码需遵循以下规则：</p>\n<blockquote>\n<p>i.保留字符A-Z、a-z、0-9 以及.-*_<br>ii.用<code>+</code>替换所有空格<br>iii.将其他所有字符编码为UTF-8，并将每个字节都编码为%后面紧跟一个两位的十六进制数字<br>比如发送”New York, NY”，可以使用New+York%2C+NY</p>\n</blockquote>\n<hr>\n<h4 id=\"四、基于TCP的Socket通信\"><a href=\"#四、基于TCP的Socket通信\" class=\"headerlink\" title=\"四、基于TCP的Socket通信\"></a>四、基于TCP的Socket通信</h4><p>1.创建ServerSocket和Socket<br>2.打开连接到Socket的输入/输出流<br>3.按照协议对Socket进行读/写操作<br>4.关闭输入/输出流，关闭Socket<br><strong>服务端</strong>（多线程响应多个客户端）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并负责监听此端口</span></span><br><span class=\"line\">ServerSocket serverSocket=<span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">Socket socket=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"***服务器即将启动，等待客户端的连接***\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用accept()方法开始监听，等待客户端的连接</span></span><br><span class=\"line\">    socket=serverSocket.accept();</span><br><span class=\"line\">    <span class=\"comment\">//创建一个新的线程</span></span><br><span class=\"line\">    ServerThread serverThread=<span class=\"keyword\">new</span> ServerThread(socket);</span><br><span class=\"line\">    <span class=\"comment\">//启动线程</span></span><br><span class=\"line\">    serverThread.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ServerThread类</p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\tSocket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerThread</span><span class=\"params\">(Socket socket)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.socket = socket;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//线程执行的操作，响应客户端的请求</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tInputStream is=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tInputStreamReader isr=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tBufferedReader br=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tOutputStream os=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tPrintWriter pw=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//获取输入流，并读取客户端信息</span></span><br><span class=\"line\">\t\t\tis = socket.getInputStream();</span><br><span class=\"line\">\t\t\tisr = <span class=\"keyword\">new</span> InputStreamReader(is);</span><br><span class=\"line\">\t\t\tbr = <span class=\"keyword\">new</span> BufferedReader(isr);</span><br><span class=\"line\">\t\t\tString info=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>((info=br.readLine())!=<span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//循环读取客户端的信息</span></span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"我是服务器，客户端说：\"</span>+info);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tsocket.shutdownInput();<span class=\"comment\">//关闭输入流，半关闭</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//获取输出流，响应客户端的请求</span></span><br><span class=\"line\">\t\t\tos = socket.getOutputStream();</span><br><span class=\"line\">\t\t\tpw = <span class=\"keyword\">new</span> PrintWriter(os);</span><br><span class=\"line\">\t\t\tpw.write(<span class=\"string\">\"欢迎您！\"</span>);</span><br><span class=\"line\">\t\t\tpw.flush();<span class=\"comment\">//调用flush()方法将缓冲输出</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//关闭资源</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(pw!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tpw.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(os!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tos.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(br!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tbr.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(isr!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tisr.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(is!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tis.close();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(socket!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\tsocket.close();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><p><strong>客户端</strong></p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建客户端Socket，指定服务器地址和端口</span></span><br><span class=\"line\">Socket socket=<span class=\"keyword\">new</span> Socket(<span class=\"string\">\"localhost\"</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\"><span class=\"comment\">//2.获取输出流，向服务器端发送信息</span></span><br><span class=\"line\">OutputStream os=socket.getOutputStream();<span class=\"comment\">//字节输出流</span></span><br><span class=\"line\">PrintWriter pw=<span class=\"keyword\">new</span> PrintWriter(os);<span class=\"comment\">//将输出流包装为打印流</span></span><br><span class=\"line\">pw.write(<span class=\"string\">\"用户名：alice;密码：789\"</span>);</span><br><span class=\"line\">pw.flush();</span><br><span class=\"line\">socket.shutdownOutput();<span class=\"comment\">//关闭输出流</span></span><br><span class=\"line\"><span class=\"comment\">//3.获取输入流，并读取服务器端的响应信息</span></span><br><span class=\"line\">InputStream is=socket.getInputStream();</span><br><span class=\"line\">BufferedReader br=<span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(is));</span><br><span class=\"line\">String info=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>((info=br.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"我是客户端，服务器说：\"</span>+info);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//4.关闭资源</span></span><br><span class=\"line\">br.close();</span><br><span class=\"line\">is.close();</span><br><span class=\"line\">pw.close();</span><br><span class=\"line\">os.close();</span><br><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure>\n</code></pre><hr>\n<h3 id=\"五、基于UDP的SOcket通信\"><a href=\"#五、基于UDP的SOcket通信\" class=\"headerlink\" title=\"五、基于UDP的SOcket通信\"></a>五、基于UDP的SOcket通信</h3><p>1.定义发送信息<br>2.创建DatagramPacket，包含将要发送的信息<br>3.创建DatagramSocket<br>4.发送数据<br><strong>服务端</strong></p>\n<ul>\n<li>接收客户端发送的数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建服务器端DatagramSocket，指定端口</span></span><br><span class=\"line\">DatagramSocket socket=<span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">8800</span>);</span><br><span class=\"line\"><span class=\"comment\">//2.创建数据报，用于接收客户端发送的数据</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data =<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">//创建字节数组，指定接收的数据包的大小</span></span><br><span class=\"line\">DatagramPacket packet=<span class=\"keyword\">new</span> DatagramPacket(data, data.length);</span><br><span class=\"line\"><span class=\"comment\">//3.接收客户端发送的数据</span></span><br><span class=\"line\">socket.receive(packet);<span class=\"comment\">//此方法在接收到数据报之前会一直阻塞</span></span><br><span class=\"line\"><span class=\"comment\">//4.读取数据</span></span><br><span class=\"line\">String info=<span class=\"keyword\">new</span> String(data, <span class=\"number\">0</span>, packet.getLength());</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"我是服务器，客户端说：\"</span>+info);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>向客户端响应数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.定义客户端的地址、端口号、数据</span></span><br><span class=\"line\">InetAddress address=packet.getAddress();</span><br><span class=\"line\"><span class=\"keyword\">int</span> port=packet.getPort();</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data2=<span class=\"string\">\"欢迎您!\"</span>.getBytes();</span><br><span class=\"line\"><span class=\"comment\">//2.创建数据报，包含响应的数据信息</span></span><br><span class=\"line\">DatagramPacket packet2=<span class=\"keyword\">new</span> DatagramPacket(data2, data2.length, address, port);</span><br><span class=\"line\"><span class=\"comment\">//3.响应客户端</span></span><br><span class=\"line\">socket.send(packet2);</span><br><span class=\"line\"><span class=\"comment\">//4.关闭资源</span></span><br><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure>\n<p><strong>客户端</strong></p>\n<ul>\n<li>向服务器端发送数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.定义服务器的地址、端口号、数据</span></span><br><span class=\"line\">InetAddress address=InetAddress.getByName(<span class=\"string\">\"localhost\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> port=<span class=\"number\">8800</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data=<span class=\"string\">\"用户名：admin;密码：123\"</span>.getBytes();</span><br><span class=\"line\"><span class=\"comment\">//2.创建数据报，包含发送的数据信息</span></span><br><span class=\"line\">DatagramPacket packet=<span class=\"keyword\">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class=\"line\"><span class=\"comment\">//3.创建DatagramSocket对象</span></span><br><span class=\"line\">DatagramSocket socket=<span class=\"keyword\">new</span> DatagramSocket();</span><br><span class=\"line\"><span class=\"comment\">//4.向服务器端发送数据报</span></span><br><span class=\"line\">socket.send(packet);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>接收服务器端响应的数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建数据报，用于接收服务器端响应的数据</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data2=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">DatagramPacket packet2=<span class=\"keyword\">new</span> DatagramPacket(data2, data2.length);</span><br><span class=\"line\"><span class=\"comment\">//2.接收服务器响应的数据</span></span><br><span class=\"line\">socket.receive(packet2);</span><br><span class=\"line\"><span class=\"comment\">//3.读取数据</span></span><br><span class=\"line\">String reply=<span class=\"keyword\">new</span> String(data2, <span class=\"number\">0</span>, packet2.getLength());</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"我是客户端，服务器说：\"</span>+reply);</span><br><span class=\"line\"><span class=\"comment\">//4.关闭资源</span></span><br><span class=\"line\">socket.close();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当Socket关闭时，输入输出流也就关闭了</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/161\" target=\"_blank\" rel=\"noopener\">慕课网：Java Socket应用—通信是这样练成的</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n"},{"title":"IntelliJ IDEA 使用技巧","date":"2018-04-30T02:18:35.000Z","_content":"### 一、跳转快捷键\n\n窗口切换：Ctrl + alt + [ / ]\n文件切换：alt + -> / <-\n关闭文件：ctrl + f4\n最近修改文件： ctrl + tab + E\n最近浏览文件： ctrl + E\n回到上次编辑的地方 last edit location: ctrl + shift + backspace \n回到上次浏览的地方 back/forward: ctrl + alt + ->/<- \n利用书签跳转：\nbookmarks:f11\nbookmarks mnemonic: ctrl + f11\nshow bookmarks: shift + f11\n书签跳转：Ctrl + 1（n）\n收藏（类或方法）：shift + alt + F\nemacsIDEAs 跳转：shift + j(这个是自己设的)  然后按要找单词的首字母，如p，然后选择\n编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n)\n\t\t\t\t   从文件去到编辑区：esc\n\n### 二、精准搜索\n搜索类：ctrl + alt + N(Ctrl + N 已被vim占用）\n搜索文件： ctrl + shift + N \n搜索符号（方法和属性）：ctrl + shift + alt + N\n搜索字符串： ctrl + shift + F\n\t\tMatch case :区分大小写\n\t\tWords：搜索的字符串是一个单词\n\t\tRegex：按照正则表达式搜索\n\t\tFile mask:指定文件类型\n\t\tIn Project：在项目下搜搜\n\t\tModule：在当前模块下搜索\n\t\tDirectory：在指定目录下搜索\n\t\tScope：在指定范围下搜索\n\t\t\t\n待补充。。。\n\n \n > 参阅：\n  [慕课网：IntelliJ IDEA神器使用技巧](https://www.imooc.com/learn/924)\n\n","source":"_posts/IntelliJ-IDEA-使用技巧.md","raw":"---\ntitle: IntelliJ IDEA 使用技巧\ndate: 2018-04-30 10:18:35\ncategories: \"编辑器\" \ntags:\n\t- IDEA\n---\n### 一、跳转快捷键\n\n窗口切换：Ctrl + alt + [ / ]\n文件切换：alt + -> / <-\n关闭文件：ctrl + f4\n最近修改文件： ctrl + tab + E\n最近浏览文件： ctrl + E\n回到上次编辑的地方 last edit location: ctrl + shift + backspace \n回到上次浏览的地方 back/forward: ctrl + alt + ->/<- \n利用书签跳转：\nbookmarks:f11\nbookmarks mnemonic: ctrl + f11\nshow bookmarks: shift + f11\n书签跳转：Ctrl + 1（n）\n收藏（类或方法）：shift + alt + F\nemacsIDEAs 跳转：shift + j(这个是自己设的)  然后按要找单词的首字母，如p，然后选择\n编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n)\n\t\t\t\t   从文件去到编辑区：esc\n\n### 二、精准搜索\n搜索类：ctrl + alt + N(Ctrl + N 已被vim占用）\n搜索文件： ctrl + shift + N \n搜索符号（方法和属性）：ctrl + shift + alt + N\n搜索字符串： ctrl + shift + F\n\t\tMatch case :区分大小写\n\t\tWords：搜索的字符串是一个单词\n\t\tRegex：按照正则表达式搜索\n\t\tFile mask:指定文件类型\n\t\tIn Project：在项目下搜搜\n\t\tModule：在当前模块下搜索\n\t\tDirectory：在指定目录下搜索\n\t\tScope：在指定范围下搜索\n\t\t\t\n待补充。。。\n\n \n > 参阅：\n  [慕课网：IntelliJ IDEA神器使用技巧](https://www.imooc.com/learn/924)\n\n","slug":"IntelliJ-IDEA-使用技巧","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcl0005u7yjx7ie3iw9","content":"<h3 id=\"一、跳转快捷键\"><a href=\"#一、跳转快捷键\" class=\"headerlink\" title=\"一、跳转快捷键\"></a>一、跳转快捷键</h3><p>窗口切换：Ctrl + alt + [ / ]<br>文件切换：alt + -&gt; / &lt;-<br>关闭文件：ctrl + f4<br>最近修改文件： ctrl + tab + E<br>最近浏览文件： ctrl + E<br>回到上次编辑的地方 last edit location: ctrl + shift + backspace<br>回到上次浏览的地方 back/forward: ctrl + alt + -&gt;/&lt;-<br>利用书签跳转：<br>bookmarks:f11<br>bookmarks mnemonic: ctrl + f11<br>show bookmarks: shift + f11<br>书签跳转：Ctrl + 1（n）<br>收藏（类或方法）：shift + alt + F<br>emacsIDEAs 跳转：shift + j(这个是自己设的)  然后按要找单词的首字母，如p，然后选择<br>编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n)<br>                   从文件去到编辑区：esc</p>\n<h3 id=\"二、精准搜索\"><a href=\"#二、精准搜索\" class=\"headerlink\" title=\"二、精准搜索\"></a>二、精准搜索</h3><p>搜索类：ctrl + alt + N(Ctrl + N 已被vim占用）<br>搜索文件： ctrl + shift + N<br>搜索符号（方法和属性）：ctrl + shift + alt + N<br>搜索字符串： ctrl + shift + F<br>        Match case :区分大小写<br>        Words：搜索的字符串是一个单词<br>        Regex：按照正则表达式搜索<br>        File mask:指定文件类型<br>        In Project：在项目下搜搜<br>        Module：在当前模块下搜索<br>        Directory：在指定目录下搜索<br>        Scope：在指定范围下搜索</p>\n<p>待补充。。。</p>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/924\" target=\"_blank\" rel=\"noopener\">慕课网：IntelliJ IDEA神器使用技巧</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、跳转快捷键\"><a href=\"#一、跳转快捷键\" class=\"headerlink\" title=\"一、跳转快捷键\"></a>一、跳转快捷键</h3><p>窗口切换：Ctrl + alt + [ / ]<br>文件切换：alt + -&gt; / &lt;-<br>关闭文件：ctrl + f4<br>最近修改文件： ctrl + tab + E<br>最近浏览文件： ctrl + E<br>回到上次编辑的地方 last edit location: ctrl + shift + backspace<br>回到上次浏览的地方 back/forward: ctrl + alt + -&gt;/&lt;-<br>利用书签跳转：<br>bookmarks:f11<br>bookmarks mnemonic: ctrl + f11<br>show bookmarks: shift + f11<br>书签跳转：Ctrl + 1（n）<br>收藏（类或方法）：shift + alt + F<br>emacsIDEAs 跳转：shift + j(这个是自己设的)  然后按要找单词的首字母，如p，然后选择<br>编辑区和文件去的跳转，从编辑区到文件区：alt + 1(n)<br>                   从文件去到编辑区：esc</p>\n<h3 id=\"二、精准搜索\"><a href=\"#二、精准搜索\" class=\"headerlink\" title=\"二、精准搜索\"></a>二、精准搜索</h3><p>搜索类：ctrl + alt + N(Ctrl + N 已被vim占用）<br>搜索文件： ctrl + shift + N<br>搜索符号（方法和属性）：ctrl + shift + alt + N<br>搜索字符串： ctrl + shift + F<br>        Match case :区分大小写<br>        Words：搜索的字符串是一个单词<br>        Regex：按照正则表达式搜索<br>        File mask:指定文件类型<br>        In Project：在项目下搜搜<br>        Module：在当前模块下搜索<br>        Directory：在指定目录下搜索<br>        Scope：在指定范围下搜索</p>\n<p>待补充。。。</p>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/924\" target=\"_blank\" rel=\"noopener\">慕课网：IntelliJ IDEA神器使用技巧</a></p>\n</blockquote>\n"},{"title":"Java Web 过滤器","date":"2018-07-25T06:36:41.000Z","_content":"### 过滤器的工作原理\n![filetr_work_principle](/images/filter_work_principle.png)\n----\n### 过滤器的生命周期\n![ filetr_lifecycle](/images/filter_lifecycle.png)\n----\n### 过滤器链\nWeb项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？\n\n过滤器链：\n![filter_chain.png](/images/filter_chain.png)\n过滤器链执行过程:\n![filter_chain_process.png](/images/filter_chain_process.png)\n----\n### 过滤器分类\n![filter_classify](/images/filter_classify.png)\n> `@WebFilter`,在servlet3中，可以使用`@WebFilter`注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置\n\n> 参阅：\n  [慕课网：Java Web开发技术应用——过滤器](https://www.imooc.com/learn/213)","source":"_posts/Java-Web-过滤器.md","raw":"---\ntitle: Java Web 过滤器\ndate: 2018-07-25 14:36:41\ncategories: \"JavaWeb笔记\" \ntags:\n    - JavaWeb\n---\n### 过滤器的工作原理\n![filetr_work_principle](/images/filter_work_principle.png)\n----\n### 过滤器的生命周期\n![ filetr_lifecycle](/images/filter_lifecycle.png)\n----\n### 过滤器链\nWeb项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？\n\n过滤器链：\n![filter_chain.png](/images/filter_chain.png)\n过滤器链执行过程:\n![filter_chain_process.png](/images/filter_chain_process.png)\n----\n### 过滤器分类\n![filter_classify](/images/filter_classify.png)\n> `@WebFilter`,在servlet3中，可以使用`@WebFilter`注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置\n\n> 参阅：\n  [慕课网：Java Web开发技术应用——过滤器](https://www.imooc.com/learn/213)","slug":"Java-Web-过滤器","published":1,"updated":"2018-11-12T13:01:09.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcn0006u7yjiz1s5t2h","content":"<h3 id=\"过滤器的工作原理\"><a href=\"#过滤器的工作原理\" class=\"headerlink\" title=\"过滤器的工作原理\"></a>过滤器的工作原理</h3><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/images/filter_work_principle.png\" alt=\"filetr_work_principle\"></h2><h3 id=\"过滤器的生命周期\"><a href=\"#过滤器的生命周期\" class=\"headerlink\" title=\"过滤器的生命周期\"></a>过滤器的生命周期</h3><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"/images/filter_lifecycle.png\" alt=\" filetr_lifecycle\"></h2><h3 id=\"过滤器链\"><a href=\"#过滤器链\" class=\"headerlink\" title=\"过滤器链\"></a>过滤器链</h3><p>Web项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？</p>\n<p>过滤器链：<br><img src=\"/images/filter_chain.png\" alt=\"filter_chain.png\"><br>过滤器链执行过程:</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><img src=\"/images/filter_chain_process.png\" alt=\"filter_chain_process.png\"></h2><h3 id=\"过滤器分类\"><a href=\"#过滤器分类\" class=\"headerlink\" title=\"过滤器分类\"></a>过滤器分类</h3><p><img src=\"/images/filter_classify.png\" alt=\"filter_classify\"></p>\n<blockquote>\n<p><code>@WebFilter</code>,在servlet3中，可以使用<code>@WebFilter</code>注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/213\" target=\"_blank\" rel=\"noopener\">慕课网：Java Web开发技术应用——过滤器</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"过滤器的工作原理\"><a href=\"#过滤器的工作原理\" class=\"headerlink\" title=\"过滤器的工作原理\"></a>过滤器的工作原理</h3><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/images/filter_work_principle.png\" alt=\"filetr_work_principle\"></h2><h3 id=\"过滤器的生命周期\"><a href=\"#过滤器的生命周期\" class=\"headerlink\" title=\"过滤器的生命周期\"></a>过滤器的生命周期</h3><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"/images/filter_lifecycle.png\" alt=\" filetr_lifecycle\"></h2><h3 id=\"过滤器链\"><a href=\"#过滤器链\" class=\"headerlink\" title=\"过滤器链\"></a>过滤器链</h3><p>Web项目中多个过滤器实现，多个过滤器对应同一个路近执行顺序如何？</p>\n<p>过滤器链：<br><img src=\"/images/filter_chain.png\" alt=\"filter_chain.png\"><br>过滤器链执行过程:</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><img src=\"/images/filter_chain_process.png\" alt=\"filter_chain_process.png\"></h2><h3 id=\"过滤器分类\"><a href=\"#过滤器分类\" class=\"headerlink\" title=\"过滤器分类\"></a>过滤器分类</h3><p><img src=\"/images/filter_classify.png\" alt=\"filter_classify\"></p>\n<blockquote>\n<p><code>@WebFilter</code>,在servlet3中，可以使用<code>@WebFilter</code>注解声明过滤器，该注解会在部署时被容器处理，并根据其具体属性配置将其相应的类部署为过滤器，而不用配置</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/213\" target=\"_blank\" rel=\"noopener\">慕课网：Java Web开发技术应用——过滤器</a></p>\n</blockquote>\n"},{"title":"JSP学习笔记","date":"2018-05-03T13:17:47.000Z","_content":"### 一、jsp简介\n\n#### 1、jsp三大指令\n\n**page指令**:<%@page 属性=\"\" %>,位于jsp页面顶端，可以有多个\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" import=\"java.text.*\"%>\n\n```\n**taglib指令**：标签库\n\n**include**\ninclude指令:`<%@include file=\"date.jsp\"%>`\ninclude动作:`<jsp:include page=\"url\" flush=\"true|false\"/>`\n> page:要包含的页面,\nflush：被包含的页面是否从缓冲区读取\n\n**include指令与include动作的区别：**\n![diff_between_includeCommand_includeAction](/imgages/jsp_diff_between_includeCommand_includeAction.png)\n**forward动作**：`<jsp: forward page=\"url\"/>`\n等同于：`request.getRequestDispatcher(\"/url\").forward(request,response);`\n\n**param动作**：`<jsp:param name=\"参数名\" value=\"参数值\">`\n常与<jsp:forward>一起使用，作为其的子标签:\n\n``` jsp\n<jsp:forward page=\"user.jsp\">\n\t<%--用<jsp:param \"></jsp:param>添加参数--%>\n\t<jsp:param name=\"email\" value=\"11111111@163.com\"></jsp:param>\n</jsp:forward>\n```\n\n#### 2、jsp注释\n- html的注释\n\t<!-- html注释 -->\n- jsp的注释\n <%-- jsp注释 -->（客户端不可见）\n- jsp脚本注释:\n//单行\n/* */ 多行\n \n#### 3、jsp脚本\n<% java代码 %>\n\n#### 4、jsp声明变量或方法\n<%! java代码 %>\n\n#### 5、jsp表达式\n<%=表达式 %>  ps:不可;分号结束\n\n#### 6、jsp页面的生命周期\n\n![jsp_life_cycle.png](/images/jsp_life_cycle.png) \n\n\n### 二、jsp内置对象\n** 九大内置对象：**`out`,`request`,`response`,`session`,`application`,`Page`,`pageContext`,`exception`,`config`\n\n**out**\n\n```html\n\n\t<%\n    \tout.println(\"<h2>静夜思</h2>\");\n    \tout.println(\"床前明月光<br>\");\n    \tout.println(\"疑是地上霜<br>\");\n    \tout.flush();\n   \t\t/*out.clear();会抛出异常*/\n    \tout.clearBuffer();//这里不会抛出异常\n    \tout.println(\"举头望明月<br>\");\n    \tout.println(\"低头思故乡<br>\");\n    %>\n\n    缓冲区大小：<%= out.getBufferSize()%>byte<br>\n    缓冲区剩余大小：<%= out.getRemaining()%>byte<br>\n    是否自动清空缓冲区：<%= out.isAutoFlush()%><br>\n```\n\n**request**\n \n```html\n\n\t<%\n        request.setCharacterEncoding(\"utf-8\");//解决post中文乱码问题，但无法解决get，get解决需要直接Tomcat配置文件\n        request.setAttribute(\"password\",\"123456\");//设置属性密码\n    %>\n    用户名：<%= request.getParameter(\"username\")%><br>\n    爱好：\n    <%\n        if(request.getParameterValues(\"favorite\") != null){  //这里需要判断为不为空，jsp这里不能将String数组看为Boolean\n            String[] favorites = request.getParameterValues(\"favorite\");\n            for (int i = 0; i < favorites.length; i++) {\n                out.println(favorites[i] + \"&nbsp;&nbsp;&nbsp;\");\n            }\n        }\n        String realPath = request.getRealPath(\"requset.jsp\");%><br>\n\n    密码：\n    <%=request.getAttribute(\"password\")%><br>\n\n    请求体的MIME类型：\n    <%=request.getContentType()%><br>\n\n    协议类型和版本号：\n    <%=request.getProtocol()%><br>\n\n    服务器主机名：\n    <%=request.getServerName()%><br>\n\n    服务器端口号：\n    <%=request.getServerPort()%><br>\n\n    请求文件长度：\n    <%=request.getContentLength()%><br>\n\n    请求的客户端地址：\n    <%=request.getRemoteAddr()%><<br>\n\n    请求的真实路径：\n    <%=request.getRealPath(\"requset.jsp\")%><br>\n\n    请求的上下文路径：\n    <%=request.getContextPath()%>\n```\n\t\n**response**\n\n```html\n\n\t<%\n        response.setContentType(\"text/html;charset=utf-8\");\n        out.println(\"<h1>response内置对象</h1>\");\n        out.println(\"<hr>\");\n        //out.flush();\n        /* 因为getWrite获得的输出流对象会先于内置对象out输出，\n        所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer\n        再输出out*/\n\n        PrintWriter outer = response.getWriter();\n        outer.println(\"大家好，我是response生成的输出流outer\");\n\t//  response.sendRedirect(\"login.jsp\");//重定向\n\t//  response.sendRedirect(\"request.jsp\");\n        request.getRequestDispatcher(\"request.jsp\").forward(request,response);//转发\n    %>\n\n```\n\n**请求转发和请求重定向的区别：**\n\n![redirectAndTransmit.PNG](/images/jsp_diff_dispatch_redirect.png)\n\n**session**\nHttpSession的实例，周期：在第一个jsp页面被加载时自动创建，即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束，在服务器的几个页面之间切换，服务器应当知道这是一个客户，就可以用session对象\n\n```html\n\n\t<%\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年mm月dd日 HH:mm:ss\");\n        Date d = new Date(session.getCreationTime());\n        session.setAttribute(\"username\",\"pinnuli\");\n        session.setAttribute(\"password\",\"123456\");\n        session.setAttribute(\"age\",20);\n\t//  session.setMaxInactiveInterval(10);\n\n\t//设置session最大生成期限，单位秒,也可在web.xml中设置session-timeout\n\n    %>\n    Session创建时间：\n    <%=sdf.format(d)%><br>\n\n    Session的ID：\n    <%=session.getId()%><br>\n\n    Session中获取属性值：\n    <%=session.getAttribute(\"username\")%><br>\n\n    Session保存的属性数组：\n    <%\n        String[] names = session.getValueNames();\n        for(int i=0; i<names.length; i++){\n            out.println(names[i] + \"&nbsp;&nbsp;\");\n        }\n\t//        session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session\n    %><br>\n    <%--测试不同页面是否同一个session--%>\n    <a href=\"session_page2.jsp\">跳转到session_page2</a>\n```\n\n**application**\n实现用户间数据的共享，可存放全局边变量，相当于java的静态变量\n\n```html\n\n\t<%\n        application.setAttribute(\"city\",\"广州\");\n        application.setAttribute(\"postcode\",\"510000\");\n        application.setAttribute(\"email\",\"guangzhou@163.com\");\n    %>\n    所在城市：<%=application.getAttribute(\"city\")%><br>\n    所有属性：\n    <%\n        Enumeration attributes = application.getAttributeNames();\n        while (attributes.hasMoreElements()){\n            out.println(attributes.nextElement() + \"&nbsp;&nbsp;\");\n        }\n    %><br>\n\n    jsp(serviet)引擎名和版本号：<%=application.getServerInfo()%><br>\n```\n\t\n**page、pageContext**\n\n```html\n\t<h3>page:</h3>当前page页面的字符串描述：<%=page.toString()%><br><br>\n\n   <h3>pageContext:</h3>用户名：从session中获取属性-<%=pageContext.getSession().getAttribute(\"username\")%><br>\n\n    <%--跳转到其他页面--%>\n   <%--<%\n       pageContext.forward(\"out.jsp\");\n   %>--%>\n    include方法，包含其他页面:\n        <%\n            pageContext.include(\"out.jsp\");\n        %>\n```\n\n**exception**\n\n```html\n\n\t异常消息：<%=exception.getMessage()%><br>\n    异常的字符串描述：<%=exception.toString()%>\n```\n\n\n### 三、jsp使用Javabean\n\n#### 1. Javabean的设计原则\n\n- 必须是公有类\n- 必须包含无参构造方法\n- 属性私有\n- 用getter()和setter()进行封装\n\n例如：\n\n```java\n\npublic class Students{\n\tprivate String name;\n\tprivate int age;\n\n\tpublic  Students(){\n\t\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n}\n\n```\n#### 2. 存取Javabean有关的jsp动作元素  \n**在jsp页面中使用Javabeans：**\n\n方法一：像使用普通java类一样，创建Javabean实例\n方法二：在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty\n\n- `<jsp:useBeans>`\n\n在jsp页面中实例化或者在指定范围内使用Javabean：\n\n`<jsp:useBeans id=\"标示符\" class=\"java类名\" scope=\"作用范围\"/>`\n> scope属性：指定Javabean的作用范围\n> page：当前页面,重定向和转发都无效\n> request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效\n> session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效\n> application:可通过application.getAttribute()取得Javabean对象，不同会话都有效\n\n例如：\n```html\n\t<jsp:useBean id=\"myUsers\" class=\"com.po.Users\" scope=\"application\"></jsp:useBean>\n\t用户名：<jsp:getProperty name=\"myUsers\" property=\"username\"></jsp:getProperty>\n\t密码：<jsp:getProperty name=\"myUsers\" property=\"password\"></jsp:getProperty>\n```\n\n也可使用内置对象获取：\n```html\n\t用户名：<%=((Users)application.getAttribute(\"myUsers\")).getUsername()%>\n\t密码： <%=((Users) application.getAttribute(\"myUsers\")).getPassword()%>\n\n\n```\n\n- `<jsp:setProperty>`\n\t\n```html\t\n\t根据表单自动匹配所有属性:\n\t<jsp:setProperty name=\"myUsers\" property=\"username\"></jsp:setProperty>\n\n\t根据表单匹配部分属性:\n\t<jsp:setProperty name=\"myUsers\" property=\"username\"></jsp:setProperty>\n\n\t与表单无关，通过手工赋值给属性:\n\t<jsp:setProperty name=\"myUsers\" property=\"password\" value=\"hahahaha\"></jsp:setProperty>\n\n\t通过url传参数给属性赋值:\n\t<jsp:setProperty name=\"myUsers\" property=\"password\" param=\"testparam\"></jsp:setProperty>\n\n```\n\n- `<jsp:getProperty>`\n\n```html\n\t使用getProperty获取属性值:\n\t<jsp:getProperty name=\"myUsers\" property=\"username\"></jsp:getProperty>\n\n```\n\t\n> 参阅：\n  [慕课网：JAVA遇见HTML——JSP篇](https://www.imooc.com/learn/166)\n\t\n","source":"_posts/JSP学习笔记.md","raw":"---\ntitle: JSP学习笔记\ndate: 2018-05-03 21:17:47\ncategories: \"Jsp笔记\" \ntags:\n\t- Jsp\n\t- JavaWeb\n---\n### 一、jsp简介\n\n#### 1、jsp三大指令\n\n**page指令**:<%@page 属性=\"\" %>,位于jsp页面顶端，可以有多个\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" import=\"java.text.*\"%>\n\n```\n**taglib指令**：标签库\n\n**include**\ninclude指令:`<%@include file=\"date.jsp\"%>`\ninclude动作:`<jsp:include page=\"url\" flush=\"true|false\"/>`\n> page:要包含的页面,\nflush：被包含的页面是否从缓冲区读取\n\n**include指令与include动作的区别：**\n![diff_between_includeCommand_includeAction](/imgages/jsp_diff_between_includeCommand_includeAction.png)\n**forward动作**：`<jsp: forward page=\"url\"/>`\n等同于：`request.getRequestDispatcher(\"/url\").forward(request,response);`\n\n**param动作**：`<jsp:param name=\"参数名\" value=\"参数值\">`\n常与<jsp:forward>一起使用，作为其的子标签:\n\n``` jsp\n<jsp:forward page=\"user.jsp\">\n\t<%--用<jsp:param \"></jsp:param>添加参数--%>\n\t<jsp:param name=\"email\" value=\"11111111@163.com\"></jsp:param>\n</jsp:forward>\n```\n\n#### 2、jsp注释\n- html的注释\n\t<!-- html注释 -->\n- jsp的注释\n <%-- jsp注释 -->（客户端不可见）\n- jsp脚本注释:\n//单行\n/* */ 多行\n \n#### 3、jsp脚本\n<% java代码 %>\n\n#### 4、jsp声明变量或方法\n<%! java代码 %>\n\n#### 5、jsp表达式\n<%=表达式 %>  ps:不可;分号结束\n\n#### 6、jsp页面的生命周期\n\n![jsp_life_cycle.png](/images/jsp_life_cycle.png) \n\n\n### 二、jsp内置对象\n** 九大内置对象：**`out`,`request`,`response`,`session`,`application`,`Page`,`pageContext`,`exception`,`config`\n\n**out**\n\n```html\n\n\t<%\n    \tout.println(\"<h2>静夜思</h2>\");\n    \tout.println(\"床前明月光<br>\");\n    \tout.println(\"疑是地上霜<br>\");\n    \tout.flush();\n   \t\t/*out.clear();会抛出异常*/\n    \tout.clearBuffer();//这里不会抛出异常\n    \tout.println(\"举头望明月<br>\");\n    \tout.println(\"低头思故乡<br>\");\n    %>\n\n    缓冲区大小：<%= out.getBufferSize()%>byte<br>\n    缓冲区剩余大小：<%= out.getRemaining()%>byte<br>\n    是否自动清空缓冲区：<%= out.isAutoFlush()%><br>\n```\n\n**request**\n \n```html\n\n\t<%\n        request.setCharacterEncoding(\"utf-8\");//解决post中文乱码问题，但无法解决get，get解决需要直接Tomcat配置文件\n        request.setAttribute(\"password\",\"123456\");//设置属性密码\n    %>\n    用户名：<%= request.getParameter(\"username\")%><br>\n    爱好：\n    <%\n        if(request.getParameterValues(\"favorite\") != null){  //这里需要判断为不为空，jsp这里不能将String数组看为Boolean\n            String[] favorites = request.getParameterValues(\"favorite\");\n            for (int i = 0; i < favorites.length; i++) {\n                out.println(favorites[i] + \"&nbsp;&nbsp;&nbsp;\");\n            }\n        }\n        String realPath = request.getRealPath(\"requset.jsp\");%><br>\n\n    密码：\n    <%=request.getAttribute(\"password\")%><br>\n\n    请求体的MIME类型：\n    <%=request.getContentType()%><br>\n\n    协议类型和版本号：\n    <%=request.getProtocol()%><br>\n\n    服务器主机名：\n    <%=request.getServerName()%><br>\n\n    服务器端口号：\n    <%=request.getServerPort()%><br>\n\n    请求文件长度：\n    <%=request.getContentLength()%><br>\n\n    请求的客户端地址：\n    <%=request.getRemoteAddr()%><<br>\n\n    请求的真实路径：\n    <%=request.getRealPath(\"requset.jsp\")%><br>\n\n    请求的上下文路径：\n    <%=request.getContextPath()%>\n```\n\t\n**response**\n\n```html\n\n\t<%\n        response.setContentType(\"text/html;charset=utf-8\");\n        out.println(\"<h1>response内置对象</h1>\");\n        out.println(\"<hr>\");\n        //out.flush();\n        /* 因为getWrite获得的输出流对象会先于内置对象out输出，\n        所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer\n        再输出out*/\n\n        PrintWriter outer = response.getWriter();\n        outer.println(\"大家好，我是response生成的输出流outer\");\n\t//  response.sendRedirect(\"login.jsp\");//重定向\n\t//  response.sendRedirect(\"request.jsp\");\n        request.getRequestDispatcher(\"request.jsp\").forward(request,response);//转发\n    %>\n\n```\n\n**请求转发和请求重定向的区别：**\n\n![redirectAndTransmit.PNG](/images/jsp_diff_dispatch_redirect.png)\n\n**session**\nHttpSession的实例，周期：在第一个jsp页面被加载时自动创建，即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束，在服务器的几个页面之间切换，服务器应当知道这是一个客户，就可以用session对象\n\n```html\n\n\t<%\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年mm月dd日 HH:mm:ss\");\n        Date d = new Date(session.getCreationTime());\n        session.setAttribute(\"username\",\"pinnuli\");\n        session.setAttribute(\"password\",\"123456\");\n        session.setAttribute(\"age\",20);\n\t//  session.setMaxInactiveInterval(10);\n\n\t//设置session最大生成期限，单位秒,也可在web.xml中设置session-timeout\n\n    %>\n    Session创建时间：\n    <%=sdf.format(d)%><br>\n\n    Session的ID：\n    <%=session.getId()%><br>\n\n    Session中获取属性值：\n    <%=session.getAttribute(\"username\")%><br>\n\n    Session保存的属性数组：\n    <%\n        String[] names = session.getValueNames();\n        for(int i=0; i<names.length; i++){\n            out.println(names[i] + \"&nbsp;&nbsp;\");\n        }\n\t//        session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session\n    %><br>\n    <%--测试不同页面是否同一个session--%>\n    <a href=\"session_page2.jsp\">跳转到session_page2</a>\n```\n\n**application**\n实现用户间数据的共享，可存放全局边变量，相当于java的静态变量\n\n```html\n\n\t<%\n        application.setAttribute(\"city\",\"广州\");\n        application.setAttribute(\"postcode\",\"510000\");\n        application.setAttribute(\"email\",\"guangzhou@163.com\");\n    %>\n    所在城市：<%=application.getAttribute(\"city\")%><br>\n    所有属性：\n    <%\n        Enumeration attributes = application.getAttributeNames();\n        while (attributes.hasMoreElements()){\n            out.println(attributes.nextElement() + \"&nbsp;&nbsp;\");\n        }\n    %><br>\n\n    jsp(serviet)引擎名和版本号：<%=application.getServerInfo()%><br>\n```\n\t\n**page、pageContext**\n\n```html\n\t<h3>page:</h3>当前page页面的字符串描述：<%=page.toString()%><br><br>\n\n   <h3>pageContext:</h3>用户名：从session中获取属性-<%=pageContext.getSession().getAttribute(\"username\")%><br>\n\n    <%--跳转到其他页面--%>\n   <%--<%\n       pageContext.forward(\"out.jsp\");\n   %>--%>\n    include方法，包含其他页面:\n        <%\n            pageContext.include(\"out.jsp\");\n        %>\n```\n\n**exception**\n\n```html\n\n\t异常消息：<%=exception.getMessage()%><br>\n    异常的字符串描述：<%=exception.toString()%>\n```\n\n\n### 三、jsp使用Javabean\n\n#### 1. Javabean的设计原则\n\n- 必须是公有类\n- 必须包含无参构造方法\n- 属性私有\n- 用getter()和setter()进行封装\n\n例如：\n\n```java\n\npublic class Students{\n\tprivate String name;\n\tprivate int age;\n\n\tpublic  Students(){\n\t\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n}\n\n```\n#### 2. 存取Javabean有关的jsp动作元素  \n**在jsp页面中使用Javabeans：**\n\n方法一：像使用普通java类一样，创建Javabean实例\n方法二：在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty\n\n- `<jsp:useBeans>`\n\n在jsp页面中实例化或者在指定范围内使用Javabean：\n\n`<jsp:useBeans id=\"标示符\" class=\"java类名\" scope=\"作用范围\"/>`\n> scope属性：指定Javabean的作用范围\n> page：当前页面,重定向和转发都无效\n> request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效\n> session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效\n> application:可通过application.getAttribute()取得Javabean对象，不同会话都有效\n\n例如：\n```html\n\t<jsp:useBean id=\"myUsers\" class=\"com.po.Users\" scope=\"application\"></jsp:useBean>\n\t用户名：<jsp:getProperty name=\"myUsers\" property=\"username\"></jsp:getProperty>\n\t密码：<jsp:getProperty name=\"myUsers\" property=\"password\"></jsp:getProperty>\n```\n\n也可使用内置对象获取：\n```html\n\t用户名：<%=((Users)application.getAttribute(\"myUsers\")).getUsername()%>\n\t密码： <%=((Users) application.getAttribute(\"myUsers\")).getPassword()%>\n\n\n```\n\n- `<jsp:setProperty>`\n\t\n```html\t\n\t根据表单自动匹配所有属性:\n\t<jsp:setProperty name=\"myUsers\" property=\"username\"></jsp:setProperty>\n\n\t根据表单匹配部分属性:\n\t<jsp:setProperty name=\"myUsers\" property=\"username\"></jsp:setProperty>\n\n\t与表单无关，通过手工赋值给属性:\n\t<jsp:setProperty name=\"myUsers\" property=\"password\" value=\"hahahaha\"></jsp:setProperty>\n\n\t通过url传参数给属性赋值:\n\t<jsp:setProperty name=\"myUsers\" property=\"password\" param=\"testparam\"></jsp:setProperty>\n\n```\n\n- `<jsp:getProperty>`\n\n```html\n\t使用getProperty获取属性值:\n\t<jsp:getProperty name=\"myUsers\" property=\"username\"></jsp:getProperty>\n\n```\n\t\n> 参阅：\n  [慕课网：JAVA遇见HTML——JSP篇](https://www.imooc.com/learn/166)\n\t\n","slug":"JSP学习笔记","published":1,"updated":"2018-11-25T14:36:47.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fco0007u7yjazty9ycu","content":"<h3 id=\"一、jsp简介\"><a href=\"#一、jsp简介\" class=\"headerlink\" title=\"一、jsp简介\"></a>一、jsp简介</h3><h4 id=\"1、jsp三大指令\"><a href=\"#1、jsp三大指令\" class=\"headerlink\" title=\"1、jsp三大指令\"></a>1、jsp三大指令</h4><p><strong>page指令</strong>:&lt;%@page 属性=”” %&gt;,位于jsp页面顶端，可以有多个</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page contentType=<span class=\"string\">\"text/html;charset=UTF-8\"</span> language=<span class=\"string\">\"java\"</span> <span class=\"keyword\">import</span>=<span class=\"string\">\"java.text.*\"</span>%&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>taglib指令</strong>：标签库</p>\n<p><strong>include</strong><br>include指令:<code>&lt;%@include file=&quot;date.jsp&quot;%&gt;</code><br>include动作:<code>&lt;jsp:include page=&quot;url&quot; flush=&quot;true|false&quot;/&gt;</code></p>\n<blockquote>\n<p>page:要包含的页面,<br>flush：被包含的页面是否从缓冲区读取</p>\n</blockquote>\n<p><strong>include指令与include动作的区别：</strong><br><img src=\"/imgages/jsp_diff_between_includeCommand_includeAction.png\" alt=\"diff_between_includeCommand_includeAction\"><br><strong>forward动作</strong>：<code>&lt;jsp: forward page=&quot;url&quot;/&gt;</code><br>等同于：<code>request.getRequestDispatcher(&quot;/url&quot;).forward(request,response);</code></p>\n<p><strong>param动作</strong>：<code>&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt;</code><br>常与<jsp:forward>一起使用，作为其的子标签:</jsp:forward></p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;jsp:forward page=<span class=\"string\">\"user.jsp\"</span>&gt;</span><br><span class=\"line\">\t&lt;%--用&lt;jsp:param <span class=\"string\">\"&gt;&lt;/jsp:param&gt;添加参数--%&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t&lt;jsp:param name=\"</span>email<span class=\"string\">\" value=\"</span><span class=\"number\">11111111</span>@<span class=\"number\">163</span>.com<span class=\"string\">\"&gt;&lt;/jsp:param&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/jsp:forward&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2、jsp注释\"><a href=\"#2、jsp注释\" class=\"headerlink\" title=\"2、jsp注释\"></a>2、jsp注释</h4><ul>\n<li>html的注释  <!-- html注释 --></li>\n<li>jsp的注释<br>&lt;%– jsp注释 –&gt;（客户端不可见）</li>\n<li>jsp脚本注释:<br>//单行<br>/<em> </em>/ 多行</li>\n</ul>\n<h4 id=\"3、jsp脚本\"><a href=\"#3、jsp脚本\" class=\"headerlink\" title=\"3、jsp脚本\"></a>3、jsp脚本</h4><p>&lt;% java代码 %&gt;</p>\n<h4 id=\"4、jsp声明变量或方法\"><a href=\"#4、jsp声明变量或方法\" class=\"headerlink\" title=\"4、jsp声明变量或方法\"></a>4、jsp声明变量或方法</h4><p>&lt;%! java代码 %&gt;</p>\n<h4 id=\"5、jsp表达式\"><a href=\"#5、jsp表达式\" class=\"headerlink\" title=\"5、jsp表达式\"></a>5、jsp表达式</h4><p>&lt;%=表达式 %&gt;  ps:不可;分号结束</p>\n<h4 id=\"6、jsp页面的生命周期\"><a href=\"#6、jsp页面的生命周期\" class=\"headerlink\" title=\"6、jsp页面的生命周期\"></a>6、jsp页面的生命周期</h4><p><img src=\"/images/jsp_life_cycle.png\" alt=\"jsp_life_cycle.png\"> </p>\n<h3 id=\"二、jsp内置对象\"><a href=\"#二、jsp内置对象\" class=\"headerlink\" title=\"二、jsp内置对象\"></a>二、jsp内置对象</h3><p><strong> 九大内置对象：</strong><code>out</code>,<code>request</code>,<code>response</code>,<code>session</code>,<code>application</code>,<code>Page</code>,<code>pageContext</code>,<code>exception</code>,<code>config</code></p>\n<p><strong>out</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\">   \tout.println(\"&lt;h2&gt;静夜思&lt;/h2&gt;\");</span><br><span class=\"line\">   \tout.println(\"床前明月光<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   \tout.println(\"疑是地上霜<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   \tout.flush();</span><br><span class=\"line\">  \t\t/*out.clear();会抛出异常*/</span><br><span class=\"line\">   \tout.clearBuffer();//这里不会抛出异常</span><br><span class=\"line\">   \tout.println(\"举头望明月<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   \tout.println(\"低头思故乡<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   缓冲区大小：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">out.getBufferSize</span>()%&gt;</span>byte<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   缓冲区剩余大小：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">out.getRemaining</span>()%&gt;</span>byte<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   是否自动清空缓冲区：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">out.isAutoFlush</span>()%&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>request</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">request.setCharacterEncoding</span>(\"<span class=\"attr\">utf-8</span>\");//解决<span class=\"attr\">post</span>中文乱码问题，但无法解决<span class=\"attr\">get</span>，<span class=\"attr\">get</span>解决需要直接<span class=\"attr\">Tomcat</span>配置文件</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">request.setAttribute</span>(\"<span class=\"attr\">password</span>\",\"<span class=\"attr\">123456</span>\");//设置属性密码</span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span></span><br><span class=\"line\">   用户名：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">request.getParameter</span>(\"<span class=\"attr\">username</span>\")%&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   爱好：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">if</span>(<span class=\"attr\">request.getParameterValues</span>(\"<span class=\"attr\">favorite</span>\") != <span class=\"string\">null)&#123;</span>  //这里需要判断为不为空，<span class=\"attr\">jsp</span>这里不能将<span class=\"attr\">String</span>数组看为<span class=\"attr\">Boolean</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">String</span>[] <span class=\"attr\">favorites</span> = <span class=\"string\">request.getParameterValues(</span>\"<span class=\"attr\">favorite</span>\");</span></span><br><span class=\"line\">           for (int i = 0; i &lt; favorites.length; i++) &#123;</span><br><span class=\"line\">               out.println(favorites[i] + \"&amp;nbsp;&amp;nbsp;&amp;nbsp;\");</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       String realPath = request.getRealPath(\"requset.jsp\");%&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   密码：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getAttribute(\"password\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求体的MIME类型：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getContentType()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   协议类型和版本号：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getProtocol()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   服务器主机名：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getServerName()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   服务器端口号：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getServerPort()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求文件长度：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getContentLength()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求的客户端地址：</span><br><span class=\"line\">   &lt;%=request.getRemoteAddr()%&gt;&lt;&lt;br&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   请求的真实路径：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getRealPath(\"requset.jsp\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求的上下文路径：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getContextPath()%</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>response</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">response.setContentType</span>(\"<span class=\"attr\">text</span>/<span class=\"attr\">html</span>;<span class=\"attr\">charset</span>=<span class=\"string\">utf-8</span>\");</span></span><br><span class=\"line\">       out.println(\"&lt;h1&gt;response内置对象&lt;/h1&gt;\");</span><br><span class=\"line\">       out.println(\"<span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span>\");</span><br><span class=\"line\">       //out.flush();</span><br><span class=\"line\">       /* 因为getWrite获得的输出流对象会先于内置对象out输出，</span><br><span class=\"line\">       所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer</span><br><span class=\"line\">       再输出out*/</span><br><span class=\"line\"></span><br><span class=\"line\">       PrintWriter outer = response.getWriter();</span><br><span class=\"line\">       outer.println(\"大家好，我是response生成的输出流outer\");</span><br><span class=\"line\">//  response.sendRedirect(\"login.jsp\");//重定向</span><br><span class=\"line\">//  response.sendRedirect(\"request.jsp\");</span><br><span class=\"line\">       request.getRequestDispatcher(\"request.jsp\").forward(request,response);//转发</span><br><span class=\"line\">   %&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>请求转发和请求重定向的区别：</strong></p>\n<p><img src=\"/images/jsp_diff_dispatch_redirect.png\" alt=\"redirectAndTransmit.PNG\"></p>\n<p><strong>session</strong><br>HttpSession的实例，周期：在第一个jsp页面被加载时自动创建，即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束，在服务器的几个页面之间切换，服务器应当知道这是一个客户，就可以用session对象</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">SimpleDateFormat</span> <span class=\"attr\">sdf</span> = <span class=\"string\">new</span> <span class=\"attr\">SimpleDateFormat</span>(\"<span class=\"attr\">yyyy</span>年<span class=\"attr\">mm</span>月<span class=\"attr\">dd</span>日 <span class=\"attr\">HH:mm:ss</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">Date</span> <span class=\"attr\">d</span> = <span class=\"string\">new</span> <span class=\"attr\">Date</span>(<span class=\"attr\">session.getCreationTime</span>());</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">session.setAttribute</span>(\"<span class=\"attr\">username</span>\",\"<span class=\"attr\">pinnuli</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">session.setAttribute</span>(\"<span class=\"attr\">password</span>\",\"<span class=\"attr\">123456</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">session.setAttribute</span>(\"<span class=\"attr\">age</span>\",<span class=\"attr\">20</span>);</span></span><br><span class=\"line\"><span class=\"tag\">//  <span class=\"attr\">session.setMaxInactiveInterval</span>(<span class=\"attr\">10</span>);</span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">//设置<span class=\"attr\">session</span>最大生成期限，单位秒,也可在<span class=\"attr\">web.xml</span>中设置<span class=\"attr\">session-timeout</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span></span><br><span class=\"line\">   Session创建时间：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=sdf.format(d)%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Session的ID：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=session.getId()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Session中获取属性值：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=session.getAttribute(\"username\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Session保存的属性数组：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">String</span>[] <span class=\"attr\">names</span> = <span class=\"string\">session.getValueNames();</span></span></span><br><span class=\"line\">       for(int i=0; i&lt;names.length; i++)&#123;</span><br><span class=\"line\">           out.println(names[i] + \"&amp;nbsp;&amp;nbsp;\");</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">//        session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session</span><br><span class=\"line\">   %&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%--测试不同页面是否同一个session--%</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"session_page2.jsp\"</span>&gt;</span>跳转到session_page2<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>application</strong><br>实现用户间数据的共享，可存放全局边变量，相当于java的静态变量</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">application.setAttribute</span>(\"<span class=\"attr\">city</span>\",\"广州\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">application.setAttribute</span>(\"<span class=\"attr\">postcode</span>\",\"<span class=\"attr\">510000</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">application.setAttribute</span>(\"<span class=\"attr\">email</span>\",\"<span class=\"attr\">guangzhou</span>@<span class=\"attr\">163.com</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span></span><br><span class=\"line\">   所在城市：<span class=\"tag\">&lt;<span class=\"name\">%=application.getAttribute(\"city\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   所有属性：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">Enumeration</span> <span class=\"attr\">attributes</span> = <span class=\"string\">application.getAttributeNames();</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">while</span> (<span class=\"attr\">attributes.hasMoreElements</span>())&#123;</span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">out.println</span>(<span class=\"attr\">attributes.nextElement</span>() + \"&amp;<span class=\"attr\">nbsp</span>;&amp;<span class=\"attr\">nbsp</span>;\");</span></span><br><span class=\"line\"><span class=\"tag\">       &#125;</span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   jsp(serviet)引擎名和版本号：<span class=\"tag\">&lt;<span class=\"name\">%=application.getServerInfo()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>page、pageContext</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>page:<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>当前page页面的字符串描述：<span class=\"tag\">&lt;<span class=\"name\">%=page.toString()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>pageContext:<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>用户名：从session中获取属性-<span class=\"tag\">&lt;<span class=\"name\">%=pageContext.getSession().getAttribute(\"username\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%--跳转到其他页面--%</span>&gt;</span></span><br><span class=\"line\">  &lt;%--&lt;%</span><br><span class=\"line\">      pageContext.forward(\"out.jsp\");</span><br><span class=\"line\">  %&gt;--%&gt;</span><br><span class=\"line\">   include方法，包含其他页面:</span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">pageContext.include</span>(\"<span class=\"attr\">out.jsp</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       %&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>exception</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">异常消息：<span class=\"tag\">&lt;<span class=\"name\">%=exception.getMessage()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   异常的字符串描述：<span class=\"tag\">&lt;<span class=\"name\">%=exception.toString()%</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三、jsp使用Javabean\"><a href=\"#三、jsp使用Javabean\" class=\"headerlink\" title=\"三、jsp使用Javabean\"></a>三、jsp使用Javabean</h3><h4 id=\"1-Javabean的设计原则\"><a href=\"#1-Javabean的设计原则\" class=\"headerlink\" title=\"1. Javabean的设计原则\"></a>1. Javabean的设计原则</h4><ul>\n<li>必须是公有类</li>\n<li>必须包含无参构造方法</li>\n<li>属性私有</li>\n<li>用getter()和setter()进行封装</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Students</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"title\">Students</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-存取Javabean有关的jsp动作元素\"><a href=\"#2-存取Javabean有关的jsp动作元素\" class=\"headerlink\" title=\"2. 存取Javabean有关的jsp动作元素\"></a>2. 存取Javabean有关的jsp动作元素</h4><p><strong>在jsp页面中使用Javabeans：</strong></p>\n<p>方法一：像使用普通java类一样，创建Javabean实例<br>方法二：在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty</p>\n<ul>\n<li><code>&lt;jsp:useBeans&gt;</code></li>\n</ul>\n<p>在jsp页面中实例化或者在指定范围内使用Javabean：</p>\n<p><code>&lt;jsp:useBeans id=&quot;标示符&quot; class=&quot;java类名&quot; scope=&quot;作用范围&quot;/&gt;</code></p>\n<blockquote>\n<p>scope属性：指定Javabean的作用范围<br>page：当前页面,重定向和转发都无效<br>request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效<br>session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效<br>application:可通过application.getAttribute()取得Javabean对象，不同会话都有效</p>\n</blockquote>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:useBean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.po.Users\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"application\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:useBean</span>&gt;</span></span><br><span class=\"line\">用户名：<span class=\"tag\">&lt;<span class=\"name\">jsp:getProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:getProperty</span>&gt;</span></span><br><span class=\"line\">密码：<span class=\"tag\">&lt;<span class=\"name\">jsp:getProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:getProperty</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>也可使用内置对象获取：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户名：<span class=\"tag\">&lt;<span class=\"name\">%=((Users)application.getAttribute(\"myUsers\")).getUsername()%</span>&gt;</span></span><br><span class=\"line\">密码： <span class=\"tag\">&lt;<span class=\"name\">%=((Users)</span> <span class=\"attr\">application.getAttribute</span>(\"<span class=\"attr\">myUsers</span>\"))<span class=\"attr\">.getPassword</span>()%&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>&lt;jsp:setProperty&gt;</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据表单自动匹配所有属性:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">根据表单匹配部分属性:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">与表单无关，通过手工赋值给属性:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"hahahaha\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">通过url传参数给属性赋值:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">param</span>=<span class=\"string\">\"testparam\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;jsp:getProperty&gt;</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用getProperty获取属性值:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:getProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:getProperty</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/166\" target=\"_blank\" rel=\"noopener\">慕课网：JAVA遇见HTML——JSP篇</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、jsp简介\"><a href=\"#一、jsp简介\" class=\"headerlink\" title=\"一、jsp简介\"></a>一、jsp简介</h3><h4 id=\"1、jsp三大指令\"><a href=\"#1、jsp三大指令\" class=\"headerlink\" title=\"1、jsp三大指令\"></a>1、jsp三大指令</h4><p><strong>page指令</strong>:&lt;%@page 属性=”” %&gt;,位于jsp页面顶端，可以有多个</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page contentType=<span class=\"string\">\"text/html;charset=UTF-8\"</span> language=<span class=\"string\">\"java\"</span> <span class=\"keyword\">import</span>=<span class=\"string\">\"java.text.*\"</span>%&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>taglib指令</strong>：标签库</p>\n<p><strong>include</strong><br>include指令:<code>&lt;%@include file=&quot;date.jsp&quot;%&gt;</code><br>include动作:<code>&lt;jsp:include page=&quot;url&quot; flush=&quot;true|false&quot;/&gt;</code></p>\n<blockquote>\n<p>page:要包含的页面,<br>flush：被包含的页面是否从缓冲区读取</p>\n</blockquote>\n<p><strong>include指令与include动作的区别：</strong><br><img src=\"/imgages/jsp_diff_between_includeCommand_includeAction.png\" alt=\"diff_between_includeCommand_includeAction\"><br><strong>forward动作</strong>：<code>&lt;jsp: forward page=&quot;url&quot;/&gt;</code><br>等同于：<code>request.getRequestDispatcher(&quot;/url&quot;).forward(request,response);</code></p>\n<p><strong>param动作</strong>：<code>&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot;&gt;</code><br>常与<jsp:forward>一起使用，作为其的子标签:</jsp:forward></p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;jsp:forward page=<span class=\"string\">\"user.jsp\"</span>&gt;</span><br><span class=\"line\">\t&lt;%--用&lt;jsp:param <span class=\"string\">\"&gt;&lt;/jsp:param&gt;添加参数--%&gt;</span></span><br><span class=\"line\"><span class=\"string\">\t&lt;jsp:param name=\"</span>email<span class=\"string\">\" value=\"</span><span class=\"number\">11111111</span>@<span class=\"number\">163</span>.com<span class=\"string\">\"&gt;&lt;/jsp:param&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/jsp:forward&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2、jsp注释\"><a href=\"#2、jsp注释\" class=\"headerlink\" title=\"2、jsp注释\"></a>2、jsp注释</h4><ul>\n<li>html的注释  <!-- html注释 --></li>\n<li>jsp的注释<br>&lt;%– jsp注释 –&gt;（客户端不可见）</li>\n<li>jsp脚本注释:<br>//单行<br>/<em> </em>/ 多行</li>\n</ul>\n<h4 id=\"3、jsp脚本\"><a href=\"#3、jsp脚本\" class=\"headerlink\" title=\"3、jsp脚本\"></a>3、jsp脚本</h4><p>&lt;% java代码 %&gt;</p>\n<h4 id=\"4、jsp声明变量或方法\"><a href=\"#4、jsp声明变量或方法\" class=\"headerlink\" title=\"4、jsp声明变量或方法\"></a>4、jsp声明变量或方法</h4><p>&lt;%! java代码 %&gt;</p>\n<h4 id=\"5、jsp表达式\"><a href=\"#5、jsp表达式\" class=\"headerlink\" title=\"5、jsp表达式\"></a>5、jsp表达式</h4><p>&lt;%=表达式 %&gt;  ps:不可;分号结束</p>\n<h4 id=\"6、jsp页面的生命周期\"><a href=\"#6、jsp页面的生命周期\" class=\"headerlink\" title=\"6、jsp页面的生命周期\"></a>6、jsp页面的生命周期</h4><p><img src=\"/images/jsp_life_cycle.png\" alt=\"jsp_life_cycle.png\"> </p>\n<h3 id=\"二、jsp内置对象\"><a href=\"#二、jsp内置对象\" class=\"headerlink\" title=\"二、jsp内置对象\"></a>二、jsp内置对象</h3><p><strong> 九大内置对象：</strong><code>out</code>,<code>request</code>,<code>response</code>,<code>session</code>,<code>application</code>,<code>Page</code>,<code>pageContext</code>,<code>exception</code>,<code>config</code></p>\n<p><strong>out</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\">   \tout.println(\"&lt;h2&gt;静夜思&lt;/h2&gt;\");</span><br><span class=\"line\">   \tout.println(\"床前明月光<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   \tout.println(\"疑是地上霜<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   \tout.flush();</span><br><span class=\"line\">  \t\t/*out.clear();会抛出异常*/</span><br><span class=\"line\">   \tout.clearBuffer();//这里不会抛出异常</span><br><span class=\"line\">   \tout.println(\"举头望明月<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   \tout.println(\"低头思故乡<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>\");</span><br><span class=\"line\">   %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   缓冲区大小：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">out.getBufferSize</span>()%&gt;</span>byte<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   缓冲区剩余大小：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">out.getRemaining</span>()%&gt;</span>byte<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   是否自动清空缓冲区：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">out.isAutoFlush</span>()%&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>request</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">request.setCharacterEncoding</span>(\"<span class=\"attr\">utf-8</span>\");//解决<span class=\"attr\">post</span>中文乱码问题，但无法解决<span class=\"attr\">get</span>，<span class=\"attr\">get</span>解决需要直接<span class=\"attr\">Tomcat</span>配置文件</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">request.setAttribute</span>(\"<span class=\"attr\">password</span>\",\"<span class=\"attr\">123456</span>\");//设置属性密码</span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span></span><br><span class=\"line\">   用户名：<span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">request.getParameter</span>(\"<span class=\"attr\">username</span>\")%&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   爱好：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">if</span>(<span class=\"attr\">request.getParameterValues</span>(\"<span class=\"attr\">favorite</span>\") != <span class=\"string\">null)&#123;</span>  //这里需要判断为不为空，<span class=\"attr\">jsp</span>这里不能将<span class=\"attr\">String</span>数组看为<span class=\"attr\">Boolean</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">String</span>[] <span class=\"attr\">favorites</span> = <span class=\"string\">request.getParameterValues(</span>\"<span class=\"attr\">favorite</span>\");</span></span><br><span class=\"line\">           for (int i = 0; i &lt; favorites.length; i++) &#123;</span><br><span class=\"line\">               out.println(favorites[i] + \"&amp;nbsp;&amp;nbsp;&amp;nbsp;\");</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       String realPath = request.getRealPath(\"requset.jsp\");%&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   密码：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getAttribute(\"password\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求体的MIME类型：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getContentType()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   协议类型和版本号：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getProtocol()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   服务器主机名：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getServerName()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   服务器端口号：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getServerPort()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求文件长度：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getContentLength()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求的客户端地址：</span><br><span class=\"line\">   &lt;%=request.getRemoteAddr()%&gt;&lt;&lt;br&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">   请求的真实路径：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getRealPath(\"requset.jsp\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   请求的上下文路径：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=request.getContextPath()%</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>response</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">response.setContentType</span>(\"<span class=\"attr\">text</span>/<span class=\"attr\">html</span>;<span class=\"attr\">charset</span>=<span class=\"string\">utf-8</span>\");</span></span><br><span class=\"line\">       out.println(\"&lt;h1&gt;response内置对象&lt;/h1&gt;\");</span><br><span class=\"line\">       out.println(\"<span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span>\");</span><br><span class=\"line\">       //out.flush();</span><br><span class=\"line\">       /* 因为getWrite获得的输出流对象会先于内置对象out输出，</span><br><span class=\"line\">       所以要先清空缓冲区，使out强制输出，否则结果会是先输出outer</span><br><span class=\"line\">       再输出out*/</span><br><span class=\"line\"></span><br><span class=\"line\">       PrintWriter outer = response.getWriter();</span><br><span class=\"line\">       outer.println(\"大家好，我是response生成的输出流outer\");</span><br><span class=\"line\">//  response.sendRedirect(\"login.jsp\");//重定向</span><br><span class=\"line\">//  response.sendRedirect(\"request.jsp\");</span><br><span class=\"line\">       request.getRequestDispatcher(\"request.jsp\").forward(request,response);//转发</span><br><span class=\"line\">   %&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>请求转发和请求重定向的区别：</strong></p>\n<p><img src=\"/images/jsp_diff_dispatch_redirect.png\" alt=\"redirectAndTransmit.PNG\"></p>\n<p><strong>session</strong><br>HttpSession的实例，周期：在第一个jsp页面被加载时自动创建，即浏览器连接到服务器开始，关闭浏览器离开这个服务器结束，在服务器的几个页面之间切换，服务器应当知道这是一个客户，就可以用session对象</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">SimpleDateFormat</span> <span class=\"attr\">sdf</span> = <span class=\"string\">new</span> <span class=\"attr\">SimpleDateFormat</span>(\"<span class=\"attr\">yyyy</span>年<span class=\"attr\">mm</span>月<span class=\"attr\">dd</span>日 <span class=\"attr\">HH:mm:ss</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">Date</span> <span class=\"attr\">d</span> = <span class=\"string\">new</span> <span class=\"attr\">Date</span>(<span class=\"attr\">session.getCreationTime</span>());</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">session.setAttribute</span>(\"<span class=\"attr\">username</span>\",\"<span class=\"attr\">pinnuli</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">session.setAttribute</span>(\"<span class=\"attr\">password</span>\",\"<span class=\"attr\">123456</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">session.setAttribute</span>(\"<span class=\"attr\">age</span>\",<span class=\"attr\">20</span>);</span></span><br><span class=\"line\"><span class=\"tag\">//  <span class=\"attr\">session.setMaxInactiveInterval</span>(<span class=\"attr\">10</span>);</span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">//设置<span class=\"attr\">session</span>最大生成期限，单位秒,也可在<span class=\"attr\">web.xml</span>中设置<span class=\"attr\">session-timeout</span></span></span><br><span class=\"line\"><span class=\"tag\"></span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span></span><br><span class=\"line\">   Session创建时间：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=sdf.format(d)%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Session的ID：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=session.getId()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Session中获取属性值：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%=session.getAttribute(\"username\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   Session保存的属性数组：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">String</span>[] <span class=\"attr\">names</span> = <span class=\"string\">session.getValueNames();</span></span></span><br><span class=\"line\">       for(int i=0; i&lt;names.length; i++)&#123;</span><br><span class=\"line\">           out.println(names[i] + \"&amp;nbsp;&amp;nbsp;\");</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">//        session.invalidate();//销毁当前会话,每次刷新一次页面就会新建一个session</span><br><span class=\"line\">   %&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%--测试不同页面是否同一个session--%</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"session_page2.jsp\"</span>&gt;</span>跳转到session_page2<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>application</strong><br>实现用户间数据的共享，可存放全局边变量，相当于java的静态变量</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">application.setAttribute</span>(\"<span class=\"attr\">city</span>\",\"广州\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">application.setAttribute</span>(\"<span class=\"attr\">postcode</span>\",\"<span class=\"attr\">510000</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">application.setAttribute</span>(\"<span class=\"attr\">email</span>\",\"<span class=\"attr\">guangzhou</span>@<span class=\"attr\">163.com</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span></span><br><span class=\"line\">   所在城市：<span class=\"tag\">&lt;<span class=\"name\">%=application.getAttribute(\"city\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   所有属性：</span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">Enumeration</span> <span class=\"attr\">attributes</span> = <span class=\"string\">application.getAttributeNames();</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">while</span> (<span class=\"attr\">attributes.hasMoreElements</span>())&#123;</span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">out.println</span>(<span class=\"attr\">attributes.nextElement</span>() + \"&amp;<span class=\"attr\">nbsp</span>;&amp;<span class=\"attr\">nbsp</span>;\");</span></span><br><span class=\"line\"><span class=\"tag\">       &#125;</span></span><br><span class=\"line\"><span class=\"tag\">   %&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   jsp(serviet)引擎名和版本号：<span class=\"tag\">&lt;<span class=\"name\">%=application.getServerInfo()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>page、pageContext</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>page:<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>当前page页面的字符串描述：<span class=\"tag\">&lt;<span class=\"name\">%=page.toString()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>pageContext:<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span>用户名：从session中获取属性-<span class=\"tag\">&lt;<span class=\"name\">%=pageContext.getSession().getAttribute(\"username\")%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">%--跳转到其他页面--%</span>&gt;</span></span><br><span class=\"line\">  &lt;%--&lt;%</span><br><span class=\"line\">      pageContext.forward(\"out.jsp\");</span><br><span class=\"line\">  %&gt;--%&gt;</span><br><span class=\"line\">   include方法，包含其他页面:</span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">%</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">pageContext.include</span>(\"<span class=\"attr\">out.jsp</span>\");</span></span><br><span class=\"line\"><span class=\"tag\">       %&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>exception</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">异常消息：<span class=\"tag\">&lt;<span class=\"name\">%=exception.getMessage()%</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">   异常的字符串描述：<span class=\"tag\">&lt;<span class=\"name\">%=exception.toString()%</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三、jsp使用Javabean\"><a href=\"#三、jsp使用Javabean\" class=\"headerlink\" title=\"三、jsp使用Javabean\"></a>三、jsp使用Javabean</h3><h4 id=\"1-Javabean的设计原则\"><a href=\"#1-Javabean的设计原则\" class=\"headerlink\" title=\"1. Javabean的设计原则\"></a>1. Javabean的设计原则</h4><ul>\n<li>必须是公有类</li>\n<li>必须包含无参构造方法</li>\n<li>属性私有</li>\n<li>用getter()和setter()进行封装</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Students</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"title\">Students</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-存取Javabean有关的jsp动作元素\"><a href=\"#2-存取Javabean有关的jsp动作元素\" class=\"headerlink\" title=\"2. 存取Javabean有关的jsp动作元素\"></a>2. 存取Javabean有关的jsp动作元素</h4><p><strong>在jsp页面中使用Javabeans：</strong></p>\n<p>方法一：像使用普通java类一样，创建Javabean实例<br>方法二：在jsp页面中通常使用jsp动作标签使用javabean,常用的动作标签：userBeans、setProperty、getProperty</p>\n<ul>\n<li><code>&lt;jsp:useBeans&gt;</code></li>\n</ul>\n<p>在jsp页面中实例化或者在指定范围内使用Javabean：</p>\n<p><code>&lt;jsp:useBeans id=&quot;标示符&quot; class=&quot;java类名&quot; scope=&quot;作用范围&quot;/&gt;</code></p>\n<blockquote>\n<p>scope属性：指定Javabean的作用范围<br>page：当前页面,重定向和转发都无效<br>request：可通过HttpRequest.getAttribute()取得Javabean对象，重定向无效，转发有效<br>session：可通过HttpSession.getAttribute()取得Javabean对象，同个会话有效<br>application:可通过application.getAttribute()取得Javabean对象，不同会话都有效</p>\n</blockquote>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:useBean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.po.Users\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"application\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:useBean</span>&gt;</span></span><br><span class=\"line\">用户名：<span class=\"tag\">&lt;<span class=\"name\">jsp:getProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:getProperty</span>&gt;</span></span><br><span class=\"line\">密码：<span class=\"tag\">&lt;<span class=\"name\">jsp:getProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:getProperty</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>也可使用内置对象获取：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户名：<span class=\"tag\">&lt;<span class=\"name\">%=((Users)application.getAttribute(\"myUsers\")).getUsername()%</span>&gt;</span></span><br><span class=\"line\">密码： <span class=\"tag\">&lt;<span class=\"name\">%=((Users)</span> <span class=\"attr\">application.getAttribute</span>(\"<span class=\"attr\">myUsers</span>\"))<span class=\"attr\">.getPassword</span>()%&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>&lt;jsp:setProperty&gt;</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据表单自动匹配所有属性:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">根据表单匹配部分属性:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">与表单无关，通过手工赋值给属性:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"hahahaha\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">通过url传参数给属性赋值:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:setProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">param</span>=<span class=\"string\">\"testparam\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:setProperty</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;jsp:getProperty&gt;</code></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用getProperty获取属性值:</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">jsp:getProperty</span> <span class=\"attr\">name</span>=<span class=\"string\">\"myUsers\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"username\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">jsp:getProperty</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/166\" target=\"_blank\" rel=\"noopener\">慕课网：JAVA遇见HTML——JSP篇</a></p>\n</blockquote>\n"},{"title":"Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J","date":"2018-07-30T04:17:35.000Z","copyright":null,"_content":"\n现有以下XML文档books.xml,下面的解析示例解析此文档部分内容\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\t<book id=\"1\">\n\t\t<name>冰与火之歌</name>\n\t\t<author>乔治马丁</author>\n\t\t<year>2014</year>\n\t\t<price>89</price>\n\t</book>\n\t<book id=\"2\">\n\t\t<name>安徒生童话</name>\n\t\t<year>2004</year>\n\t\t<price>77</price>\n\t\t<language>English</language>\n\t</book>\n</bookstore>\n```\n### DOM解析\n1、创建一个DocumentBuilder的对象\n```java\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\n```\n2、调用parser方法加载books.xml文件到当前项目下\n```java\nDocument document = db.parse(\"books.xml\");\n```\n3、进行解析\n```java\n//获取所有book节点的集合\nNodeList bookList = document.getElementsByTagName(\"book\");\n//?????book??\nfor (int i = 0; i < bookList.getLength(); i++) {\n    //通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始\n    Node book = bookList.item(i);\n\n    //获取book节点的所有属性集合\n    NamedNodeMap attrs = book.getAttributes();\n\n    //前提：已经知道book节点有且只能有1个id属性\n    //将book节点进行强制类型转换，转换成Element类型\n    Element book = (Element) bookList.item(i);\n\n    //通过getAttribute(\"id\")方法获取属性值\n    String attrValue = book.getAttribute(\"id\");\n    \n    //解析book节点的子节点\n    NodeList childNodes = book.getChildNodes();\n}\n```\n> 更多解析方法查看API\n\n----\n### SAX解析\n1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例\n```java\nSAXParserFactory factory = SAXParserFactory.newInstance();\n```\n2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例\n```java\nSAXParser parser = factory.newSAXParser();\n```\n3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler\n```java\nSAXParserHandler handler = new SAXParserHandler();\nparser.parse(\"books.xml\", handler);\n```\nhandler类\n```java\n//标识解析开始\n@Override\npublic void startDocument() throws SAXException {\n    // TODO Auto-generated method stub\n    super.startDocument();\n    System.out.println(\"SAX解析开始\");\n}\n\n//标识解析结束\n@Override\npublic void endDocument() throws SAXException {\n    // TODO Auto-generated method stub\n    super.endDocument();\n    System.out.println(\"SAX解析结束\");\n}\n\n//解析xml元素\n@Override\npublic void startElement(String uri, String localName, String qName,\n        Attributes attributes) throws SAXException {\n    //调用DefaultHandler类的startElement方法\n    super.startElement(uri, localName, qName, attributes);\n    if (qName.equals(\"book\")) {\n        //已知book元素下属性的名称，根据属性名称获取属性值\n        String value = attributes.getValue(\"id\");\n        System.out.println(\"book的属性值是：\" + value);\n\n    }else if (!qName.equals(\"name\") && !qName.equals(\"bookstore\")) {\n        System.out.print(\"节点名是：\" + qName + \"---\");\n    }\n}\n\n@Override\npublic void endElement(String uri, String localName, String qName)\n        throws SAXException {\n    //调用DefaultHandler类的endElement方法\n    super.endElement(uri, localName, qName);\n    //判断是否针对一本书已经遍历结束\n    if (qName.equals(\"book\")) {\n        System.out.println(\"结束遍历某一本书的内容\");\n    }\n}\n\n@Override\npublic void characters(char[] ch, int start, int length)\n        throws SAXException {\n    // TODO Auto-generated method stub\n    super.characters(ch, start, length);\n    value = new String(ch, start, length);\n    if (!value.trim().equals(\"\")) {\n        System.out.println(\"节点值是：\" + value);\n    }\n}\n```\n----\n### JDOM解析\n1、创建一个SAXBuilder的对象\n```\nSAXBuilder saxBuilder = new SAXBuilder();\n```\n2、创建一个输入流，将xml文件加载到输入流中\n```\nin = new FileInputStream(\"books.xml\");\n```\n3、通过saxBuilder的build方法，将输入流加载到saxBuilder中\n```\nDocument document = saxBuilder.build(in);\n```\n4、通过document对象获取xml文件的根节点\n```\nElement rootElement = document.getRootElement();\n```\n5、获取根节点下的子节点的List集合\n```\nList<Element> bookList = rootElement.getChildren();\nfor (Element book : bookList) {\n    // 解析book的属性集合\n    List<Attribute> attrList = book.getAttributes();\n    //知道节点下属性名称时，获取节点值\n    book.getAttributeValue(\"id\");\n\n    // 对book节点的子节点的节点名以及节点值的遍历\n    List<Element> bookChilds = book.getChildren();\n    for (Element child : bookChilds) {\n        System.out.println(\"????\" + child.getName() + \"----????\"\n                + child.getValue());\n    }\n}\n\n```\n> 如果需要设置编码可以按照以下方式设置\n\n```java\nInputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\nDocument document = saxBuilder.build(isr);\n```\n----\n### DOM4J解析\n1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象\n```java\nSAXReader reader = new SAXReader();\nDocument document = reader.read(new File(\"src/res/books.xml\"));\n```\n2、通过document对象获取根节点\n```java\nElement bookStore = document.getRootElement();\n```\n3、通过element对象的elementIterator方法获取迭代器\n```java\nIterator it = bookStore.elementIterator();\n```\n4、遍历迭代器，获取根节点中的信息\n```java\nwhile (it.hasNext()) {\n    Element book = (Element) it.next();\n    // 获取book的属性名以及 属性值\n    List<Attribute> bookAttrs = book.attributes();\n    for (Attribute attr : bookAttrs) {\n        System.out.println(\"????\" + attr.getName() + \"--????\"\n                + attr.getValue());\n    }\n    //遍历子节点\n    Iterator itt = book.elementIterator();\n    while (itt.hasNext()) {\n        Element bookChild = (Element) itt.next();\n        System.out.println(\"????\" + bookChild.getName() + \"--????\" + bookChild.getStringValue());\n    }\n}\n\n```\n----\n### 四种解析方式的区别\n- DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时\n    >优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改\n    缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出\n- SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时\n    >优点：内存消耗小\n    缺点：不易编码；很难同时访问同一个xml中的多处不同数据\n- JDOM：API大量使用了Collections类\n- DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用\n\n> 参阅：\n  [慕课网：Java眼中的XML---文件读取](https://www.imooc.com/learn/171)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)","source":"_posts/Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J.md","raw":"---\ntitle: Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J\ndate: 2018-07-30 12:17:35\ncategories: \"JavaSE笔记\"\ntags:\n    - JavaSE\n    - XML\ncopyright:\n---\n\n现有以下XML文档books.xml,下面的解析示例解析此文档部分内容\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\t<book id=\"1\">\n\t\t<name>冰与火之歌</name>\n\t\t<author>乔治马丁</author>\n\t\t<year>2014</year>\n\t\t<price>89</price>\n\t</book>\n\t<book id=\"2\">\n\t\t<name>安徒生童话</name>\n\t\t<year>2004</year>\n\t\t<price>77</price>\n\t\t<language>English</language>\n\t</book>\n</bookstore>\n```\n### DOM解析\n1、创建一个DocumentBuilder的对象\n```java\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\n```\n2、调用parser方法加载books.xml文件到当前项目下\n```java\nDocument document = db.parse(\"books.xml\");\n```\n3、进行解析\n```java\n//获取所有book节点的集合\nNodeList bookList = document.getElementsByTagName(\"book\");\n//?????book??\nfor (int i = 0; i < bookList.getLength(); i++) {\n    //通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始\n    Node book = bookList.item(i);\n\n    //获取book节点的所有属性集合\n    NamedNodeMap attrs = book.getAttributes();\n\n    //前提：已经知道book节点有且只能有1个id属性\n    //将book节点进行强制类型转换，转换成Element类型\n    Element book = (Element) bookList.item(i);\n\n    //通过getAttribute(\"id\")方法获取属性值\n    String attrValue = book.getAttribute(\"id\");\n    \n    //解析book节点的子节点\n    NodeList childNodes = book.getChildNodes();\n}\n```\n> 更多解析方法查看API\n\n----\n### SAX解析\n1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例\n```java\nSAXParserFactory factory = SAXParserFactory.newInstance();\n```\n2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例\n```java\nSAXParser parser = factory.newSAXParser();\n```\n3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler\n```java\nSAXParserHandler handler = new SAXParserHandler();\nparser.parse(\"books.xml\", handler);\n```\nhandler类\n```java\n//标识解析开始\n@Override\npublic void startDocument() throws SAXException {\n    // TODO Auto-generated method stub\n    super.startDocument();\n    System.out.println(\"SAX解析开始\");\n}\n\n//标识解析结束\n@Override\npublic void endDocument() throws SAXException {\n    // TODO Auto-generated method stub\n    super.endDocument();\n    System.out.println(\"SAX解析结束\");\n}\n\n//解析xml元素\n@Override\npublic void startElement(String uri, String localName, String qName,\n        Attributes attributes) throws SAXException {\n    //调用DefaultHandler类的startElement方法\n    super.startElement(uri, localName, qName, attributes);\n    if (qName.equals(\"book\")) {\n        //已知book元素下属性的名称，根据属性名称获取属性值\n        String value = attributes.getValue(\"id\");\n        System.out.println(\"book的属性值是：\" + value);\n\n    }else if (!qName.equals(\"name\") && !qName.equals(\"bookstore\")) {\n        System.out.print(\"节点名是：\" + qName + \"---\");\n    }\n}\n\n@Override\npublic void endElement(String uri, String localName, String qName)\n        throws SAXException {\n    //调用DefaultHandler类的endElement方法\n    super.endElement(uri, localName, qName);\n    //判断是否针对一本书已经遍历结束\n    if (qName.equals(\"book\")) {\n        System.out.println(\"结束遍历某一本书的内容\");\n    }\n}\n\n@Override\npublic void characters(char[] ch, int start, int length)\n        throws SAXException {\n    // TODO Auto-generated method stub\n    super.characters(ch, start, length);\n    value = new String(ch, start, length);\n    if (!value.trim().equals(\"\")) {\n        System.out.println(\"节点值是：\" + value);\n    }\n}\n```\n----\n### JDOM解析\n1、创建一个SAXBuilder的对象\n```\nSAXBuilder saxBuilder = new SAXBuilder();\n```\n2、创建一个输入流，将xml文件加载到输入流中\n```\nin = new FileInputStream(\"books.xml\");\n```\n3、通过saxBuilder的build方法，将输入流加载到saxBuilder中\n```\nDocument document = saxBuilder.build(in);\n```\n4、通过document对象获取xml文件的根节点\n```\nElement rootElement = document.getRootElement();\n```\n5、获取根节点下的子节点的List集合\n```\nList<Element> bookList = rootElement.getChildren();\nfor (Element book : bookList) {\n    // 解析book的属性集合\n    List<Attribute> attrList = book.getAttributes();\n    //知道节点下属性名称时，获取节点值\n    book.getAttributeValue(\"id\");\n\n    // 对book节点的子节点的节点名以及节点值的遍历\n    List<Element> bookChilds = book.getChildren();\n    for (Element child : bookChilds) {\n        System.out.println(\"????\" + child.getName() + \"----????\"\n                + child.getValue());\n    }\n}\n\n```\n> 如果需要设置编码可以按照以下方式设置\n\n```java\nInputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\nDocument document = saxBuilder.build(isr);\n```\n----\n### DOM4J解析\n1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象\n```java\nSAXReader reader = new SAXReader();\nDocument document = reader.read(new File(\"src/res/books.xml\"));\n```\n2、通过document对象获取根节点\n```java\nElement bookStore = document.getRootElement();\n```\n3、通过element对象的elementIterator方法获取迭代器\n```java\nIterator it = bookStore.elementIterator();\n```\n4、遍历迭代器，获取根节点中的信息\n```java\nwhile (it.hasNext()) {\n    Element book = (Element) it.next();\n    // 获取book的属性名以及 属性值\n    List<Attribute> bookAttrs = book.attributes();\n    for (Attribute attr : bookAttrs) {\n        System.out.println(\"????\" + attr.getName() + \"--????\"\n                + attr.getValue());\n    }\n    //遍历子节点\n    Iterator itt = book.elementIterator();\n    while (itt.hasNext()) {\n        Element bookChild = (Element) itt.next();\n        System.out.println(\"????\" + bookChild.getName() + \"--????\" + bookChild.getStringValue());\n    }\n}\n\n```\n----\n### 四种解析方式的区别\n- DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时\n    >优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改\n    缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出\n- SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时\n    >优点：内存消耗小\n    缺点：不易编码；很难同时访问同一个xml中的多处不同数据\n- JDOM：API大量使用了Collections类\n- DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用\n\n> 参阅：\n  [慕课网：Java眼中的XML---文件读取](https://www.imooc.com/learn/171)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)","slug":"Java中的XML之四种方式解析XML文档：DOM，SAX，JDOM，DOM4J","published":1,"updated":"2018-11-13T06:13:07.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcq000bu7yjq8dae3dz","content":"<p>现有以下XML文档books.xml,下面的解析示例解析此文档部分内容<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bookstore</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>冰与火之歌<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">author</span>&gt;</span>乔治马丁<span class=\"tag\">&lt;/<span class=\"name\">author</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2014<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>89<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"2\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>安徒生童话<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2004<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>77<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">language</span>&gt;</span>English<span class=\"tag\">&lt;/<span class=\"name\">language</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DOM解析\"><a href=\"#DOM解析\" class=\"headerlink\" title=\"DOM解析\"></a>DOM解析</h3><p>1、创建一个DocumentBuilder的对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class=\"line\">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p>\n<p>2、调用parser方法加载books.xml文件到当前项目下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = db.parse(<span class=\"string\">\"books.xml\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3、进行解析<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取所有book节点的集合</span></span><br><span class=\"line\">NodeList bookList = document.getElementsByTagName(<span class=\"string\">\"book\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//?????book??</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bookList.getLength(); i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始</span></span><br><span class=\"line\">    Node book = bookList.item(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取book节点的所有属性集合</span></span><br><span class=\"line\">    NamedNodeMap attrs = book.getAttributes();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//前提：已经知道book节点有且只能有1个id属性</span></span><br><span class=\"line\">    <span class=\"comment\">//将book节点进行强制类型转换，转换成Element类型</span></span><br><span class=\"line\">    Element book = (Element) bookList.item(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通过getAttribute(\"id\")方法获取属性值</span></span><br><span class=\"line\">    String attrValue = book.getAttribute(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//解析book节点的子节点</span></span><br><span class=\"line\">    NodeList childNodes = book.getChildNodes();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>更多解析方法查看API</p>\n</blockquote>\n<hr>\n<h3 id=\"SAX解析\"><a href=\"#SAX解析\" class=\"headerlink\" title=\"SAX解析\"></a>SAX解析</h3><p>1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXParserFactory factory = SAXParserFactory.newInstance();</span><br></pre></td></tr></table></figure></p>\n<p>2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXParser parser = factory.newSAXParser();</span><br></pre></td></tr></table></figure></p>\n<p>3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXParserHandler handler = <span class=\"keyword\">new</span> SAXParserHandler();</span><br><span class=\"line\">parser.parse(<span class=\"string\">\"books.xml\"</span>, handler);</span><br></pre></td></tr></table></figure></p>\n<p>handler类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标识解析开始</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.startDocument();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"SAX解析开始\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//标识解析结束</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">endDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.endDocument();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"SAX解析结束\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解析xml元素</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startElement</span><span class=\"params\">(String uri, String localName, String qName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用DefaultHandler类的startElement方法</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.startElement(uri, localName, qName, attributes);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (qName.equals(<span class=\"string\">\"book\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//已知book元素下属性的名称，根据属性名称获取属性值</span></span><br><span class=\"line\">        String value = attributes.getValue(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"book的属性值是：\"</span> + value);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!qName.equals(<span class=\"string\">\"name\"</span>) &amp;&amp; !qName.equals(<span class=\"string\">\"bookstore\"</span>)) &#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"节点名是：\"</span> + qName + <span class=\"string\">\"---\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">endElement</span><span class=\"params\">(String uri, String localName, String qName)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用DefaultHandler类的endElement方法</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.endElement(uri, localName, qName);</span><br><span class=\"line\">    <span class=\"comment\">//判断是否针对一本书已经遍历结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (qName.equals(<span class=\"string\">\"book\"</span>)) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"结束遍历某一本书的内容\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">characters</span><span class=\"params\">(<span class=\"keyword\">char</span>[] ch, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> length)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.characters(ch, start, length);</span><br><span class=\"line\">    value = <span class=\"keyword\">new</span> String(ch, start, length);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value.trim().equals(<span class=\"string\">\"\"</span>)) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"节点值是：\"</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"JDOM解析\"><a href=\"#JDOM解析\" class=\"headerlink\" title=\"JDOM解析\"></a>JDOM解析</h3><p>1、创建一个SAXBuilder的对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXBuilder saxBuilder = new SAXBuilder();</span><br></pre></td></tr></table></figure></p>\n<p>2、创建一个输入流，将xml文件加载到输入流中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in = new FileInputStream(&quot;books.xml&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>3、通过saxBuilder的build方法，将输入流加载到saxBuilder中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = saxBuilder.build(in);</span><br></pre></td></tr></table></figure></p>\n<p>4、通过document对象获取xml文件的根节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element rootElement = document.getRootElement();</span><br></pre></td></tr></table></figure></p>\n<p>5、获取根节点下的子节点的List集合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Element&gt; bookList = rootElement.getChildren();</span><br><span class=\"line\">for (Element book : bookList) &#123;</span><br><span class=\"line\">    // 解析book的属性集合</span><br><span class=\"line\">    List&lt;Attribute&gt; attrList = book.getAttributes();</span><br><span class=\"line\">    //知道节点下属性名称时，获取节点值</span><br><span class=\"line\">    book.getAttributeValue(&quot;id&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对book节点的子节点的节点名以及节点值的遍历</span><br><span class=\"line\">    List&lt;Element&gt; bookChilds = book.getChildren();</span><br><span class=\"line\">    for (Element child : bookChilds) &#123;</span><br><span class=\"line\">        System.out.println(&quot;????&quot; + child.getName() + &quot;----????&quot;</span><br><span class=\"line\">                + child.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果需要设置编码可以按照以下方式设置</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(in, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">Document document = saxBuilder.build(isr);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"DOM4J解析\"><a href=\"#DOM4J解析\" class=\"headerlink\" title=\"DOM4J解析\"></a>DOM4J解析</h3><p>1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXReader reader = <span class=\"keyword\">new</span> SAXReader();</span><br><span class=\"line\">Document document = reader.read(<span class=\"keyword\">new</span> File(<span class=\"string\">\"src/res/books.xml\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>2、通过document对象获取根节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element bookStore = document.getRootElement();</span><br></pre></td></tr></table></figure></p>\n<p>3、通过element对象的elementIterator方法获取迭代器<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator it = bookStore.elementIterator();</span><br></pre></td></tr></table></figure></p>\n<p>4、遍历迭代器，获取根节点中的信息<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">    Element book = (Element) it.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取book的属性名以及 属性值</span></span><br><span class=\"line\">    List&lt;Attribute&gt; bookAttrs = book.attributes();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Attribute attr : bookAttrs) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"????\"</span> + attr.getName() + <span class=\"string\">\"--????\"</span></span><br><span class=\"line\">                + attr.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历子节点</span></span><br><span class=\"line\">    Iterator itt = book.elementIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (itt.hasNext()) &#123;</span><br><span class=\"line\">        Element bookChild = (Element) itt.next();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"????\"</span> + bookChild.getName() + <span class=\"string\">\"--????\"</span> + bookChild.getStringValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"四种解析方式的区别\"><a href=\"#四种解析方式的区别\" class=\"headerlink\" title=\"四种解析方式的区别\"></a>四种解析方式的区别</h3><ul>\n<li>DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时<blockquote>\n<p>优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改<br>  缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出</p>\n</blockquote>\n</li>\n<li>SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时<blockquote>\n<p>优点：内存消耗小<br>  缺点：不易编码；很难同时访问同一个xml中的多处不同数据</p>\n</blockquote>\n</li>\n<li>JDOM：API大量使用了Collections类</li>\n<li>DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用</li>\n</ul>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/171\" target=\"_blank\" rel=\"noopener\">慕课网：Java眼中的XML—文件读取</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>现有以下XML文档books.xml,下面的解析示例解析此文档部分内容<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bookstore</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>冰与火之歌<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">author</span>&gt;</span>乔治马丁<span class=\"tag\">&lt;/<span class=\"name\">author</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2014<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>89<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"2\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>安徒生童话<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2004<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>77<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">language</span>&gt;</span>English<span class=\"tag\">&lt;/<span class=\"name\">language</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DOM解析\"><a href=\"#DOM解析\" class=\"headerlink\" title=\"DOM解析\"></a>DOM解析</h3><p>1、创建一个DocumentBuilder的对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class=\"line\">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p>\n<p>2、调用parser方法加载books.xml文件到当前项目下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = db.parse(<span class=\"string\">\"books.xml\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3、进行解析<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取所有book节点的集合</span></span><br><span class=\"line\">NodeList bookList = document.getElementsByTagName(<span class=\"string\">\"book\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//?????book??</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; bookList.getLength(); i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过 item(i)方法 获取一个book节点，nodelist的索引值从0开始</span></span><br><span class=\"line\">    Node book = bookList.item(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取book节点的所有属性集合</span></span><br><span class=\"line\">    NamedNodeMap attrs = book.getAttributes();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//前提：已经知道book节点有且只能有1个id属性</span></span><br><span class=\"line\">    <span class=\"comment\">//将book节点进行强制类型转换，转换成Element类型</span></span><br><span class=\"line\">    Element book = (Element) bookList.item(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通过getAttribute(\"id\")方法获取属性值</span></span><br><span class=\"line\">    String attrValue = book.getAttribute(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//解析book节点的子节点</span></span><br><span class=\"line\">    NodeList childNodes = book.getChildNodes();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>更多解析方法查看API</p>\n</blockquote>\n<hr>\n<h3 id=\"SAX解析\"><a href=\"#SAX解析\" class=\"headerlink\" title=\"SAX解析\"></a>SAX解析</h3><p>1、通过SAXParserFactory的静态newsInstance()方法获取SAXParserFactory实例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXParserFactory factory = SAXParserFactory.newInstance();</span><br></pre></td></tr></table></figure></p>\n<p>2、通过SAXParserFactory实例的newSAXParser()方法返回SAXParser实例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXParser parser = factory.newSAXParser();</span><br></pre></td></tr></table></figure></p>\n<p>3、创建一个类继承DefaultHandler，重写其中的一些方法进行处理，并创建这个类的实例handler<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXParserHandler handler = <span class=\"keyword\">new</span> SAXParserHandler();</span><br><span class=\"line\">parser.parse(<span class=\"string\">\"books.xml\"</span>, handler);</span><br></pre></td></tr></table></figure></p>\n<p>handler类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//标识解析开始</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.startDocument();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"SAX解析开始\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//标识解析结束</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">endDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.endDocument();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"SAX解析结束\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解析xml元素</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startElement</span><span class=\"params\">(String uri, String localName, String qName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Attributes attributes)</span> <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用DefaultHandler类的startElement方法</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.startElement(uri, localName, qName, attributes);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (qName.equals(<span class=\"string\">\"book\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//已知book元素下属性的名称，根据属性名称获取属性值</span></span><br><span class=\"line\">        String value = attributes.getValue(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"book的属性值是：\"</span> + value);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!qName.equals(<span class=\"string\">\"name\"</span>) &amp;&amp; !qName.equals(<span class=\"string\">\"bookstore\"</span>)) &#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">\"节点名是：\"</span> + qName + <span class=\"string\">\"---\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">endElement</span><span class=\"params\">(String uri, String localName, String qName)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用DefaultHandler类的endElement方法</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.endElement(uri, localName, qName);</span><br><span class=\"line\">    <span class=\"comment\">//判断是否针对一本书已经遍历结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (qName.equals(<span class=\"string\">\"book\"</span>)) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"结束遍历某一本书的内容\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">characters</span><span class=\"params\">(<span class=\"keyword\">char</span>[] ch, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> length)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> SAXException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.characters(ch, start, length);</span><br><span class=\"line\">    value = <span class=\"keyword\">new</span> String(ch, start, length);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!value.trim().equals(<span class=\"string\">\"\"</span>)) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"节点值是：\"</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"JDOM解析\"><a href=\"#JDOM解析\" class=\"headerlink\" title=\"JDOM解析\"></a>JDOM解析</h3><p>1、创建一个SAXBuilder的对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXBuilder saxBuilder = new SAXBuilder();</span><br></pre></td></tr></table></figure></p>\n<p>2、创建一个输入流，将xml文件加载到输入流中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in = new FileInputStream(&quot;books.xml&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>3、通过saxBuilder的build方法，将输入流加载到saxBuilder中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = saxBuilder.build(in);</span><br></pre></td></tr></table></figure></p>\n<p>4、通过document对象获取xml文件的根节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element rootElement = document.getRootElement();</span><br></pre></td></tr></table></figure></p>\n<p>5、获取根节点下的子节点的List集合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Element&gt; bookList = rootElement.getChildren();</span><br><span class=\"line\">for (Element book : bookList) &#123;</span><br><span class=\"line\">    // 解析book的属性集合</span><br><span class=\"line\">    List&lt;Attribute&gt; attrList = book.getAttributes();</span><br><span class=\"line\">    //知道节点下属性名称时，获取节点值</span><br><span class=\"line\">    book.getAttributeValue(&quot;id&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对book节点的子节点的节点名以及节点值的遍历</span><br><span class=\"line\">    List&lt;Element&gt; bookChilds = book.getChildren();</span><br><span class=\"line\">    for (Element child : bookChilds) &#123;</span><br><span class=\"line\">        System.out.println(&quot;????&quot; + child.getName() + &quot;----????&quot;</span><br><span class=\"line\">                + child.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果需要设置编码可以按照以下方式设置</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(in, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">Document document = saxBuilder.build(isr);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"DOM4J解析\"><a href=\"#DOM4J解析\" class=\"headerlink\" title=\"DOM4J解析\"></a>DOM4J解析</h3><p>1、通过reader对象的read方法加载books.xml文件,获取docuemnt对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXReader reader = <span class=\"keyword\">new</span> SAXReader();</span><br><span class=\"line\">Document document = reader.read(<span class=\"keyword\">new</span> File(<span class=\"string\">\"src/res/books.xml\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>2、通过document对象获取根节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element bookStore = document.getRootElement();</span><br></pre></td></tr></table></figure></p>\n<p>3、通过element对象的elementIterator方法获取迭代器<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator it = bookStore.elementIterator();</span><br></pre></td></tr></table></figure></p>\n<p>4、遍历迭代器，获取根节点中的信息<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">    Element book = (Element) it.next();</span><br><span class=\"line\">    <span class=\"comment\">// 获取book的属性名以及 属性值</span></span><br><span class=\"line\">    List&lt;Attribute&gt; bookAttrs = book.attributes();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Attribute attr : bookAttrs) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"????\"</span> + attr.getName() + <span class=\"string\">\"--????\"</span></span><br><span class=\"line\">                + attr.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历子节点</span></span><br><span class=\"line\">    Iterator itt = book.elementIterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (itt.hasNext()) &#123;</span><br><span class=\"line\">        Element bookChild = (Element) itt.next();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"????\"</span> + bookChild.getName() + <span class=\"string\">\"--????\"</span> + bookChild.getStringValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"四种解析方式的区别\"><a href=\"#四种解析方式的区别\" class=\"headerlink\" title=\"四种解析方式的区别\"></a>四种解析方式的区别</h3><ul>\n<li>DOM:将文件全部加载到内存中，形成树结构，适用于小文件，需要频繁修改时<blockquote>\n<p>优点：直观好理解，代码易编写；解析过程树结构保留在内存中，方便修改<br>  缺点：当xml文件较大时，对内存消耗比较大，容易影响解析性能并造成内存溢出</p>\n</blockquote>\n</li>\n<li>SAX:采用事件驱动模式，适用于只需要处理xml中的数据时，不需要频繁修改时<blockquote>\n<p>优点：内存消耗小<br>  缺点：不易编码；很难同时访问同一个xml中的多处不同数据</p>\n</blockquote>\n</li>\n<li>JDOM：API大量使用了Collections类</li>\n<li>DOM4J：JDOM的一种智能分支，合并了许多超出基本xml文档表示的功能，性能优异，灵活性好，功能强大，十分易用</li>\n</ul>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/171\" target=\"_blank\" rel=\"noopener\">慕课网：Java眼中的XML—文件读取</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n"},{"title":"Java并发","date":"2018-11-15T08:01:42.000Z","copyright":null,"_content":"\n### 基本的线程机制\n#### 定义一个线程\n- 实现Runnable接口，重写run()方法，并传递给Thread构造器\n- 继承Thread类，重写run()方法\n\n> 调用Thread.start()方法时，其实是创建一个线程，并初始化之后，再去调run()方法\n\n#### 使用Executor\n> Executor从来管理Thread对象，在客户端和任务之间提供了一个间接层，可以管理一部任务的执行，无须显式地管理线程的生命周期。ExecutorService（具有服务生命周期的Executor）知道如何构建恰当的上下文来执行Runnable对象\n\n有集中不同的Executor：\n- **CacheThreadPool**：通常创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程（首先的Executor）\n- **FixedThreadPool**：使用有限的线程集来执行所提交的任务，可以一次性预先执行代价高昂的线程分配\n- **SingleThreadPool**：像是线程数量为1的FixedThreadPool，当希望在另一个线程中连续运行某事物来说很有用。当提交多个任务时，这些任务会排队。\n示例（三种Executor都这样使用）：\n\n``` java\npublic class SingleThreadPool {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newSingleThreadPool();\n        for (int i = 0; i < 5; i++) {\n            exec.execute(new LiftOff());\n        }\n        exec.shutdown();\n    }\n}\n```\n\n#### 从任务中产生返回值\n> 实现Callable接口，从call（）方法中返回值，必须使用ExecutorService.submit()方法调用。submit()方法会产生Future对象。可以用isDone()方法来查询Future是否完成，完成时可以调用get()方法获取该结果，若完成就调用get()方法将阻塞到完成。\n\n\n```java\npublic class TaskWithResult implements Callable<String> {\n    private int id ;\n    public TaskWithResult(int id) {\n        this.id = id;\n    }\n    public String call() {\n        return \"result of TaskWithResult \" + id;\n    }\n}\n\npublic class CallableDemo {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newCachedThreadPool();\n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();\n        for (int i = 0; i < 5; i++) {\n            results.add(exec.submit(new TaskWithResult(i)));\n        }\n        for(Future<String> fs: results) {\n            try {\n                System.out.println(fs.get());\n            } catch {\n                System.out.printLn(e);\n                return;\n            } finally {\n                exce.shutdown();\n            }\n        }\n    }\n}\n```\n\n#### 休眠(sleep)\n> sleep(),使任务中止执行给定的时间，但不会释放持有的锁\n\n####  优先级\n> Java有十个优先级，但不同的操作系统有不同的优先级，不能与操作系统有很好的映射。在调整优先级时只是用MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY三个等级\n\n#### 让步(yield)\n> 暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。\n\n#### 加入一个线(join)\n> 某个线程在另一个线程t上个调用join()，此线程被挂起，知道目标线程t结束(即.isAlive()为假)才恢复，也可调用join()时带一个超时参数，超时便返回\n\n#### 后台线程(维护线程)\n- 可以在线程启动之前调用setDaemon()方法设置为后台线程\n- 一个后台进程创建的任何线程被自动地设置为后台线程\n- 后台线程在不执行finally子句时就终止器run()方法 \n\n#### 编码变体\n> 有时候可以使用内部类将代码隐藏在类中\n\n- 继承Thread的两种写法：\n1.扩展自Thread的匿名内部类\n\n``` java\nclass InnerThread1 {\n  private Inner inner;\n  private class Inner extends Thread {\n    Inner(String name) {\n      super(name);\n      start();\n    }\n    public void run() {\n        ......\n    }\n  }\n  public InnerThread1(String name) {\n    inner = new Inner(name);\n  }\n}\n```\n\n2.在构造器中穿件一个匿名的Thread子类，并且向上转型为Thread引用t\n\n``` java\nclass InnerThread2 {}\n  private Thread t;\n  public InnerThread2(String name) {\n    t = new Thread(name) {\n      public void run() {\n        ......\n      }\n    };\n    t.start();\n  }\n}\n```\n\n- 实现Runnable的两种写法（同上两种情况）\n\n```java\nclass InnerRunnable1 {\n    private Inner inner;\n    private class Inner implements Runnable {\n    Thread t;\n    Inner(String name) {\n      t = new Thread(this, name);\n      t.start();\n    }\n    public void run() {\n      ......\n    }\n  }\n  public InnerRunnable1(String name) {\n    inner = new Inner(name);\n  }\n}\n```\n\n```java\nclass InnerRunnable2 {\n  private Thread t;\n  public InnerRunnable2(String name) {\n    t = new Thread(new Runnable() {\n      public void run() {\n        ......\n    }, name);\n    t.start();\n  }\n}\n```\n\n- 在方法内部创建线程\n\n```java\nclass ThreadMethod {\n  private Thread t;\n  private String name;\n  public ThreadMethod(String name) { this.name = name; }\n  public void runTask() {\n    if(t == null) {\n      t = new Thread(name) {\n        public void run() {\n          ......\n        }\n      };\n      t.start();\n    }\n  }\n}\n```\n\n#### 捕获异常\n> 线程的本质特征使得我们態捕获从线程中逃逸的异常，而是直接向外传播到控制台，就算用try-catch语句也没有作用。因而要捕获异常，需要修改Executor产生线程的方式，为每个新创建的Thread附着一个Thread.UnCaughtExceptionHandler()，Thread.UnCaughtExceptionHandler.uncaughtException()会在线程因在线程因未捕获异常而临近死亡时被调用\n\n实例：\n\n```java\nclass ExceptionThread2 implements Runnable {\n  public void run() {\n    Thread t = Thread.currentThread();\n    System.out.println(\"run() by \" + t);\n    System.out.println(\n      \"eh = \" + t.getUncaughtExceptionHandler());\n    throw new RuntimeException();\n  }\n}\n\n//创建一个uncaughtExceptionHandler\nclass MyUncaughtExceptionHandler implements\nThread.UncaughtExceptionHandler {\n  public void uncaughtException(Thread t, Throwable e) {\n    System.out.println(\"caught \" + e);\n  }\n}\n\nclass HandlerThreadFactory implements ThreadFactory {\n  public Thread newThread(Runnable r) {\n    System.out.println(this + \" creating new Thread\");\n    Thread t = new Thread(r);\n    System.out.println(\"created \" + t);\n    //设置uncaughtExceptionHandler\n    t.setUncaughtExceptionHandler(\n      new MyUncaughtExceptionHandler());\n    System.out.println(\n      \"eh = \" + t.getUncaughtExceptionHandler());\n    return t;\n  }\n}\n\npublic class CaptureUncaughtException {\n  public static void main(String[] args) {\n    ExecutorService exec = Executors.newCachedThreadPool(\n      new HandlerThreadFactory());\n    exec.execute(new ExceptionThread2());\n  }\n} \n```\n\n以上代码将输出：\n  HandlerThreadFactory@de6ced creating new Thread\n  created Thread[Thread-0,5,main]\n  eh = MyUncaughtExceptionHandler@1fb8ee3\n  run() by Thread[Thread-0,5,main]\n  eh = MyUncaughtExceptionHandler@1fb8ee3\n  caught java.lang.RuntimeException\n\n#### 线程安全性\n> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。\n\n- **无状态对象**: 无状态对象一定是线程安全的\n- **竞态条件**： 由于不恰当的执行时序而出现不正确的结果的情况，大多数竞态条件的本质是———基于一种可能失效的观察结果做出判断或执行某个计算，比如“先检查后执行”操作\n- **复合操作**： 包含了一组必须以原子方式执行的操作以确保线程安全性\n- **内置锁**：每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁\n  i.同步代码块分为两部分：一个作为锁的对象的引用，一个作为这个锁保护的代码块\n  ii. 对象锁：用来控制实例方法之间的同步，包括用synchronized修饰的方法和代码块均是对象锁\n  iii. 类锁： 即以Class对象作为锁，用来控制静态方法之间的同步，包括静态的synchronized方法\n- **重入**： 某个线程试图获得一个已经由它自己持有的锁，那么这个请求会成功\n\n----\n\n### 共享受限资源\n#### 解决共享资源竞争\n1.使用synchronized关键字\n2.使用显式的Lock对象\n示例：\n\n```java\npublic class MutexEvenGenerator extends IntGenerator {\n  private int currentEvenValue = 0;\n  private Lock lock = new ReentrantLock();\n  public int next() {\n    lock.lock();\n    try {\n      ++currentEvenValue;\n      Thread.yield(); \n      ++currentEvenValue;\n      return currentEvenValue;\n    } finally {\n      lock.unlock();\n    }\n  }\n  public static void main(String[] args) {\n    EvenChecker.test(new MutexEvenGenerator());\n  }\n}\n```\n\n- 对lock()的调用必须放置在finally语句中带有unlock()的try-finally语句中\n- return语句必须出现在try子句中，以确保unlock()不会过早发生\n- 这里finally子句也可以同时放置其他处理，以维护系统在正确的状态，避免抛出异常\n- `lock.trylock()`,ReentrantLock允许你尝试着获取但最终未获取锁，如果其他线程已经获取了这个锁，那可以离开去执行其他的任务\n\n#### 线程本地存储\n> 一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储\n\n----\n\n### 线程之间的协作\n#### wait(),notify(),notifyAll()\n> wait()使你将当前任务挂起，可以等待某个条件发生，而改变这个条件超出了当前方法的控制能力，通常这种条件由另一个任务来改变\n\n- 调用wait()时，对象上的锁被释放，该对象上的其他synchronized方法可以在wait()期间被调用；\n- 只有在notify()或notifyAll()发生时，调用wait()的任务才会被唤醒；\n- wait()，notify()，notifyAll()是Object()的一部分，所以可以把wait()放在任何同步控制方法中，不需要考虑是否继承Thread或实现Runnable;\n- 只能在同步控制方法或同步控制块里调用wait()，notify()，notifyAll()；\n- 为了使任务从wait()中唤醒，必须首先重新获得当它进入wait()时释放的锁；\n- 有两种形式的wait()：\n  i. 接受毫秒数作为参数，可以通过notify()，notifyAll()，或者时间到期后恢复\n  ii. 不接受任何参数，通过notify()，notifyAll()恢复\n\n- 使用notify()，众多等待同一个锁的任务中只有一个会被唤醒，必须保证被唤醒的任务是恰当的任务，而且所有任务必须等待相同的条件\n- notifyAll()将唤醒所有等待这个锁的任务\n\n----\n\n### 新类库中的构件\n#### CountDownLatch\n> **适用场景**：用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成\n\n- CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()方法都将阻塞，知道这个计数值到达0；\n- 其他任务结束时，可调用对象上的countDown()减小计数值\n- 计数值不能被重置（需要重置计数值可以用CyclicBarrier）\n\n#### CyclicBarrier\n> **适用场景**： 希望创建一组任务，他们并行地执行工作，然后在下一个步骤之前等待，直至所有任务都完成\n与CountDownLatch的区别\n- 可以重用\n- 可以向CyclicBarrier提供一个Runnable，当计数值到达0时自动执行\n\n#### DelayQueue\n> 一个无边界的BlockingQueue，用于放置实现了Delayed接口的对象，队列是有序的，对头对象的延迟到期的时间最长，对象只能在到期时才能取走\n\n#### PriorityBlockingQueue\n> 基础的优先级队列，具有可阻塞的读取操作\n\n#### ScheduleExecutor\n> 解决在预定时间运行的任务，使用schedule()（运行一次）或scheduleThreadFixedRate()（每隔规定的时间重复执行任务），可以将Runnable对象设置为将来的某个时刻执行\n\n#### Semaphore\n> 计数信号量，允许n个任务同时访问这个资源\n\n#### Exchanger\n> 应用于一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象，通过使用Exchanger，可以有更多的对象在创建的同时被消费\n\n\n\n","source":"_posts/Java并发.md","raw":"---\ntitle: Java并发\ndate: 2018-11-15 16:01:42\ncategories: \"JavaSE笔记\"\ntags:\n    - JavaSE\n    - Java并发\ncopyright:\n---\n\n### 基本的线程机制\n#### 定义一个线程\n- 实现Runnable接口，重写run()方法，并传递给Thread构造器\n- 继承Thread类，重写run()方法\n\n> 调用Thread.start()方法时，其实是创建一个线程，并初始化之后，再去调run()方法\n\n#### 使用Executor\n> Executor从来管理Thread对象，在客户端和任务之间提供了一个间接层，可以管理一部任务的执行，无须显式地管理线程的生命周期。ExecutorService（具有服务生命周期的Executor）知道如何构建恰当的上下文来执行Runnable对象\n\n有集中不同的Executor：\n- **CacheThreadPool**：通常创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程（首先的Executor）\n- **FixedThreadPool**：使用有限的线程集来执行所提交的任务，可以一次性预先执行代价高昂的线程分配\n- **SingleThreadPool**：像是线程数量为1的FixedThreadPool，当希望在另一个线程中连续运行某事物来说很有用。当提交多个任务时，这些任务会排队。\n示例（三种Executor都这样使用）：\n\n``` java\npublic class SingleThreadPool {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newSingleThreadPool();\n        for (int i = 0; i < 5; i++) {\n            exec.execute(new LiftOff());\n        }\n        exec.shutdown();\n    }\n}\n```\n\n#### 从任务中产生返回值\n> 实现Callable接口，从call（）方法中返回值，必须使用ExecutorService.submit()方法调用。submit()方法会产生Future对象。可以用isDone()方法来查询Future是否完成，完成时可以调用get()方法获取该结果，若完成就调用get()方法将阻塞到完成。\n\n\n```java\npublic class TaskWithResult implements Callable<String> {\n    private int id ;\n    public TaskWithResult(int id) {\n        this.id = id;\n    }\n    public String call() {\n        return \"result of TaskWithResult \" + id;\n    }\n}\n\npublic class CallableDemo {\n    public static void main(String[] args) {\n        ExecutorService exec = Executors.newCachedThreadPool();\n        ArrayList<Future<String>> results = new ArrayList<Future<String>>();\n        for (int i = 0; i < 5; i++) {\n            results.add(exec.submit(new TaskWithResult(i)));\n        }\n        for(Future<String> fs: results) {\n            try {\n                System.out.println(fs.get());\n            } catch {\n                System.out.printLn(e);\n                return;\n            } finally {\n                exce.shutdown();\n            }\n        }\n    }\n}\n```\n\n#### 休眠(sleep)\n> sleep(),使任务中止执行给定的时间，但不会释放持有的锁\n\n####  优先级\n> Java有十个优先级，但不同的操作系统有不同的优先级，不能与操作系统有很好的映射。在调整优先级时只是用MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY三个等级\n\n#### 让步(yield)\n> 暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。\n\n#### 加入一个线(join)\n> 某个线程在另一个线程t上个调用join()，此线程被挂起，知道目标线程t结束(即.isAlive()为假)才恢复，也可调用join()时带一个超时参数，超时便返回\n\n#### 后台线程(维护线程)\n- 可以在线程启动之前调用setDaemon()方法设置为后台线程\n- 一个后台进程创建的任何线程被自动地设置为后台线程\n- 后台线程在不执行finally子句时就终止器run()方法 \n\n#### 编码变体\n> 有时候可以使用内部类将代码隐藏在类中\n\n- 继承Thread的两种写法：\n1.扩展自Thread的匿名内部类\n\n``` java\nclass InnerThread1 {\n  private Inner inner;\n  private class Inner extends Thread {\n    Inner(String name) {\n      super(name);\n      start();\n    }\n    public void run() {\n        ......\n    }\n  }\n  public InnerThread1(String name) {\n    inner = new Inner(name);\n  }\n}\n```\n\n2.在构造器中穿件一个匿名的Thread子类，并且向上转型为Thread引用t\n\n``` java\nclass InnerThread2 {}\n  private Thread t;\n  public InnerThread2(String name) {\n    t = new Thread(name) {\n      public void run() {\n        ......\n      }\n    };\n    t.start();\n  }\n}\n```\n\n- 实现Runnable的两种写法（同上两种情况）\n\n```java\nclass InnerRunnable1 {\n    private Inner inner;\n    private class Inner implements Runnable {\n    Thread t;\n    Inner(String name) {\n      t = new Thread(this, name);\n      t.start();\n    }\n    public void run() {\n      ......\n    }\n  }\n  public InnerRunnable1(String name) {\n    inner = new Inner(name);\n  }\n}\n```\n\n```java\nclass InnerRunnable2 {\n  private Thread t;\n  public InnerRunnable2(String name) {\n    t = new Thread(new Runnable() {\n      public void run() {\n        ......\n    }, name);\n    t.start();\n  }\n}\n```\n\n- 在方法内部创建线程\n\n```java\nclass ThreadMethod {\n  private Thread t;\n  private String name;\n  public ThreadMethod(String name) { this.name = name; }\n  public void runTask() {\n    if(t == null) {\n      t = new Thread(name) {\n        public void run() {\n          ......\n        }\n      };\n      t.start();\n    }\n  }\n}\n```\n\n#### 捕获异常\n> 线程的本质特征使得我们態捕获从线程中逃逸的异常，而是直接向外传播到控制台，就算用try-catch语句也没有作用。因而要捕获异常，需要修改Executor产生线程的方式，为每个新创建的Thread附着一个Thread.UnCaughtExceptionHandler()，Thread.UnCaughtExceptionHandler.uncaughtException()会在线程因在线程因未捕获异常而临近死亡时被调用\n\n实例：\n\n```java\nclass ExceptionThread2 implements Runnable {\n  public void run() {\n    Thread t = Thread.currentThread();\n    System.out.println(\"run() by \" + t);\n    System.out.println(\n      \"eh = \" + t.getUncaughtExceptionHandler());\n    throw new RuntimeException();\n  }\n}\n\n//创建一个uncaughtExceptionHandler\nclass MyUncaughtExceptionHandler implements\nThread.UncaughtExceptionHandler {\n  public void uncaughtException(Thread t, Throwable e) {\n    System.out.println(\"caught \" + e);\n  }\n}\n\nclass HandlerThreadFactory implements ThreadFactory {\n  public Thread newThread(Runnable r) {\n    System.out.println(this + \" creating new Thread\");\n    Thread t = new Thread(r);\n    System.out.println(\"created \" + t);\n    //设置uncaughtExceptionHandler\n    t.setUncaughtExceptionHandler(\n      new MyUncaughtExceptionHandler());\n    System.out.println(\n      \"eh = \" + t.getUncaughtExceptionHandler());\n    return t;\n  }\n}\n\npublic class CaptureUncaughtException {\n  public static void main(String[] args) {\n    ExecutorService exec = Executors.newCachedThreadPool(\n      new HandlerThreadFactory());\n    exec.execute(new ExceptionThread2());\n  }\n} \n```\n\n以上代码将输出：\n  HandlerThreadFactory@de6ced creating new Thread\n  created Thread[Thread-0,5,main]\n  eh = MyUncaughtExceptionHandler@1fb8ee3\n  run() by Thread[Thread-0,5,main]\n  eh = MyUncaughtExceptionHandler@1fb8ee3\n  caught java.lang.RuntimeException\n\n#### 线程安全性\n> 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。\n\n- **无状态对象**: 无状态对象一定是线程安全的\n- **竞态条件**： 由于不恰当的执行时序而出现不正确的结果的情况，大多数竞态条件的本质是———基于一种可能失效的观察结果做出判断或执行某个计算，比如“先检查后执行”操作\n- **复合操作**： 包含了一组必须以原子方式执行的操作以确保线程安全性\n- **内置锁**：每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁\n  i.同步代码块分为两部分：一个作为锁的对象的引用，一个作为这个锁保护的代码块\n  ii. 对象锁：用来控制实例方法之间的同步，包括用synchronized修饰的方法和代码块均是对象锁\n  iii. 类锁： 即以Class对象作为锁，用来控制静态方法之间的同步，包括静态的synchronized方法\n- **重入**： 某个线程试图获得一个已经由它自己持有的锁，那么这个请求会成功\n\n----\n\n### 共享受限资源\n#### 解决共享资源竞争\n1.使用synchronized关键字\n2.使用显式的Lock对象\n示例：\n\n```java\npublic class MutexEvenGenerator extends IntGenerator {\n  private int currentEvenValue = 0;\n  private Lock lock = new ReentrantLock();\n  public int next() {\n    lock.lock();\n    try {\n      ++currentEvenValue;\n      Thread.yield(); \n      ++currentEvenValue;\n      return currentEvenValue;\n    } finally {\n      lock.unlock();\n    }\n  }\n  public static void main(String[] args) {\n    EvenChecker.test(new MutexEvenGenerator());\n  }\n}\n```\n\n- 对lock()的调用必须放置在finally语句中带有unlock()的try-finally语句中\n- return语句必须出现在try子句中，以确保unlock()不会过早发生\n- 这里finally子句也可以同时放置其他处理，以维护系统在正确的状态，避免抛出异常\n- `lock.trylock()`,ReentrantLock允许你尝试着获取但最终未获取锁，如果其他线程已经获取了这个锁，那可以离开去执行其他的任务\n\n#### 线程本地存储\n> 一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储\n\n----\n\n### 线程之间的协作\n#### wait(),notify(),notifyAll()\n> wait()使你将当前任务挂起，可以等待某个条件发生，而改变这个条件超出了当前方法的控制能力，通常这种条件由另一个任务来改变\n\n- 调用wait()时，对象上的锁被释放，该对象上的其他synchronized方法可以在wait()期间被调用；\n- 只有在notify()或notifyAll()发生时，调用wait()的任务才会被唤醒；\n- wait()，notify()，notifyAll()是Object()的一部分，所以可以把wait()放在任何同步控制方法中，不需要考虑是否继承Thread或实现Runnable;\n- 只能在同步控制方法或同步控制块里调用wait()，notify()，notifyAll()；\n- 为了使任务从wait()中唤醒，必须首先重新获得当它进入wait()时释放的锁；\n- 有两种形式的wait()：\n  i. 接受毫秒数作为参数，可以通过notify()，notifyAll()，或者时间到期后恢复\n  ii. 不接受任何参数，通过notify()，notifyAll()恢复\n\n- 使用notify()，众多等待同一个锁的任务中只有一个会被唤醒，必须保证被唤醒的任务是恰当的任务，而且所有任务必须等待相同的条件\n- notifyAll()将唤醒所有等待这个锁的任务\n\n----\n\n### 新类库中的构件\n#### CountDownLatch\n> **适用场景**：用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成\n\n- CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()方法都将阻塞，知道这个计数值到达0；\n- 其他任务结束时，可调用对象上的countDown()减小计数值\n- 计数值不能被重置（需要重置计数值可以用CyclicBarrier）\n\n#### CyclicBarrier\n> **适用场景**： 希望创建一组任务，他们并行地执行工作，然后在下一个步骤之前等待，直至所有任务都完成\n与CountDownLatch的区别\n- 可以重用\n- 可以向CyclicBarrier提供一个Runnable，当计数值到达0时自动执行\n\n#### DelayQueue\n> 一个无边界的BlockingQueue，用于放置实现了Delayed接口的对象，队列是有序的，对头对象的延迟到期的时间最长，对象只能在到期时才能取走\n\n#### PriorityBlockingQueue\n> 基础的优先级队列，具有可阻塞的读取操作\n\n#### ScheduleExecutor\n> 解决在预定时间运行的任务，使用schedule()（运行一次）或scheduleThreadFixedRate()（每隔规定的时间重复执行任务），可以将Runnable对象设置为将来的某个时刻执行\n\n#### Semaphore\n> 计数信号量，允许n个任务同时访问这个资源\n\n#### Exchanger\n> 应用于一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象，通过使用Exchanger，可以有更多的对象在创建的同时被消费\n\n\n\n","slug":"Java并发","published":1,"updated":"2018-11-22T11:23:16.458Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcs000cu7yj1xhywf8a","content":"<h3 id=\"基本的线程机制\"><a href=\"#基本的线程机制\" class=\"headerlink\" title=\"基本的线程机制\"></a>基本的线程机制</h3><h4 id=\"定义一个线程\"><a href=\"#定义一个线程\" class=\"headerlink\" title=\"定义一个线程\"></a>定义一个线程</h4><ul>\n<li>实现Runnable接口，重写run()方法，并传递给Thread构造器</li>\n<li>继承Thread类，重写run()方法</li>\n</ul>\n<blockquote>\n<p>调用Thread.start()方法时，其实是创建一个线程，并初始化之后，再去调run()方法</p>\n</blockquote>\n<h4 id=\"使用Executor\"><a href=\"#使用Executor\" class=\"headerlink\" title=\"使用Executor\"></a>使用Executor</h4><blockquote>\n<p>Executor从来管理Thread对象，在客户端和任务之间提供了一个间接层，可以管理一部任务的执行，无须显式地管理线程的生命周期。ExecutorService（具有服务生命周期的Executor）知道如何构建恰当的上下文来执行Runnable对象</p>\n</blockquote>\n<p>有集中不同的Executor：</p>\n<ul>\n<li><strong>CacheThreadPool</strong>：通常创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程（首先的Executor）</li>\n<li><strong>FixedThreadPool</strong>：使用有限的线程集来执行所提交的任务，可以一次性预先执行代价高昂的线程分配</li>\n<li><strong>SingleThreadPool</strong>：像是线程数量为1的FixedThreadPool，当希望在另一个线程中连续运行某事物来说很有用。当提交多个任务时，这些任务会排队。<br>示例（三种Executor都这样使用）：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newSingleThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> LiftOff());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"从任务中产生返回值\"><a href=\"#从任务中产生返回值\" class=\"headerlink\" title=\"从任务中产生返回值\"></a>从任务中产生返回值</h4><blockquote>\n<p>实现Callable接口，从call（）方法中返回值，必须使用ExecutorService.submit()方法调用。submit()方法会产生Future对象。可以用isDone()方法来查询Future是否完成，完成时可以调用get()方法获取该结果，若完成就调用get()方法将阻塞到完成。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskWithResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id ;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"result of TaskWithResult \"</span> + id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            results.add(exec.submit(<span class=\"keyword\">new</span> TaskWithResult(i)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Future&lt;String&gt; fs: results) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(fs.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">                System.out.printLn(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                exce.shutdown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"休眠-sleep\"><a href=\"#休眠-sleep\" class=\"headerlink\" title=\"休眠(sleep)\"></a>休眠(sleep)</h4><blockquote>\n<p>sleep(),使任务中止执行给定的时间，但不会释放持有的锁</p>\n</blockquote>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><blockquote>\n<p>Java有十个优先级，但不同的操作系统有不同的优先级，不能与操作系统有很好的映射。在调整优先级时只是用MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY三个等级</p>\n</blockquote>\n<h4 id=\"让步-yield\"><a href=\"#让步-yield\" class=\"headerlink\" title=\"让步(yield)\"></a>让步(yield)</h4><blockquote>\n<p>暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>\n</blockquote>\n<h4 id=\"加入一个线-join\"><a href=\"#加入一个线-join\" class=\"headerlink\" title=\"加入一个线(join)\"></a>加入一个线(join)</h4><blockquote>\n<p>某个线程在另一个线程t上个调用join()，此线程被挂起，知道目标线程t结束(即.isAlive()为假)才恢复，也可调用join()时带一个超时参数，超时便返回</p>\n</blockquote>\n<h4 id=\"后台线程-维护线程\"><a href=\"#后台线程-维护线程\" class=\"headerlink\" title=\"后台线程(维护线程)\"></a>后台线程(维护线程)</h4><ul>\n<li>可以在线程启动之前调用setDaemon()方法设置为后台线程</li>\n<li>一个后台进程创建的任何线程被自动地设置为后台线程</li>\n<li>后台线程在不执行finally子句时就终止器run()方法 </li>\n</ul>\n<h4 id=\"编码变体\"><a href=\"#编码变体\" class=\"headerlink\" title=\"编码变体\"></a>编码变体</h4><blockquote>\n<p>有时候可以使用内部类将代码隐藏在类中</p>\n</blockquote>\n<ul>\n<li>继承Thread的两种写法：<br>1.扩展自Thread的匿名内部类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerThread1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Inner inner;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    Inner(String name) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">      start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerThread1</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    inner = <span class=\"keyword\">new</span> Inner(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.在构造器中穿件一个匿名的Thread子类，并且向上转型为Thread引用t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerThread2</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerThread2</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    t = <span class=\"keyword\">new</span> Thread(name) &#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现Runnable的两种写法（同上两种情况）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerRunnable1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Inner inner;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    Thread t;</span><br><span class=\"line\">    Inner(String name) &#123;</span><br><span class=\"line\">      t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerRunnable1</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    inner = <span class=\"keyword\">new</span> Inner(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerRunnable2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerRunnable2</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;, name);</span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在方法内部创建线程</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadMethod</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadMethod</span><span class=\"params\">(String name)</span> </span>&#123; <span class=\"keyword\">this</span>.name = name; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      t = <span class=\"keyword\">new</span> Thread(name) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h4><blockquote>\n<p>线程的本质特征使得我们態捕获从线程中逃逸的异常，而是直接向外传播到控制台，就算用try-catch语句也没有作用。因而要捕获异常，需要修改Executor产生线程的方式，为每个新创建的Thread附着一个Thread.UnCaughtExceptionHandler()，Thread.UnCaughtExceptionHandler.uncaughtException()会在线程因在线程因未捕获异常而临近死亡时被调用</p>\n</blockquote>\n<p>实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionThread2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"run() by \"</span> + t);</span><br><span class=\"line\">    System.out.println(</span><br><span class=\"line\">      <span class=\"string\">\"eh = \"</span> + t.getUncaughtExceptionHandler());</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个uncaughtExceptionHandler</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUncaughtExceptionHandler</span> <span class=\"keyword\">implements</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Thread</span>.<span class=\"title\">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">uncaughtException</span><span class=\"params\">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"caught \"</span> + e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"keyword\">this</span> + <span class=\"string\">\" creating new Thread\"</span>);</span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"created \"</span> + t);</span><br><span class=\"line\">    <span class=\"comment\">//设置uncaughtExceptionHandler</span></span><br><span class=\"line\">    t.setUncaughtExceptionHandler(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> MyUncaughtExceptionHandler());</span><br><span class=\"line\">    System.out.println(</span><br><span class=\"line\">      <span class=\"string\">\"eh = \"</span> + t.getUncaughtExceptionHandler());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaptureUncaughtException</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService exec = Executors.newCachedThreadPool(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> HandlerThreadFactory());</span><br><span class=\"line\">    exec.execute(<span class=\"keyword\">new</span> ExceptionThread2());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码将输出：<br>  HandlerThreadFactory@de6ced creating new Thread<br>  created Thread[Thread-0,5,main]<br>  eh = MyUncaughtExceptionHandler@1fb8ee3<br>  run() by Thread[Thread-0,5,main]<br>  eh = MyUncaughtExceptionHandler@1fb8ee3<br>  caught java.lang.RuntimeException</p>\n<h4 id=\"线程安全性\"><a href=\"#线程安全性\" class=\"headerlink\" title=\"线程安全性\"></a>线程安全性</h4><blockquote>\n<p>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。</p>\n</blockquote>\n<ul>\n<li><strong>无状态对象</strong>: 无状态对象一定是线程安全的</li>\n<li><strong>竞态条件</strong>： 由于不恰当的执行时序而出现不正确的结果的情况，大多数竞态条件的本质是———基于一种可能失效的观察结果做出判断或执行某个计算，比如“先检查后执行”操作</li>\n<li><strong>复合操作</strong>： 包含了一组必须以原子方式执行的操作以确保线程安全性</li>\n<li><strong>内置锁</strong>：每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁<br>i.同步代码块分为两部分：一个作为锁的对象的引用，一个作为这个锁保护的代码块<br>ii. 对象锁：用来控制实例方法之间的同步，包括用synchronized修饰的方法和代码块均是对象锁<br>iii. 类锁： 即以Class对象作为锁，用来控制静态方法之间的同步，包括静态的synchronized方法</li>\n<li><strong>重入</strong>： 某个线程试图获得一个已经由它自己持有的锁，那么这个请求会成功</li>\n</ul>\n<hr>\n<h3 id=\"共享受限资源\"><a href=\"#共享受限资源\" class=\"headerlink\" title=\"共享受限资源\"></a>共享受限资源</h3><h4 id=\"解决共享资源竞争\"><a href=\"#解决共享资源竞争\" class=\"headerlink\" title=\"解决共享资源竞争\"></a>解决共享资源竞争</h4><p>1.使用synchronized关键字<br>2.使用显式的Lock对象<br>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MutexEvenGenerator</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntGenerator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentEvenValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ++currentEvenValue;</span><br><span class=\"line\">      Thread.yield(); </span><br><span class=\"line\">      ++currentEvenValue;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentEvenValue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    EvenChecker.test(<span class=\"keyword\">new</span> MutexEvenGenerator());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对lock()的调用必须放置在finally语句中带有unlock()的try-finally语句中</li>\n<li>return语句必须出现在try子句中，以确保unlock()不会过早发生</li>\n<li>这里finally子句也可以同时放置其他处理，以维护系统在正确的状态，避免抛出异常</li>\n<li><code>lock.trylock()</code>,ReentrantLock允许你尝试着获取但最终未获取锁，如果其他线程已经获取了这个锁，那可以离开去执行其他的任务</li>\n</ul>\n<h4 id=\"线程本地存储\"><a href=\"#线程本地存储\" class=\"headerlink\" title=\"线程本地存储\"></a>线程本地存储</h4><blockquote>\n<p>一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储</p>\n</blockquote>\n<hr>\n<h3 id=\"线程之间的协作\"><a href=\"#线程之间的协作\" class=\"headerlink\" title=\"线程之间的协作\"></a>线程之间的协作</h3><h4 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait(),notify(),notifyAll()\"></a>wait(),notify(),notifyAll()</h4><blockquote>\n<p>wait()使你将当前任务挂起，可以等待某个条件发生，而改变这个条件超出了当前方法的控制能力，通常这种条件由另一个任务来改变</p>\n</blockquote>\n<ul>\n<li>调用wait()时，对象上的锁被释放，该对象上的其他synchronized方法可以在wait()期间被调用；</li>\n<li>只有在notify()或notifyAll()发生时，调用wait()的任务才会被唤醒；</li>\n<li>wait()，notify()，notifyAll()是Object()的一部分，所以可以把wait()放在任何同步控制方法中，不需要考虑是否继承Thread或实现Runnable;</li>\n<li>只能在同步控制方法或同步控制块里调用wait()，notify()，notifyAll()；</li>\n<li>为了使任务从wait()中唤醒，必须首先重新获得当它进入wait()时释放的锁；</li>\n<li><p>有两种形式的wait()：<br>i. 接受毫秒数作为参数，可以通过notify()，notifyAll()，或者时间到期后恢复<br>ii. 不接受任何参数，通过notify()，notifyAll()恢复</p>\n</li>\n<li><p>使用notify()，众多等待同一个锁的任务中只有一个会被唤醒，必须保证被唤醒的任务是恰当的任务，而且所有任务必须等待相同的条件</p>\n</li>\n<li>notifyAll()将唤醒所有等待这个锁的任务</li>\n</ul>\n<hr>\n<h3 id=\"新类库中的构件\"><a href=\"#新类库中的构件\" class=\"headerlink\" title=\"新类库中的构件\"></a>新类库中的构件</h3><h4 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h4><blockquote>\n<p><strong>适用场景</strong>：用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成</p>\n</blockquote>\n<ul>\n<li>CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()方法都将阻塞，知道这个计数值到达0；</li>\n<li>其他任务结束时，可调用对象上的countDown()减小计数值</li>\n<li>计数值不能被重置（需要重置计数值可以用CyclicBarrier）</li>\n</ul>\n<h4 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h4><blockquote>\n<p><strong>适用场景</strong>： 希望创建一组任务，他们并行地执行工作，然后在下一个步骤之前等待，直至所有任务都完成<br>与CountDownLatch的区别</p>\n<ul>\n<li>可以重用</li>\n<li>可以向CyclicBarrier提供一个Runnable，当计数值到达0时自动执行</li>\n</ul>\n</blockquote>\n<h4 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h4><blockquote>\n<p>一个无边界的BlockingQueue，用于放置实现了Delayed接口的对象，队列是有序的，对头对象的延迟到期的时间最长，对象只能在到期时才能取走</p>\n</blockquote>\n<h4 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h4><blockquote>\n<p>基础的优先级队列，具有可阻塞的读取操作</p>\n</blockquote>\n<h4 id=\"ScheduleExecutor\"><a href=\"#ScheduleExecutor\" class=\"headerlink\" title=\"ScheduleExecutor\"></a>ScheduleExecutor</h4><blockquote>\n<p>解决在预定时间运行的任务，使用schedule()（运行一次）或scheduleThreadFixedRate()（每隔规定的时间重复执行任务），可以将Runnable对象设置为将来的某个时刻执行</p>\n</blockquote>\n<h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><blockquote>\n<p>计数信号量，允许n个任务同时访问这个资源</p>\n</blockquote>\n<h4 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h4><blockquote>\n<p>应用于一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象，通过使用Exchanger，可以有更多的对象在创建的同时被消费</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本的线程机制\"><a href=\"#基本的线程机制\" class=\"headerlink\" title=\"基本的线程机制\"></a>基本的线程机制</h3><h4 id=\"定义一个线程\"><a href=\"#定义一个线程\" class=\"headerlink\" title=\"定义一个线程\"></a>定义一个线程</h4><ul>\n<li>实现Runnable接口，重写run()方法，并传递给Thread构造器</li>\n<li>继承Thread类，重写run()方法</li>\n</ul>\n<blockquote>\n<p>调用Thread.start()方法时，其实是创建一个线程，并初始化之后，再去调run()方法</p>\n</blockquote>\n<h4 id=\"使用Executor\"><a href=\"#使用Executor\" class=\"headerlink\" title=\"使用Executor\"></a>使用Executor</h4><blockquote>\n<p>Executor从来管理Thread对象，在客户端和任务之间提供了一个间接层，可以管理一部任务的执行，无须显式地管理线程的生命周期。ExecutorService（具有服务生命周期的Executor）知道如何构建恰当的上下文来执行Runnable对象</p>\n</blockquote>\n<p>有集中不同的Executor：</p>\n<ul>\n<li><strong>CacheThreadPool</strong>：通常创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程（首先的Executor）</li>\n<li><strong>FixedThreadPool</strong>：使用有限的线程集来执行所提交的任务，可以一次性预先执行代价高昂的线程分配</li>\n<li><strong>SingleThreadPool</strong>：像是线程数量为1的FixedThreadPool，当希望在另一个线程中连续运行某事物来说很有用。当提交多个任务时，这些任务会排队。<br>示例（三种Executor都这样使用）：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newSingleThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            exec.execute(<span class=\"keyword\">new</span> LiftOff());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exec.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"从任务中产生返回值\"><a href=\"#从任务中产生返回值\" class=\"headerlink\" title=\"从任务中产生返回值\"></a>从任务中产生返回值</h4><blockquote>\n<p>实现Callable接口，从call（）方法中返回值，必须使用ExecutorService.submit()方法调用。submit()方法会产生Future对象。可以用isDone()方法来查询Future是否完成，完成时可以调用get()方法获取该结果，若完成就调用get()方法将阻塞到完成。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskWithResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id ;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskWithResult</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"result of TaskWithResult \"</span> + id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class=\"line\">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            results.add(exec.submit(<span class=\"keyword\">new</span> TaskWithResult(i)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Future&lt;String&gt; fs: results) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(fs.get());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">                System.out.printLn(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                exce.shutdown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"休眠-sleep\"><a href=\"#休眠-sleep\" class=\"headerlink\" title=\"休眠(sleep)\"></a>休眠(sleep)</h4><blockquote>\n<p>sleep(),使任务中止执行给定的时间，但不会释放持有的锁</p>\n</blockquote>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><blockquote>\n<p>Java有十个优先级，但不同的操作系统有不同的优先级，不能与操作系统有很好的映射。在调整优先级时只是用MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY三个等级</p>\n</blockquote>\n<h4 id=\"让步-yield\"><a href=\"#让步-yield\" class=\"headerlink\" title=\"让步(yield)\"></a>让步(yield)</h4><blockquote>\n<p>暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>\n</blockquote>\n<h4 id=\"加入一个线-join\"><a href=\"#加入一个线-join\" class=\"headerlink\" title=\"加入一个线(join)\"></a>加入一个线(join)</h4><blockquote>\n<p>某个线程在另一个线程t上个调用join()，此线程被挂起，知道目标线程t结束(即.isAlive()为假)才恢复，也可调用join()时带一个超时参数，超时便返回</p>\n</blockquote>\n<h4 id=\"后台线程-维护线程\"><a href=\"#后台线程-维护线程\" class=\"headerlink\" title=\"后台线程(维护线程)\"></a>后台线程(维护线程)</h4><ul>\n<li>可以在线程启动之前调用setDaemon()方法设置为后台线程</li>\n<li>一个后台进程创建的任何线程被自动地设置为后台线程</li>\n<li>后台线程在不执行finally子句时就终止器run()方法 </li>\n</ul>\n<h4 id=\"编码变体\"><a href=\"#编码变体\" class=\"headerlink\" title=\"编码变体\"></a>编码变体</h4><blockquote>\n<p>有时候可以使用内部类将代码隐藏在类中</p>\n</blockquote>\n<ul>\n<li>继承Thread的两种写法：<br>1.扩展自Thread的匿名内部类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerThread1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Inner inner;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    Inner(String name) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">      start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerThread1</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    inner = <span class=\"keyword\">new</span> Inner(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.在构造器中穿件一个匿名的Thread子类，并且向上转型为Thread引用t</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerThread2</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerThread2</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    t = <span class=\"keyword\">new</span> Thread(name) &#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现Runnable的两种写法（同上两种情况）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerRunnable1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Inner inner;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    Thread t;</span><br><span class=\"line\">    Inner(String name) &#123;</span><br><span class=\"line\">      t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerRunnable1</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    inner = <span class=\"keyword\">new</span> Inner(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerRunnable2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerRunnable2</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;, name);</span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在方法内部创建线程</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadMethod</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Thread t;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadMethod</span><span class=\"params\">(String name)</span> </span>&#123; <span class=\"keyword\">this</span>.name = name; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      t = <span class=\"keyword\">new</span> Thread(name) &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h4><blockquote>\n<p>线程的本质特征使得我们態捕获从线程中逃逸的异常，而是直接向外传播到控制台，就算用try-catch语句也没有作用。因而要捕获异常，需要修改Executor产生线程的方式，为每个新创建的Thread附着一个Thread.UnCaughtExceptionHandler()，Thread.UnCaughtExceptionHandler.uncaughtException()会在线程因在线程因未捕获异常而临近死亡时被调用</p>\n</blockquote>\n<p>实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionThread2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"run() by \"</span> + t);</span><br><span class=\"line\">    System.out.println(</span><br><span class=\"line\">      <span class=\"string\">\"eh = \"</span> + t.getUncaughtExceptionHandler());</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个uncaughtExceptionHandler</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUncaughtExceptionHandler</span> <span class=\"keyword\">implements</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Thread</span>.<span class=\"title\">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">uncaughtException</span><span class=\"params\">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"caught \"</span> + e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"keyword\">this</span> + <span class=\"string\">\" creating new Thread\"</span>);</span><br><span class=\"line\">    Thread t = <span class=\"keyword\">new</span> Thread(r);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"created \"</span> + t);</span><br><span class=\"line\">    <span class=\"comment\">//设置uncaughtExceptionHandler</span></span><br><span class=\"line\">    t.setUncaughtExceptionHandler(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> MyUncaughtExceptionHandler());</span><br><span class=\"line\">    System.out.println(</span><br><span class=\"line\">      <span class=\"string\">\"eh = \"</span> + t.getUncaughtExceptionHandler());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CaptureUncaughtException</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService exec = Executors.newCachedThreadPool(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> HandlerThreadFactory());</span><br><span class=\"line\">    exec.execute(<span class=\"keyword\">new</span> ExceptionThread2());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码将输出：<br>  HandlerThreadFactory@de6ced creating new Thread<br>  created Thread[Thread-0,5,main]<br>  eh = MyUncaughtExceptionHandler@1fb8ee3<br>  run() by Thread[Thread-0,5,main]<br>  eh = MyUncaughtExceptionHandler@1fb8ee3<br>  caught java.lang.RuntimeException</p>\n<h4 id=\"线程安全性\"><a href=\"#线程安全性\" class=\"headerlink\" title=\"线程安全性\"></a>线程安全性</h4><blockquote>\n<p>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么称这个类是线程安全的。</p>\n</blockquote>\n<ul>\n<li><strong>无状态对象</strong>: 无状态对象一定是线程安全的</li>\n<li><strong>竞态条件</strong>： 由于不恰当的执行时序而出现不正确的结果的情况，大多数竞态条件的本质是———基于一种可能失效的观察结果做出判断或执行某个计算，比如“先检查后执行”操作</li>\n<li><strong>复合操作</strong>： 包含了一组必须以原子方式执行的操作以确保线程安全性</li>\n<li><strong>内置锁</strong>：每个Java对象都可以用作一个实现同步的锁，这些锁称为内置锁<br>i.同步代码块分为两部分：一个作为锁的对象的引用，一个作为这个锁保护的代码块<br>ii. 对象锁：用来控制实例方法之间的同步，包括用synchronized修饰的方法和代码块均是对象锁<br>iii. 类锁： 即以Class对象作为锁，用来控制静态方法之间的同步，包括静态的synchronized方法</li>\n<li><strong>重入</strong>： 某个线程试图获得一个已经由它自己持有的锁，那么这个请求会成功</li>\n</ul>\n<hr>\n<h3 id=\"共享受限资源\"><a href=\"#共享受限资源\" class=\"headerlink\" title=\"共享受限资源\"></a>共享受限资源</h3><h4 id=\"解决共享资源竞争\"><a href=\"#解决共享资源竞争\" class=\"headerlink\" title=\"解决共享资源竞争\"></a>解决共享资源竞争</h4><p>1.使用synchronized关键字<br>2.使用显式的Lock对象<br>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MutexEvenGenerator</span> <span class=\"keyword\">extends</span> <span class=\"title\">IntGenerator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> currentEvenValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      ++currentEvenValue;</span><br><span class=\"line\">      Thread.yield(); </span><br><span class=\"line\">      ++currentEvenValue;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentEvenValue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    EvenChecker.test(<span class=\"keyword\">new</span> MutexEvenGenerator());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对lock()的调用必须放置在finally语句中带有unlock()的try-finally语句中</li>\n<li>return语句必须出现在try子句中，以确保unlock()不会过早发生</li>\n<li>这里finally子句也可以同时放置其他处理，以维护系统在正确的状态，避免抛出异常</li>\n<li><code>lock.trylock()</code>,ReentrantLock允许你尝试着获取但最终未获取锁，如果其他线程已经获取了这个锁，那可以离开去执行其他的任务</li>\n</ul>\n<h4 id=\"线程本地存储\"><a href=\"#线程本地存储\" class=\"headerlink\" title=\"线程本地存储\"></a>线程本地存储</h4><blockquote>\n<p>一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储</p>\n</blockquote>\n<hr>\n<h3 id=\"线程之间的协作\"><a href=\"#线程之间的协作\" class=\"headerlink\" title=\"线程之间的协作\"></a>线程之间的协作</h3><h4 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait(),notify(),notifyAll()\"></a>wait(),notify(),notifyAll()</h4><blockquote>\n<p>wait()使你将当前任务挂起，可以等待某个条件发生，而改变这个条件超出了当前方法的控制能力，通常这种条件由另一个任务来改变</p>\n</blockquote>\n<ul>\n<li>调用wait()时，对象上的锁被释放，该对象上的其他synchronized方法可以在wait()期间被调用；</li>\n<li>只有在notify()或notifyAll()发生时，调用wait()的任务才会被唤醒；</li>\n<li>wait()，notify()，notifyAll()是Object()的一部分，所以可以把wait()放在任何同步控制方法中，不需要考虑是否继承Thread或实现Runnable;</li>\n<li>只能在同步控制方法或同步控制块里调用wait()，notify()，notifyAll()；</li>\n<li>为了使任务从wait()中唤醒，必须首先重新获得当它进入wait()时释放的锁；</li>\n<li><p>有两种形式的wait()：<br>i. 接受毫秒数作为参数，可以通过notify()，notifyAll()，或者时间到期后恢复<br>ii. 不接受任何参数，通过notify()，notifyAll()恢复</p>\n</li>\n<li><p>使用notify()，众多等待同一个锁的任务中只有一个会被唤醒，必须保证被唤醒的任务是恰当的任务，而且所有任务必须等待相同的条件</p>\n</li>\n<li>notifyAll()将唤醒所有等待这个锁的任务</li>\n</ul>\n<hr>\n<h3 id=\"新类库中的构件\"><a href=\"#新类库中的构件\" class=\"headerlink\" title=\"新类库中的构件\"></a>新类库中的构件</h3><h4 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h4><blockquote>\n<p><strong>适用场景</strong>：用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成</p>\n</blockquote>\n<ul>\n<li>CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()方法都将阻塞，知道这个计数值到达0；</li>\n<li>其他任务结束时，可调用对象上的countDown()减小计数值</li>\n<li>计数值不能被重置（需要重置计数值可以用CyclicBarrier）</li>\n</ul>\n<h4 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h4><blockquote>\n<p><strong>适用场景</strong>： 希望创建一组任务，他们并行地执行工作，然后在下一个步骤之前等待，直至所有任务都完成<br>与CountDownLatch的区别</p>\n<ul>\n<li>可以重用</li>\n<li>可以向CyclicBarrier提供一个Runnable，当计数值到达0时自动执行</li>\n</ul>\n</blockquote>\n<h4 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h4><blockquote>\n<p>一个无边界的BlockingQueue，用于放置实现了Delayed接口的对象，队列是有序的，对头对象的延迟到期的时间最长，对象只能在到期时才能取走</p>\n</blockquote>\n<h4 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h4><blockquote>\n<p>基础的优先级队列，具有可阻塞的读取操作</p>\n</blockquote>\n<h4 id=\"ScheduleExecutor\"><a href=\"#ScheduleExecutor\" class=\"headerlink\" title=\"ScheduleExecutor\"></a>ScheduleExecutor</h4><blockquote>\n<p>解决在预定时间运行的任务，使用schedule()（运行一次）或scheduleThreadFixedRate()（每隔规定的时间重复执行任务），可以将Runnable对象设置为将来的某个时刻执行</p>\n</blockquote>\n<h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><blockquote>\n<p>计数信号量，允许n个任务同时访问这个资源</p>\n</blockquote>\n<h4 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h4><blockquote>\n<p>应用于一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象，通过使用Exchanger，可以有更多的对象在创建的同时被消费</p>\n</blockquote>\n"},{"title":"Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J","date":"2018-07-30T04:17:44.000Z","copyright":null,"_content":"现有以下XML文档books.xml,下面的示例生成此文档部分内容\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\t<book id=\"1\">\n\t\t<name>冰与火之歌</name>\n\t\t<author>乔治马丁</author>\n\t\t<year>2014</year>\n\t\t<price>89</price>\n\t</book>\n\t<book id=\"2\">\n\t\t<name>安徒生童话</name>\n\t\t<year>2004</year>\n\t\t<price>77</price>\n\t\t<language>English</language>\n\t</book>\n</bookstore>\n```\n### DOM\n1、创建DocumentBuilder对象\n```java\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\n```\n2、添加节点\n```java\ndocument.setXmlStandalone(true);\nElement bookstore = document.createElement(\"bookStore\");\n//向bookstore根节点中添加子节点book\nElement book = document.createElement(\"book\");\nElement name = document.createElement(\"name\");\nname.setTextContent(\"???\");\n\nbook.appendChild(name);\nbook.setAttribute(\"id\", \"1\");\n//将book节点添加到bookstore根节点中\nbookstore.appendChild(book);\n//将bookstore节点（已经包含了book）添加到dom树中\ndocument.appendChild(bookstore);\n```\n3、生成xml文件\n```java\nTransformerFactory tff = TransformerFactory.newInstance();\nTransformer tf = tff.newTransformer();\n//设置文件\ntf.setOutputProperty(OutputKeys.INDENT, \"yes\");\ntf.transform(new DOMSource(document),new StreamResult(new File(\"books1.xml\")));\n```\n----\n### SAX\n1、创建一个TransformerFactory类的对象\n```java\nSAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance();\n```\n2、通过SAXTransformerFactory对象创建一个TransformerHandler对象\n```java\nTransformerHandler handler = tff.newTransformerHandler();\n```\n3、通过handler对象创建一个Transformer对象\n```java\nTransformer tr = handler.getTransformer();\n```\n4、通过Transformer对象对生成的xml文件进行设置\n```\n// 设置xml的编码\ntr.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n// 设置xml的“是否换行”\ntr.setOutputProperty(OutputKeys.INDENT, \"yes\");\n5、创建一个Result对象\n```java\nFile f = new File(\"newbooks.xml\");\nif (!f.exists()) {\n    f.createNewFile();\n}\n```\n6、创建Result对象，并且使其与handler关联\n```java\nResult result = new StreamResult(new FileOutputStream(f));\nhandler.setResult(result);\n```\n7、利用handler对象进行xml文件内容的编写O\n```java\n// 打开document\nhandler.startDocument();\n```\n8、添加节点属性和节点值\n```java\nAttributesImpl attr = new AttributesImpl();\nhandler.startElement(\"\", \"\", \"bookstore\", attr);\nfor (Book book : bookList) {\n    attr.clear();\n    attr.addAttribute(\"\", \"\", \"id\", \"\", book.getId());\n    handler.startElement(\"\", \"\", \"book\", attr);\n    // 创建name节点\n    if (book.getName() != null && !book.getName().trim().equals(\"\")) {\n        attr.clear();\n        handler.startElement(\"\", \"\", \"name\", attr);\n        handler.characters(book.getName().toCharArray(), 0, book\n                .getName().length());\n        handler.endElement(\"\", \"\", \"name\");\n    }\n    handler.endElement(\"\", \"\", \"book\");\n}\nhandler.endElement(\"\", \"\", \"bookstore\");\n// 关闭document\nhandler.endDocument();\n```\n----\n### JDOM\n1.生成一个根节点\n```java\nElement rss = new Element(\"rss\");\n```\n2.为节点添加属性\n```java\nrss.setAttribute(\"version\", \"2.0\");\n```\n3.生成一个document对象\n```java\nDocument document = new Document(rss);\nElement channel = new Element(\"channel\");\nrss.addContent(channel);\nElement title = new Element(\"title\");\ntitle.setText(\"<![CDATA[上海移动互联网产业促进中心正式揭牌 ]]>\");\nchannel.addContent(title);\n//设置文件编码和换行\nFormat format = Format.getCompactFormat();\nformat.setIndent(\"\");\nformat.setEncoding(\"GBK\");\n```\n4.创建XMLOutputter的对象\n```java\nXMLOutputter outputer = new XMLOutputter(format);\n```\n5.利用outputer将document对象转换成xml文档\n```java\noutputer.output(document, new FileOutputStream(new File(\"rssnews.xml\")));\n```\n----\n### DOM4J\n\n>使用DOM4J生成RSS文件\n\n1.创建document对象，代表整个xml文档\n```java\nDocument document = DocumentHelper.createDocument();\n```\n2.创建根节点rss\n```java\nElement rss = document.addElement(\"rss\");\n```\n3.向rss节点中添加version属性\n```java\nrss.addAttribute(\"version\", \"2.0\");\n```\n4.生成子节点及节点内容\n```java\nElement channel = rss.addElement(\"channel\");\nElement title = channel.addElement(\"title\");\ntitle.setText(\"<![CDATA[上海移动互联网产业促进中心正式揭牌 ]]>\");\n```\n5.设置生成xml的格式\n```java\nOutputFormat format = OutputFormat.createPrettyPrint();\nformat.setEncoding(\"GBK\");\n```\n6.生成xml文件\n```java\nFile file = new File(\"rssnews.xml\");\nXMLWriter writer;\nwriter = new XMLWriter(new FileOutputStream(file), format);\n//设置是否转义，默认值是true，代表转义\nwriter.setEscapeText(false);\nwriter.write(document);\nwriter.close();\n```\n\n> 参阅：\n  [慕课网：Java眼中的XML---文件读取](https://www.imooc.com/learn/171)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)","source":"_posts/Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J.md","raw":"---\ntitle: Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J\ndate: 2018-07-30 12:17:44\ncategories: \"JavaSE笔记\"\ntags:\n    - JavaSE\n    - XML\ncopyright:\n---\n现有以下XML文档books.xml,下面的示例生成此文档部分内容\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\t<book id=\"1\">\n\t\t<name>冰与火之歌</name>\n\t\t<author>乔治马丁</author>\n\t\t<year>2014</year>\n\t\t<price>89</price>\n\t</book>\n\t<book id=\"2\">\n\t\t<name>安徒生童话</name>\n\t\t<year>2004</year>\n\t\t<price>77</price>\n\t\t<language>English</language>\n\t</book>\n</bookstore>\n```\n### DOM\n1、创建DocumentBuilder对象\n```java\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\n```\n2、添加节点\n```java\ndocument.setXmlStandalone(true);\nElement bookstore = document.createElement(\"bookStore\");\n//向bookstore根节点中添加子节点book\nElement book = document.createElement(\"book\");\nElement name = document.createElement(\"name\");\nname.setTextContent(\"???\");\n\nbook.appendChild(name);\nbook.setAttribute(\"id\", \"1\");\n//将book节点添加到bookstore根节点中\nbookstore.appendChild(book);\n//将bookstore节点（已经包含了book）添加到dom树中\ndocument.appendChild(bookstore);\n```\n3、生成xml文件\n```java\nTransformerFactory tff = TransformerFactory.newInstance();\nTransformer tf = tff.newTransformer();\n//设置文件\ntf.setOutputProperty(OutputKeys.INDENT, \"yes\");\ntf.transform(new DOMSource(document),new StreamResult(new File(\"books1.xml\")));\n```\n----\n### SAX\n1、创建一个TransformerFactory类的对象\n```java\nSAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance();\n```\n2、通过SAXTransformerFactory对象创建一个TransformerHandler对象\n```java\nTransformerHandler handler = tff.newTransformerHandler();\n```\n3、通过handler对象创建一个Transformer对象\n```java\nTransformer tr = handler.getTransformer();\n```\n4、通过Transformer对象对生成的xml文件进行设置\n```\n// 设置xml的编码\ntr.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n// 设置xml的“是否换行”\ntr.setOutputProperty(OutputKeys.INDENT, \"yes\");\n5、创建一个Result对象\n```java\nFile f = new File(\"newbooks.xml\");\nif (!f.exists()) {\n    f.createNewFile();\n}\n```\n6、创建Result对象，并且使其与handler关联\n```java\nResult result = new StreamResult(new FileOutputStream(f));\nhandler.setResult(result);\n```\n7、利用handler对象进行xml文件内容的编写O\n```java\n// 打开document\nhandler.startDocument();\n```\n8、添加节点属性和节点值\n```java\nAttributesImpl attr = new AttributesImpl();\nhandler.startElement(\"\", \"\", \"bookstore\", attr);\nfor (Book book : bookList) {\n    attr.clear();\n    attr.addAttribute(\"\", \"\", \"id\", \"\", book.getId());\n    handler.startElement(\"\", \"\", \"book\", attr);\n    // 创建name节点\n    if (book.getName() != null && !book.getName().trim().equals(\"\")) {\n        attr.clear();\n        handler.startElement(\"\", \"\", \"name\", attr);\n        handler.characters(book.getName().toCharArray(), 0, book\n                .getName().length());\n        handler.endElement(\"\", \"\", \"name\");\n    }\n    handler.endElement(\"\", \"\", \"book\");\n}\nhandler.endElement(\"\", \"\", \"bookstore\");\n// 关闭document\nhandler.endDocument();\n```\n----\n### JDOM\n1.生成一个根节点\n```java\nElement rss = new Element(\"rss\");\n```\n2.为节点添加属性\n```java\nrss.setAttribute(\"version\", \"2.0\");\n```\n3.生成一个document对象\n```java\nDocument document = new Document(rss);\nElement channel = new Element(\"channel\");\nrss.addContent(channel);\nElement title = new Element(\"title\");\ntitle.setText(\"<![CDATA[上海移动互联网产业促进中心正式揭牌 ]]>\");\nchannel.addContent(title);\n//设置文件编码和换行\nFormat format = Format.getCompactFormat();\nformat.setIndent(\"\");\nformat.setEncoding(\"GBK\");\n```\n4.创建XMLOutputter的对象\n```java\nXMLOutputter outputer = new XMLOutputter(format);\n```\n5.利用outputer将document对象转换成xml文档\n```java\noutputer.output(document, new FileOutputStream(new File(\"rssnews.xml\")));\n```\n----\n### DOM4J\n\n>使用DOM4J生成RSS文件\n\n1.创建document对象，代表整个xml文档\n```java\nDocument document = DocumentHelper.createDocument();\n```\n2.创建根节点rss\n```java\nElement rss = document.addElement(\"rss\");\n```\n3.向rss节点中添加version属性\n```java\nrss.addAttribute(\"version\", \"2.0\");\n```\n4.生成子节点及节点内容\n```java\nElement channel = rss.addElement(\"channel\");\nElement title = channel.addElement(\"title\");\ntitle.setText(\"<![CDATA[上海移动互联网产业促进中心正式揭牌 ]]>\");\n```\n5.设置生成xml的格式\n```java\nOutputFormat format = OutputFormat.createPrettyPrint();\nformat.setEncoding(\"GBK\");\n```\n6.生成xml文件\n```java\nFile file = new File(\"rssnews.xml\");\nXMLWriter writer;\nwriter = new XMLWriter(new FileOutputStream(file), format);\n//设置是否转义，默认值是true，代表转义\nwriter.setEscapeText(false);\nwriter.write(document);\nwriter.close();\n```\n\n> 参阅：\n  [慕课网：Java眼中的XML---文件读取](https://www.imooc.com/learn/171)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)","slug":"Java中的XML之四种方式生成XML文档：DOM，SAX，JDOM，DOM4J","published":1,"updated":"2018-11-13T06:13:12.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcv000gu7yjaj097hl0","content":"<p>现有以下XML文档books.xml,下面的示例生成此文档部分内容<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bookstore</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>冰与火之歌<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">author</span>&gt;</span>乔治马丁<span class=\"tag\">&lt;/<span class=\"name\">author</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2014<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>89<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"2\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>安徒生童话<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2004<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>77<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">language</span>&gt;</span>English<span class=\"tag\">&lt;/<span class=\"name\">language</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><p>1、创建DocumentBuilder对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class=\"line\">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p>\n<p>2、添加节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.setXmlStandalone(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">Element bookstore = document.createElement(<span class=\"string\">\"bookStore\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//向bookstore根节点中添加子节点book</span></span><br><span class=\"line\">Element book = document.createElement(<span class=\"string\">\"book\"</span>);</span><br><span class=\"line\">Element name = document.createElement(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">name.setTextContent(<span class=\"string\">\"???\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">book.appendChild(name);</span><br><span class=\"line\">book.setAttribute(<span class=\"string\">\"id\"</span>, <span class=\"string\">\"1\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//将book节点添加到bookstore根节点中</span></span><br><span class=\"line\">bookstore.appendChild(book);</span><br><span class=\"line\"><span class=\"comment\">//将bookstore节点（已经包含了book）添加到dom树中</span></span><br><span class=\"line\">document.appendChild(bookstore);</span><br></pre></td></tr></table></figure></p>\n<p>3、生成xml文件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TransformerFactory tff = TransformerFactory.newInstance();</span><br><span class=\"line\">Transformer tf = tff.newTransformer();</span><br><span class=\"line\"><span class=\"comment\">//设置文件</span></span><br><span class=\"line\">tf.setOutputProperty(OutputKeys.INDENT, <span class=\"string\">\"yes\"</span>);</span><br><span class=\"line\">tf.transform(<span class=\"keyword\">new</span> DOMSource(document),<span class=\"keyword\">new</span> StreamResult(<span class=\"keyword\">new</span> File(<span class=\"string\">\"books1.xml\"</span>)));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"SAX\"><a href=\"#SAX\" class=\"headerlink\" title=\"SAX\"></a>SAX</h3><p>1、创建一个TransformerFactory类的对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance();</span><br></pre></td></tr></table></figure></p>\n<p>2、通过SAXTransformerFactory对象创建一个TransformerHandler对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TransformerHandler handler = tff.newTransformerHandler();</span><br></pre></td></tr></table></figure></p>\n<p>3、通过handler对象创建一个Transformer对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Transformer tr = handler.getTransformer();</span><br></pre></td></tr></table></figure></p>\n<p>4、通过Transformer对象对生成的xml文件进行设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置xml的编码</span><br><span class=\"line\">tr.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span><br><span class=\"line\">// 设置xml的“是否换行”</span><br><span class=\"line\">tr.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class=\"line\">5、创建一个Result对象</span><br><span class=\"line\">```java</span><br><span class=\"line\">File f = new File(&quot;newbooks.xml&quot;);</span><br><span class=\"line\">if (!f.exists()) &#123;</span><br><span class=\"line\">    f.createNewFile();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6、创建Result对象，并且使其与handler关联<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result result = <span class=\"keyword\">new</span> StreamResult(<span class=\"keyword\">new</span> FileOutputStream(f));</span><br><span class=\"line\">handler.setResult(result);</span><br></pre></td></tr></table></figure></p>\n<p>7、利用handler对象进行xml文件内容的编写O<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打开document</span></span><br><span class=\"line\">handler.startDocument();</span><br></pre></td></tr></table></figure></p>\n<p>8、添加节点属性和节点值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AttributesImpl attr = <span class=\"keyword\">new</span> AttributesImpl();</span><br><span class=\"line\">handler.startElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"bookstore\"</span>, attr);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Book book : bookList) &#123;</span><br><span class=\"line\">    attr.clear();</span><br><span class=\"line\">    attr.addAttribute(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"id\"</span>, <span class=\"string\">\"\"</span>, book.getId());</span><br><span class=\"line\">    handler.startElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"book\"</span>, attr);</span><br><span class=\"line\">    <span class=\"comment\">// 创建name节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (book.getName() != <span class=\"keyword\">null</span> &amp;&amp; !book.getName().trim().equals(<span class=\"string\">\"\"</span>)) &#123;</span><br><span class=\"line\">        attr.clear();</span><br><span class=\"line\">        handler.startElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"name\"</span>, attr);</span><br><span class=\"line\">        handler.characters(book.getName().toCharArray(), <span class=\"number\">0</span>, book</span><br><span class=\"line\">                .getName().length());</span><br><span class=\"line\">        handler.endElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handler.endElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"book\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">handler.endElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"bookstore\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 关闭document</span></span><br><span class=\"line\">handler.endDocument();</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"JDOM\"><a href=\"#JDOM\" class=\"headerlink\" title=\"JDOM\"></a>JDOM</h3><p>1.生成一个根节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element rss = <span class=\"keyword\">new</span> Element(<span class=\"string\">\"rss\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2.为节点添加属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rss.setAttribute(<span class=\"string\">\"version\"</span>, <span class=\"string\">\"2.0\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3.生成一个document对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = <span class=\"keyword\">new</span> Document(rss);</span><br><span class=\"line\">Element channel = <span class=\"keyword\">new</span> Element(<span class=\"string\">\"channel\"</span>);</span><br><span class=\"line\">rss.addContent(channel);</span><br><span class=\"line\">Element title = <span class=\"keyword\">new</span> Element(<span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">title.setText(<span class=\"string\">\"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;\"</span>);</span><br><span class=\"line\">channel.addContent(title);</span><br><span class=\"line\"><span class=\"comment\">//设置文件编码和换行</span></span><br><span class=\"line\">Format format = Format.getCompactFormat();</span><br><span class=\"line\">format.setIndent(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">format.setEncoding(<span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4.创建XMLOutputter的对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XMLOutputter outputer = <span class=\"keyword\">new</span> XMLOutputter(format);</span><br></pre></td></tr></table></figure></p>\n<p>5.利用outputer将document对象转换成xml文档<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outputer.output(document, <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(<span class=\"string\">\"rssnews.xml\"</span>)));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"DOM4J\"><a href=\"#DOM4J\" class=\"headerlink\" title=\"DOM4J\"></a>DOM4J</h3><blockquote>\n<p>使用DOM4J生成RSS文件</p>\n</blockquote>\n<p>1.创建document对象，代表整个xml文档<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = DocumentHelper.createDocument();</span><br></pre></td></tr></table></figure></p>\n<p>2.创建根节点rss<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element rss = document.addElement(<span class=\"string\">\"rss\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3.向rss节点中添加version属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rss.addAttribute(<span class=\"string\">\"version\"</span>, <span class=\"string\">\"2.0\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4.生成子节点及节点内容<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element channel = rss.addElement(<span class=\"string\">\"channel\"</span>);</span><br><span class=\"line\">Element title = channel.addElement(<span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">title.setText(<span class=\"string\">\"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>5.设置生成xml的格式<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class=\"line\">format.setEncoding(<span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>6.生成xml文件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"rssnews.xml\"</span>);</span><br><span class=\"line\">XMLWriter writer;</span><br><span class=\"line\">writer = <span class=\"keyword\">new</span> XMLWriter(<span class=\"keyword\">new</span> FileOutputStream(file), format);</span><br><span class=\"line\"><span class=\"comment\">//设置是否转义，默认值是true，代表转义</span></span><br><span class=\"line\">writer.setEscapeText(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">writer.write(document);</span><br><span class=\"line\">writer.close();</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/171\" target=\"_blank\" rel=\"noopener\">慕课网：Java眼中的XML—文件读取</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>现有以下XML文档books.xml,下面的示例生成此文档部分内容<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bookstore</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"1\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>冰与火之歌<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">author</span>&gt;</span>乔治马丁<span class=\"tag\">&lt;/<span class=\"name\">author</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2014<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>89<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">\"2\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>安徒生童话<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">year</span>&gt;</span>2004<span class=\"tag\">&lt;/<span class=\"name\">year</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>77<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">language</span>&gt;</span>English<span class=\"tag\">&lt;/<span class=\"name\">language</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><p>1、创建DocumentBuilder对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class=\"line\">DocumentBuilder db = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure></p>\n<p>2、添加节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.setXmlStandalone(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">Element bookstore = document.createElement(<span class=\"string\">\"bookStore\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//向bookstore根节点中添加子节点book</span></span><br><span class=\"line\">Element book = document.createElement(<span class=\"string\">\"book\"</span>);</span><br><span class=\"line\">Element name = document.createElement(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">name.setTextContent(<span class=\"string\">\"???\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">book.appendChild(name);</span><br><span class=\"line\">book.setAttribute(<span class=\"string\">\"id\"</span>, <span class=\"string\">\"1\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//将book节点添加到bookstore根节点中</span></span><br><span class=\"line\">bookstore.appendChild(book);</span><br><span class=\"line\"><span class=\"comment\">//将bookstore节点（已经包含了book）添加到dom树中</span></span><br><span class=\"line\">document.appendChild(bookstore);</span><br></pre></td></tr></table></figure></p>\n<p>3、生成xml文件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TransformerFactory tff = TransformerFactory.newInstance();</span><br><span class=\"line\">Transformer tf = tff.newTransformer();</span><br><span class=\"line\"><span class=\"comment\">//设置文件</span></span><br><span class=\"line\">tf.setOutputProperty(OutputKeys.INDENT, <span class=\"string\">\"yes\"</span>);</span><br><span class=\"line\">tf.transform(<span class=\"keyword\">new</span> DOMSource(document),<span class=\"keyword\">new</span> StreamResult(<span class=\"keyword\">new</span> File(<span class=\"string\">\"books1.xml\"</span>)));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"SAX\"><a href=\"#SAX\" class=\"headerlink\" title=\"SAX\"></a>SAX</h3><p>1、创建一个TransformerFactory类的对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAXTransformerFactory tff = (SAXTransformerFactory) SAXTransformerFactory.newsInstance();</span><br></pre></td></tr></table></figure></p>\n<p>2、通过SAXTransformerFactory对象创建一个TransformerHandler对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TransformerHandler handler = tff.newTransformerHandler();</span><br></pre></td></tr></table></figure></p>\n<p>3、通过handler对象创建一个Transformer对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Transformer tr = handler.getTransformer();</span><br></pre></td></tr></table></figure></p>\n<p>4、通过Transformer对象对生成的xml文件进行设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 设置xml的编码</span><br><span class=\"line\">tr.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span><br><span class=\"line\">// 设置xml的“是否换行”</span><br><span class=\"line\">tr.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span><br><span class=\"line\">5、创建一个Result对象</span><br><span class=\"line\">```java</span><br><span class=\"line\">File f = new File(&quot;newbooks.xml&quot;);</span><br><span class=\"line\">if (!f.exists()) &#123;</span><br><span class=\"line\">    f.createNewFile();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6、创建Result对象，并且使其与handler关联<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Result result = <span class=\"keyword\">new</span> StreamResult(<span class=\"keyword\">new</span> FileOutputStream(f));</span><br><span class=\"line\">handler.setResult(result);</span><br></pre></td></tr></table></figure></p>\n<p>7、利用handler对象进行xml文件内容的编写O<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打开document</span></span><br><span class=\"line\">handler.startDocument();</span><br></pre></td></tr></table></figure></p>\n<p>8、添加节点属性和节点值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AttributesImpl attr = <span class=\"keyword\">new</span> AttributesImpl();</span><br><span class=\"line\">handler.startElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"bookstore\"</span>, attr);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Book book : bookList) &#123;</span><br><span class=\"line\">    attr.clear();</span><br><span class=\"line\">    attr.addAttribute(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"id\"</span>, <span class=\"string\">\"\"</span>, book.getId());</span><br><span class=\"line\">    handler.startElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"book\"</span>, attr);</span><br><span class=\"line\">    <span class=\"comment\">// 创建name节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (book.getName() != <span class=\"keyword\">null</span> &amp;&amp; !book.getName().trim().equals(<span class=\"string\">\"\"</span>)) &#123;</span><br><span class=\"line\">        attr.clear();</span><br><span class=\"line\">        handler.startElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"name\"</span>, attr);</span><br><span class=\"line\">        handler.characters(book.getName().toCharArray(), <span class=\"number\">0</span>, book</span><br><span class=\"line\">                .getName().length());</span><br><span class=\"line\">        handler.endElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handler.endElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"book\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">handler.endElement(<span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"bookstore\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 关闭document</span></span><br><span class=\"line\">handler.endDocument();</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"JDOM\"><a href=\"#JDOM\" class=\"headerlink\" title=\"JDOM\"></a>JDOM</h3><p>1.生成一个根节点<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element rss = <span class=\"keyword\">new</span> Element(<span class=\"string\">\"rss\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2.为节点添加属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rss.setAttribute(<span class=\"string\">\"version\"</span>, <span class=\"string\">\"2.0\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3.生成一个document对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = <span class=\"keyword\">new</span> Document(rss);</span><br><span class=\"line\">Element channel = <span class=\"keyword\">new</span> Element(<span class=\"string\">\"channel\"</span>);</span><br><span class=\"line\">rss.addContent(channel);</span><br><span class=\"line\">Element title = <span class=\"keyword\">new</span> Element(<span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">title.setText(<span class=\"string\">\"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;\"</span>);</span><br><span class=\"line\">channel.addContent(title);</span><br><span class=\"line\"><span class=\"comment\">//设置文件编码和换行</span></span><br><span class=\"line\">Format format = Format.getCompactFormat();</span><br><span class=\"line\">format.setIndent(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">format.setEncoding(<span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4.创建XMLOutputter的对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XMLOutputter outputer = <span class=\"keyword\">new</span> XMLOutputter(format);</span><br></pre></td></tr></table></figure></p>\n<p>5.利用outputer将document对象转换成xml文档<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outputer.output(document, <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(<span class=\"string\">\"rssnews.xml\"</span>)));</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"DOM4J\"><a href=\"#DOM4J\" class=\"headerlink\" title=\"DOM4J\"></a>DOM4J</h3><blockquote>\n<p>使用DOM4J生成RSS文件</p>\n</blockquote>\n<p>1.创建document对象，代表整个xml文档<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document document = DocumentHelper.createDocument();</span><br></pre></td></tr></table></figure></p>\n<p>2.创建根节点rss<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element rss = document.addElement(<span class=\"string\">\"rss\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>3.向rss节点中添加version属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rss.addAttribute(<span class=\"string\">\"version\"</span>, <span class=\"string\">\"2.0\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4.生成子节点及节点内容<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element channel = rss.addElement(<span class=\"string\">\"channel\"</span>);</span><br><span class=\"line\">Element title = channel.addElement(<span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">title.setText(<span class=\"string\">\"&lt;![CDATA[上海移动互联网产业促进中心正式揭牌 ]]&gt;\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>5.设置生成xml的格式<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class=\"line\">format.setEncoding(<span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>6.生成xml文件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"rssnews.xml\"</span>);</span><br><span class=\"line\">XMLWriter writer;</span><br><span class=\"line\">writer = <span class=\"keyword\">new</span> XMLWriter(<span class=\"keyword\">new</span> FileOutputStream(file), format);</span><br><span class=\"line\"><span class=\"comment\">//设置是否转义，默认值是true，代表转义</span></span><br><span class=\"line\">writer.setEscapeText(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">writer.write(document);</span><br><span class=\"line\">writer.close();</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/171\" target=\"_blank\" rel=\"noopener\">慕课网：Java眼中的XML—文件读取</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n"},{"title":"Spring Bean装配之各装配项 XML实现和注解实现","date":"2018-07-27T10:56:18.000Z","_content":"\n### 一、Bean管理的XML配置实现\n#### 1.Bean的配置项\n- `Id`:Bean的唯一标识\n- `Class`：对应实现的类\n- `Scope`：范围\n- `Constructor arguments`：构造器参数\n- `Properties`：属性\n- `Autowiring mode`：自动装配模式 \n- `lazy-initialization mode`：懒加载模式\n- `Initialization/destruction method`：初始化/销毁方法\n\n#### 2.Bean的定义\n这里以`InjectionImpl`中包含`InjectionDAO`成员变量为例，说明设置注入和构造注入,`InjectionImpl`类如下：\n\n```java\npublic class InjectionServiceImpl implements InjectionService {\n    private InjectionDAO injectionDAO;\n}\n```\n\n##### 方式一：设置注入\n`bean`的XML配置:\n\n```XML\n<bean id=\"injectionService\" class=\"com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl\">\n    <property name=\"injectionDAO\" ref=\"injectionDAO\"></property>\n</bean>\n<bean id=\"injectionDAO\" class=\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"></bean>\n```\n\n`InjectionIml`中setter方法:\n\n```java\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n\n\n##### 方式二：构造注入\n\nbean的XML配置：\n\n```XML\n<bean id=\"injectionService\" class=\"com.imooc.ioc.injection.service.InjectionServiceImpl\">\n    <constructor-arg name=\"injectionDAO\" ref=\"injectionDAO\"></constructor-arg>\n</bean>\n<bean id=\"injectionDAO\" class=\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"></bean>\n```\n\n`InjectionIml`中构造方法：\n\n```java\npublic InjectionServiceImpl(InjectionDAOImpl injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n\n\n#### 2.Bean的作用域\n- `singleton`:单例，一个Bean容器中指存在一份（默认情况下为singleton)\n- `prototype`：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效\n- `request`：每次http请求创建一个实例且仅在当前request内有效\n- `session`：同上，每次http请求创建，当前session有效\n- `global session`：给予portel的web中有效，如果是在web中，则同session\n\nXML文件中的配置\n```XML\n<bean id=\"beanScope\" class=\"com.pinnuli.spring.ioc.bean.BeanScope\" scope=\"singleton\"></bean>\n```\n\n#### 3.Bean的生命周期\n> 定义 &rArr; 初始化 &rArr;\t使用 &rArr; 销毁\n\n**初始化**\n##### 方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法\n```java\npublic class ExampleInitializingBean implements InitialingBean{\n\n    @Override\n    public void afterPropertiesSet() throws Exception{\n    }\n}\n```\n##### 方式二：配置init-method\nXML文件中的配置：\n```XML\n<bean id=\"exampleInitBean\" class=\"example.Example\" init-method=\"init\"/>\n```\n对应实现类：\n```Java\npublic class ExampleBean{\n    public void init(){\n    }\n}\n```\n\n**销毁:**\n\n##### 方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法\n```java\npublic class ExampleInitializingBean implements DisposableBean{\n\n    @Override\n    public void destroy() throws Exception{\n    }\n}\n```\n\n##### 方式二：配置destory-method\nXML文件中的配置：\n```XML\n<bean id=\"exampleInitBean\" class=\"example.Example\" init-method=\"destroy\"/>\n```\n\n`destory`方法：\n```Java\npublic class ExampleBean{\n    public void destroy(){\n    }\n}\n```\n\n#### 配置全局默认初始化、销毁方法\n\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-init-method=\"init\" default-destroy-mothod=\"destroy\">\n</beans>\n```\n\n>i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效；\n  ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错；\n  iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。\n\n\n#### 4.Bean的自动装配\n- `No`：什么都不操作\n- `byname`：即<bean>中的`id`，根据属性名自动装配，\n- `byType`：即<bean>中的`class`\n\n> i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；\nii.如果存在多个该类型的bean，则抛出异常，并指出不能使用`byType`方式进行自动装配\niii.如果没有找到匹配的bean，则不进行任何操作\n以上两种情况bean的XML配置如下：\n\n```XML\n<beans default-autowire=\"byType\"/\"byName\">\n    <bean id=\"autoWiringService\" class=\"com.pinnuli.spring.ioc.autowiring.AutoWiringService\"></bean>\n\n    <bean id=\"autoWiringDAO\" class=\"com.pinnuli.spring.ioc.autowiring.AutoWiringDAO\"></bean>\n</beans>\n```\n\n- `Constructor`: 应用于构造器参数，与`byType`类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常\n\n> 对应的类中的构造方法和setter方法与设置注入或构造注入一致\n\n----\n### 二、Bean管理的注解实现\n#### 1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\" >\n        \n    <context:annotation-config/>\n\n</beans>\n```\n- `<context:annotation-config/>`\n仅会查找同一个`applicat context`中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解\n通过在基于XML的Spring配置如下标签\n\n\n- `<context:component-scan>`会扫描所有有bean注解的类，并注册到IOC容器，包含了`<context:annotation-config>`的全部功能，因而通常只需要使用前者，而不用后者\n\n```XML\n<context:component-scan base-package=\"org.example>\n```\n> base-package表示扫描包下的所有类\n\n#### 2.使用过滤器进行自定义扫描\n默认情况下，类被自动发现并注册bean的条件是：使用了`@Component`，`@Repository`，`@Service`，`@Controller`注解，或者使用@`Component`的自定义注解，可以通过过滤器修改上述的行为\n\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\">\n        <context:include-filter type=\"regex\" expression=\".*Stub.*Respository\"/>\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/>\n    <context:component-scan/>    \n</beans>\n```\n> 还可以使用`use-default-filters=\"false\"`禁用自动发现与注册\n\n\n#### Bean的定义\nBean名称是由`BeannameGenerator`生成的，默认情况下为类名的首字母变为小写\n\n> `@Component`，`@Repository`，`@Service`,`@Controller`都有一个那么属性用于显示设置Bean的名称,如\n```java\n@Component(\"beanName\")\npublic class BeanAnnotation {\n}\n```\n\n也可自定义命名策略,实现`BeanNameGenerator`接口，并一定要包含一个无参构造器\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\" name-generator=\"org.example.MyNameGenerator\"/>\n</beans>\n```\n\n#### Bean的作用域\n通常情况下启动查找的Spring组件，其scope是`singleton`，可用`@Scope`表示scope,\n```java\n@Scope(\"prototype\")\n```\n\n也可自定义scope策略，实现实现`ScopeMetadataResolver`接口，并一定要包含一个无参构造器\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\" name-generator=\"org.example.MyScopeResolver\"/>\n</beans>\n```\n\n> 对于自动装配注解，参见[Spring Bean装配之Autowired注解](/2018/07/28/Spring-Bean装配之Autowired注解/#more)\n\n#### 代理方式\n有三个值可选：`no`,`interfaces`,`targetClass`，默认情况下为no\n\n可以配置`@Scope`注解的`proxyMode`属性来配置代理方式，即XML配置时的`scope-proxy`属性\n```java\n@Scope(value=\"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n```\n\n可以在XML文件中使用`scope-proxy`属性指定代理\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\" scope-proxy=\"interfaces\"/>\n</beans>\n```\n----\n### 三、Resource&ResourceLoader\n#### Resource\n针对资源文件的统一入口，用于Spring加载资源文件\n- UrlResource:URL对应的资源，根据一个URL地址即可构建\n- ClassPathResource：获取类路径下的资源文件\n- FileSystemResource：获取文件系统里面的资源\n- ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源\n- InputStreamResource：针对于输入流封装的资源\n- ByArrayResource：针对于字节数组封装的资源\n\n\n#### ResourceLoader\n> i.所有的application contexts都实现了`ResourceLoader`接口，即可以通过`ApplicationContext`获得Resource实例\nii.使用参数的前缀说明获取资源的类型\n\n##### 1.类路径下的资源文件\n```java\nResource resource = applicationContext.getResource(\"classpath:config.txt\");\n```\n##### 2.文件系统中的资源\n```java\nResource resource = applicationContext.getResource(\"file:/var/SpringDemo/src/main/resources/config.txt\");\n```\n##### 3.URL对应的资源\n```java\nResource resource = applicationContext.getResource(\"url:httpS://www.pinnuli.com/index.html\");\n```\n> 没有前缀时，取决于`ApplicationContext`的路径（之后再添加解释）\n\n```java\nResource resource = applicationContext.getResource(\"config.txt\");\n```\n\n> 参阅：\n  [慕课网：Spring入门篇](https://www.imooc.com/learn/196)","source":"_posts/Spring-Bean装配之各装配项-XML实现和注解实现.md","raw":"---\ntitle: Spring Bean装配之各装配项 XML实现和注解实现\ndate: 2018-07-27 18:56:18\ncategories: \"Spring笔记\"\ntags:\n    - JavaWeb\n    - Spring\n---\n\n### 一、Bean管理的XML配置实现\n#### 1.Bean的配置项\n- `Id`:Bean的唯一标识\n- `Class`：对应实现的类\n- `Scope`：范围\n- `Constructor arguments`：构造器参数\n- `Properties`：属性\n- `Autowiring mode`：自动装配模式 \n- `lazy-initialization mode`：懒加载模式\n- `Initialization/destruction method`：初始化/销毁方法\n\n#### 2.Bean的定义\n这里以`InjectionImpl`中包含`InjectionDAO`成员变量为例，说明设置注入和构造注入,`InjectionImpl`类如下：\n\n```java\npublic class InjectionServiceImpl implements InjectionService {\n    private InjectionDAO injectionDAO;\n}\n```\n\n##### 方式一：设置注入\n`bean`的XML配置:\n\n```XML\n<bean id=\"injectionService\" class=\"com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl\">\n    <property name=\"injectionDAO\" ref=\"injectionDAO\"></property>\n</bean>\n<bean id=\"injectionDAO\" class=\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"></bean>\n```\n\n`InjectionIml`中setter方法:\n\n```java\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n\n\n##### 方式二：构造注入\n\nbean的XML配置：\n\n```XML\n<bean id=\"injectionService\" class=\"com.imooc.ioc.injection.service.InjectionServiceImpl\">\n    <constructor-arg name=\"injectionDAO\" ref=\"injectionDAO\"></constructor-arg>\n</bean>\n<bean id=\"injectionDAO\" class=\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"></bean>\n```\n\n`InjectionIml`中构造方法：\n\n```java\npublic InjectionServiceImpl(InjectionDAOImpl injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n\n\n#### 2.Bean的作用域\n- `singleton`:单例，一个Bean容器中指存在一份（默认情况下为singleton)\n- `prototype`：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效\n- `request`：每次http请求创建一个实例且仅在当前request内有效\n- `session`：同上，每次http请求创建，当前session有效\n- `global session`：给予portel的web中有效，如果是在web中，则同session\n\nXML文件中的配置\n```XML\n<bean id=\"beanScope\" class=\"com.pinnuli.spring.ioc.bean.BeanScope\" scope=\"singleton\"></bean>\n```\n\n#### 3.Bean的生命周期\n> 定义 &rArr; 初始化 &rArr;\t使用 &rArr; 销毁\n\n**初始化**\n##### 方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法\n```java\npublic class ExampleInitializingBean implements InitialingBean{\n\n    @Override\n    public void afterPropertiesSet() throws Exception{\n    }\n}\n```\n##### 方式二：配置init-method\nXML文件中的配置：\n```XML\n<bean id=\"exampleInitBean\" class=\"example.Example\" init-method=\"init\"/>\n```\n对应实现类：\n```Java\npublic class ExampleBean{\n    public void init(){\n    }\n}\n```\n\n**销毁:**\n\n##### 方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法\n```java\npublic class ExampleInitializingBean implements DisposableBean{\n\n    @Override\n    public void destroy() throws Exception{\n    }\n}\n```\n\n##### 方式二：配置destory-method\nXML文件中的配置：\n```XML\n<bean id=\"exampleInitBean\" class=\"example.Example\" init-method=\"destroy\"/>\n```\n\n`destory`方法：\n```Java\npublic class ExampleBean{\n    public void destroy(){\n    }\n}\n```\n\n#### 配置全局默认初始化、销毁方法\n\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       default-init-method=\"init\" default-destroy-mothod=\"destroy\">\n</beans>\n```\n\n>i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效；\n  ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错；\n  iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。\n\n\n#### 4.Bean的自动装配\n- `No`：什么都不操作\n- `byname`：即<bean>中的`id`，根据属性名自动装配，\n- `byType`：即<bean>中的`class`\n\n> i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；\nii.如果存在多个该类型的bean，则抛出异常，并指出不能使用`byType`方式进行自动装配\niii.如果没有找到匹配的bean，则不进行任何操作\n以上两种情况bean的XML配置如下：\n\n```XML\n<beans default-autowire=\"byType\"/\"byName\">\n    <bean id=\"autoWiringService\" class=\"com.pinnuli.spring.ioc.autowiring.AutoWiringService\"></bean>\n\n    <bean id=\"autoWiringDAO\" class=\"com.pinnuli.spring.ioc.autowiring.AutoWiringDAO\"></bean>\n</beans>\n```\n\n- `Constructor`: 应用于构造器参数，与`byType`类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常\n\n> 对应的类中的构造方法和setter方法与设置注入或构造注入一致\n\n----\n### 二、Bean管理的注解实现\n#### 1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\" >\n        \n    <context:annotation-config/>\n\n</beans>\n```\n- `<context:annotation-config/>`\n仅会查找同一个`applicat context`中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解\n通过在基于XML的Spring配置如下标签\n\n\n- `<context:component-scan>`会扫描所有有bean注解的类，并注册到IOC容器，包含了`<context:annotation-config>`的全部功能，因而通常只需要使用前者，而不用后者\n\n```XML\n<context:component-scan base-package=\"org.example>\n```\n> base-package表示扫描包下的所有类\n\n#### 2.使用过滤器进行自定义扫描\n默认情况下，类被自动发现并注册bean的条件是：使用了`@Component`，`@Repository`，`@Service`，`@Controller`注解，或者使用@`Component`的自定义注解，可以通过过滤器修改上述的行为\n\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\">\n        <context:include-filter type=\"regex\" expression=\".*Stub.*Respository\"/>\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/>\n    <context:component-scan/>    \n</beans>\n```\n> 还可以使用`use-default-filters=\"false\"`禁用自动发现与注册\n\n\n#### Bean的定义\nBean名称是由`BeannameGenerator`生成的，默认情况下为类名的首字母变为小写\n\n> `@Component`，`@Repository`，`@Service`,`@Controller`都有一个那么属性用于显示设置Bean的名称,如\n```java\n@Component(\"beanName\")\npublic class BeanAnnotation {\n}\n```\n\n也可自定义命名策略,实现`BeanNameGenerator`接口，并一定要包含一个无参构造器\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\" name-generator=\"org.example.MyNameGenerator\"/>\n</beans>\n```\n\n#### Bean的作用域\n通常情况下启动查找的Spring组件，其scope是`singleton`，可用`@Scope`表示scope,\n```java\n@Scope(\"prototype\")\n```\n\n也可自定义scope策略，实现实现`ScopeMetadataResolver`接口，并一定要包含一个无参构造器\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\" name-generator=\"org.example.MyScopeResolver\"/>\n</beans>\n```\n\n> 对于自动装配注解，参见[Spring Bean装配之Autowired注解](/2018/07/28/Spring-Bean装配之Autowired注解/#more)\n\n#### 代理方式\n有三个值可选：`no`,`interfaces`,`targetClass`，默认情况下为no\n\n可以配置`@Scope`注解的`proxyMode`属性来配置代理方式，即XML配置时的`scope-proxy`属性\n```java\n@Scope(value=\"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n```\n\n可以在XML文件中使用`scope-proxy`属性指定代理\n```XML\n<beans>\n    <context:component-scan base-package=\"org.example\" scope-proxy=\"interfaces\"/>\n</beans>\n```\n----\n### 三、Resource&ResourceLoader\n#### Resource\n针对资源文件的统一入口，用于Spring加载资源文件\n- UrlResource:URL对应的资源，根据一个URL地址即可构建\n- ClassPathResource：获取类路径下的资源文件\n- FileSystemResource：获取文件系统里面的资源\n- ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源\n- InputStreamResource：针对于输入流封装的资源\n- ByArrayResource：针对于字节数组封装的资源\n\n\n#### ResourceLoader\n> i.所有的application contexts都实现了`ResourceLoader`接口，即可以通过`ApplicationContext`获得Resource实例\nii.使用参数的前缀说明获取资源的类型\n\n##### 1.类路径下的资源文件\n```java\nResource resource = applicationContext.getResource(\"classpath:config.txt\");\n```\n##### 2.文件系统中的资源\n```java\nResource resource = applicationContext.getResource(\"file:/var/SpringDemo/src/main/resources/config.txt\");\n```\n##### 3.URL对应的资源\n```java\nResource resource = applicationContext.getResource(\"url:httpS://www.pinnuli.com/index.html\");\n```\n> 没有前缀时，取决于`ApplicationContext`的路径（之后再添加解释）\n\n```java\nResource resource = applicationContext.getResource(\"config.txt\");\n```\n\n> 参阅：\n  [慕课网：Spring入门篇](https://www.imooc.com/learn/196)","slug":"Spring-Bean装配之各装配项-XML实现和注解实现","published":1,"updated":"2018-11-12T13:01:22.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcx000iu7yj2affxghq","content":"<h3 id=\"一、Bean管理的XML配置实现\"><a href=\"#一、Bean管理的XML配置实现\" class=\"headerlink\" title=\"一、Bean管理的XML配置实现\"></a>一、Bean管理的XML配置实现</h3><h4 id=\"1-Bean的配置项\"><a href=\"#1-Bean的配置项\" class=\"headerlink\" title=\"1.Bean的配置项\"></a>1.Bean的配置项</h4><ul>\n<li><code>Id</code>:Bean的唯一标识</li>\n<li><code>Class</code>：对应实现的类</li>\n<li><code>Scope</code>：范围</li>\n<li><code>Constructor arguments</code>：构造器参数</li>\n<li><code>Properties</code>：属性</li>\n<li><code>Autowiring mode</code>：自动装配模式 </li>\n<li><code>lazy-initialization mode</code>：懒加载模式</li>\n<li><code>Initialization/destruction method</code>：初始化/销毁方法</li>\n</ul>\n<h4 id=\"2-Bean的定义\"><a href=\"#2-Bean的定义\" class=\"headerlink\" title=\"2.Bean的定义\"></a>2.Bean的定义</h4><p>这里以<code>InjectionImpl</code>中包含<code>InjectionDAO</code>成员变量为例，说明设置注入和构造注入,<code>InjectionImpl</code>类如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InjectionServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">InjectionService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InjectionDAO injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式一：设置注入\"><a href=\"#方式一：设置注入\" class=\"headerlink\" title=\"方式一：设置注入\"></a>方式一：设置注入</h5><p><code>bean</code>的XML配置:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"injectionDAO\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>InjectionIml</code>中setter方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式二：构造注入\"><a href=\"#方式二：构造注入\" class=\"headerlink\" title=\"方式二：构造注入\"></a>方式二：构造注入</h5><p>bean的XML配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.imooc.ioc.injection.service.InjectionServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"injectionDAO\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>InjectionIml</code>中构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InjectionServiceImpl</span><span class=\"params\">(InjectionDAOImpl injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-Bean的作用域\"><a href=\"#2-Bean的作用域\" class=\"headerlink\" title=\"2.Bean的作用域\"></a>2.Bean的作用域</h4><ul>\n<li><code>singleton</code>:单例，一个Bean容器中指存在一份（默认情况下为singleton)</li>\n<li><code>prototype</code>：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效</li>\n<li><code>request</code>：每次http请求创建一个实例且仅在当前request内有效</li>\n<li><code>session</code>：同上，每次http请求创建，当前session有效</li>\n<li><code>global session</code>：给予portel的web中有效，如果是在web中，则同session</li>\n</ul>\n<p>XML文件中的配置<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanScope\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.bean.BeanScope\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"singleton\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-Bean的生命周期\"><a href=\"#3-Bean的生命周期\" class=\"headerlink\" title=\"3.Bean的生命周期\"></a>3.Bean的生命周期</h4><blockquote>\n<p>定义 &rArr; 初始化 &rArr;    使用 &rArr; 销毁</p>\n</blockquote>\n<p><strong>初始化</strong></p>\n<h5 id=\"方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法\"><a href=\"#方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法\" class=\"headerlink\" title=\"方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法\"></a>方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleInitializingBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitialingBean</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式二：配置init-method\"><a href=\"#方式二：配置init-method\" class=\"headerlink\" title=\"方式二：配置init-method\"></a>方式二：配置init-method</h5><p>XML文件中的配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleInitBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.Example\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>对应实现类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>销毁:</strong></p>\n<h5 id=\"方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法\"><a href=\"#方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法\" class=\"headerlink\" title=\"方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法\"></a>方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleInitializingBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式二：配置destory-method\"><a href=\"#方式二：配置destory-method\" class=\"headerlink\" title=\"方式二：配置destory-method\"></a>方式二：配置destory-method</h5><p>XML文件中的配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleInitBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.Example\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>destory</code>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"配置全局默认初始化、销毁方法\"><a href=\"#配置全局默认初始化、销毁方法\" class=\"headerlink\" title=\"配置全局默认初始化、销毁方法\"></a>配置全局默认初始化、销毁方法</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">default-init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">default-destroy-mothod</span>=<span class=\"string\">\"destroy\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效；<br>  ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错；<br>  iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。</p>\n</blockquote>\n<h4 id=\"4-Bean的自动装配\"><a href=\"#4-Bean的自动装配\" class=\"headerlink\" title=\"4.Bean的自动装配\"></a>4.Bean的自动装配</h4><ul>\n<li><code>No</code>：什么都不操作</li>\n<li><code>byname</code>：即<bean>中的<code>id</code>，根据属性名自动装配，</bean></li>\n<li><code>byType</code>：即<bean>中的<code>class</code></bean></li>\n</ul>\n<blockquote>\n<p>i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；<br>ii.如果存在多个该类型的bean，则抛出异常，并指出不能使用<code>byType</code>方式进行自动装配<br>iii.如果没有找到匹配的bean，则不进行任何操作<br>以上两种情况bean的XML配置如下：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">default-autowire</span>=<span class=\"string\">\"byType\"</span>/\"<span class=\"attr\">byName</span>\"&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"autoWiringService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.autowiring.AutoWiringService\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"autoWiringDAO\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.autowiring.AutoWiringDAO\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Constructor</code>: 应用于构造器参数，与<code>byType</code>类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常</li>\n</ul>\n<blockquote>\n<p>对应的类中的构造方法和setter方法与设置注入或构造注入一致</p>\n</blockquote>\n<hr>\n<h3 id=\"二、Bean管理的注解实现\"><a href=\"#二、Bean管理的注解实现\" class=\"headerlink\" title=\"二、Bean管理的注解实现\"></a>二、Bean管理的注解实现</h3><h4 id=\"1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\"><a href=\"#1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\" class=\"headerlink\" title=\"1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\"></a>1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context/spring-context.xsd\"</span> &gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:annotation-config</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;context:annotation-config/&gt;</code><br>仅会查找同一个<code>applicat context</code>中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解<br>通过在基于XML的Spring配置如下标签</li>\n</ul>\n<ul>\n<li><code>&lt;context:component-scan&gt;</code>会扫描所有有bean注解的类，并注册到IOC容器，包含了<code>&lt;context:annotation-config&gt;</code>的全部功能，因而通常只需要使用前者，而不用后者</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example&gt;</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>base-package表示扫描包下的所有类</p>\n</blockquote>\n<h4 id=\"2-使用过滤器进行自定义扫描\"><a href=\"#2-使用过滤器进行自定义扫描\" class=\"headerlink\" title=\"2.使用过滤器进行自定义扫描\"></a>2.使用过滤器进行自定义扫描</h4><p>默认情况下，类被自动发现并注册bean的条件是：使用了<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>注解，或者使用@<code>Component</code>的自定义注解，可以通过过滤器修改上述的行为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"regex\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\".*Stub.*Respository\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Repository\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span>/&gt;</span>    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>还可以使用<code>use-default-filters=&quot;false&quot;</code>禁用自动发现与注册</p>\n</blockquote>\n<h4 id=\"Bean的定义\"><a href=\"#Bean的定义\" class=\"headerlink\" title=\"Bean的定义\"></a>Bean的定义</h4><p>Bean名称是由<code>BeannameGenerator</code>生成的，默认情况下为类名的首字母变为小写</p>\n<blockquote>\n<p><code>@Component</code>，<code>@Repository</code>，<code>@Service</code>,<code>@Controller</code>都有一个那么属性用于显示设置Bean的名称,如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"beanName\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanAnnotation</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>也可自定义命名策略,实现<code>BeanNameGenerator</code>接口，并一定要包含一个无参构造器<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span> <span class=\"attr\">name-generator</span>=<span class=\"string\">\"org.example.MyNameGenerator\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Bean的作用域\"><a href=\"#Bean的作用域\" class=\"headerlink\" title=\"Bean的作用域\"></a>Bean的作用域</h4><p>通常情况下启动查找的Spring组件，其scope是<code>singleton</code>，可用<code>@Scope</code>表示scope,<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(<span class=\"string\">\"prototype\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>也可自定义scope策略，实现实现<code>ScopeMetadataResolver</code>接口，并一定要包含一个无参构造器<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span> <span class=\"attr\">name-generator</span>=<span class=\"string\">\"org.example.MyScopeResolver\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>对于自动装配注解，参见<a href=\"/2018/07/28/Spring-Bean装配之Autowired注解/#more\">Spring Bean装配之Autowired注解</a></p>\n</blockquote>\n<h4 id=\"代理方式\"><a href=\"#代理方式\" class=\"headerlink\" title=\"代理方式\"></a>代理方式</h4><p>有三个值可选：<code>no</code>,<code>interfaces</code>,<code>targetClass</code>，默认情况下为no</p>\n<p>可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(value=<span class=\"string\">\"prototype\"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure></p>\n<p>可以在XML文件中使用<code>scope-proxy</code>属性指定代理<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span> <span class=\"attr\">scope-proxy</span>=<span class=\"string\">\"interfaces\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"三、Resource-amp-ResourceLoader\"><a href=\"#三、Resource-amp-ResourceLoader\" class=\"headerlink\" title=\"三、Resource&amp;ResourceLoader\"></a>三、Resource&amp;ResourceLoader</h3><h4 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h4><p>针对资源文件的统一入口，用于Spring加载资源文件</p>\n<ul>\n<li>UrlResource:URL对应的资源，根据一个URL地址即可构建</li>\n<li>ClassPathResource：获取类路径下的资源文件</li>\n<li>FileSystemResource：获取文件系统里面的资源</li>\n<li>ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源</li>\n<li>InputStreamResource：针对于输入流封装的资源</li>\n<li>ByArrayResource：针对于字节数组封装的资源</li>\n</ul>\n<h4 id=\"ResourceLoader\"><a href=\"#ResourceLoader\" class=\"headerlink\" title=\"ResourceLoader\"></a>ResourceLoader</h4><blockquote>\n<p>i.所有的application contexts都实现了<code>ResourceLoader</code>接口，即可以通过<code>ApplicationContext</code>获得Resource实例<br>ii.使用参数的前缀说明获取资源的类型</p>\n</blockquote>\n<h5 id=\"1-类路径下的资源文件\"><a href=\"#1-类路径下的资源文件\" class=\"headerlink\" title=\"1.类路径下的资源文件\"></a>1.类路径下的资源文件</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"classpath:config.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-文件系统中的资源\"><a href=\"#2-文件系统中的资源\" class=\"headerlink\" title=\"2.文件系统中的资源\"></a>2.文件系统中的资源</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"file:/var/SpringDemo/src/main/resources/config.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-URL对应的资源\"><a href=\"#3-URL对应的资源\" class=\"headerlink\" title=\"3.URL对应的资源\"></a>3.URL对应的资源</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"url:httpS://www.pinnuli.com/index.html\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>没有前缀时，取决于<code>ApplicationContext</code>的路径（之后再添加解释）</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"config.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/196\" target=\"_blank\" rel=\"noopener\">慕课网：Spring入门篇</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、Bean管理的XML配置实现\"><a href=\"#一、Bean管理的XML配置实现\" class=\"headerlink\" title=\"一、Bean管理的XML配置实现\"></a>一、Bean管理的XML配置实现</h3><h4 id=\"1-Bean的配置项\"><a href=\"#1-Bean的配置项\" class=\"headerlink\" title=\"1.Bean的配置项\"></a>1.Bean的配置项</h4><ul>\n<li><code>Id</code>:Bean的唯一标识</li>\n<li><code>Class</code>：对应实现的类</li>\n<li><code>Scope</code>：范围</li>\n<li><code>Constructor arguments</code>：构造器参数</li>\n<li><code>Properties</code>：属性</li>\n<li><code>Autowiring mode</code>：自动装配模式 </li>\n<li><code>lazy-initialization mode</code>：懒加载模式</li>\n<li><code>Initialization/destruction method</code>：初始化/销毁方法</li>\n</ul>\n<h4 id=\"2-Bean的定义\"><a href=\"#2-Bean的定义\" class=\"headerlink\" title=\"2.Bean的定义\"></a>2.Bean的定义</h4><p>这里以<code>InjectionImpl</code>中包含<code>InjectionDAO</code>成员变量为例，说明设置注入和构造注入,<code>InjectionImpl</code>类如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InjectionServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">InjectionService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InjectionDAO injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式一：设置注入\"><a href=\"#方式一：设置注入\" class=\"headerlink\" title=\"方式一：设置注入\"></a>方式一：设置注入</h5><p><code>bean</code>的XML配置:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.injection.service.InjectionServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"injectionDAO\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>InjectionIml</code>中setter方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式二：构造注入\"><a href=\"#方式二：构造注入\" class=\"headerlink\" title=\"方式二：构造注入\"></a>方式二：构造注入</h5><p>bean的XML配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.imooc.ioc.injection.service.InjectionServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"injectionDAO\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"injectionDAO\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.injection.dao.InjectionDAOImpl\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>InjectionIml</code>中构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InjectionServiceImpl</span><span class=\"params\">(InjectionDAOImpl injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-Bean的作用域\"><a href=\"#2-Bean的作用域\" class=\"headerlink\" title=\"2.Bean的作用域\"></a>2.Bean的作用域</h4><ul>\n<li><code>singleton</code>:单例，一个Bean容器中指存在一份（默认情况下为singleton)</li>\n<li><code>prototype</code>：每次使用（每次请求，即每次向IOC容器请求获取一个对象时）都创建新的实例，destroy方法不生效</li>\n<li><code>request</code>：每次http请求创建一个实例且仅在当前request内有效</li>\n<li><code>session</code>：同上，每次http请求创建，当前session有效</li>\n<li><code>global session</code>：给予portel的web中有效，如果是在web中，则同session</li>\n</ul>\n<p>XML文件中的配置<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanScope\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.bean.BeanScope\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"singleton\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-Bean的生命周期\"><a href=\"#3-Bean的生命周期\" class=\"headerlink\" title=\"3.Bean的生命周期\"></a>3.Bean的生命周期</h4><blockquote>\n<p>定义 &rArr; 初始化 &rArr;    使用 &rArr; 销毁</p>\n</blockquote>\n<p><strong>初始化</strong></p>\n<h5 id=\"方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法\"><a href=\"#方式一：实现org-springframework-beans-factory-InitializingBean借口，覆盖afterPropertiesSet方法\" class=\"headerlink\" title=\"方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法\"></a>方式一：实现org.springframework.beans.factory.InitializingBean借口，覆盖afterPropertiesSet方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleInitializingBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitialingBean</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式二：配置init-method\"><a href=\"#方式二：配置init-method\" class=\"headerlink\" title=\"方式二：配置init-method\"></a>方式二：配置init-method</h5><p>XML文件中的配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleInitBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.Example\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>对应实现类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>销毁:</strong></p>\n<h5 id=\"方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法\"><a href=\"#方式一：实现org-springframework-beans-factory-DisposableBean借口，覆盖destory方法\" class=\"headerlink\" title=\"方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法\"></a>方式一：实现org.springframework.beans.factory.DisposableBean借口，覆盖destory方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleInitializingBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方式二：配置destory-method\"><a href=\"#方式二：配置destory-method\" class=\"headerlink\" title=\"方式二：配置destory-method\"></a>方式二：配置destory-method</h5><p>XML文件中的配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleInitBean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.Example\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"destroy\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>destory</code>方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"配置全局默认初始化、销毁方法\"><a href=\"#配置全局默认初始化、销毁方法\" class=\"headerlink\" title=\"配置全局默认初始化、销毁方法\"></a>配置全局默认初始化、销毁方法</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">default-init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">default-destroy-mothod</span>=<span class=\"string\">\"destroy\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>i.当三种方式同时配置时，实现接口和配置bean初始化/销毁方法会覆盖全局默认方法，全局默认方法会失效；<br>  ii.即使配置了全局方法，在具体实现中依然可以不定义对应的方法，不会有任何异常或报错；<br>  iii.一旦配置了bean初始化/销毁方法，则必须定义对应的初始化销毁方法。</p>\n</blockquote>\n<h4 id=\"4-Bean的自动装配\"><a href=\"#4-Bean的自动装配\" class=\"headerlink\" title=\"4.Bean的自动装配\"></a>4.Bean的自动装配</h4><ul>\n<li><code>No</code>：什么都不操作</li>\n<li><code>byname</code>：即<bean>中的<code>id</code>，根据属性名自动装配，</bean></li>\n<li><code>byType</code>：即<bean>中的<code>class</code></bean></li>\n</ul>\n<blockquote>\n<p>i.如果容器中存在一个与制定属性类型相同的bean，将与该属性自动装配；<br>ii.如果存在多个该类型的bean，则抛出异常，并指出不能使用<code>byType</code>方式进行自动装配<br>iii.如果没有找到匹配的bean，则不进行任何操作<br>以上两种情况bean的XML配置如下：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">default-autowire</span>=<span class=\"string\">\"byType\"</span>/\"<span class=\"attr\">byName</span>\"&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"autoWiringService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.autowiring.AutoWiringService\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"autoWiringDAO\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.autowiring.AutoWiringDAO\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Constructor</code>: 应用于构造器参数，与<code>byType</code>类似，如果容器没有找到与构造器参数类型一致的bean，则抛出异常</li>\n</ul>\n<blockquote>\n<p>对应的类中的构造方法和setter方法与设置注入或构造注入一致</p>\n</blockquote>\n<hr>\n<h3 id=\"二、Bean管理的注解实现\"><a href=\"#二、Bean管理的注解实现\" class=\"headerlink\" title=\"二、Bean管理的注解实现\"></a>二、Bean管理的注解实现</h3><h4 id=\"1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\"><a href=\"#1-用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\" class=\"headerlink\" title=\"1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：\"></a>1.用注解实现时，需要配置以下XML文件扫描有Bean注解的类：</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context/spring-context.xsd\"</span> &gt;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:annotation-config</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&lt;context:annotation-config/&gt;</code><br>仅会查找同一个<code>applicat context</code>中的bean注解,即扫描完成注册后的bean中方法和成员变量的注解<br>通过在基于XML的Spring配置如下标签</li>\n</ul>\n<ul>\n<li><code>&lt;context:component-scan&gt;</code>会扫描所有有bean注解的类，并注册到IOC容器，包含了<code>&lt;context:annotation-config&gt;</code>的全部功能，因而通常只需要使用前者，而不用后者</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example&gt;</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>base-package表示扫描包下的所有类</p>\n</blockquote>\n<h4 id=\"2-使用过滤器进行自定义扫描\"><a href=\"#2-使用过滤器进行自定义扫描\" class=\"headerlink\" title=\"2.使用过滤器进行自定义扫描\"></a>2.使用过滤器进行自定义扫描</h4><p>默认情况下，类被自动发现并注册bean的条件是：使用了<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>注解，或者使用@<code>Component</code>的自定义注解，可以通过过滤器修改上述的行为</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"regex\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\".*Stub.*Respository\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">context:include-filter</span> <span class=\"attr\">type</span>=<span class=\"string\">\"annotation\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"org.springframework.stereotype.Repository\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span>/&gt;</span>    </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>还可以使用<code>use-default-filters=&quot;false&quot;</code>禁用自动发现与注册</p>\n</blockquote>\n<h4 id=\"Bean的定义\"><a href=\"#Bean的定义\" class=\"headerlink\" title=\"Bean的定义\"></a>Bean的定义</h4><p>Bean名称是由<code>BeannameGenerator</code>生成的，默认情况下为类名的首字母变为小写</p>\n<blockquote>\n<p><code>@Component</code>，<code>@Repository</code>，<code>@Service</code>,<code>@Controller</code>都有一个那么属性用于显示设置Bean的名称,如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"beanName\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanAnnotation</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>也可自定义命名策略,实现<code>BeanNameGenerator</code>接口，并一定要包含一个无参构造器<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span> <span class=\"attr\">name-generator</span>=<span class=\"string\">\"org.example.MyNameGenerator\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Bean的作用域\"><a href=\"#Bean的作用域\" class=\"headerlink\" title=\"Bean的作用域\"></a>Bean的作用域</h4><p>通常情况下启动查找的Spring组件，其scope是<code>singleton</code>，可用<code>@Scope</code>表示scope,<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(<span class=\"string\">\"prototype\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>也可自定义scope策略，实现实现<code>ScopeMetadataResolver</code>接口，并一定要包含一个无参构造器<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span> <span class=\"attr\">name-generator</span>=<span class=\"string\">\"org.example.MyScopeResolver\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>对于自动装配注解，参见<a href=\"/2018/07/28/Spring-Bean装配之Autowired注解/#more\">Spring Bean装配之Autowired注解</a></p>\n</blockquote>\n<h4 id=\"代理方式\"><a href=\"#代理方式\" class=\"headerlink\" title=\"代理方式\"></a>代理方式</h4><p>有三个值可选：<code>no</code>,<code>interfaces</code>,<code>targetClass</code>，默认情况下为no</p>\n<p>可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(value=<span class=\"string\">\"prototype\"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure></p>\n<p>可以在XML文件中使用<code>scope-proxy</code>属性指定代理<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"org.example\"</span> <span class=\"attr\">scope-proxy</span>=<span class=\"string\">\"interfaces\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"三、Resource-amp-ResourceLoader\"><a href=\"#三、Resource-amp-ResourceLoader\" class=\"headerlink\" title=\"三、Resource&amp;ResourceLoader\"></a>三、Resource&amp;ResourceLoader</h3><h4 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h4><p>针对资源文件的统一入口，用于Spring加载资源文件</p>\n<ul>\n<li>UrlResource:URL对应的资源，根据一个URL地址即可构建</li>\n<li>ClassPathResource：获取类路径下的资源文件</li>\n<li>FileSystemResource：获取文件系统里面的资源</li>\n<li>ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源</li>\n<li>InputStreamResource：针对于输入流封装的资源</li>\n<li>ByArrayResource：针对于字节数组封装的资源</li>\n</ul>\n<h4 id=\"ResourceLoader\"><a href=\"#ResourceLoader\" class=\"headerlink\" title=\"ResourceLoader\"></a>ResourceLoader</h4><blockquote>\n<p>i.所有的application contexts都实现了<code>ResourceLoader</code>接口，即可以通过<code>ApplicationContext</code>获得Resource实例<br>ii.使用参数的前缀说明获取资源的类型</p>\n</blockquote>\n<h5 id=\"1-类路径下的资源文件\"><a href=\"#1-类路径下的资源文件\" class=\"headerlink\" title=\"1.类路径下的资源文件\"></a>1.类路径下的资源文件</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"classpath:config.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-文件系统中的资源\"><a href=\"#2-文件系统中的资源\" class=\"headerlink\" title=\"2.文件系统中的资源\"></a>2.文件系统中的资源</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"file:/var/SpringDemo/src/main/resources/config.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-URL对应的资源\"><a href=\"#3-URL对应的资源\" class=\"headerlink\" title=\"3.URL对应的资源\"></a>3.URL对应的资源</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"url:httpS://www.pinnuli.com/index.html\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>没有前缀时，取决于<code>ApplicationContext</code>的路径（之后再添加解释）</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resource resource = applicationContext.getResource(<span class=\"string\">\"config.txt\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/196\" target=\"_blank\" rel=\"noopener\">慕课网：Spring入门篇</a></p>\n</blockquote>\n"},{"title":"Spring Bean装配之基于Java的容器注解 ","date":"2018-07-29T09:13:43.000Z","copyright":true,"_content":"\n### @Bean\n用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的<bean/>，通常和`@Configuration`配合使用\n\n```java\n@Configuration\npublic class StoreConfig {\n\n    @Bean(name = \"store\",initMethod = \"init\",destroyMethod=\"destroy\")\n    public BeanStore beanStore(){\n        return new BeanStore();\n    }\n}\n```\n相当于以下XML配置\n```XML\n<beans>\n\n    <bean id=\"store\" class=\"com.pinnuli.spring.ioc.beanannotation.BeanStore\" init-method=\"init\" destroy-method=\"destroy\"></bean>\n</beans>\n```\n> 如果`@Bean`没有指定名称，则默认为方法名，这里即是beanStore。</br>\n如果需要指定范围，即XML配置时的属性`scope`，那么可以用`@Scop`e注解，且可以配置`@Scope`注解的`proxyMode`属性来配置代理方式，即XML配置时的`scope-proxy`属性\n\n```java\n@Scope(value=\"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n```\n----\n### @ImportResource,@Value\n> 通过`@ImportResource`加载资源文件,`@Value`获取属性值，比如有文件`config.properties`内容如下：\n```\njdbc.username=root\npassword=root\nurl=127.0.0.1\n```\n\n则可以通过将此内容配置到XML文件，如`config.xml`：\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\" >\n\n    <context:property-placeholder location=\"classpath:/config.properties\"/>\n\n</beans>\n```\n\n然后在定义`bean`时，通过`@ImportResource`加载文件，通过`@Value`获取属性的值\n```java\n@Configuration\n@ImportResource(\"classpath:config.xml\")\npublic class StoreConfig {\n\n    @Value(\"${url}\")\n    private String url;\n\n    @Value(\"${jdbc.username}\")\n    private String username;\n\n    @Value(\"${password}\")\n    private String password;\n\n    @Bean\n    public MyDriverManager myDriverManager() {\n        return new MyDriverManager(url, username, password);\n    }\n}\n```\n> 注意：这里的用户名字段如果直接为`username`，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如`jdbc.username`,`jdbc.password`等\n\n----\n### 基于泛型的自动装配\n比如现有如下接口：\n```java\npublic interface Store<T> {\n}\n```\n\n`IntegerStore`和`StringStore`是他的两个实现类：\n```java\npublic class IntegerStore implements Store<Integer> {\n}\n```\n```java\npublic class StringStore implements Store<String> {\n}\n```\n那么在定义`bean`时可以按照如下方法：\n```java\n@Autowired\nprivate Store<String> s1;\n\n@Autowired\nprivate Store<Integer> s2;\n\n@Bean\npublic StringStore stringStore() {\n    return new StringStore();\n}\n\n@Bean\npublic IntegerStore integerStore() {\n    return new IntegerStore();\n}\n```\n> 那么`s1`将会自动装配到`StringStore`，`s2`将会是`IntegerStore`\n\n----\n### JSR支持\n#### JSR250的支持\n1.@Resource \n注解变量或方法，且有一个name属性值，默认`Spring`解释改值为被注入`bea`n的名称，若没有指定`name`,那么名称从方法名或者属性名得出\n```java\n@Service\npublic class JsrServie {\n\t\n\t@Resource\n\tprivate JsrDAO jsrDAO;\n\t\n\t@Resource\n\tpublic void setJsrDAO(@Named(\"jsrDAO\") JsrDAO jsrDAO) {\n\t\tthis.jsrDAO = jsrDAO;\n\t}\n}\n```\n2.@PostConstruct和@PreDestroy\n`@PostConstruct`,初始化，相当于`init-Method`属性\n`@PreDestroy`，销毁，相当于`destroy-Method`属性\n```java\n@PostConstruct\npublic void init() {\n}\n\n@PreDestroy\npublic void destroy() {\n}\n```\n#### JSR330的支持\n> 需要依赖`javax.injet`包\n\n1.@Inject\n与`@Autowired`等效，可以使用于类，属性，方法，构造器\n2.@Named\n使用特定名称进行依赖注入，与`@Component`等效\n\n```java\n@Named\npublic class JsrServie {\n\t\n\t@Inject\n\tprivate JsrDAO jsrDAO;\n\t\n\t@Inject\n\tpublic void setJsrDAO(@Named(\"jsrDAO\") JsrDAO jsrDAO) {\n\t\tthis.jsrDAO = jsrDAO;\n\t}\n}\n```\n\n> 参阅:\n  [慕课网：Spring入门篇](https://www.imooc.com/learn/196)","source":"_posts/Spring-Bean装配之基于Java的容器注解.md","raw":"---\ntitle: 'Spring Bean装配之基于Java的容器注解 '\ndate: 2018-07-29 17:13:43\ncategories: \"Spring笔记\"\ntags:\n    - JavaWeb\n    - Spring\ncopyright: true\n---\n\n### @Bean\n用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的<bean/>，通常和`@Configuration`配合使用\n\n```java\n@Configuration\npublic class StoreConfig {\n\n    @Bean(name = \"store\",initMethod = \"init\",destroyMethod=\"destroy\")\n    public BeanStore beanStore(){\n        return new BeanStore();\n    }\n}\n```\n相当于以下XML配置\n```XML\n<beans>\n\n    <bean id=\"store\" class=\"com.pinnuli.spring.ioc.beanannotation.BeanStore\" init-method=\"init\" destroy-method=\"destroy\"></bean>\n</beans>\n```\n> 如果`@Bean`没有指定名称，则默认为方法名，这里即是beanStore。</br>\n如果需要指定范围，即XML配置时的属性`scope`，那么可以用`@Scop`e注解，且可以配置`@Scope`注解的`proxyMode`属性来配置代理方式，即XML配置时的`scope-proxy`属性\n\n```java\n@Scope(value=\"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\n```\n----\n### @ImportResource,@Value\n> 通过`@ImportResource`加载资源文件,`@Value`获取属性值，比如有文件`config.properties`内容如下：\n```\njdbc.username=root\npassword=root\nurl=127.0.0.1\n```\n\n则可以通过将此内容配置到XML文件，如`config.xml`：\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\" >\n\n    <context:property-placeholder location=\"classpath:/config.properties\"/>\n\n</beans>\n```\n\n然后在定义`bean`时，通过`@ImportResource`加载文件，通过`@Value`获取属性的值\n```java\n@Configuration\n@ImportResource(\"classpath:config.xml\")\npublic class StoreConfig {\n\n    @Value(\"${url}\")\n    private String url;\n\n    @Value(\"${jdbc.username}\")\n    private String username;\n\n    @Value(\"${password}\")\n    private String password;\n\n    @Bean\n    public MyDriverManager myDriverManager() {\n        return new MyDriverManager(url, username, password);\n    }\n}\n```\n> 注意：这里的用户名字段如果直接为`username`，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如`jdbc.username`,`jdbc.password`等\n\n----\n### 基于泛型的自动装配\n比如现有如下接口：\n```java\npublic interface Store<T> {\n}\n```\n\n`IntegerStore`和`StringStore`是他的两个实现类：\n```java\npublic class IntegerStore implements Store<Integer> {\n}\n```\n```java\npublic class StringStore implements Store<String> {\n}\n```\n那么在定义`bean`时可以按照如下方法：\n```java\n@Autowired\nprivate Store<String> s1;\n\n@Autowired\nprivate Store<Integer> s2;\n\n@Bean\npublic StringStore stringStore() {\n    return new StringStore();\n}\n\n@Bean\npublic IntegerStore integerStore() {\n    return new IntegerStore();\n}\n```\n> 那么`s1`将会自动装配到`StringStore`，`s2`将会是`IntegerStore`\n\n----\n### JSR支持\n#### JSR250的支持\n1.@Resource \n注解变量或方法，且有一个name属性值，默认`Spring`解释改值为被注入`bea`n的名称，若没有指定`name`,那么名称从方法名或者属性名得出\n```java\n@Service\npublic class JsrServie {\n\t\n\t@Resource\n\tprivate JsrDAO jsrDAO;\n\t\n\t@Resource\n\tpublic void setJsrDAO(@Named(\"jsrDAO\") JsrDAO jsrDAO) {\n\t\tthis.jsrDAO = jsrDAO;\n\t}\n}\n```\n2.@PostConstruct和@PreDestroy\n`@PostConstruct`,初始化，相当于`init-Method`属性\n`@PreDestroy`，销毁，相当于`destroy-Method`属性\n```java\n@PostConstruct\npublic void init() {\n}\n\n@PreDestroy\npublic void destroy() {\n}\n```\n#### JSR330的支持\n> 需要依赖`javax.injet`包\n\n1.@Inject\n与`@Autowired`等效，可以使用于类，属性，方法，构造器\n2.@Named\n使用特定名称进行依赖注入，与`@Component`等效\n\n```java\n@Named\npublic class JsrServie {\n\t\n\t@Inject\n\tprivate JsrDAO jsrDAO;\n\t\n\t@Inject\n\tpublic void setJsrDAO(@Named(\"jsrDAO\") JsrDAO jsrDAO) {\n\t\tthis.jsrDAO = jsrDAO;\n\t}\n}\n```\n\n> 参阅:\n  [慕课网：Spring入门篇](https://www.imooc.com/learn/196)","slug":"Spring-Bean装配之基于Java的容器注解","published":1,"updated":"2018-11-12T13:01:24.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fcz000mu7yj2pn71snr","content":"<h3 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h3><p>用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的<bean>，通常和<code>@Configuration</code>配合使用</bean></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name = <span class=\"string\">\"store\"</span>,initMethod = <span class=\"string\">\"init\"</span>,destroyMethod=<span class=\"string\">\"destroy\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BeanStore <span class=\"title\">beanStore</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BeanStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相当于以下XML配置<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"store\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.beanannotation.BeanStore\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果<code>@Bean</code>没有指定名称，则默认为方法名，这里即是beanStore。<br><br>如果需要指定范围，即XML配置时的属性<code>scope</code>，那么可以用<code>@Scop</code>e注解，且可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(value=<span class=\"string\">\"prototype\"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"ImportResource-Value\"><a href=\"#ImportResource-Value\" class=\"headerlink\" title=\"@ImportResource,@Value\"></a>@ImportResource,@Value</h3><blockquote>\n<p>通过<code>@ImportResource</code>加载资源文件,<code>@Value</code>获取属性值，比如有文件<code>config.properties</code>内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.username=root</span><br><span class=\"line\">password=root</span><br><span class=\"line\">url=127.0.0.1</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>则可以通过将此内容配置到XML文件，如<code>config.xml</code>：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context/spring-context.xsd\"</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:/config.properties\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后在定义<code>bean</code>时，通过<code>@ImportResource</code>加载文件，通过<code>@Value</code>获取属性的值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(<span class=\"string\">\"classpath:config.xml\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;url&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;jdbc.username&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;password&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MyDriverManager <span class=\"title\">myDriverManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyDriverManager(url, username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：这里的用户名字段如果直接为<code>username</code>，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如<code>jdbc.username</code>,<code>jdbc.password</code>等</p>\n</blockquote>\n<hr>\n<h3 id=\"基于泛型的自动装配\"><a href=\"#基于泛型的自动装配\" class=\"headerlink\" title=\"基于泛型的自动装配\"></a>基于泛型的自动装配</h3><p>比如现有如下接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>IntegerStore</code>和<code>StringStore</code>是他的两个实现类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerStore</span> <span class=\"keyword\">implements</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringStore</span> <span class=\"keyword\">implements</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在定义<code>bean</code>时可以按照如下方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Store&lt;String&gt; s1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Store&lt;Integer&gt; s2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringStore <span class=\"title\">stringStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StringStore();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IntegerStore <span class=\"title\">integerStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IntegerStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>那么<code>s1</code>将会自动装配到<code>StringStore</code>，<code>s2</code>将会是<code>IntegerStore</code></p>\n</blockquote>\n<hr>\n<h3 id=\"JSR支持\"><a href=\"#JSR支持\" class=\"headerlink\" title=\"JSR支持\"></a>JSR支持</h3><h4 id=\"JSR250的支持\"><a href=\"#JSR250的支持\" class=\"headerlink\" title=\"JSR250的支持\"></a>JSR250的支持</h4><p>1.@Resource<br>注解变量或方法，且有一个name属性值，默认<code>Spring</code>解释改值为被注入<code>bea</code>n的名称，若没有指定<code>name</code>,那么名称从方法名或者属性名得出<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsrServie</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Resource</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> JsrDAO jsrDAO;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Resource</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setJsrDAO</span><span class=\"params\">(@Named(<span class=\"string\">\"jsrDAO\"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.jsrDAO = jsrDAO;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.@PostConstruct和@PreDestroy<br><code>@PostConstruct</code>,初始化，相当于<code>init-Method</code>属性<br><code>@PreDestroy</code>，销毁，相当于<code>destroy-Method</code>属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSR330的支持\"><a href=\"#JSR330的支持\" class=\"headerlink\" title=\"JSR330的支持\"></a>JSR330的支持</h4><blockquote>\n<p>需要依赖<code>javax.injet</code>包</p>\n</blockquote>\n<p>1.@Inject<br>与<code>@Autowired</code>等效，可以使用于类，属性，方法，构造器<br>2.@Named<br>使用特定名称进行依赖注入，与<code>@Component</code>等效</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Named</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsrServie</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> JsrDAO jsrDAO;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setJsrDAO</span><span class=\"params\">(@Named(<span class=\"string\">\"jsrDAO\"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.jsrDAO = jsrDAO;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅:<br>  <a href=\"https://www.imooc.com/learn/196\" target=\"_blank\" rel=\"noopener\">慕课网：Spring入门篇</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"@Bean\"></a>@Bean</h3><p>用于配置和初始化一个有SpringIOC容器管理的新对象的方法，类似于XML配置文件的<bean>，通常和<code>@Configuration</code>配合使用</bean></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name = <span class=\"string\">\"store\"</span>,initMethod = <span class=\"string\">\"init\"</span>,destroyMethod=<span class=\"string\">\"destroy\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BeanStore <span class=\"title\">beanStore</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BeanStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相当于以下XML配置<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"store\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.pinnuli.spring.ioc.beanannotation.BeanStore\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"destroy\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果<code>@Bean</code>没有指定名称，则默认为方法名，这里即是beanStore。<br><br>如果需要指定范围，即XML配置时的属性<code>scope</code>，那么可以用<code>@Scop</code>e注解，且可以配置<code>@Scope</code>注解的<code>proxyMode</code>属性来配置代理方式，即XML配置时的<code>scope-proxy</code>属性</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scope</span>(value=<span class=\"string\">\"prototype\"</span>, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"ImportResource-Value\"><a href=\"#ImportResource-Value\" class=\"headerlink\" title=\"@ImportResource,@Value\"></a>@ImportResource,@Value</h3><blockquote>\n<p>通过<code>@ImportResource</code>加载资源文件,<code>@Value</code>获取属性值，比如有文件<code>config.properties</code>内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.username=root</span><br><span class=\"line\">password=root</span><br><span class=\"line\">url=127.0.0.1</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>则可以通过将此内容配置到XML文件，如<code>config.xml</code>：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">        http://www.springframework.org/schema/context/spring-context.xsd\"</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:/config.properties\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后在定义<code>bean</code>时，通过<code>@ImportResource</code>加载文件，通过<code>@Value</code>获取属性的值<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ImportResource</span>(<span class=\"string\">\"classpath:config.xml\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;url&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;jdbc.username&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"$&#123;password&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MyDriverManager <span class=\"title\">myDriverManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyDriverManager(url, username, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：这里的用户名字段如果直接为<code>username</code>，那么得到的将是当前系统的用户名，而不是文件中的属性值，所以一般此类属性名称加前缀，如<code>jdbc.username</code>,<code>jdbc.password</code>等</p>\n</blockquote>\n<hr>\n<h3 id=\"基于泛型的自动装配\"><a href=\"#基于泛型的自动装配\" class=\"headerlink\" title=\"基于泛型的自动装配\"></a>基于泛型的自动装配</h3><p>比如现有如下接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>IntegerStore</code>和<code>StringStore</code>是他的两个实现类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerStore</span> <span class=\"keyword\">implements</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringStore</span> <span class=\"keyword\">implements</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么在定义<code>bean</code>时可以按照如下方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Store&lt;String&gt; s1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Store&lt;Integer&gt; s2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringStore <span class=\"title\">stringStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StringStore();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IntegerStore <span class=\"title\">integerStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IntegerStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>那么<code>s1</code>将会自动装配到<code>StringStore</code>，<code>s2</code>将会是<code>IntegerStore</code></p>\n</blockquote>\n<hr>\n<h3 id=\"JSR支持\"><a href=\"#JSR支持\" class=\"headerlink\" title=\"JSR支持\"></a>JSR支持</h3><h4 id=\"JSR250的支持\"><a href=\"#JSR250的支持\" class=\"headerlink\" title=\"JSR250的支持\"></a>JSR250的支持</h4><p>1.@Resource<br>注解变量或方法，且有一个name属性值，默认<code>Spring</code>解释改值为被注入<code>bea</code>n的名称，若没有指定<code>name</code>,那么名称从方法名或者属性名得出<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsrServie</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Resource</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> JsrDAO jsrDAO;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Resource</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setJsrDAO</span><span class=\"params\">(@Named(<span class=\"string\">\"jsrDAO\"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.jsrDAO = jsrDAO;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.@PostConstruct和@PreDestroy<br><code>@PostConstruct</code>,初始化，相当于<code>init-Method</code>属性<br><code>@PreDestroy</code>，销毁，相当于<code>destroy-Method</code>属性<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSR330的支持\"><a href=\"#JSR330的支持\" class=\"headerlink\" title=\"JSR330的支持\"></a>JSR330的支持</h4><blockquote>\n<p>需要依赖<code>javax.injet</code>包</p>\n</blockquote>\n<p>1.@Inject<br>与<code>@Autowired</code>等效，可以使用于类，属性，方法，构造器<br>2.@Named<br>使用特定名称进行依赖注入，与<code>@Component</code>等效</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Named</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsrServie</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> JsrDAO jsrDAO;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setJsrDAO</span><span class=\"params\">(@Named(<span class=\"string\">\"jsrDAO\"</span>)</span> JsrDAO jsrDAO) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.jsrDAO = jsrDAO;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅:<br>  <a href=\"https://www.imooc.com/learn/196\" target=\"_blank\" rel=\"noopener\">慕课网：Spring入门篇</a></p>\n</blockquote>\n"},{"title":"centos7 Let's Encrypt用Certbot获取Https证书 部署nginx","date":"2018-07-15T09:24:42.000Z","_content":"\n1.检查nginx下是否有`--with-http_stub_status_module` 和`--with-http_ssl_module`两个模块，安装之后再重新编译\n```bash\n\t nginx -V\n```\n\n2.用http克隆github上的certbot\n```bash\n\tgit clone https://github.com/certbot/certbot /opt/certbot-master\n```\n\t\n3.安装所有依赖\n```bash\n \t/opt/certbot-master/letsencrypt-auto --help\n```\n4.关闭nginx，检出80端口，443端口是否有开启\n```\n\tnginx -s stop\n```\n```\n\tfirewall-cmd --query-port=80/tcp\n```\n```\n\tfirewall-cmd --query-port=443/tcp\n```\n没有的话就开启\n```\n\tfirewall-cmd --permanent --zone=public --add-port=80/tcp\n```\n5.获取证书\n```\n\t/opt/certbot-master/letsencrypt-auto --nginx -d www.pinnuli.com \n```\n6.配置nginx（也可选择自动配置)\n```bash\n\t\nuser nginx;\nworker_processes auto;\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n\ninclude /usr/share/nginx/modules/*.conf;\n\nevents {\n\tworker_connections 1024;\n}\n\nhttp {\n\tlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" \n\t\t\t\t'$status $body_bytes_sent \"$http_referer\" '\n\t\t\t\t'\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n\taccess_log  /var/log/nginx/access.log  main;\n\n\tsendfile            on;\n\ttcp_nopush          on;\n\ttcp_nodelay         on;\n\tkeepalive_timeout   65;\n\ttypes_hash_max_size 2048;\n\n\tinclude             /etc/nginx/mime.types;\n\tdefault_type        application/octet-stream;\n\n\tinclude /etc/nginx/conf.d/*.conf;\n\n\tserver {\n\t\tlisten       80 default_server;\n\t\tlisten       [::]:80 default_server;\n\t\tserver_name  _;\n\t\troot        /var/www/pinnuli.github.io;\n\n\t\tinclude /etc/nginx/default.d/*.conf;\n\n\t\tlocation / {\n\t\t}\n\n\t\terror_page 404 /404.html;\n\t\tlocation = /40x.html {\n\t\t}\n\n\t\terror_page 500 502 503 504 /50x.html;\n\t\tlocation = /50x.html {\n\t\t}\n\t}\n\tserver {\n\t\t\tserver_name www.pinnuli.com; # managed by Certbot\n\t\t\troot        /var/www/pinnuli.github.io;\n\t\t\tinclude /etc/nginx/default.d/*.conf;\n\t\t\tlocation / {\n\t\t\t}\n\t\t\terror_page 404 /404.html;\n\t\t\tlocation = /40x.html {\n\t\t\t}\n\t\t\terror_page 500 502 503 504 /50x.html;\n\t\t\tlocation = /50x.html {\n\t\t\t}\n\t\t\tlisten [::]:443 ssl ipv6only=on; # managed by Certbot\n\t\t\tlisten 443 ssl; # managed by Certbot\n\t\t\tssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot\n\t\t\tssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot\n\t\t\tinclude /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n\t\t\tssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n\t}\n}\n```\n7.设置自动更新\n\n未完待续。。。","source":"_posts/centos7-Let-s-Encrypt用Certbot获取Https证书-部署nginx.md","raw":"title: centos7 Let's Encrypt用Certbot获取Https证书 部署nginx\ndate: 2018-07-15 17:24:42\ncategories: \"服务器\"\ntags:\n\t- 服务器\n---\n\n1.检查nginx下是否有`--with-http_stub_status_module` 和`--with-http_ssl_module`两个模块，安装之后再重新编译\n```bash\n\t nginx -V\n```\n\n2.用http克隆github上的certbot\n```bash\n\tgit clone https://github.com/certbot/certbot /opt/certbot-master\n```\n\t\n3.安装所有依赖\n```bash\n \t/opt/certbot-master/letsencrypt-auto --help\n```\n4.关闭nginx，检出80端口，443端口是否有开启\n```\n\tnginx -s stop\n```\n```\n\tfirewall-cmd --query-port=80/tcp\n```\n```\n\tfirewall-cmd --query-port=443/tcp\n```\n没有的话就开启\n```\n\tfirewall-cmd --permanent --zone=public --add-port=80/tcp\n```\n5.获取证书\n```\n\t/opt/certbot-master/letsencrypt-auto --nginx -d www.pinnuli.com \n```\n6.配置nginx（也可选择自动配置)\n```bash\n\t\nuser nginx;\nworker_processes auto;\nerror_log /var/log/nginx/error.log;\npid /run/nginx.pid;\n\ninclude /usr/share/nginx/modules/*.conf;\n\nevents {\n\tworker_connections 1024;\n}\n\nhttp {\n\tlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" \n\t\t\t\t'$status $body_bytes_sent \"$http_referer\" '\n\t\t\t\t'\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n\taccess_log  /var/log/nginx/access.log  main;\n\n\tsendfile            on;\n\ttcp_nopush          on;\n\ttcp_nodelay         on;\n\tkeepalive_timeout   65;\n\ttypes_hash_max_size 2048;\n\n\tinclude             /etc/nginx/mime.types;\n\tdefault_type        application/octet-stream;\n\n\tinclude /etc/nginx/conf.d/*.conf;\n\n\tserver {\n\t\tlisten       80 default_server;\n\t\tlisten       [::]:80 default_server;\n\t\tserver_name  _;\n\t\troot        /var/www/pinnuli.github.io;\n\n\t\tinclude /etc/nginx/default.d/*.conf;\n\n\t\tlocation / {\n\t\t}\n\n\t\terror_page 404 /404.html;\n\t\tlocation = /40x.html {\n\t\t}\n\n\t\terror_page 500 502 503 504 /50x.html;\n\t\tlocation = /50x.html {\n\t\t}\n\t}\n\tserver {\n\t\t\tserver_name www.pinnuli.com; # managed by Certbot\n\t\t\troot        /var/www/pinnuli.github.io;\n\t\t\tinclude /etc/nginx/default.d/*.conf;\n\t\t\tlocation / {\n\t\t\t}\n\t\t\terror_page 404 /404.html;\n\t\t\tlocation = /40x.html {\n\t\t\t}\n\t\t\terror_page 500 502 503 504 /50x.html;\n\t\t\tlocation = /50x.html {\n\t\t\t}\n\t\t\tlisten [::]:443 ssl ipv6only=on; # managed by Certbot\n\t\t\tlisten 443 ssl; # managed by Certbot\n\t\t\tssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot\n\t\t\tssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot\n\t\t\tinclude /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n\t\t\tssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n\t}\n}\n```\n7.设置自动更新\n\n未完待续。。。","slug":"centos7-Let-s-Encrypt用Certbot获取Https证书-部署nginx","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fd1000pu7yjquuf0ki3","content":"<p>1.检查nginx下是否有<code>--with-http_stub_status_module</code> 和<code>--with-http_ssl_module</code>两个模块，安装之后再重新编译<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure></p>\n<p>2.用http克隆github上的certbot<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/certbot/certbot /opt/certbot-master</span><br></pre></td></tr></table></figure></p>\n<p>3.安装所有依赖<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/opt/certbot-master/letsencrypt-auto --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></p>\n<p>4.关闭nginx，检出80端口，443端口是否有开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s stop</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --query-port=80/tcp</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --query-port=443/tcp</span><br></pre></td></tr></table></figure>\n<p>没有的话就开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --permanent --zone=public --add-port=80/tcp</span><br></pre></td></tr></table></figure></p>\n<p>5.获取证书<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/opt/certbot-master/letsencrypt-auto --nginx -d www.pinnuli.com</span><br></pre></td></tr></table></figure></p>\n<p>6.配置nginx（也可选择自动配置)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">user nginx;</span><br><span class=\"line\">worker_processes auto;</span><br><span class=\"line\">error_log /var/<span class=\"built_in\">log</span>/nginx/error.log;</span><br><span class=\"line\">pid /run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">include /usr/share/nginx/modules/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">\tworker_connections 1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">\tlog_format  main  <span class=\"string\">'$remote_addr - $remote_user [$time_local] \"$request\" </span></span><br><span class=\"line\"><span class=\"string\">\t\t\t\t'</span><span class=\"variable\">$status</span> <span class=\"variable\">$body_bytes_sent</span> <span class=\"string\">\"<span class=\"variable\">$http_referer</span>\"</span> <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t\t'</span><span class=\"string\">\"<span class=\"variable\">$http_user_agent</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$http_x_forwarded_for</span>\"</span><span class=\"string\">';</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\taccess_log  /var/log/nginx/access.log  main;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tsendfile            on;</span></span><br><span class=\"line\"><span class=\"string\">\ttcp_nopush          on;</span></span><br><span class=\"line\"><span class=\"string\">\ttcp_nodelay         on;</span></span><br><span class=\"line\"><span class=\"string\">\tkeepalive_timeout   65;</span></span><br><span class=\"line\"><span class=\"string\">\ttypes_hash_max_size 2048;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tinclude             /etc/nginx/mime.types;</span></span><br><span class=\"line\"><span class=\"string\">\tdefault_type        application/octet-stream;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tinclude /etc/nginx/conf.d/*.conf;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tserver &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlisten       80 default_server;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlisten       [::]:80 default_server;</span></span><br><span class=\"line\"><span class=\"string\">\t\tserver_name  _;</span></span><br><span class=\"line\"><span class=\"string\">\t\troot        /var/www/pinnuli.github.io;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\tinclude /etc/nginx/default.d/*.conf;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\tlocation / &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\terror_page 404 /404.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlocation = /40x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\terror_page 500 502 503 504 /50x.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlocation = /50x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\tserver &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tserver_name www.pinnuli.com; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\troot        /var/www/pinnuli.github.io;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tinclude /etc/nginx/default.d/*.conf;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlocation / &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\terror_page 404 /404.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlocation = /40x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\terror_page 500 502 503 504 /50x.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlocation = /50x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlisten [::]:443 ssl ipv6only=on; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlisten 443 ssl; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tinclude /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>7.设置自动更新</p>\n<p>未完待续。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.检查nginx下是否有<code>--with-http_stub_status_module</code> 和<code>--with-http_ssl_module</code>两个模块，安装之后再重新编译<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure></p>\n<p>2.用http克隆github上的certbot<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/certbot/certbot /opt/certbot-master</span><br></pre></td></tr></table></figure></p>\n<p>3.安装所有依赖<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/opt/certbot-master/letsencrypt-auto --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></p>\n<p>4.关闭nginx，检出80端口，443端口是否有开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s stop</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --query-port=80/tcp</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --query-port=443/tcp</span><br></pre></td></tr></table></figure>\n<p>没有的话就开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --permanent --zone=public --add-port=80/tcp</span><br></pre></td></tr></table></figure></p>\n<p>5.获取证书<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/opt/certbot-master/letsencrypt-auto --nginx -d www.pinnuli.com</span><br></pre></td></tr></table></figure></p>\n<p>6.配置nginx（也可选择自动配置)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">user nginx;</span><br><span class=\"line\">worker_processes auto;</span><br><span class=\"line\">error_log /var/<span class=\"built_in\">log</span>/nginx/error.log;</span><br><span class=\"line\">pid /run/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\">include /usr/share/nginx/modules/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">\tworker_connections 1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">\tlog_format  main  <span class=\"string\">'$remote_addr - $remote_user [$time_local] \"$request\" </span></span><br><span class=\"line\"><span class=\"string\">\t\t\t\t'</span><span class=\"variable\">$status</span> <span class=\"variable\">$body_bytes_sent</span> <span class=\"string\">\"<span class=\"variable\">$http_referer</span>\"</span> <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t\t'</span><span class=\"string\">\"<span class=\"variable\">$http_user_agent</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$http_x_forwarded_for</span>\"</span><span class=\"string\">';</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\taccess_log  /var/log/nginx/access.log  main;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tsendfile            on;</span></span><br><span class=\"line\"><span class=\"string\">\ttcp_nopush          on;</span></span><br><span class=\"line\"><span class=\"string\">\ttcp_nodelay         on;</span></span><br><span class=\"line\"><span class=\"string\">\tkeepalive_timeout   65;</span></span><br><span class=\"line\"><span class=\"string\">\ttypes_hash_max_size 2048;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tinclude             /etc/nginx/mime.types;</span></span><br><span class=\"line\"><span class=\"string\">\tdefault_type        application/octet-stream;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tinclude /etc/nginx/conf.d/*.conf;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\tserver &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlisten       80 default_server;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlisten       [::]:80 default_server;</span></span><br><span class=\"line\"><span class=\"string\">\t\tserver_name  _;</span></span><br><span class=\"line\"><span class=\"string\">\t\troot        /var/www/pinnuli.github.io;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\tinclude /etc/nginx/default.d/*.conf;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\tlocation / &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\terror_page 404 /404.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlocation = /40x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">\t\terror_page 500 502 503 504 /50x.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\tlocation = /50x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\tserver &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tserver_name www.pinnuli.com; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\troot        /var/www/pinnuli.github.io;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tinclude /etc/nginx/default.d/*.conf;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlocation / &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\terror_page 404 /404.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlocation = /40x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\terror_page 500 502 503 504 /50x.html;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlocation = /50x.html &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlisten [::]:443 ssl ipv6only=on; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tlisten 443 ssl; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tssl_certificate /etc/letsencrypt/live/www.pinnuli.com/fullchain.pem; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tssl_certificate_key /etc/letsencrypt/live/www.pinnuli.com/privkey.pem; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tinclude /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t\t\tssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>7.设置自动更新</p>\n<p>未完待续。。。</p>\n"},{"title":"Spring Bean装配之Autowired注解","date":"2018-07-28T14:36:17.000Z","_content":"\n### 1.可以将@Autowired注解为setter方法\n```java\n@Autowired\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n\n----\n### 2.可以用于构造器或成员变量\n\n```java\n@Autowired(required=false)\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n默认情况下，如果因找不到合适的`bean`将会导致`autowiring`失败抛出异常，可以通过将其`required`设置为false表示并非必须，每个类只能有一个构造器标记为`required=true`,也就是只能有一个构造器为必须，这种情况下建议使用`@Required`注解：\n\n```java\n@Required\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n > `@Required`表示标记的`bean`属性在`bean`装配时必须被填充，通过在`bean`定义或者自动装配一个明确的属性值\n\n----\n\n### 3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等\n```java\npublic class BeanSutowired{\n    @Autowired\n    private ApplicationContext context;\n}\n```\n----\n### 4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\n下面的示例中，`list`添加了`@Autowired`注解，那么所有的实现`BeanInterface`接口的`bean`，假如有`BeanimplOne`和`BeanimplTwo`都实现了`BeanInterface`接口，那么这时`list`中将包含有`BeanimplOne`和`BeanimplTwo`。\n\n```java\n@Component\npublic class BeanInvoker implements BeanInterface{\n\n    @Autowired\n    private List<BeanInterface> list;\n\n    public void say(){\n        System.out.println(\"list...\");\n        for (BeanInterface bean : list) {\n            System.out.println(bean.getClass().getName());\n        }\n}\n```\n> 如果希望数组有序，可以使用`@Order`注解或者实现`org.springframework.core.Ordered`接口，但是对`map`无效\n\n```java\n@Order(1)\n@Component\npublic class BeanimplTwo implements BeanInterface{\n}\n```\n----\n### 5.用于装配key为String的Map\n下面的示例中，`map`添加了`@Autowired`注解，那么所有的实现`BeanInterface`接口的`bean`，加入有`BeanimplOne`和`BeanimplTwo`都实现了`BeanInterface`接口，那么这时map中将包含有键为`bean`名称和值为`bean`的两个元素。\n```java\n@Component\npublic class BeanInvoker implements BeanInterface{\n\n    @Autowired\n    private Map<String, BeanInterface> map;\n\n    public void say(){\n        System.out.println(\"map...\");\n        for (Map.Entry<String, BeanInterface> entry : map.entrySet()) {\n            System.out.println(entry.getKey() + \"      \" + entry.getValue().getClass().getName());\n        }\n}\n```\n----\n### 6.@Qualifier\n- 按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一\n \n```java\n@Autowired\n@Qualifier(\"beanImplTwo\")\nprivate BeanInterface beanInterface;\n```\n\n- 用于指定单独的构造器参数或方法参数\n- 用于注解集合类型变量\n\n可以在bean的定义中使用`@Qualifier`注解给他限定一个范围，比如\n```java\n@Qualifier(\"beanImpl\")\n@Component\npublic class BeanImplTwo implements BeanInterface{\n}\n```\n然后在注入时，使用`@Qualifier`限定，则下面的`list`将会匹配到所有`@Qualifier(\"beanImp\")`的`bean`\n```java\n@Autowired\n@Qualifier(\"beanImpl\")\nprivate List<BeanInterface> list;\n```\n\n> 参阅：\n  [慕课网：Spring入门篇](https://www.imooc.com/learn/196)","source":"_posts/Spring-Bean装配之Autowired注解.md","raw":"---\ntitle: Spring Bean装配之Autowired注解\ndate: 2018-07-28 22:36:17\ncategories: \"Spring笔记\"\ntags:\n    - Spring\n    - JavaWeb\n---\n\n### 1.可以将@Autowired注解为setter方法\n```java\n@Autowired\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n\n----\n### 2.可以用于构造器或成员变量\n\n```java\n@Autowired(required=false)\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n默认情况下，如果因找不到合适的`bean`将会导致`autowiring`失败抛出异常，可以通过将其`required`设置为false表示并非必须，每个类只能有一个构造器标记为`required=true`,也就是只能有一个构造器为必须，这种情况下建议使用`@Required`注解：\n\n```java\n@Required\npublic void setInjectionDAO(InjectionDAO injectionDAO) {\n    this.injectionDAO = injectionDAO;\n}\n```\n > `@Required`表示标记的`bean`属性在`bean`装配时必须被填充，通过在`bean`定义或者自动装配一个明确的属性值\n\n----\n\n### 3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等\n```java\npublic class BeanSutowired{\n    @Autowired\n    private ApplicationContext context;\n}\n```\n----\n### 4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\n下面的示例中，`list`添加了`@Autowired`注解，那么所有的实现`BeanInterface`接口的`bean`，假如有`BeanimplOne`和`BeanimplTwo`都实现了`BeanInterface`接口，那么这时`list`中将包含有`BeanimplOne`和`BeanimplTwo`。\n\n```java\n@Component\npublic class BeanInvoker implements BeanInterface{\n\n    @Autowired\n    private List<BeanInterface> list;\n\n    public void say(){\n        System.out.println(\"list...\");\n        for (BeanInterface bean : list) {\n            System.out.println(bean.getClass().getName());\n        }\n}\n```\n> 如果希望数组有序，可以使用`@Order`注解或者实现`org.springframework.core.Ordered`接口，但是对`map`无效\n\n```java\n@Order(1)\n@Component\npublic class BeanimplTwo implements BeanInterface{\n}\n```\n----\n### 5.用于装配key为String的Map\n下面的示例中，`map`添加了`@Autowired`注解，那么所有的实现`BeanInterface`接口的`bean`，加入有`BeanimplOne`和`BeanimplTwo`都实现了`BeanInterface`接口，那么这时map中将包含有键为`bean`名称和值为`bean`的两个元素。\n```java\n@Component\npublic class BeanInvoker implements BeanInterface{\n\n    @Autowired\n    private Map<String, BeanInterface> map;\n\n    public void say(){\n        System.out.println(\"map...\");\n        for (Map.Entry<String, BeanInterface> entry : map.entrySet()) {\n            System.out.println(entry.getKey() + \"      \" + entry.getValue().getClass().getName());\n        }\n}\n```\n----\n### 6.@Qualifier\n- 按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一\n \n```java\n@Autowired\n@Qualifier(\"beanImplTwo\")\nprivate BeanInterface beanInterface;\n```\n\n- 用于指定单独的构造器参数或方法参数\n- 用于注解集合类型变量\n\n可以在bean的定义中使用`@Qualifier`注解给他限定一个范围，比如\n```java\n@Qualifier(\"beanImpl\")\n@Component\npublic class BeanImplTwo implements BeanInterface{\n}\n```\n然后在注入时，使用`@Qualifier`限定，则下面的`list`将会匹配到所有`@Qualifier(\"beanImp\")`的`bean`\n```java\n@Autowired\n@Qualifier(\"beanImpl\")\nprivate List<BeanInterface> list;\n```\n\n> 参阅：\n  [慕课网：Spring入门篇](https://www.imooc.com/learn/196)","slug":"Spring-Bean装配之Autowired注解","published":1,"updated":"2018-11-12T13:00:24.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fd2000tu7yjif59usok","content":"<h3 id=\"1-可以将-Autowired注解为setter方法\"><a href=\"#1-可以将-Autowired注解为setter方法\" class=\"headerlink\" title=\"1.可以将@Autowired注解为setter方法\"></a>1.可以将@Autowired注解为setter方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-可以用于构造器或成员变量\"><a href=\"#2-可以用于构造器或成员变量\" class=\"headerlink\" title=\"2.可以用于构造器或成员变量\"></a>2.可以用于构造器或成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span>(required=<span class=\"keyword\">false</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，如果因找不到合适的<code>bean</code>将会导致<code>autowiring</code>失败抛出异常，可以通过将其<code>required</code>设置为false表示并非必须，每个类只能有一个构造器标记为<code>required=true</code>,也就是只能有一个构造器为必须，这种情况下建议使用<code>@Required</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Required</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>@Required</code>表示标记的<code>bean</code>属性在<code>bean</code>装配时必须被填充，通过在<code>bean</code>定义或者自动装配一个明确的属性值</p>\n</blockquote>\n<hr>\n<h3 id=\"3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等\"><a href=\"#3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等\" class=\"headerlink\" title=\"3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等\"></a>3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanSutowired</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\"><a href=\"#4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\" class=\"headerlink\" title=\"4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\"></a>4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean</h3><p>下面的示例中，<code>list</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，假如有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时<code>list</code>中将包含有<code>BeanimplOne</code>和<code>BeanimplTwo</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanInvoker</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;BeanInterface&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"list...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (BeanInterface bean : list) &#123;</span><br><span class=\"line\">            System.out.println(bean.getClass().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果希望数组有序，可以使用<code>@Order</code>注解或者实现<code>org.springframework.core.Ordered</code>接口，但是对<code>map</code>无效</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanimplTwo</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-用于装配key为String的Map\"><a href=\"#5-用于装配key为String的Map\" class=\"headerlink\" title=\"5.用于装配key为String的Map\"></a>5.用于装配key为String的Map</h3><p>下面的示例中，<code>map</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，加入有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时map中将包含有键为<code>bean</code>名称和值为<code>bean</code>的两个元素。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanInvoker</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, BeanInterface&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"map...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, BeanInterface&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">\"      \"</span> + entry.getValue().getClass().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"6-Qualifier\"><a href=\"#6-Qualifier\" class=\"headerlink\" title=\"6.@Qualifier\"></a>6.@Qualifier</h3><ul>\n<li>按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"beanImplTwo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> BeanInterface beanInterface;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用于指定单独的构造器参数或方法参数</li>\n<li>用于注解集合类型变量</li>\n</ul>\n<p>可以在bean的定义中使用<code>@Qualifier</code>注解给他限定一个范围，比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"beanImpl\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanImplTwo</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在注入时，使用<code>@Qualifier</code>限定，则下面的<code>list</code>将会匹配到所有<code>@Qualifier(&quot;beanImp&quot;)</code>的<code>bean</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"beanImpl\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;BeanInterface&gt; list;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/196\" target=\"_blank\" rel=\"noopener\">慕课网：Spring入门篇</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-可以将-Autowired注解为setter方法\"><a href=\"#1-可以将-Autowired注解为setter方法\" class=\"headerlink\" title=\"1.可以将@Autowired注解为setter方法\"></a>1.可以将@Autowired注解为setter方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-可以用于构造器或成员变量\"><a href=\"#2-可以用于构造器或成员变量\" class=\"headerlink\" title=\"2.可以用于构造器或成员变量\"></a>2.可以用于构造器或成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span>(required=<span class=\"keyword\">false</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，如果因找不到合适的<code>bean</code>将会导致<code>autowiring</code>失败抛出异常，可以通过将其<code>required</code>设置为false表示并非必须，每个类只能有一个构造器标记为<code>required=true</code>,也就是只能有一个构造器为必须，这种情况下建议使用<code>@Required</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Required</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setInjectionDAO</span><span class=\"params\">(InjectionDAO injectionDAO)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.injectionDAO = injectionDAO;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>@Required</code>表示标记的<code>bean</code>属性在<code>bean</code>装配时必须被填充，通过在<code>bean</code>定义或者自动装配一个明确的属性值</p>\n</blockquote>\n<hr>\n<h3 id=\"3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等\"><a href=\"#3-用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource-等\" class=\"headerlink\" title=\"3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等\"></a>3.用于注解众所周知的解析依赖性借口，如BeanFactory，ApplicationCon，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 等</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanSutowired</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\"><a href=\"#4-可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\" class=\"headerlink\" title=\"4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean\"></a>4.可通过添加注解给需要该类型的数组的字段或方法，提供ApplicationContext中的所有特定类型的bean</h3><p>下面的示例中，<code>list</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，假如有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时<code>list</code>中将包含有<code>BeanimplOne</code>和<code>BeanimplTwo</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanInvoker</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;BeanInterface&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"list...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (BeanInterface bean : list) &#123;</span><br><span class=\"line\">            System.out.println(bean.getClass().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果希望数组有序，可以使用<code>@Order</code>注解或者实现<code>org.springframework.core.Ordered</code>接口，但是对<code>map</code>无效</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanimplTwo</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-用于装配key为String的Map\"><a href=\"#5-用于装配key为String的Map\" class=\"headerlink\" title=\"5.用于装配key为String的Map\"></a>5.用于装配key为String的Map</h3><p>下面的示例中，<code>map</code>添加了<code>@Autowired</code>注解，那么所有的实现<code>BeanInterface</code>接口的<code>bean</code>，加入有<code>BeanimplOne</code>和<code>BeanimplTwo</code>都实现了<code>BeanInterface</code>接口，那么这时map中将包含有键为<code>bean</code>名称和值为<code>bean</code>的两个元素。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanInvoker</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, BeanInterface&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">say</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"map...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, BeanInterface&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            System.out.println(entry.getKey() + <span class=\"string\">\"      \"</span> + entry.getValue().getClass().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"6-Qualifier\"><a href=\"#6-Qualifier\" class=\"headerlink\" title=\"6.@Qualifier\"></a>6.@Qualifier</h3><ul>\n<li>按类型自动装配可能多个bean实例的情况，可以使用Qualifier注解缩小范围或指定唯一</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"beanImplTwo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> BeanInterface beanInterface;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用于指定单独的构造器参数或方法参数</li>\n<li>用于注解集合类型变量</li>\n</ul>\n<p>可以在bean的定义中使用<code>@Qualifier</code>注解给他限定一个范围，比如<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"beanImpl\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanImplTwo</span> <span class=\"keyword\">implements</span> <span class=\"title\">BeanInterface</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在注入时，使用<code>@Qualifier</code>限定，则下面的<code>list</code>将会匹配到所有<code>@Qualifier(&quot;beanImp&quot;)</code>的<code>bean</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"beanImpl\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;BeanInterface&gt; list;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/196\" target=\"_blank\" rel=\"noopener\">慕课网：Spring入门篇</a></p>\n</blockquote>\n"},{"title":"JavaWeb 监听器","date":"2018-07-25T11:50:55.000Z","_content":"\n### 按监听的对象划分\n#### 1.用于监听应用程序环境对象（`ServletContext`）的事件监听器，实现`ServletContextListener`接口\n```java\npublic class MyServletContextListener implements ServletContextListener {\n\n\tpublic void contextInitialized(ServletContextEvent servletcontextevent) {\n\t\tString initParam = servletcontextevent.getServletContext().getInitParameter(\"initParam\");\n\t\tSystem.out.println(\"contextInitialized : initParam = \"+initParam);\n\t}\n\n\tpublic void contextDestroyed(ServletContextEvent servletcontextevent) {\n\t\tSystem.out.println(\"contextDestroyed\");\n\t}\n\n}\n```\n#### 2.用于监听用户会话对象（`HttpSession`）的事件监听器，实现`HttpSessionListener`接口\n```java\npublic class MyHttpSessionListener implements HttpSessionListener {\n\n\tpublic void sessionCreated(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionCreated\");\n\t}\n\n\tpublic void sessionDestroyed(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionDestroyed\");\n\t}\n\n}\n```\n#### 3.用于监听请求消息对象（`ServletRequest`）的事件监听器，实现`ServletRequestListener`接口\n```java\npublic class MyServletRequestListener implements ServletRequestListener {\n\n\tpublic void requestDestroyed(ServletRequestEvent servletrequestevent) {\n\t\tSystem.out.println(\"requestDestroyed \");\n\t}\n\n\tpublic void requestInitialized(ServletRequestEvent servletrequestevent) {\n\t\tString name = servletrequestevent.getServletRequest().getParameter(\"name\");\n\t\tSystem.out.println(\"requestInitialized name:\"+name);\n\t}\n\n}\n```\n----\n### 按监听的事件划分\n#### 1.监听域对象自身的创建和销毁的事件监听器\n> 即按监听对象划分的那几种\n\n#### 2.监听域对象的属性的增加和删除的事件监听器，实现`ServletContextAttributeListener`，`HttpSessionAttributeListener` 或 `ServletRequestAttributeListener`接口\n```java\npublic class MyServletContextAttributeListener implements ServletContextAttributeListener {\n\n\tpublic void attributeAdded(ServletContextAttributeEvent servletcontextattributeevent) {\n\t\tSystem.out.println(\"ServletContext_attributeAdded:\"+servletcontextattributeevent.getName());\n\t}\n\n\tpublic void attributeRemoved(ServletContextAttributeEvent servletcontextattributeevent) {\n\t\tSystem.out.println(\"ServletContext_attributeRemoved:\"+servletcontextattributeevent.getName());\n\n\t}\n\n\tpublic void attributeReplaced(ServletContextAttributeEvent servletcontextattributeevent) {\n\t\tSystem.out.println(\"ServletContext_attributeReplaced:\"+servletcontextattributeevent.getName());\n\n\t}\n\n}\n```\n> `HttpSession` 和 `ServletRequest` 同理，只是方法参数类型不同\n\n#### 3.监听绑定到`HttpSession`域中的某个对象的状态的事件监听器\n> 这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口：\n\n```java\npublic class User implements HttpSessionBindingListener,HttpSessionActivationListener,Serializable {\n\n\tprivate String username;\n\t\n\tpublic void valueBound(HttpSessionBindingEvent httpsessionbindingevent) {\n\t\tSystem.out.println(\"valueBound Name:\"+httpsessionbindingevent.getName());\n\t}\n\n\tpublic void valueUnbound(HttpSessionBindingEvent httpsessionbindingevent) {\n\t\tSystem.out.println(\"valueUnbound Name:\"+httpsessionbindingevent.getName());\n\t}\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\t//钝化\n\tpublic void sessionWillPassivate(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionWillPassivate \"+httpsessionevent.getSource());\n\t}\n\t//活化\n\tpublic void sessionDidActivate(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionDidActivate \"+httpsessionevent.getSource());\n\t}\n}\n```\n绑定和解除绑定：实现`HttpSessionBindingListener`接口\n钝化和活化：实现`HttpSessionActivationListener`和`Serializable`接口\n> 实现`Serializable`接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化\n\n> 参阅：\n  [慕课网：JAVA Web开发技术应用——监听器](https://www.imooc.com/learn/271)","source":"_posts/Java-Web-监听器.md","raw":"---\ntitle: JavaWeb 监听器\ndate: 2018-07-25 19:50:55\ncategories: \"JavaWeb笔记\"\ntags:\n    - JavaWeb\n---\n\n### 按监听的对象划分\n#### 1.用于监听应用程序环境对象（`ServletContext`）的事件监听器，实现`ServletContextListener`接口\n```java\npublic class MyServletContextListener implements ServletContextListener {\n\n\tpublic void contextInitialized(ServletContextEvent servletcontextevent) {\n\t\tString initParam = servletcontextevent.getServletContext().getInitParameter(\"initParam\");\n\t\tSystem.out.println(\"contextInitialized : initParam = \"+initParam);\n\t}\n\n\tpublic void contextDestroyed(ServletContextEvent servletcontextevent) {\n\t\tSystem.out.println(\"contextDestroyed\");\n\t}\n\n}\n```\n#### 2.用于监听用户会话对象（`HttpSession`）的事件监听器，实现`HttpSessionListener`接口\n```java\npublic class MyHttpSessionListener implements HttpSessionListener {\n\n\tpublic void sessionCreated(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionCreated\");\n\t}\n\n\tpublic void sessionDestroyed(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionDestroyed\");\n\t}\n\n}\n```\n#### 3.用于监听请求消息对象（`ServletRequest`）的事件监听器，实现`ServletRequestListener`接口\n```java\npublic class MyServletRequestListener implements ServletRequestListener {\n\n\tpublic void requestDestroyed(ServletRequestEvent servletrequestevent) {\n\t\tSystem.out.println(\"requestDestroyed \");\n\t}\n\n\tpublic void requestInitialized(ServletRequestEvent servletrequestevent) {\n\t\tString name = servletrequestevent.getServletRequest().getParameter(\"name\");\n\t\tSystem.out.println(\"requestInitialized name:\"+name);\n\t}\n\n}\n```\n----\n### 按监听的事件划分\n#### 1.监听域对象自身的创建和销毁的事件监听器\n> 即按监听对象划分的那几种\n\n#### 2.监听域对象的属性的增加和删除的事件监听器，实现`ServletContextAttributeListener`，`HttpSessionAttributeListener` 或 `ServletRequestAttributeListener`接口\n```java\npublic class MyServletContextAttributeListener implements ServletContextAttributeListener {\n\n\tpublic void attributeAdded(ServletContextAttributeEvent servletcontextattributeevent) {\n\t\tSystem.out.println(\"ServletContext_attributeAdded:\"+servletcontextattributeevent.getName());\n\t}\n\n\tpublic void attributeRemoved(ServletContextAttributeEvent servletcontextattributeevent) {\n\t\tSystem.out.println(\"ServletContext_attributeRemoved:\"+servletcontextattributeevent.getName());\n\n\t}\n\n\tpublic void attributeReplaced(ServletContextAttributeEvent servletcontextattributeevent) {\n\t\tSystem.out.println(\"ServletContext_attributeReplaced:\"+servletcontextattributeevent.getName());\n\n\t}\n\n}\n```\n> `HttpSession` 和 `ServletRequest` 同理，只是方法参数类型不同\n\n#### 3.监听绑定到`HttpSession`域中的某个对象的状态的事件监听器\n> 这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口：\n\n```java\npublic class User implements HttpSessionBindingListener,HttpSessionActivationListener,Serializable {\n\n\tprivate String username;\n\t\n\tpublic void valueBound(HttpSessionBindingEvent httpsessionbindingevent) {\n\t\tSystem.out.println(\"valueBound Name:\"+httpsessionbindingevent.getName());\n\t}\n\n\tpublic void valueUnbound(HttpSessionBindingEvent httpsessionbindingevent) {\n\t\tSystem.out.println(\"valueUnbound Name:\"+httpsessionbindingevent.getName());\n\t}\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\t//钝化\n\tpublic void sessionWillPassivate(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionWillPassivate \"+httpsessionevent.getSource());\n\t}\n\t//活化\n\tpublic void sessionDidActivate(HttpSessionEvent httpsessionevent) {\n\t\tSystem.out.println(\"sessionDidActivate \"+httpsessionevent.getSource());\n\t}\n}\n```\n绑定和解除绑定：实现`HttpSessionBindingListener`接口\n钝化和活化：实现`HttpSessionActivationListener`和`Serializable`接口\n> 实现`Serializable`接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化\n\n> 参阅：\n  [慕课网：JAVA Web开发技术应用——监听器](https://www.imooc.com/learn/271)","slug":"Java-Web-监听器","published":1,"updated":"2018-11-12T13:01:16.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fd4000wu7yj9tmxmwls","content":"<h3 id=\"按监听的对象划分\"><a href=\"#按监听的对象划分\" class=\"headerlink\" title=\"按监听的对象划分\"></a>按监听的对象划分</h3><h4 id=\"1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口\"><a href=\"#1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口\" class=\"headerlink\" title=\"1.用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口\"></a>1.用于监听应用程序环境对象（<code>ServletContext</code>）的事件监听器，实现<code>ServletContextListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletContextListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletContextListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tString initParam = servletcontextevent.getServletContext().getInitParameter(<span class=\"string\">\"initParam\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"contextInitialized : initParam = \"</span>+initParam);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDestroyed</span><span class=\"params\">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"contextDestroyed\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口\"><a href=\"#2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口\" class=\"headerlink\" title=\"2.用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口\"></a>2.用于监听用户会话对象（<code>HttpSession</code>）的事件监听器，实现<code>HttpSessionListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHttpSessionListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">HttpSessionListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionCreated</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionCreated\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionDestroyed</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionDestroyed\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口\"><a href=\"#3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口\" class=\"headerlink\" title=\"3.用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口\"></a>3.用于监听请求消息对象（<code>ServletRequest</code>）的事件监听器，实现<code>ServletRequestListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletRequestListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletRequestListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestDestroyed</span><span class=\"params\">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"requestDestroyed \"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestInitialized</span><span class=\"params\">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tString name = servletrequestevent.getServletRequest().getParameter(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"requestInitialized name:\"</span>+name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"按监听的事件划分\"><a href=\"#按监听的事件划分\" class=\"headerlink\" title=\"按监听的事件划分\"></a>按监听的事件划分</h3><h4 id=\"1-监听域对象自身的创建和销毁的事件监听器\"><a href=\"#1-监听域对象自身的创建和销毁的事件监听器\" class=\"headerlink\" title=\"1.监听域对象自身的创建和销毁的事件监听器\"></a>1.监听域对象自身的创建和销毁的事件监听器</h4><blockquote>\n<p>即按监听对象划分的那几种</p>\n</blockquote>\n<h4 id=\"2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口\"><a href=\"#2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口\" class=\"headerlink\" title=\"2.监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener 或 ServletRequestAttributeListener接口\"></a>2.监听域对象的属性的增加和删除的事件监听器，实现<code>ServletContextAttributeListener</code>，<code>HttpSessionAttributeListener</code> 或 <code>ServletRequestAttributeListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletContextAttributeListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletContextAttributeListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attributeAdded</span><span class=\"params\">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"ServletContext_attributeAdded:\"</span>+servletcontextattributeevent.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attributeRemoved</span><span class=\"params\">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"ServletContext_attributeRemoved:\"</span>+servletcontextattributeevent.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attributeReplaced</span><span class=\"params\">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"ServletContext_attributeReplaced:\"</span>+servletcontextattributeevent.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>HttpSession</code> 和 <code>ServletRequest</code> 同理，只是方法参数类型不同</p>\n</blockquote>\n<h4 id=\"3-监听绑定到HttpSession域中的某个对象的状态的事件监听器\"><a href=\"#3-监听绑定到HttpSession域中的某个对象的状态的事件监听器\" class=\"headerlink\" title=\"3.监听绑定到HttpSession域中的某个对象的状态的事件监听器\"></a>3.监听绑定到<code>HttpSession</code>域中的某个对象的状态的事件监听器</h4><blockquote>\n<p>这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">HttpSessionBindingListener</span>,<span class=\"title\">HttpSessionActivationListener</span>,<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">valueBound</span><span class=\"params\">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"valueBound Name:\"</span>+httpsessionbindingevent.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">valueUnbound</span><span class=\"params\">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"valueUnbound Name:\"</span>+httpsessionbindingevent.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//钝化</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionWillPassivate</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionWillPassivate \"</span>+httpsessionevent.getSource());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//活化</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionDidActivate</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionDidActivate \"</span>+httpsessionevent.getSource());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>绑定和解除绑定：实现<code>HttpSessionBindingListener</code>接口<br>钝化和活化：实现<code>HttpSessionActivationListener</code>和<code>Serializable</code>接口</p>\n<blockquote>\n<p>实现<code>Serializable</code>接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/271\" target=\"_blank\" rel=\"noopener\">慕课网：JAVA Web开发技术应用——监听器</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"按监听的对象划分\"><a href=\"#按监听的对象划分\" class=\"headerlink\" title=\"按监听的对象划分\"></a>按监听的对象划分</h3><h4 id=\"1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口\"><a href=\"#1-用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口\" class=\"headerlink\" title=\"1.用于监听应用程序环境对象（ServletContext）的事件监听器，实现ServletContextListener接口\"></a>1.用于监听应用程序环境对象（<code>ServletContext</code>）的事件监听器，实现<code>ServletContextListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletContextListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletContextListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tString initParam = servletcontextevent.getServletContext().getInitParameter(<span class=\"string\">\"initParam\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"contextInitialized : initParam = \"</span>+initParam);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDestroyed</span><span class=\"params\">(ServletContextEvent servletcontextevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"contextDestroyed\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口\"><a href=\"#2-用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口\" class=\"headerlink\" title=\"2.用于监听用户会话对象（HttpSession）的事件监听器，实现HttpSessionListener接口\"></a>2.用于监听用户会话对象（<code>HttpSession</code>）的事件监听器，实现<code>HttpSessionListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHttpSessionListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">HttpSessionListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionCreated</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionCreated\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionDestroyed</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionDestroyed\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口\"><a href=\"#3-用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口\" class=\"headerlink\" title=\"3.用于监听请求消息对象（ServletRequest）的事件监听器，实现ServletRequestListener接口\"></a>3.用于监听请求消息对象（<code>ServletRequest</code>）的事件监听器，实现<code>ServletRequestListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletRequestListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletRequestListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestDestroyed</span><span class=\"params\">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"requestDestroyed \"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestInitialized</span><span class=\"params\">(ServletRequestEvent servletrequestevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tString name = servletrequestevent.getServletRequest().getParameter(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"requestInitialized name:\"</span>+name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"按监听的事件划分\"><a href=\"#按监听的事件划分\" class=\"headerlink\" title=\"按监听的事件划分\"></a>按监听的事件划分</h3><h4 id=\"1-监听域对象自身的创建和销毁的事件监听器\"><a href=\"#1-监听域对象自身的创建和销毁的事件监听器\" class=\"headerlink\" title=\"1.监听域对象自身的创建和销毁的事件监听器\"></a>1.监听域对象自身的创建和销毁的事件监听器</h4><blockquote>\n<p>即按监听对象划分的那几种</p>\n</blockquote>\n<h4 id=\"2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口\"><a href=\"#2-监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener-或-ServletRequestAttributeListener接口\" class=\"headerlink\" title=\"2.监听域对象的属性的增加和删除的事件监听器，实现ServletContextAttributeListener，HttpSessionAttributeListener 或 ServletRequestAttributeListener接口\"></a>2.监听域对象的属性的增加和删除的事件监听器，实现<code>ServletContextAttributeListener</code>，<code>HttpSessionAttributeListener</code> 或 <code>ServletRequestAttributeListener</code>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServletContextAttributeListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletContextAttributeListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attributeAdded</span><span class=\"params\">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"ServletContext_attributeAdded:\"</span>+servletcontextattributeevent.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attributeRemoved</span><span class=\"params\">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"ServletContext_attributeRemoved:\"</span>+servletcontextattributeevent.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attributeReplaced</span><span class=\"params\">(ServletContextAttributeEvent servletcontextattributeevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"ServletContext_attributeReplaced:\"</span>+servletcontextattributeevent.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>HttpSession</code> 和 <code>ServletRequest</code> 同理，只是方法参数类型不同</p>\n</blockquote>\n<h4 id=\"3-监听绑定到HttpSession域中的某个对象的状态的事件监听器\"><a href=\"#3-监听绑定到HttpSession域中的某个对象的状态的事件监听器\" class=\"headerlink\" title=\"3.监听绑定到HttpSession域中的某个对象的状态的事件监听器\"></a>3.监听绑定到<code>HttpSession</code>域中的某个对象的状态的事件监听器</h4><blockquote>\n<p>这种情况不需要专门设计一个作为监听器的类，可以作为一个实体类，然后继承需要的接口：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">implements</span> <span class=\"title\">HttpSessionBindingListener</span>,<span class=\"title\">HttpSessionActivationListener</span>,<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">valueBound</span><span class=\"params\">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"valueBound Name:\"</span>+httpsessionbindingevent.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">valueUnbound</span><span class=\"params\">(HttpSessionBindingEvent httpsessionbindingevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"valueUnbound Name:\"</span>+httpsessionbindingevent.getName());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//钝化</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionWillPassivate</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionWillPassivate \"</span>+httpsessionevent.getSource());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//活化</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sessionDidActivate</span><span class=\"params\">(HttpSessionEvent httpsessionevent)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"sessionDidActivate \"</span>+httpsessionevent.getSource());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>绑定和解除绑定：实现<code>HttpSessionBindingListener</code>接口<br>钝化和活化：实现<code>HttpSessionActivationListener</code>和<code>Serializable</code>接口</p>\n<blockquote>\n<p>实现<code>Serializable</code>接口是因为钝化时需要将seesion序列化存储到文件或者数据库，活化时需要反序列化</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/271\" target=\"_blank\" rel=\"noopener\">慕课网：JAVA Web开发技术应用——监听器</a></p>\n</blockquote>\n"},{"title":"Java中的XML之与HTML的区别验证，定位信息，命名空间","date":"2018-07-30T04:19:45.000Z","copyright":null,"_content":"### HTML与XML的区别\n- HTML对大小写不敏感，XML大小写敏感\n- HTML结束标签可以省略，如`</p>`，XML不能\n- XML只有单个标签而没有结束标签的元素必须以`/`结束\n- XML属性值必须用引号括起来\n- HTML属性可以没有值，XML所有属性必须有值    \n\n----\n### 验证XML文档\n需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema\n#### 文档类型定义\n- 将这些规则纳入XML文档\n\n```XML\n<?xml version=\"1.0\"?>\n<!DOCTYPE configuration[\n\n    <!ELEMENT configuration...>\n    ...\n]>\n<configuration>\n...\n</configuration>\n```\n\n>这些规则被纳入到DOCTYPE声明中，代码块[...]用来限定其界限，比如configuration\n\n- SYSTEM声明，将DTD存储在外面\n\n```XML\n<!DOCTYPE configuration SYSTEM \"config.dtd\">\n<!DOCTYPE configuration SYSTEM \"http://myserver.com/config.dtd\">\n```\n- 标记PUBLIC标识符\n\n```java\nclass MyEntityResolver implements EntityResolver{\n    public InputSource resolveEntity(String publicId, String systemID){\n        if(publicID.equals(a knowx ID)){\n            return new InputSource(DTD data):\n        }else{\n            return null;\n        }\n    }\n}\n```\n>PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空\n\n#### XML Schema\n- 声明Schema文件\n```XML\n<?xml version=\"1.0\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n</project>\n```\n- 使用xsd:表示XSL Schema定义的命名空间\n```XML\n<xsd:element name=\"name\" type=\"xsd:string\"/>\n- ref属性引用Schema中位于别处的定义\n<xsd:element ref=\"name\"/>\n<xsd:element name=\"style\" type=StyleType\"/>\n    <xsd:restriction base=\"xsd:string\"/>\n        <xsd:enumeration value=\"PLAIN\"/>\n    </xsd:restriction>\n</xsd:element>\n```\n----\n### 使用XPath定位信息\n- 查找下列的username的值，,通过XPath表达式/configuration/database/username\n```XML\n<configfuration>\n    <database>\n        <username id=\"test\">pinnuli</username>\n        <password>123456</password>\n    </database>\n</configfuration>\n```\n- 用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式\n```XML\nXPathFactory xpFactory = XPathFactory.newInstance();\npath = xpfactory.newXPath();\nString username = path.evaluate(/configuration/database/username\",doc);\n```\n>具体的语法看文档\n\n----\n### XML的命名空间\n- 使用xmlns给定命名空间\n```XML\n<element xmlns=\"namespaceURI1\">\n    <child xmlns=\"namespaceURI2\">\n        grandchildren\n    </child>\n</element>\n```\n    >这里第一个子元素和孙元素都是第二个命名空间的一部分\n- 使用xmlns:prefix=\"namespaceURI\"定义命名空间和前缀\n``` \n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n    <xsd:element name=\"pinnuli\" type=\"haha\"/>\n    ...\n</xsd:schema>\n```\n    >在这里xsd:schema实际上指的是命名空间`http://www.w3.org/2001/XMLSchema`中的`schema`\n- 可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性\n```\nfactory.serNamespaceAware(true);\n```\n----\n\n> 参阅：\n  [慕课网：Java眼中的XML---文件读取](https://www.imooc.com/learn/171)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)","source":"_posts/Java中的XML之与HTML的区别验证，定位信息，命名空间.md","raw":"---\ntitle: Java中的XML之与HTML的区别验证，定位信息，命名空间\ndate: 2018-07-30 12:19:45\ncategories: \"JavaSE笔记\"\ntags:\n    - JavaSE\n    - XML\ncopyright:\n---\n### HTML与XML的区别\n- HTML对大小写不敏感，XML大小写敏感\n- HTML结束标签可以省略，如`</p>`，XML不能\n- XML只有单个标签而没有结束标签的元素必须以`/`结束\n- XML属性值必须用引号括起来\n- HTML属性可以没有值，XML所有属性必须有值    \n\n----\n### 验证XML文档\n需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema\n#### 文档类型定义\n- 将这些规则纳入XML文档\n\n```XML\n<?xml version=\"1.0\"?>\n<!DOCTYPE configuration[\n\n    <!ELEMENT configuration...>\n    ...\n]>\n<configuration>\n...\n</configuration>\n```\n\n>这些规则被纳入到DOCTYPE声明中，代码块[...]用来限定其界限，比如configuration\n\n- SYSTEM声明，将DTD存储在外面\n\n```XML\n<!DOCTYPE configuration SYSTEM \"config.dtd\">\n<!DOCTYPE configuration SYSTEM \"http://myserver.com/config.dtd\">\n```\n- 标记PUBLIC标识符\n\n```java\nclass MyEntityResolver implements EntityResolver{\n    public InputSource resolveEntity(String publicId, String systemID){\n        if(publicID.equals(a knowx ID)){\n            return new InputSource(DTD data):\n        }else{\n            return null;\n        }\n    }\n}\n```\n>PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空\n\n#### XML Schema\n- 声明Schema文件\n```XML\n<?xml version=\"1.0\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n</project>\n```\n- 使用xsd:表示XSL Schema定义的命名空间\n```XML\n<xsd:element name=\"name\" type=\"xsd:string\"/>\n- ref属性引用Schema中位于别处的定义\n<xsd:element ref=\"name\"/>\n<xsd:element name=\"style\" type=StyleType\"/>\n    <xsd:restriction base=\"xsd:string\"/>\n        <xsd:enumeration value=\"PLAIN\"/>\n    </xsd:restriction>\n</xsd:element>\n```\n----\n### 使用XPath定位信息\n- 查找下列的username的值，,通过XPath表达式/configuration/database/username\n```XML\n<configfuration>\n    <database>\n        <username id=\"test\">pinnuli</username>\n        <password>123456</password>\n    </database>\n</configfuration>\n```\n- 用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式\n```XML\nXPathFactory xpFactory = XPathFactory.newInstance();\npath = xpfactory.newXPath();\nString username = path.evaluate(/configuration/database/username\",doc);\n```\n>具体的语法看文档\n\n----\n### XML的命名空间\n- 使用xmlns给定命名空间\n```XML\n<element xmlns=\"namespaceURI1\">\n    <child xmlns=\"namespaceURI2\">\n        grandchildren\n    </child>\n</element>\n```\n    >这里第一个子元素和孙元素都是第二个命名空间的一部分\n- 使用xmlns:prefix=\"namespaceURI\"定义命名空间和前缀\n``` \n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n    <xsd:element name=\"pinnuli\" type=\"haha\"/>\n    ...\n</xsd:schema>\n```\n    >在这里xsd:schema实际上指的是命名空间`http://www.w3.org/2001/XMLSchema`中的`schema`\n- 可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性\n```\nfactory.serNamespaceAware(true);\n```\n----\n\n> 参阅：\n  [慕课网：Java眼中的XML---文件读取](https://www.imooc.com/learn/171)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)","slug":"Java中的XML之与HTML的区别验证，定位信息，命名空间","published":1,"updated":"2018-11-13T06:13:14.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fd5000yu7yjhmb8mjbr","content":"<h3 id=\"HTML与XML的区别\"><a href=\"#HTML与XML的区别\" class=\"headerlink\" title=\"HTML与XML的区别\"></a>HTML与XML的区别</h3><ul>\n<li>HTML对大小写不敏感，XML大小写敏感</li>\n<li>HTML结束标签可以省略，如<code>&lt;/p&gt;</code>，XML不能</li>\n<li>XML只有单个标签而没有结束标签的元素必须以<code>/</code>结束</li>\n<li>XML属性值必须用引号括起来</li>\n<li>HTML属性可以没有值，XML所有属性必须有值    </li>\n</ul>\n<hr>\n<h3 id=\"验证XML文档\"><a href=\"#验证XML文档\" class=\"headerlink\" title=\"验证XML文档\"></a>验证XML文档</h3><p>需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema</p>\n<h4 id=\"文档类型定义\"><a href=\"#文档类型定义\" class=\"headerlink\" title=\"文档类型定义\"></a>文档类型定义</h4><ul>\n<li>将这些规则纳入XML文档</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\"?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration[</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">    &lt;!ELEMENT configuration...&gt;</span></span><br><span class=\"line\"><span class=\"meta\">    ...</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这些规则被纳入到DOCTYPE声明中，代码块[…]用来限定其界限，比如configuration</p>\n</blockquote>\n<ul>\n<li>SYSTEM声明，将DTD存储在外面</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration SYSTEM \"config.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration SYSTEM \"http://myserver.com/config.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>标记PUBLIC标识符</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEntityResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">EntityResolver</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InputSource <span class=\"title\">resolveEntity</span><span class=\"params\">(String publicId, String systemID)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(publicID.equals(a knowx ID))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InputSource(DTD data):</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空</p>\n</blockquote>\n<h4 id=\"XML-Schema\"><a href=\"#XML-Schema\" class=\"headerlink\" title=\"XML Schema\"></a>XML Schema</h4><ul>\n<li><p>声明Schema文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用xsd:表示XSL Schema定义的命名空间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xsd:element</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"xsd:string\"</span>/&gt;</span></span><br><span class=\"line\">- ref属性引用Schema中位于别处的定义</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xsd:element</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"name\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xsd:element</span> <span class=\"attr\">name</span>=<span class=\"string\">\"style\"</span> <span class=\"attr\">type</span>=<span class=\"string\">StyleType</span>\"/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">xsd:restriction</span> <span class=\"attr\">base</span>=<span class=\"string\">\"xsd:string\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">xsd:enumeration</span> <span class=\"attr\">value</span>=<span class=\"string\">\"PLAIN\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">xsd:restriction</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"使用XPath定位信息\"><a href=\"#使用XPath定位信息\" class=\"headerlink\" title=\"使用XPath定位信息\"></a>使用XPath定位信息</h3><ul>\n<li><p>查找下列的username的值，,通过XPath表达式/configuration/database/username</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configfuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">database</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">username</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span>&gt;</span>pinnuli<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>123456<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">database</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configfuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XPathFactory xpFactory = XPathFactory.newInstance();</span><br><span class=\"line\">path = xpfactory.newXPath();</span><br><span class=\"line\">String username = path.evaluate(/configuration/database/username\",doc);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>具体的语法看文档</p>\n</blockquote>\n<hr>\n<h3 id=\"XML的命名空间\"><a href=\"#XML的命名空间\" class=\"headerlink\" title=\"XML的命名空间\"></a>XML的命名空间</h3><ul>\n<li><p>使用xmlns给定命名空间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">element</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"namespaceURI1\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"namespaceURI2\"</span>&gt;</span></span><br><span class=\"line\">        grandchildren</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">element</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里第一个子元素和孙元素都是第二个命名空间的一部分</p>\n</blockquote>\n</li>\n<li><p>使用xmlns:prefix=”namespaceURI”定义命名空间和前缀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</span><br><span class=\"line\">    &lt;xsd:element name=&quot;pinnuli&quot; type=&quot;haha&quot;/&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&lt;/xsd:schema&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在这里xsd:schema实际上指的是命名空间<code>http://www.w3.org/2001/XMLSchema</code>中的<code>schema</code></p>\n</blockquote>\n</li>\n<li>可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factory.serNamespaceAware(true);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/171\" target=\"_blank\" rel=\"noopener\">慕课网：Java眼中的XML—文件读取</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"HTML与XML的区别\"><a href=\"#HTML与XML的区别\" class=\"headerlink\" title=\"HTML与XML的区别\"></a>HTML与XML的区别</h3><ul>\n<li>HTML对大小写不敏感，XML大小写敏感</li>\n<li>HTML结束标签可以省略，如<code>&lt;/p&gt;</code>，XML不能</li>\n<li>XML只有单个标签而没有结束标签的元素必须以<code>/</code>结束</li>\n<li>XML属性值必须用引号括起来</li>\n<li>HTML属性可以没有值，XML所有属性必须有值    </li>\n</ul>\n<hr>\n<h3 id=\"验证XML文档\"><a href=\"#验证XML文档\" class=\"headerlink\" title=\"验证XML文档\"></a>验证XML文档</h3><p>需要指定文档结构时，可以提供一个文档类型定义（DTD）或XML Schema</p>\n<h4 id=\"文档类型定义\"><a href=\"#文档类型定义\" class=\"headerlink\" title=\"文档类型定义\"></a>文档类型定义</h4><ul>\n<li>将这些规则纳入XML文档</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\"?&gt;</span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration[</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">    &lt;!ELEMENT configuration...&gt;</span></span><br><span class=\"line\"><span class=\"meta\">    ...</span></span><br><span class=\"line\"><span class=\"meta\">]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这些规则被纳入到DOCTYPE声明中，代码块[…]用来限定其界限，比如configuration</p>\n</blockquote>\n<ul>\n<li>SYSTEM声明，将DTD存储在外面</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration SYSTEM \"config.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration SYSTEM \"http://myserver.com/config.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>标记PUBLIC标识符</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEntityResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">EntityResolver</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InputSource <span class=\"title\">resolveEntity</span><span class=\"params\">(String publicId, String systemID)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(publicID.equals(a knowx ID))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InputSource(DTD data):</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PS：具体的类型规则看文档，注意在设计DTD时应该要么只包含文本，要么包含其他元素，避免解析混合式（标签和文本的混合）内容时空</p>\n</blockquote>\n<h4 id=\"XML-Schema\"><a href=\"#XML-Schema\" class=\"headerlink\" title=\"XML Schema\"></a>XML Schema</h4><ul>\n<li><p>声明Schema文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用xsd:表示XSL Schema定义的命名空间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xsd:element</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"xsd:string\"</span>/&gt;</span></span><br><span class=\"line\">- ref属性引用Schema中位于别处的定义</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xsd:element</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"name\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xsd:element</span> <span class=\"attr\">name</span>=<span class=\"string\">\"style\"</span> <span class=\"attr\">type</span>=<span class=\"string\">StyleType</span>\"/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">xsd:restriction</span> <span class=\"attr\">base</span>=<span class=\"string\">\"xsd:string\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">xsd:enumeration</span> <span class=\"attr\">value</span>=<span class=\"string\">\"PLAIN\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">xsd:restriction</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"使用XPath定位信息\"><a href=\"#使用XPath定位信息\" class=\"headerlink\" title=\"使用XPath定位信息\"></a>使用XPath定位信息</h3><ul>\n<li><p>查找下列的username的值，,通过XPath表达式/configuration/database/username</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configfuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">database</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">username</span> <span class=\"attr\">id</span>=<span class=\"string\">\"test\"</span>&gt;</span>pinnuli<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>123456<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">database</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configfuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用XPathFactory创建一个XPath对象，调用evaluate方法计算XPath表达式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XPathFactory xpFactory = XPathFactory.newInstance();</span><br><span class=\"line\">path = xpfactory.newXPath();</span><br><span class=\"line\">String username = path.evaluate(/configuration/database/username\",doc);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>具体的语法看文档</p>\n</blockquote>\n<hr>\n<h3 id=\"XML的命名空间\"><a href=\"#XML的命名空间\" class=\"headerlink\" title=\"XML的命名空间\"></a>XML的命名空间</h3><ul>\n<li><p>使用xmlns给定命名空间</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">element</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"namespaceURI1\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"namespaceURI2\"</span>&gt;</span></span><br><span class=\"line\">        grandchildren</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">element</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里第一个子元素和孙元素都是第二个命名空间的一部分</p>\n</blockquote>\n</li>\n<li><p>使用xmlns:prefix=”namespaceURI”定义命名空间和前缀</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</span><br><span class=\"line\">    &lt;xsd:element name=&quot;pinnuli&quot; type=&quot;haha&quot;/&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&lt;/xsd:schema&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在这里xsd:schema实际上指的是命名空间<code>http://www.w3.org/2001/XMLSchema</code>中的<code>schema</code></p>\n</blockquote>\n</li>\n<li>可以控制解析器对命名空间的处理，默认情况下DOM解析器并非“命名空间感知的”，可以调用DocumentBuilderFactory类的setNamespaceAware()打开命名空间处理特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factory.serNamespaceAware(true);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/171\" target=\"_blank\" rel=\"noopener\">慕课网：Java眼中的XML—文件读取</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n"},{"title":"java反射","date":"2018-07-22T05:30:00.000Z","_content":"### 一、Class类的使用\n类是对象，任何一个类都是`java.lang.class`类的实例对象，这个类，这个实例对象可以有三种表达方式，比如`Student`类：\n- 任何一个类都有一个隐含的静态成员变量class\n\n```java\nClass c1 = Student.class;\n```\n- 通过getClass方法获得\n\n```java\nClass c2 = Student.getClass();\n```\n- forName\n\n```java\nClass c3 = Class.forName(\"com.Student\");\n```\n> c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例---->通过c1 or c2 or c3创建Student的实例对象\n```java\nStudent stu = c1.newInstance();\n```\n----\n### 二、动态加载类\n- 静态加载类：编译时加载的类，通过new创建对象是静态加载类\n- 动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题\n\n----\n### 三、获取方法信息和成员变量，构造函数信息\n#### 方法信息\n- 所有的public的函数，包括父类继承而来的\n\n```java\nMethod[] ms = c.getMethods();\n```\n- 所有该类自己声明的方法，不问访问权限\n\n```java\nMethod[] ms = c.getDeclaredMethods();\n```\n- 返回值类型的类类型\n\n```java\nClass returnType = ms[i].getReturnType();\n```\n- 参数列表的类型的类类型\n\n```java\nClass[] paramTypes = ms[i].getParameterTypes();\n```\n- 方法的名称\n\n```java\nString methodName = ms[i].getName();\n```\n#### 成员变量\n- 所有的public的成员变量的信息\n\n```java\nField[] fs = c.getFields();\n```\n- 该类自己声明的成员变量的信息\n\n```java\nField[] fs = c.getDeclaredFields();\n```\n- 成员变量的类型的类类型\n\n```java\nClass fieldType = field.getType();\n```\n- 成员变量的名称\n\n```java\nString fieldName = field.getName();\n```\n- 构造函数\n- 所有的public构造函数\n\n```java\nConstructor[] cs = c.getConstructors();\n```\n- 所有的构造函数\n\n```java\nConstructor[] cs = c.getDeclaredConstructors();\n```\n\n- 构造函数的参数列表，得到的是参数列表的类类型\n\n```java\nClass fieldType = field.getType();\n```\n- 获取类的私有属性或私有方法\n直接获取私有属性或者方法会报java.lang.IllegalAccessException异常，AccessibleObject是Class、Method、Field的父类，通过设置setAccessible(true)可以获取类的私有属性，获取和调用私有方法\n\nStudent类：\n```java\npublic class Student {\n\n    private String name;\n\n    private int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    private void speck(String name) {\n        System.out.println(\"I am \" + name);\n    }\n\n    @Override\n    public String toString() {\n        return \"name: \" + name + \"age: \" + age;\n    }\n}\n```\n获取私有属性：\n```java\n    Student student = new Student(\"pinnuli\", 18);\n    Class studentClass = student.getClass();\n    Field[] studentField = studentClass.getDeclaredFields();\n\n    for (int i = 0; i < studentField.length; i++) {\n        studentField[i].setAccessible(true);\n        try {\n            System.out.println(studentField[i].get(student));\n        } catch (IllegalArgumentException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        System.out.println(studentField[i].getName());\n    }\n```\n获取私有方法\n```java\n    Student student = new Student(\"pinnuli\", 18);\n    Class studentClass = student.getClass();\n    Method[] studentMethods = studentClass.getDeclaredMethods();\n    for (int i = 0; i < studentMethods.length; i++) {\n        studentMethods[i].setAccessible(true);\n        System.out.println(studentMethods[i].getName());\n    }\n```\n\n调用私有方法\n```java\n    Student student = new Student(\"pinnuli\", 18);\n    Class studentClass = student.getClass();\n    Method[] studentMethods = studentClass.getDeclaredMethods();\n    for (int i = 0; i < studentMethods.length; i++) {\n        studentMethods[i].setAccessible(true);\n        try {\n            studentMethods[i].invoke(student,\"pinnuli\");\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (IllegalArgumentException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        System.out.println(studentMethods[i].getName());\n    }\n```\n\n> 更多方法看API文档\n\n----\n### 四、方法反射的基本操作 \n\n现有A类如下：\n```java\nclass A{\n    public void print(){\n        System.out.println(\"helloworld\");\n    }\n    public void print(int a,int b){\n        System.out.println(a+b);\n    }\n        public void print(String a,String b){\n    System.out.println(a.toUpperCase()+\",\"+b.toLowerCase());\n    }\n}\n```\n\n1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型\n```java\nA a1 = new A();\nClass c = a1.getClass();\n```\n2.通过名称和参数列表来获取方法\n```java\nMethod m = c.getMethod(\"print\", int.class,int.class);\n```\n3.方法的反射操作\n```java\nObject o = m.invoke(a1, 10,20);\n```\n> 这个操作的效果等同于`a1.print(10,20)`\n\n> 通过方法的反射，我们可以绕过编译\n\n> 参阅：\n  [慕课网：反射——Java高级开发必须懂的](https://www.imooc.com/learn/199)","source":"_posts/java反射.md","raw":"---\ntitle: java反射\ndate: 2018-07-22 13:30:00\ncategories: \"JavaSE笔记\" \ntags:\n    - JavaSE\n---\n### 一、Class类的使用\n类是对象，任何一个类都是`java.lang.class`类的实例对象，这个类，这个实例对象可以有三种表达方式，比如`Student`类：\n- 任何一个类都有一个隐含的静态成员变量class\n\n```java\nClass c1 = Student.class;\n```\n- 通过getClass方法获得\n\n```java\nClass c2 = Student.getClass();\n```\n- forName\n\n```java\nClass c3 = Class.forName(\"com.Student\");\n```\n> c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例---->通过c1 or c2 or c3创建Student的实例对象\n```java\nStudent stu = c1.newInstance();\n```\n----\n### 二、动态加载类\n- 静态加载类：编译时加载的类，通过new创建对象是静态加载类\n- 动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题\n\n----\n### 三、获取方法信息和成员变量，构造函数信息\n#### 方法信息\n- 所有的public的函数，包括父类继承而来的\n\n```java\nMethod[] ms = c.getMethods();\n```\n- 所有该类自己声明的方法，不问访问权限\n\n```java\nMethod[] ms = c.getDeclaredMethods();\n```\n- 返回值类型的类类型\n\n```java\nClass returnType = ms[i].getReturnType();\n```\n- 参数列表的类型的类类型\n\n```java\nClass[] paramTypes = ms[i].getParameterTypes();\n```\n- 方法的名称\n\n```java\nString methodName = ms[i].getName();\n```\n#### 成员变量\n- 所有的public的成员变量的信息\n\n```java\nField[] fs = c.getFields();\n```\n- 该类自己声明的成员变量的信息\n\n```java\nField[] fs = c.getDeclaredFields();\n```\n- 成员变量的类型的类类型\n\n```java\nClass fieldType = field.getType();\n```\n- 成员变量的名称\n\n```java\nString fieldName = field.getName();\n```\n- 构造函数\n- 所有的public构造函数\n\n```java\nConstructor[] cs = c.getConstructors();\n```\n- 所有的构造函数\n\n```java\nConstructor[] cs = c.getDeclaredConstructors();\n```\n\n- 构造函数的参数列表，得到的是参数列表的类类型\n\n```java\nClass fieldType = field.getType();\n```\n- 获取类的私有属性或私有方法\n直接获取私有属性或者方法会报java.lang.IllegalAccessException异常，AccessibleObject是Class、Method、Field的父类，通过设置setAccessible(true)可以获取类的私有属性，获取和调用私有方法\n\nStudent类：\n```java\npublic class Student {\n\n    private String name;\n\n    private int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    private void speck(String name) {\n        System.out.println(\"I am \" + name);\n    }\n\n    @Override\n    public String toString() {\n        return \"name: \" + name + \"age: \" + age;\n    }\n}\n```\n获取私有属性：\n```java\n    Student student = new Student(\"pinnuli\", 18);\n    Class studentClass = student.getClass();\n    Field[] studentField = studentClass.getDeclaredFields();\n\n    for (int i = 0; i < studentField.length; i++) {\n        studentField[i].setAccessible(true);\n        try {\n            System.out.println(studentField[i].get(student));\n        } catch (IllegalArgumentException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        System.out.println(studentField[i].getName());\n    }\n```\n获取私有方法\n```java\n    Student student = new Student(\"pinnuli\", 18);\n    Class studentClass = student.getClass();\n    Method[] studentMethods = studentClass.getDeclaredMethods();\n    for (int i = 0; i < studentMethods.length; i++) {\n        studentMethods[i].setAccessible(true);\n        System.out.println(studentMethods[i].getName());\n    }\n```\n\n调用私有方法\n```java\n    Student student = new Student(\"pinnuli\", 18);\n    Class studentClass = student.getClass();\n    Method[] studentMethods = studentClass.getDeclaredMethods();\n    for (int i = 0; i < studentMethods.length; i++) {\n        studentMethods[i].setAccessible(true);\n        try {\n            studentMethods[i].invoke(student,\"pinnuli\");\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (IllegalArgumentException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        System.out.println(studentMethods[i].getName());\n    }\n```\n\n> 更多方法看API文档\n\n----\n### 四、方法反射的基本操作 \n\n现有A类如下：\n```java\nclass A{\n    public void print(){\n        System.out.println(\"helloworld\");\n    }\n    public void print(int a,int b){\n        System.out.println(a+b);\n    }\n        public void print(String a,String b){\n    System.out.println(a.toUpperCase()+\",\"+b.toLowerCase());\n    }\n}\n```\n\n1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型\n```java\nA a1 = new A();\nClass c = a1.getClass();\n```\n2.通过名称和参数列表来获取方法\n```java\nMethod m = c.getMethod(\"print\", int.class,int.class);\n```\n3.方法的反射操作\n```java\nObject o = m.invoke(a1, 10,20);\n```\n> 这个操作的效果等同于`a1.print(10,20)`\n\n> 通过方法的反射，我们可以绕过编译\n\n> 参阅：\n  [慕课网：反射——Java高级开发必须懂的](https://www.imooc.com/learn/199)","slug":"java反射","published":1,"updated":"2019-01-21T08:26:12.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fd80013u7yj70z23jv5","content":"<h3 id=\"一、Class类的使用\"><a href=\"#一、Class类的使用\" class=\"headerlink\" title=\"一、Class类的使用\"></a>一、Class类的使用</h3><p>类是对象，任何一个类都是<code>java.lang.class</code>类的实例对象，这个类，这个实例对象可以有三种表达方式，比如<code>Student</code>类：</p>\n<ul>\n<li>任何一个类都有一个隐含的静态成员变量class</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c1 = Student.class;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过getClass方法获得</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c2 = Student.getClass();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>forName</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c3 = Class.forName(<span class=\"string\">\"com.Student\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例—-&gt;通过c1 or c2 or c3创建Student的实例对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student stu = c1.newInstance();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<hr>\n<h3 id=\"二、动态加载类\"><a href=\"#二、动态加载类\" class=\"headerlink\" title=\"二、动态加载类\"></a>二、动态加载类</h3><ul>\n<li>静态加载类：编译时加载的类，通过new创建对象是静态加载类</li>\n<li>动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题</li>\n</ul>\n<hr>\n<h3 id=\"三、获取方法信息和成员变量，构造函数信息\"><a href=\"#三、获取方法信息和成员变量，构造函数信息\" class=\"headerlink\" title=\"三、获取方法信息和成员变量，构造函数信息\"></a>三、获取方法信息和成员变量，构造函数信息</h3><h4 id=\"方法信息\"><a href=\"#方法信息\" class=\"headerlink\" title=\"方法信息\"></a>方法信息</h4><ul>\n<li>所有的public的函数，包括父类继承而来的</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getMethods();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有该类自己声明的方法，不问访问权限</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getDeclaredMethods();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回值类型的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class returnType = ms[i].getReturnType();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参数列表的类型的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class[] paramTypes = ms[i].getParameterTypes();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法的名称</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String methodName = ms[i].getName();</span><br></pre></td></tr></table></figure>\n<h4 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h4><ul>\n<li>所有的public的成员变量的信息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] fs = c.getFields();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>该类自己声明的成员变量的信息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] fs = c.getDeclaredFields();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>成员变量的类型的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class fieldType = field.getType();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>成员变量的名称</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String fieldName = field.getName();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数</li>\n<li>所有的public构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor[] cs = c.getConstructors();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有的构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor[] cs = c.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数的参数列表，得到的是参数列表的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class fieldType = field.getType();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取类的私有属性或私有方法<br>直接获取私有属性或者方法会报java.lang.IllegalAccessException异常，AccessibleObject是Class、Method、Field的父类，通过设置setAccessible(true)可以获取类的私有属性，获取和调用私有方法</li>\n</ul>\n<p>Student类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">speck</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"I am \"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"name: \"</span> + name + <span class=\"string\">\"age: \"</span> + age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取私有属性：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"pinnuli\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Class studentClass = student.getClass();</span><br><span class=\"line\">Field[] studentField = studentClass.getDeclaredFields();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentField.length; i++) &#123;</span><br><span class=\"line\">    studentField[i].setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(studentField[i].get(student));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(studentField[i].getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取私有方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"pinnuli\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Class studentClass = student.getClass();</span><br><span class=\"line\">Method[] studentMethods = studentClass.getDeclaredMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentMethods.length; i++) &#123;</span><br><span class=\"line\">    studentMethods[i].setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    System.out.println(studentMethods[i].getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用私有方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"pinnuli\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Class studentClass = student.getClass();</span><br><span class=\"line\">Method[] studentMethods = studentClass.getDeclaredMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentMethods.length; i++) &#123;</span><br><span class=\"line\">    studentMethods[i].setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        studentMethods[i].invoke(student,<span class=\"string\">\"pinnuli\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(studentMethods[i].getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>更多方法看API文档</p>\n</blockquote>\n<hr>\n<h3 id=\"四、方法反射的基本操作\"><a href=\"#四、方法反射的基本操作\" class=\"headerlink\" title=\"四、方法反射的基本操作\"></a>四、方法反射的基本操作</h3><p>现有A类如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"helloworld\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(a+b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String a,String b)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(a.toUpperCase()+<span class=\"string\">\",\"</span>+b.toLowerCase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a1 = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">Class c = a1.getClass();</span><br></pre></td></tr></table></figure></p>\n<p>2.通过名称和参数列表来获取方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method m = c.getMethod(<span class=\"string\">\"print\"</span>, <span class=\"keyword\">int</span>.class,<span class=\"keyword\">int</span>.class);</span><br></pre></td></tr></table></figure></p>\n<p>3.方法的反射操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = m.invoke(a1, <span class=\"number\">10</span>,<span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这个操作的效果等同于<code>a1.print(10,20)</code></p>\n<p>通过方法的反射，我们可以绕过编译</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/199\" target=\"_blank\" rel=\"noopener\">慕课网：反射——Java高级开发必须懂的</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、Class类的使用\"><a href=\"#一、Class类的使用\" class=\"headerlink\" title=\"一、Class类的使用\"></a>一、Class类的使用</h3><p>类是对象，任何一个类都是<code>java.lang.class</code>类的实例对象，这个类，这个实例对象可以有三种表达方式，比如<code>Student</code>类：</p>\n<ul>\n<li>任何一个类都有一个隐含的静态成员变量class</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c1 = Student.class;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过getClass方法获得</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c2 = Student.getClass();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>forName</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c3 = Class.forName(<span class=\"string\">\"com.Student\"</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>c1,c2,c3表示了Student类的类类型（class type),可以通过类的类类型创建该类的对象实例—-&gt;通过c1 or c2 or c3创建Student的实例对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student stu = c1.newInstance();</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<hr>\n<h3 id=\"二、动态加载类\"><a href=\"#二、动态加载类\" class=\"headerlink\" title=\"二、动态加载类\"></a>二、动态加载类</h3><ul>\n<li>静态加载类：编译时加载的类，通过new创建对象是静态加载类</li>\n<li>动态加载类：运行时加载的类，编译时不用管类是否存在或者是否错误等问题</li>\n</ul>\n<hr>\n<h3 id=\"三、获取方法信息和成员变量，构造函数信息\"><a href=\"#三、获取方法信息和成员变量，构造函数信息\" class=\"headerlink\" title=\"三、获取方法信息和成员变量，构造函数信息\"></a>三、获取方法信息和成员变量，构造函数信息</h3><h4 id=\"方法信息\"><a href=\"#方法信息\" class=\"headerlink\" title=\"方法信息\"></a>方法信息</h4><ul>\n<li>所有的public的函数，包括父类继承而来的</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getMethods();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有该类自己声明的方法，不问访问权限</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getDeclaredMethods();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回值类型的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class returnType = ms[i].getReturnType();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参数列表的类型的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class[] paramTypes = ms[i].getParameterTypes();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法的名称</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String methodName = ms[i].getName();</span><br></pre></td></tr></table></figure>\n<h4 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h4><ul>\n<li>所有的public的成员变量的信息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] fs = c.getFields();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>该类自己声明的成员变量的信息</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] fs = c.getDeclaredFields();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>成员变量的类型的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class fieldType = field.getType();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>成员变量的名称</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String fieldName = field.getName();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数</li>\n<li>所有的public构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor[] cs = c.getConstructors();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>所有的构造函数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor[] cs = c.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数的参数列表，得到的是参数列表的类类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class fieldType = field.getType();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取类的私有属性或私有方法<br>直接获取私有属性或者方法会报java.lang.IllegalAccessException异常，AccessibleObject是Class、Method、Field的父类，通过设置setAccessible(true)可以获取类的私有属性，获取和调用私有方法</li>\n</ul>\n<p>Student类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">speck</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"I am \"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"name: \"</span> + name + <span class=\"string\">\"age: \"</span> + age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取私有属性：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"pinnuli\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Class studentClass = student.getClass();</span><br><span class=\"line\">Field[] studentField = studentClass.getDeclaredFields();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentField.length; i++) &#123;</span><br><span class=\"line\">    studentField[i].setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(studentField[i].get(student));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(studentField[i].getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取私有方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"pinnuli\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Class studentClass = student.getClass();</span><br><span class=\"line\">Method[] studentMethods = studentClass.getDeclaredMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentMethods.length; i++) &#123;</span><br><span class=\"line\">    studentMethods[i].setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    System.out.println(studentMethods[i].getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用私有方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"pinnuli\"</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">Class studentClass = student.getClass();</span><br><span class=\"line\">Method[] studentMethods = studentClass.getDeclaredMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentMethods.length; i++) &#123;</span><br><span class=\"line\">    studentMethods[i].setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        studentMethods[i].invoke(student,<span class=\"string\">\"pinnuli\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(studentMethods[i].getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>更多方法看API文档</p>\n</blockquote>\n<hr>\n<h3 id=\"四、方法反射的基本操作\"><a href=\"#四、方法反射的基本操作\" class=\"headerlink\" title=\"四、方法反射的基本操作\"></a>四、方法反射的基本操作</h3><p>现有A类如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"helloworld\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(a+b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String a,String b)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(a.toUpperCase()+<span class=\"string\">\",\"</span>+b.toLowerCase());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A a1 = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">Class c = a1.getClass();</span><br></pre></td></tr></table></figure></p>\n<p>2.通过名称和参数列表来获取方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method m = c.getMethod(<span class=\"string\">\"print\"</span>, <span class=\"keyword\">int</span>.class,<span class=\"keyword\">int</span>.class);</span><br></pre></td></tr></table></figure></p>\n<p>3.方法的反射操作<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = m.invoke(a1, <span class=\"number\">10</span>,<span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这个操作的效果等同于<code>a1.print(10,20)</code></p>\n<p>通过方法的反射，我们可以绕过编译</p>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/199\" target=\"_blank\" rel=\"noopener\">慕课网：反射——Java高级开发必须懂的</a></p>\n</blockquote>\n"},{"title":"java注解","date":"2018-07-23T04:39:36.000Z","_content":"### 一、注解分类\n- 源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在\n- 编译时注解（CLASS）：注解在源码和.class文件都存在\n- 运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解\n- 元注解：注解的注解\n\n----\n### 二、自定义注解\n#### 定义：\n```java\n//元注解\n@Target({ElementType.METHOD,ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n\n//定义注解和成员变量\npublic @interface Description{\n    String desc();\n    String author();\n    int age() default 20;\n}\n```\n- `@Target({ElementType.METHOD,ElementType.TYPE})`\n\n> 作用域,可以包括`CONSTRUCTOR`(构造方法)、`FIELD`(字段)、`LOCAL_VARIABLE`(局部变量)、`METHOD`(方法)、`PACKAGE`(包)、`PARAMETER`(参数)、`TYPE`(类和接口)声明中，这里作用域为方法、类和接口\n\n- `@Retention(RetentionPolicy.RUNTIME)`\n\n> 生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时\n\n- `@Inherited`\n\n> 标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解\n\n- `@Documented`\n\n> 生成javadoc包含注解信息\n\n- `@interface`\n\n>1.使用关键字`@interface`定义注解，\n>2.成员以无参无异常方式声明，可以用default指定一个默认值\n>3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration\n>4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即`Description(\"test\")`\n>5.注解可以没有成员名，叫标识注解\n\n#### 使用：\n@<注解名>(<成员名1>=<成员值1>,<成员名2>=<成员值2>,...)\n```java\nDescription(desc=\"I am pinnuli\",author=\"pinnuli\",age=20)\npublic String test(){\n    return \"test\";\n}\n```\n----\n### 三、解析注解\n> 通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑\n\n1.使用类加载器加载类\n```java\nClass c = Class.forname(\"com.test.Student\");\n```\n2.找到类上的注解,拿到注解实例\n```java\nif(c.isAnnotationPresent(Description.class)){\n    Description d = (Description)c.getAnnotation(Description.class);\n}\n```\n3.找到方法上的注解\n- 方法一\n\n```java\nMethod[] ms = c.getMethods();\nfor(Method m:ms){\n    if(m.isAnnotationPresent(Description.class)){\n        Description d = (Description)m.getAnnotation(Description.class);\n    }\n}\n```\n- 方法二\n\n```java\nMethod[] ms = c.getMethods();\nfor(Method m:ms){\n    for(Annotation a:as){\n        if(a instanceof Description){\n            Description d = (Description)a;\n        }\n    }\n}\n```\n\n> 参阅：\n  [慕课网：全面解析Java注解](https://www.imooc.com/learn/456)","source":"_posts/java注解.md","raw":"---\ntitle: java注解\ndate: 2018-07-23 12:39:36\ncategories: \"JavaSE笔记\" \ntags:\n    - JavaSE\n---\n### 一、注解分类\n- 源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在\n- 编译时注解（CLASS）：注解在源码和.class文件都存在\n- 运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解\n- 元注解：注解的注解\n\n----\n### 二、自定义注解\n#### 定义：\n```java\n//元注解\n@Target({ElementType.METHOD,ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\n\n//定义注解和成员变量\npublic @interface Description{\n    String desc();\n    String author();\n    int age() default 20;\n}\n```\n- `@Target({ElementType.METHOD,ElementType.TYPE})`\n\n> 作用域,可以包括`CONSTRUCTOR`(构造方法)、`FIELD`(字段)、`LOCAL_VARIABLE`(局部变量)、`METHOD`(方法)、`PACKAGE`(包)、`PARAMETER`(参数)、`TYPE`(类和接口)声明中，这里作用域为方法、类和接口\n\n- `@Retention(RetentionPolicy.RUNTIME)`\n\n> 生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时\n\n- `@Inherited`\n\n> 标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解\n\n- `@Documented`\n\n> 生成javadoc包含注解信息\n\n- `@interface`\n\n>1.使用关键字`@interface`定义注解，\n>2.成员以无参无异常方式声明，可以用default指定一个默认值\n>3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration\n>4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即`Description(\"test\")`\n>5.注解可以没有成员名，叫标识注解\n\n#### 使用：\n@<注解名>(<成员名1>=<成员值1>,<成员名2>=<成员值2>,...)\n```java\nDescription(desc=\"I am pinnuli\",author=\"pinnuli\",age=20)\npublic String test(){\n    return \"test\";\n}\n```\n----\n### 三、解析注解\n> 通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑\n\n1.使用类加载器加载类\n```java\nClass c = Class.forname(\"com.test.Student\");\n```\n2.找到类上的注解,拿到注解实例\n```java\nif(c.isAnnotationPresent(Description.class)){\n    Description d = (Description)c.getAnnotation(Description.class);\n}\n```\n3.找到方法上的注解\n- 方法一\n\n```java\nMethod[] ms = c.getMethods();\nfor(Method m:ms){\n    if(m.isAnnotationPresent(Description.class)){\n        Description d = (Description)m.getAnnotation(Description.class);\n    }\n}\n```\n- 方法二\n\n```java\nMethod[] ms = c.getMethods();\nfor(Method m:ms){\n    for(Annotation a:as){\n        if(a instanceof Description){\n            Description d = (Description)a;\n        }\n    }\n}\n```\n\n> 参阅：\n  [慕课网：全面解析Java注解](https://www.imooc.com/learn/456)","slug":"java注解","published":1,"updated":"2018-11-13T06:13:01.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fd90014u7yj7j420y3e","content":"<h3 id=\"一、注解分类\"><a href=\"#一、注解分类\" class=\"headerlink\" title=\"一、注解分类\"></a>一、注解分类</h3><ul>\n<li>源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在</li>\n<li>编译时注解（CLASS）：注解在源码和.class文件都存在</li>\n<li>运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解</li>\n<li>元注解：注解的注解</li>\n</ul>\n<hr>\n<h3 id=\"二、自定义注解\"><a href=\"#二、自定义注解\" class=\"headerlink\" title=\"二、自定义注解\"></a>二、自定义注解</h3><h4 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//元注解</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义注解和成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Description&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">desc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 20</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>@Target({ElementType.METHOD,ElementType.TYPE})</code></li>\n</ul>\n<blockquote>\n<p>作用域,可以包括<code>CONSTRUCTOR</code>(构造方法)、<code>FIELD</code>(字段)、<code>LOCAL_VARIABLE</code>(局部变量)、<code>METHOD</code>(方法)、<code>PACKAGE</code>(包)、<code>PARAMETER</code>(参数)、<code>TYPE</code>(类和接口)声明中，这里作用域为方法、类和接口</p>\n</blockquote>\n<ul>\n<li><code>@Retention(RetentionPolicy.RUNTIME)</code></li>\n</ul>\n<blockquote>\n<p>生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时</p>\n</blockquote>\n<ul>\n<li><code>@Inherited</code></li>\n</ul>\n<blockquote>\n<p>标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解</p>\n</blockquote>\n<ul>\n<li><code>@Documented</code></li>\n</ul>\n<blockquote>\n<p>生成javadoc包含注解信息</p>\n</blockquote>\n<ul>\n<li><code>@interface</code></li>\n</ul>\n<blockquote>\n<p>1.使用关键字<code>@interface</code>定义注解，<br>2.成员以无参无异常方式声明，可以用default指定一个默认值<br>3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration<br>4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即<code>Description(&quot;test&quot;)</code><br>5.注解可以没有成员名，叫标识注解</p>\n</blockquote>\n<h4 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h4><p>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Description(desc=<span class=\"string\">\"I am pinnuli\"</span>,author=<span class=\"string\">\"pinnuli\"</span>,age=<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"三、解析注解\"><a href=\"#三、解析注解\" class=\"headerlink\" title=\"三、解析注解\"></a>三、解析注解</h3><blockquote>\n<p>通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑</p>\n</blockquote>\n<p>1.使用类加载器加载类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c = Class.forname(<span class=\"string\">\"com.test.Student\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2.找到类上的注解,拿到注解实例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(c.isAnnotationPresent(Description.class))&#123;</span><br><span class=\"line\">    Description d = (Description)c.getAnnotation(Description.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.找到方法上的注解</p>\n<ul>\n<li>方法一</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m.isAnnotationPresent(Description.class))&#123;</span><br><span class=\"line\">        Description d = (Description)m.getAnnotation(Description.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法二</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Annotation a:as)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> Description)&#123;</span><br><span class=\"line\">            Description d = (Description)a;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/456\" target=\"_blank\" rel=\"noopener\">慕课网：全面解析Java注解</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、注解分类\"><a href=\"#一、注解分类\" class=\"headerlink\" title=\"一、注解分类\"></a>一、注解分类</h3><ul>\n<li>源码注解（SOURCE）：注解只在源码中存在，编译成.class文件就不存在</li>\n<li>编译时注解（CLASS）：注解在源码和.class文件都存在</li>\n<li>运行时注解（RUNTIME）：在运行阶段还起作用，甚至会影响运行逻辑的注解</li>\n<li>元注解：注解的注解</li>\n</ul>\n<hr>\n<h3 id=\"二、自定义注解\"><a href=\"#二、自定义注解\" class=\"headerlink\" title=\"二、自定义注解\"></a>二、自定义注解</h3><h4 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//元注解</span></span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义注解和成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Description&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">desc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 20</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>@Target({ElementType.METHOD,ElementType.TYPE})</code></li>\n</ul>\n<blockquote>\n<p>作用域,可以包括<code>CONSTRUCTOR</code>(构造方法)、<code>FIELD</code>(字段)、<code>LOCAL_VARIABLE</code>(局部变量)、<code>METHOD</code>(方法)、<code>PACKAGE</code>(包)、<code>PARAMETER</code>(参数)、<code>TYPE</code>(类和接口)声明中，这里作用域为方法、类和接口</p>\n</blockquote>\n<ul>\n<li><code>@Retention(RetentionPolicy.RUNTIME)</code></li>\n</ul>\n<blockquote>\n<p>生命周期，可以设置为Source，CLASS，RUNTIME,这里生命周期是运行时</p>\n</blockquote>\n<ul>\n<li><code>@Inherited</code></li>\n</ul>\n<blockquote>\n<p>标识性注解，允许子类继承，只适用于类的继承，对接口的继承无效，而且只会继承类级别的注解，不会继承超类的方法和成员变量的注解</p>\n</blockquote>\n<ul>\n<li><code>@Documented</code></li>\n</ul>\n<blockquote>\n<p>生成javadoc包含注解信息</p>\n</blockquote>\n<ul>\n<li><code>@interface</code></li>\n</ul>\n<blockquote>\n<p>1.使用关键字<code>@interface</code>定义注解，<br>2.成员以无参无异常方式声明，可以用default指定一个默认值<br>3.成员类型是受限的，合法的类型包括基本类型，String，Class，Annotation，Enumeration<br>4.如果注解只有一个成员，则成员名必须为value()，在使用时可以忽略成员名和赋值号,即<code>Description(&quot;test&quot;)</code><br>5.注解可以没有成员名，叫标识注解</p>\n</blockquote>\n<h4 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h4><p>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Description(desc=<span class=\"string\">\"I am pinnuli\"</span>,author=<span class=\"string\">\"pinnuli\"</span>,age=<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"三、解析注解\"><a href=\"#三、解析注解\" class=\"headerlink\" title=\"三、解析注解\"></a>三、解析注解</h3><blockquote>\n<p>通过反射获取类、函数或成员上的运行时追截信息，从而实现动态控制程序运行的逻辑</p>\n</blockquote>\n<p>1.使用类加载器加载类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c = Class.forname(<span class=\"string\">\"com.test.Student\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2.找到类上的注解,拿到注解实例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(c.isAnnotationPresent(Description.class))&#123;</span><br><span class=\"line\">    Description d = (Description)c.getAnnotation(Description.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>3.找到方法上的注解</p>\n<ul>\n<li>方法一</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m.isAnnotationPresent(Description.class))&#123;</span><br><span class=\"line\">        Description d = (Description)m.getAnnotation(Description.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法二</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] ms = c.getMethods();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Annotation a:as)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> Description)&#123;</span><br><span class=\"line\">            Description d = (Description)a;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/456\" target=\"_blank\" rel=\"noopener\">慕课网：全面解析Java注解</a></p>\n</blockquote>\n"},{"title":"java集合框架","date":"2018-07-10T23:02:56.000Z","_content":"\n\n### 一、迭代器\niterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素，\n\n- next()方法\n\t- 逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用；\n\t- java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用\n- 用\"for each\"循环遍历类集的内容，\n- remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态\n- 对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉\n\n----\n### 二、List\n有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类\n\n**ArrayList**\n- 基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道\n\n- 适用于需要进行随机访问时\n\t\n**LinkedList**\n- 基于双向链表，\n- 对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值\n- 适用于顺序访问\n\n----\n### 三、Set\n等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一\n\n**HashSet**\n- 基于散列表的集，无序\n- 存入的元素必须定义有hashCode()，以得到散列码\n- 可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变\n- 可以设置装填因子来实现再散列\n- 适用于不关心访问顺序，需要查找大容量容器时\n\n**TreeSet**\n- 基于红黑树排序，有序\n- 存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator\n- 每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问\n- 适用于存储大量需要进行快速检索的排序信息的情况\n\t\n**BitSet**\n- 用于存放一个位序列\n\n----\n### 四、Queue\n**双端队列**\n可以同时在头部或者尾部添加或删除元素，有两个实现\n- inkedList\n- ArrayList\n\n**PriorityQueue**\n- 基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序\n- 按照任意顺序插入，却可以按照顺序进行检索\n- 和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator\n\n----\n### 五、Map\n对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。\n**键不存在时**\nget方法返回null，可以用getOrDefault返回默认值，test.get(id,0)\n**更新映射项**\n正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，`counts.put(word,counts.get(word)+1)`,需要解决一个问题，就是键第一次出现时，这时可以有三种方法\n- `counts.put(word,counts.getOrDefault(word,0) + 1)`\n- 先调用putIfAbsent，只有原先键存在时才会放一个值,`counts.putIfAnsent(word,0)`\t\t\n\t`counts.put(word,counts.get(word)+1)`\t\t\t\n- `counts.merge(word,1,Interger::sum)`(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联\n\n**映射视图**\n集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图\n- 键集：`Set<K> keySet()`，\n- 值集：`Collection<V> values()`，\n- 键/值对集：`Set<Map.Entry<K,V>> entrySet()`\n- 这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除\n\n**散列**\n- 散列码，由对象的实例域产生的一个整数，由hashCOde()产生\n- 散列表，用链表数组实现，每个列表称为桶\n- 散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询\n> 新版jdk使用红黑树和List（数据多用树，少时用List)\n\n- 散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表\n\n**HashMap**\n- 比较快，适用于不需要按照排列顺序访问键时\n\n**TreeMap**\n- 按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序\n\n**WeakHashMap**\n- 使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键\n- 如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目\n- 适用于需要缓存时\n\n**LinkedHashMap**\n- 链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，受到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置\n- 用于实现高速缓存的“最近最少使用”原则\n \n----\n### 六、视图与包装器\n**轻量级集合包装器**\n例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法\n```java\n\tCard[] cardDeck = new Card[52];\n\tList<Card> cardList = Arrays.asList(cardDeck);\n```\n> 返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小,例如Collections类的一些使用方法，`nCopied(100,\"KKK\")`,`single(anObject)`等，返回一个不可修改的试图对象\n\n**子范围**\n- 相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用`List group2 = staff.subList(10,20);`,类似于String类中获取子串\n- 可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除\n- 对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集，\n> SortedSet<E> subSet(E from, E to)\n> SortedSet<E> headSet(E to)\n> SortedSet<E> tailSet(E from)\n\n**不可修改的视图**\n- 只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改\n- 访问器方法从原始集合对象中获取值\n- 视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如：\n> `unmodifiableCollection`方法将返回一个集合，但他的`equals()`方法不调用底层集合的，而是调用它继承了`Object类的equals()`方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的\n\n**同步视图**\n- 实现多线程访问，确保集合的线程安全，例如`Collections.synchronizedMap`\n\n**受查视图**\n- 用来对泛型类型进行检测，例如`Collections.checkedList`\n\n> 参阅：\n  [java核心技术 卷I：基础知识](http://product.dangdang.com/24035306.html)","source":"_posts/java集合框架.md","raw":"---\ntitle: java集合框架\ndate: 2018-07-11 07:02:56\ncategories: \"JavaSE笔记\" \ntags:\n\t- JavaSE\n---\n\n\n### 一、迭代器\niterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素，\n\n- next()方法\n\t- 逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用；\n\t- java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用\n- 用\"for each\"循环遍历类集的内容，\n- remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态\n- 对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉\n\n----\n### 二、List\n有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类\n\n**ArrayList**\n- 基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道\n\n- 适用于需要进行随机访问时\n\t\n**LinkedList**\n- 基于双向链表，\n- 对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值\n- 适用于顺序访问\n\n----\n### 三、Set\n等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一\n\n**HashSet**\n- 基于散列表的集，无序\n- 存入的元素必须定义有hashCode()，以得到散列码\n- 可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变\n- 可以设置装填因子来实现再散列\n- 适用于不关心访问顺序，需要查找大容量容器时\n\n**TreeSet**\n- 基于红黑树排序，有序\n- 存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator\n- 每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问\n- 适用于存储大量需要进行快速检索的排序信息的情况\n\t\n**BitSet**\n- 用于存放一个位序列\n\n----\n### 四、Queue\n**双端队列**\n可以同时在头部或者尾部添加或删除元素，有两个实现\n- inkedList\n- ArrayList\n\n**PriorityQueue**\n- 基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序\n- 按照任意顺序插入，却可以按照顺序进行检索\n- 和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator\n\n----\n### 五、Map\n对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。\n**键不存在时**\nget方法返回null，可以用getOrDefault返回默认值，test.get(id,0)\n**更新映射项**\n正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，`counts.put(word,counts.get(word)+1)`,需要解决一个问题，就是键第一次出现时，这时可以有三种方法\n- `counts.put(word,counts.getOrDefault(word,0) + 1)`\n- 先调用putIfAbsent，只有原先键存在时才会放一个值,`counts.putIfAnsent(word,0)`\t\t\n\t`counts.put(word,counts.get(word)+1)`\t\t\t\n- `counts.merge(word,1,Interger::sum)`(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联\n\n**映射视图**\n集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图\n- 键集：`Set<K> keySet()`，\n- 值集：`Collection<V> values()`，\n- 键/值对集：`Set<Map.Entry<K,V>> entrySet()`\n- 这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除\n\n**散列**\n- 散列码，由对象的实例域产生的一个整数，由hashCOde()产生\n- 散列表，用链表数组实现，每个列表称为桶\n- 散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询\n> 新版jdk使用红黑树和List（数据多用树，少时用List)\n\n- 散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表\n\n**HashMap**\n- 比较快，适用于不需要按照排列顺序访问键时\n\n**TreeMap**\n- 按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序\n\n**WeakHashMap**\n- 使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键\n- 如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目\n- 适用于需要缓存时\n\n**LinkedHashMap**\n- 链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，受到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置\n- 用于实现高速缓存的“最近最少使用”原则\n \n----\n### 六、视图与包装器\n**轻量级集合包装器**\n例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法\n```java\n\tCard[] cardDeck = new Card[52];\n\tList<Card> cardList = Arrays.asList(cardDeck);\n```\n> 返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小,例如Collections类的一些使用方法，`nCopied(100,\"KKK\")`,`single(anObject)`等，返回一个不可修改的试图对象\n\n**子范围**\n- 相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用`List group2 = staff.subList(10,20);`,类似于String类中获取子串\n- 可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除\n- 对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集，\n> SortedSet<E> subSet(E from, E to)\n> SortedSet<E> headSet(E to)\n> SortedSet<E> tailSet(E from)\n\n**不可修改的视图**\n- 只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改\n- 访问器方法从原始集合对象中获取值\n- 视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如：\n> `unmodifiableCollection`方法将返回一个集合，但他的`equals()`方法不调用底层集合的，而是调用它继承了`Object类的equals()`方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的\n\n**同步视图**\n- 实现多线程访问，确保集合的线程安全，例如`Collections.synchronizedMap`\n\n**受查视图**\n- 用来对泛型类型进行检测，例如`Collections.checkedList`\n\n> 参阅：\n  [java核心技术 卷I：基础知识](http://product.dangdang.com/24035306.html)","slug":"java集合框架","published":1,"updated":"2018-12-11T03:10:27.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdb0019u7yj9n6r4wau","content":"<h3 id=\"一、迭代器\"><a href=\"#一、迭代器\" class=\"headerlink\" title=\"一、迭代器\"></a>一、迭代器</h3><p>iterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素，</p>\n<ul>\n<li>next()方法<ul>\n<li>逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用；</li>\n<li>java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用</li>\n</ul>\n</li>\n<li>用”for each”循环遍历类集的内容，</li>\n<li>remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态</li>\n<li>对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉</li>\n</ul>\n<hr>\n<h3 id=\"二、List\"><a href=\"#二、List\" class=\"headerlink\" title=\"二、List\"></a>二、List</h3><p>有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类</p>\n<p><strong>ArrayList</strong></p>\n<ul>\n<li><p>基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道</p>\n</li>\n<li><p>适用于需要进行随机访问时</p>\n</li>\n</ul>\n<p><strong>LinkedList</strong></p>\n<ul>\n<li>基于双向链表，</li>\n<li>对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值</li>\n<li>适用于顺序访问</li>\n</ul>\n<hr>\n<h3 id=\"三、Set\"><a href=\"#三、Set\" class=\"headerlink\" title=\"三、Set\"></a>三、Set</h3><p>等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一</p>\n<p><strong>HashSet</strong></p>\n<ul>\n<li>基于散列表的集，无序</li>\n<li>存入的元素必须定义有hashCode()，以得到散列码</li>\n<li>可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变</li>\n<li>可以设置装填因子来实现再散列</li>\n<li>适用于不关心访问顺序，需要查找大容量容器时</li>\n</ul>\n<p><strong>TreeSet</strong></p>\n<ul>\n<li>基于红黑树排序，有序</li>\n<li>存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator</li>\n<li>每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问</li>\n<li>适用于存储大量需要进行快速检索的排序信息的情况</li>\n</ul>\n<p><strong>BitSet</strong></p>\n<ul>\n<li>用于存放一个位序列</li>\n</ul>\n<hr>\n<h3 id=\"四、Queue\"><a href=\"#四、Queue\" class=\"headerlink\" title=\"四、Queue\"></a>四、Queue</h3><p><strong>双端队列</strong><br>可以同时在头部或者尾部添加或删除元素，有两个实现</p>\n<ul>\n<li>inkedList</li>\n<li>ArrayList</li>\n</ul>\n<p><strong>PriorityQueue</strong></p>\n<ul>\n<li>基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序</li>\n<li>按照任意顺序插入，却可以按照顺序进行检索</li>\n<li>和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator</li>\n</ul>\n<hr>\n<h3 id=\"五、Map\"><a href=\"#五、Map\" class=\"headerlink\" title=\"五、Map\"></a>五、Map</h3><p>对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。<br><strong>键不存在时</strong><br>get方法返回null，可以用getOrDefault返回默认值，test.get(id,0)<br><strong>更新映射项</strong><br>正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，<code>counts.put(word,counts.get(word)+1)</code>,需要解决一个问题，就是键第一次出现时，这时可以有三种方法</p>\n<ul>\n<li><code>counts.put(word,counts.getOrDefault(word,0) + 1)</code></li>\n<li>先调用putIfAbsent，只有原先键存在时才会放一个值,<code>counts.putIfAnsent(word,0)</code><br>  <code>counts.put(word,counts.get(word)+1)</code>            </li>\n<li><code>counts.merge(word,1,Interger::sum)</code>(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联</li>\n</ul>\n<p><strong>映射视图</strong><br>集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图</p>\n<ul>\n<li>键集：<code>Set&lt;K&gt; keySet()</code>，</li>\n<li>值集：<code>Collection&lt;V&gt; values()</code>，</li>\n<li>键/值对集：<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></li>\n<li>这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除</li>\n</ul>\n<p><strong>散列</strong></p>\n<ul>\n<li>散列码，由对象的实例域产生的一个整数，由hashCOde()产生</li>\n<li>散列表，用链表数组实现，每个列表称为桶</li>\n<li><p>散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询</p>\n<blockquote>\n<p>新版jdk使用红黑树和List（数据多用树，少时用List)</p>\n</blockquote>\n</li>\n<li><p>散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表</p>\n</li>\n</ul>\n<p><strong>HashMap</strong></p>\n<ul>\n<li>比较快，适用于不需要按照排列顺序访问键时</li>\n</ul>\n<p><strong>TreeMap</strong></p>\n<ul>\n<li>按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序</li>\n</ul>\n<p><strong>WeakHashMap</strong></p>\n<ul>\n<li>使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键</li>\n<li>如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目</li>\n<li>适用于需要缓存时</li>\n</ul>\n<p><strong>LinkedHashMap</strong></p>\n<ul>\n<li>链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，受到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置</li>\n<li>用于实现高速缓存的“最近最少使用”原则</li>\n</ul>\n<hr>\n<h3 id=\"六、视图与包装器\"><a href=\"#六、视图与包装器\" class=\"headerlink\" title=\"六、视图与包装器\"></a>六、视图与包装器</h3><p><strong>轻量级集合包装器</strong><br>例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Card[] cardDeck = <span class=\"keyword\">new</span> Card[<span class=\"number\">52</span>];</span><br><span class=\"line\">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小,例如Collections类的一些使用方法，<code>nCopied(100,&quot;KKK&quot;)</code>,<code>single(anObject)</code>等，返回一个不可修改的试图对象</p>\n</blockquote>\n<p><strong>子范围</strong></p>\n<ul>\n<li>相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用<code>List group2 = staff.subList(10,20);</code>,类似于String类中获取子串</li>\n<li>可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除</li>\n<li>对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集，<blockquote>\n<p>SortedSet<e> subSet(E from, E to)<br>SortedSet<e> headSet(E to)<br>SortedSet<e> tailSet(E from)</e></e></e></p>\n</blockquote>\n</li>\n</ul>\n<p><strong>不可修改的视图</strong></p>\n<ul>\n<li>只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改</li>\n<li>访问器方法从原始集合对象中获取值</li>\n<li>视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如：<blockquote>\n<p><code>unmodifiableCollection</code>方法将返回一个集合，但他的<code>equals()</code>方法不调用底层集合的，而是调用它继承了<code>Object类的equals()</code>方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>同步视图</strong></p>\n<ul>\n<li>实现多线程访问，确保集合的线程安全，例如<code>Collections.synchronizedMap</code></li>\n</ul>\n<p><strong>受查视图</strong></p>\n<ul>\n<li>用来对泛型类型进行检测，例如<code>Collections.checkedList</code></li>\n</ul>\n<blockquote>\n<p>参阅：<br>  <a href=\"http://product.dangdang.com/24035306.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷I：基础知识</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、迭代器\"><a href=\"#一、迭代器\" class=\"headerlink\" title=\"一、迭代器\"></a>一、迭代器</h3><p>iterator是一个或者实现了Iterator,或者实现ListIterator接口的对象，可以通过循环输出类集的内容，从而获得或删除元素，</p>\n<ul>\n<li>next()方法<ul>\n<li>逐个访问集合中的每个元素，经常需要与hasNext()方法搭配使用；</li>\n<li>java迭代器可以认为位于两个元素之家，当调用next()时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用</li>\n</ul>\n</li>\n<li>用”for each”循环遍历类集的内容，</li>\n<li>remove()方法删除上次调用next()时返回的元素，因而调用remove之前没有调用next是不合法的，删除的元素依赖于迭代器的状态</li>\n<li>对于实现List的类集，可以使用ListIterator，可以双向访问类集，如果在调用previous之后调用remove，则会将迭代器右边的元素删掉</li>\n</ul>\n<hr>\n<h3 id=\"二、List\"><a href=\"#二、List\" class=\"headerlink\" title=\"二、List\"></a>二、List</h3><p>有序集合，使用基于零的下标，可以用迭代器访问（顺序访问）或者用一个整数索引访问（随机访问）,有两个主要的实现类</p>\n<p><strong>ArrayList</strong></p>\n<ul>\n<li><p>基于数组，能够动态到地增加或减小其大小，当也可以调用ensureCapacity方法来进行人工地增加ArrayList的容量，从而避免再分配的消耗时间，前提是事先知道需要存储很多内容，然后往往是不知道</p>\n</li>\n<li><p>适用于需要进行随机访问时</p>\n</li>\n</ul>\n<p><strong>LinkedList</strong></p>\n<ul>\n<li>基于双向链表，</li>\n<li>对于有序集合，add方法只是添加到链表的尾部，当需要将元素添加到链表中间时，可以用迭代器的add，只有对自然有序的集合使用迭代器添加元素才有实际意义，但是这里的add不返回任何值</li>\n<li>适用于顺序访问</li>\n</ul>\n<hr>\n<h3 id=\"三、Set\"><a href=\"#三、Set\" class=\"headerlink\" title=\"三、Set\"></a>三、Set</h3><p>等同于Collection,不允许增加重复的元素，需要定义equals方法来确保元素唯一</p>\n<p><strong>HashSet</strong></p>\n<ul>\n<li>基于散列表的集，无序</li>\n<li>存入的元素必须定义有hashCode()，以得到散列码</li>\n<li>可以快速地查找，对于大的集合，add()、contains()、remove()、size()等方法的运行时间保持不变</li>\n<li>可以设置装填因子来实现再散列</li>\n<li>适用于不关心访问顺序，需要查找大容量容器时</li>\n</ul>\n<p><strong>TreeSet</strong></p>\n<ul>\n<li>基于红黑树排序，有序</li>\n<li>存入的元素必须实现Comparable接口，或者构造集必须提供一个Comparator</li>\n<li>每次添加元素时元素都会被放置到正确的位置，因而迭代器总是以排好序的顺序访问</li>\n<li>适用于存储大量需要进行快速检索的排序信息的情况</li>\n</ul>\n<p><strong>BitSet</strong></p>\n<ul>\n<li>用于存放一个位序列</li>\n</ul>\n<hr>\n<h3 id=\"四、Queue\"><a href=\"#四、Queue\" class=\"headerlink\" title=\"四、Queue\"></a>四、Queue</h3><p><strong>双端队列</strong><br>可以同时在头部或者尾部添加或删除元素，有两个实现</p>\n<ul>\n<li>inkedList</li>\n<li>ArrayList</li>\n</ul>\n<p><strong>PriorityQueue</strong></p>\n<ul>\n<li>基于堆，堆是可以自我调整的二叉树，对树执行add和remove时，可以让最小的元素移动到根，不必对元素排序</li>\n<li>按照任意顺序插入，却可以按照顺序进行检索</li>\n<li>和TreeSet一样，存入的元素必须实现Comparable接口，或者构造器必须提供一个Comparator</li>\n</ul>\n<hr>\n<h3 id=\"五、Map\"><a href=\"#五、Map\" class=\"headerlink\" title=\"五、Map\"></a>五、Map</h3><p>对键进行散列或排序，键必须唯一，同一个键多次调用put时，后面的会取代前面的，put返回这个键存储的上一个值。<br><strong>键不存在时</strong><br>get方法返回null，可以用getOrDefault返回默认值，test.get(id,0)<br><strong>更新映射项</strong><br>正常情况可以得到与一个键关联的值，替代原来的值，但是在需要持续更新时，例如:使用一个映射统计一个单词在文件中的频数，<code>counts.put(word,counts.get(word)+1)</code>,需要解决一个问题，就是键第一次出现时，这时可以有三种方法</p>\n<ul>\n<li><code>counts.put(word,counts.getOrDefault(word,0) + 1)</code></li>\n<li>先调用putIfAbsent，只有原先键存在时才会放一个值,<code>counts.putIfAnsent(word,0)</code><br>  <code>counts.put(word,counts.get(word)+1)</code>            </li>\n<li><code>counts.merge(word,1,Interger::sum)</code>(推荐）,当word关联的值为空（即键值对不存在），将word与1关联；不为空时，将sum应用于word和1，sum返回的结果与word关联</li>\n</ul>\n<p><strong>映射视图</strong><br>集合框架不认为映射本身是一种集合，不过可以通过调用Map一些方法得到映射的视图</p>\n<ul>\n<li>键集：<code>Set&lt;K&gt; keySet()</code>，</li>\n<li>值集：<code>Collection&lt;V&gt; values()</code>，</li>\n<li>键/值对集：<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></li>\n<li>这些集合不能添加元素，但可以删除这些集合中的远思，键和相关联的的值也将从映射中删除</li>\n</ul>\n<p><strong>散列</strong></p>\n<ul>\n<li>散列码，由对象的实例域产生的一个整数，由hashCOde()产生</li>\n<li>散列表，用链表数组实现，每个列表称为桶</li>\n<li><p>散列实现，Map中用数组保存键，查找表中对象的位置时，先算出散列码，然后与桶的总数取余，结果为保存此元素的桶的索引，即数组的下标，查询时通过equals()方法对List中的值进行查询</p>\n<blockquote>\n<p>新版jdk使用红黑树和List（数据多用树，少时用List)</p>\n</blockquote>\n</li>\n<li><p>散列冲突，桶被占满时，可以设置装填因子（0~1），对散列表满时进行再散列，即创建桶数更多的表</p>\n</li>\n</ul>\n<p><strong>HashMap</strong></p>\n<ul>\n<li>比较快，适用于不需要按照排列顺序访问键时</li>\n</ul>\n<p><strong>TreeMap</strong></p>\n<ul>\n<li>按排序顺序存储键值对，允许快速检索，保证了元素按关键字升序排序</li>\n</ul>\n<p><strong>WeakHashMap</strong></p>\n<ul>\n<li>使用弱引用（weak reference)保存key，WeakReference对象将引用保存到另外一个对象中，就是散列键</li>\n<li>如果垃圾回收器发现某个特定的对象已经没有人引用，就将其回收，而如果某个对象只由WeakReference引用，垃圾回收器仍然回收它，并将这个对象的弱引用放入队列，WeakHashMap将周期性地检查队列，一边找出新添加的弱引用，并将删除对应的条目</li>\n<li>适用于需要缓存时</li>\n</ul>\n<p><strong>LinkedHashMap</strong></p>\n<ul>\n<li>链接散列集与映射，用访问顺序，对映射条目进行迭代，每次调用get或put时，受到影响的条目从当前位置删除，并放到条目链表的尾部，不过条目仍然在原来散列码对应的桶中，只是改变了条目在链表中的位置</li>\n<li>用于实现高速缓存的“最近最少使用”原则</li>\n</ul>\n<hr>\n<h3 id=\"六、视图与包装器\"><a href=\"#六、视图与包装器\" class=\"headerlink\" title=\"六、视图与包装器\"></a>六、视图与包装器</h3><p><strong>轻量级集合包装器</strong><br>例如Arrays类的asList返回一个包装了普通java数组的List包装器，可以将数组传递给一个期望得到列表或集合参数的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Card[] cardDeck = <span class=\"keyword\">new</span> Card[<span class=\"number\">52</span>];</span><br><span class=\"line\">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>返回的是一个视图对象，可以调用底层数组的get和set，但不可改变数组的大小,例如Collections类的一些使用方法，<code>nCopied(100,&quot;KKK&quot;)</code>,<code>single(anObject)</code>等，返回一个不可修改的试图对象</p>\n</blockquote>\n<p><strong>子范围</strong></p>\n<ul>\n<li>相当于返回几个的一个“子集合”，例如返回列表staff的第10-19个元素，可以用<code>List group2 = staff.subList(10,20);</code>,类似于String类中获取子串</li>\n<li>可以将任何操作应用于子范围，如`group2.clear()``,元素会从staff中清除</li>\n<li>对于有序集或者映射，可以使用排序顺序建立子范围，如SortedSet声明的三个方法，返回大于等于from小于to的所有元素的子集，<blockquote>\n<p>SortedSet<e> subSet(E from, E to)<br>SortedSet<e> headSet(E to)<br>SortedSet<e> tailSet(E from)</e></e></e></p>\n</blockquote>\n</li>\n</ul>\n<p><strong>不可修改的视图</strong></p>\n<ul>\n<li>只能对现有集合增加了一个运行时的检查，试图修改会抛出异常，不过仍然可以通过原始引用修改</li>\n<li>访问器方法从原始集合对象中获取值</li>\n<li>视图只是包装了接口而不是实际的集合对象，因而只能访问接口中定义的方法，例如：<blockquote>\n<p><code>unmodifiableCollection</code>方法将返回一个集合，但他的<code>equals()</code>方法不调用底层集合的，而是调用它继承了<code>Object类的equals()</code>方法，这个方法只是检测两个对象是否是同一个对象，视图就是以这种方式运行的</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>同步视图</strong></p>\n<ul>\n<li>实现多线程访问，确保集合的线程安全，例如<code>Collections.synchronizedMap</code></li>\n</ul>\n<p><strong>受查视图</strong></p>\n<ul>\n<li>用来对泛型类型进行检测，例如<code>Collections.checkedList</code></li>\n</ul>\n<blockquote>\n<p>参阅：<br>  <a href=\"http://product.dangdang.com/24035306.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷I：基础知识</a></p>\n</blockquote>\n"},{"title":"git分支管理常用命令","date":"2018-03-11T07:26:34.000Z","_content":"\n创建分支：\n\n\n\tgit branch branch_name\n\n\n切换分支：\n\n\tgit checkout branch_name\n创建并切换分支\n\t\n\tgit checkout -b branch_name\n\n\n创建远程分支到本地：\n\n\tgit checkout -b branch_name origin/branch_name\t\n\n\n查看当前分支：\n\n\n\tgit branch\n\n获取所有分支：\n\n\tgit fetch\n\n合并某分支到当前分支：\n\n\tgit merge branch_name\n禁用Fast forward（快速合并）， 普通模式合并：\n\n\tgit merge --no-ff -m \"merge with no-ff\" branch_name\n\n> 这里会在合并的时候自动生成一个新的commit\n\n删除分支：\n\n\tgit branch -d branch_name\n\n强制删除分支（用于为合并就删除时）：\n\n\tgit branch -D branch_name\n\n\n查看分支合并图：\n\n\tgit log --graph\n\n保存分支工作现场：\n\n\tgit stash\n\n查看保存列表：\n\n\tgit stash list\n\n\n恢复保存状态：\n\n\tgit stash apply\n\tgit stash apply stash@{x}\n\n删除保存状态：\n\n\tgit stash drop \n\tgit stash drop stash@{x}\n\n恢复并删除保存状态：\n\n\tgit stash pop\n\n推送分支到远程仓库：\n\n\tgit push origin branch_name\n\n建立本地分支与远程分支的关联：\n\t\n\tgit branch --set-upstream branch-name origin/branch-name\n\n\n","source":"_posts/git分支管理.md","raw":"---\ntitle: git分支管理常用命令\ndate: 2018-03-11 15:26:34\ncategories: \"git\" \ntags:\n\t- git\n---\n\n创建分支：\n\n\n\tgit branch branch_name\n\n\n切换分支：\n\n\tgit checkout branch_name\n创建并切换分支\n\t\n\tgit checkout -b branch_name\n\n\n创建远程分支到本地：\n\n\tgit checkout -b branch_name origin/branch_name\t\n\n\n查看当前分支：\n\n\n\tgit branch\n\n获取所有分支：\n\n\tgit fetch\n\n合并某分支到当前分支：\n\n\tgit merge branch_name\n禁用Fast forward（快速合并）， 普通模式合并：\n\n\tgit merge --no-ff -m \"merge with no-ff\" branch_name\n\n> 这里会在合并的时候自动生成一个新的commit\n\n删除分支：\n\n\tgit branch -d branch_name\n\n强制删除分支（用于为合并就删除时）：\n\n\tgit branch -D branch_name\n\n\n查看分支合并图：\n\n\tgit log --graph\n\n保存分支工作现场：\n\n\tgit stash\n\n查看保存列表：\n\n\tgit stash list\n\n\n恢复保存状态：\n\n\tgit stash apply\n\tgit stash apply stash@{x}\n\n删除保存状态：\n\n\tgit stash drop \n\tgit stash drop stash@{x}\n\n恢复并删除保存状态：\n\n\tgit stash pop\n\n推送分支到远程仓库：\n\n\tgit push origin branch_name\n\n建立本地分支与远程分支的关联：\n\t\n\tgit branch --set-upstream branch-name origin/branch-name\n\n\n","slug":"git分支管理","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdd001cu7yjz7us3f90","content":"<p>创建分支：</p>\n<pre><code>git branch branch_name\n</code></pre><p>切换分支：</p>\n<pre><code>git checkout branch_name\n</code></pre><p>创建并切换分支</p>\n<pre><code>git checkout -b branch_name\n</code></pre><p>创建远程分支到本地：</p>\n<pre><code>git checkout -b branch_name origin/branch_name    \n</code></pre><p>查看当前分支：</p>\n<pre><code>git branch\n</code></pre><p>获取所有分支：</p>\n<pre><code>git fetch\n</code></pre><p>合并某分支到当前分支：</p>\n<pre><code>git merge branch_name\n</code></pre><p>禁用Fast forward（快速合并）， 普通模式合并：</p>\n<pre><code>git merge --no-ff -m &quot;merge with no-ff&quot; branch_name\n</code></pre><blockquote>\n<p>这里会在合并的时候自动生成一个新的commit</p>\n</blockquote>\n<p>删除分支：</p>\n<pre><code>git branch -d branch_name\n</code></pre><p>强制删除分支（用于为合并就删除时）：</p>\n<pre><code>git branch -D branch_name\n</code></pre><p>查看分支合并图：</p>\n<pre><code>git log --graph\n</code></pre><p>保存分支工作现场：</p>\n<pre><code>git stash\n</code></pre><p>查看保存列表：</p>\n<pre><code>git stash list\n</code></pre><p>恢复保存状态：</p>\n<pre><code>git stash apply\ngit stash apply stash@{x}\n</code></pre><p>删除保存状态：</p>\n<pre><code>git stash drop \ngit stash drop stash@{x}\n</code></pre><p>恢复并删除保存状态：</p>\n<pre><code>git stash pop\n</code></pre><p>推送分支到远程仓库：</p>\n<pre><code>git push origin branch_name\n</code></pre><p>建立本地分支与远程分支的关联：</p>\n<pre><code>git branch --set-upstream branch-name origin/branch-name\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>创建分支：</p>\n<pre><code>git branch branch_name\n</code></pre><p>切换分支：</p>\n<pre><code>git checkout branch_name\n</code></pre><p>创建并切换分支</p>\n<pre><code>git checkout -b branch_name\n</code></pre><p>创建远程分支到本地：</p>\n<pre><code>git checkout -b branch_name origin/branch_name    \n</code></pre><p>查看当前分支：</p>\n<pre><code>git branch\n</code></pre><p>获取所有分支：</p>\n<pre><code>git fetch\n</code></pre><p>合并某分支到当前分支：</p>\n<pre><code>git merge branch_name\n</code></pre><p>禁用Fast forward（快速合并）， 普通模式合并：</p>\n<pre><code>git merge --no-ff -m &quot;merge with no-ff&quot; branch_name\n</code></pre><blockquote>\n<p>这里会在合并的时候自动生成一个新的commit</p>\n</blockquote>\n<p>删除分支：</p>\n<pre><code>git branch -d branch_name\n</code></pre><p>强制删除分支（用于为合并就删除时）：</p>\n<pre><code>git branch -D branch_name\n</code></pre><p>查看分支合并图：</p>\n<pre><code>git log --graph\n</code></pre><p>保存分支工作现场：</p>\n<pre><code>git stash\n</code></pre><p>查看保存列表：</p>\n<pre><code>git stash list\n</code></pre><p>恢复保存状态：</p>\n<pre><code>git stash apply\ngit stash apply stash@{x}\n</code></pre><p>删除保存状态：</p>\n<pre><code>git stash drop \ngit stash drop stash@{x}\n</code></pre><p>恢复并删除保存状态：</p>\n<pre><code>git stash pop\n</code></pre><p>推送分支到远程仓库：</p>\n<pre><code>git push origin branch_name\n</code></pre><p>建立本地分支与远程分支的关联：</p>\n<pre><code>git branch --set-upstream branch-name origin/branch-name\n</code></pre>"},{"title":"git多账号配置，同时使用多个代码托管平台","date":"2018-04-09T13:01:52.000Z","_content":"\n我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。\n\n> ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。\n\n### 1 生成密钥\n这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空\n\n``` bash\n\tssh-keygen -T rsa -C \"example@qq.com\" \n```\n生成github的密钥![git_multi_account_ssh_github](/images/git_multiaccount_ssh_github.jpg)\n\n生成osc的密钥![git_multi_account_ssh_osc](/images/git_multiaccount_ssh_osc.jpg)\n\n\n\n查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc)\n\n``` bash\n\tls -a /root/.ssh \n\t\n```\n\n![git_multi_account_ssh_file](/images/git_multiaccount_ssh_file.png)\n\n### 2 接下来配置多账号\n\n在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容\n\n``` bash\n\n\t#github\n        Host github.com    \n        HostName github.com\n        IdentityFile ~/.ssh/id_rsa_github\n        User pinnuli\n\n\t#osc\n        Host gitee.com\n        HostName gitee.com\n        IdentityFile ~/.ssh/id_rsa_osc\n        User pinnuli\n\n```\n\n![git_multiaccount_config](/images/git_multiaccount_config.png)\n\n\n### 3 把对应的公钥放到github和osc上面\n\n![git_multiaccount_pub_github](/images/git_multiaccount_pub_github.png)\n\n![git_multiaccount_pub_osc](/images/git_multiaccount_pub_osc.png)\n\n### 4 测试是否成功\n\n\n``` bash\n\tssh -T git@github.com\n\n```\n![git_multiaccount_connect_github](/images/git_multiaccount_connect_github.png)\n\n``` bash\n\tssh -T git@gitee.com\n\n\t\n```\n\n![git_multiaccount_connect_osc](/images/git_multiaccount_connect_osc.png)\n\n\n至此，git多账号配置完毕，需要更多账号也是一样的道理\n","source":"_posts/git多账号配置，同时使用多个代码托管平台.md","raw":"---\ntitle: git多账号配置，同时使用多个代码托管平台\ndate: 2018-04-09 21:01:52\ncategories: \"git\" \ntags:\t\n        - git\n---\n\n我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。\n\n> ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。\n\n### 1 生成密钥\n这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空\n\n``` bash\n\tssh-keygen -T rsa -C \"example@qq.com\" \n```\n生成github的密钥![git_multi_account_ssh_github](/images/git_multiaccount_ssh_github.jpg)\n\n生成osc的密钥![git_multi_account_ssh_osc](/images/git_multiaccount_ssh_osc.jpg)\n\n\n\n查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc)\n\n``` bash\n\tls -a /root/.ssh \n\t\n```\n\n![git_multi_account_ssh_file](/images/git_multiaccount_ssh_file.png)\n\n### 2 接下来配置多账号\n\n在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容\n\n``` bash\n\n\t#github\n        Host github.com    \n        HostName github.com\n        IdentityFile ~/.ssh/id_rsa_github\n        User pinnuli\n\n\t#osc\n        Host gitee.com\n        HostName gitee.com\n        IdentityFile ~/.ssh/id_rsa_osc\n        User pinnuli\n\n```\n\n![git_multiaccount_config](/images/git_multiaccount_config.png)\n\n\n### 3 把对应的公钥放到github和osc上面\n\n![git_multiaccount_pub_github](/images/git_multiaccount_pub_github.png)\n\n![git_multiaccount_pub_osc](/images/git_multiaccount_pub_osc.png)\n\n### 4 测试是否成功\n\n\n``` bash\n\tssh -T git@github.com\n\n```\n![git_multiaccount_connect_github](/images/git_multiaccount_connect_github.png)\n\n``` bash\n\tssh -T git@gitee.com\n\n\t\n```\n\n![git_multiaccount_connect_osc](/images/git_multiaccount_connect_osc.png)\n\n\n至此，git多账号配置完毕，需要更多账号也是一样的道理\n","slug":"git多账号配置，同时使用多个代码托管平台","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fde001hu7yjzcbrixas","content":"<p>我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。</p>\n<blockquote>\n<p>ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。</p>\n</blockquote>\n<h3 id=\"1-生成密钥\"><a href=\"#1-生成密钥\" class=\"headerlink\" title=\"1 生成密钥\"></a>1 生成密钥</h3><p>这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -T rsa -C <span class=\"string\">\"example@qq.com\"</span></span><br></pre></td></tr></table></figure>\n<p>生成github的密钥<img src=\"/images/git_multiaccount_ssh_github.jpg\" alt=\"git_multi_account_ssh_github\"></p>\n<p>生成osc的密钥<img src=\"/images/git_multiaccount_ssh_osc.jpg\" alt=\"git_multi_account_ssh_osc\"></p>\n<p>查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a /root/.ssh</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_ssh_file.png\" alt=\"git_multi_account_ssh_file\"></p>\n<h3 id=\"2-接下来配置多账号\"><a href=\"#2-接下来配置多账号\" class=\"headerlink\" title=\"2 接下来配置多账号\"></a>2 接下来配置多账号</h3><p>在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#github</span></span><br><span class=\"line\">       Host github.com    </span><br><span class=\"line\">       HostName github.com</span><br><span class=\"line\">       IdentityFile ~/.ssh/id_rsa_github</span><br><span class=\"line\">       User pinnuli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#osc</span></span><br><span class=\"line\">       Host gitee.com</span><br><span class=\"line\">       HostName gitee.com</span><br><span class=\"line\">       IdentityFile ~/.ssh/id_rsa_osc</span><br><span class=\"line\">       User pinnuli</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_config.png\" alt=\"git_multiaccount_config\"></p>\n<h3 id=\"3-把对应的公钥放到github和osc上面\"><a href=\"#3-把对应的公钥放到github和osc上面\" class=\"headerlink\" title=\"3 把对应的公钥放到github和osc上面\"></a>3 把对应的公钥放到github和osc上面</h3><p><img src=\"/images/git_multiaccount_pub_github.png\" alt=\"git_multiaccount_pub_github\"></p>\n<p><img src=\"/images/git_multiaccount_pub_osc.png\" alt=\"git_multiaccount_pub_osc\"></p>\n<h3 id=\"4-测试是否成功\"><a href=\"#4-测试是否成功\" class=\"headerlink\" title=\"4 测试是否成功\"></a>4 测试是否成功</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_connect_github.png\" alt=\"git_multiaccount_connect_github\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_connect_osc.png\" alt=\"git_multiaccount_connect_osc\"></p>\n<p>至此，git多账号配置完毕，需要更多账号也是一样的道理</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们在使用git管理代码的时候，经常需要放到不同的托管网站，如github，osc等，那么不同的网站账号不一样，就需要生成不同密钥，配置对应的不同网站，接下来我们写写如何处理。</p>\n<blockquote>\n<p>ps:这里是在centos7.2下操作，不过其他操作系统依然适用，这里举的例子，一个是github，一个是osc。</p>\n</blockquote>\n<h3 id=\"1-生成密钥\"><a href=\"#1-生成密钥\" class=\"headerlink\" title=\"1 生成密钥\"></a>1 生成密钥</h3><p>这里可以设置密钥文件名和路径，/root/.ssh 是路径（一般路径选择默认），id_rsa_github是密钥文件名, 文件命名后按两次回车，即密码为空</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -T rsa -C <span class=\"string\">\"example@qq.com\"</span></span><br></pre></td></tr></table></figure>\n<p>生成github的密钥<img src=\"/images/git_multiaccount_ssh_github.jpg\" alt=\"git_multi_account_ssh_github\"></p>\n<p>生成osc的密钥<img src=\"/images/git_multiaccount_ssh_osc.jpg\" alt=\"git_multi_account_ssh_osc\"></p>\n<p>查看一下.ssh文件夹，发现有id_rsa_github, id_rsa_github.pub（放到github）,id_rsa_osc, id_rsa_osc.pub（放到osc)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a /root/.ssh</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_ssh_file.png\" alt=\"git_multi_account_ssh_file\"></p>\n<h3 id=\"2-接下来配置多账号\"><a href=\"#2-接下来配置多账号\" class=\"headerlink\" title=\"2 接下来配置多账号\"></a>2 接下来配置多账号</h3><p>在.ssh文件夹下面新建一个命名为config的文件，编辑如下内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#github</span></span><br><span class=\"line\">       Host github.com    </span><br><span class=\"line\">       HostName github.com</span><br><span class=\"line\">       IdentityFile ~/.ssh/id_rsa_github</span><br><span class=\"line\">       User pinnuli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#osc</span></span><br><span class=\"line\">       Host gitee.com</span><br><span class=\"line\">       HostName gitee.com</span><br><span class=\"line\">       IdentityFile ~/.ssh/id_rsa_osc</span><br><span class=\"line\">       User pinnuli</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_config.png\" alt=\"git_multiaccount_config\"></p>\n<h3 id=\"3-把对应的公钥放到github和osc上面\"><a href=\"#3-把对应的公钥放到github和osc上面\" class=\"headerlink\" title=\"3 把对应的公钥放到github和osc上面\"></a>3 把对应的公钥放到github和osc上面</h3><p><img src=\"/images/git_multiaccount_pub_github.png\" alt=\"git_multiaccount_pub_github\"></p>\n<p><img src=\"/images/git_multiaccount_pub_osc.png\" alt=\"git_multiaccount_pub_osc\"></p>\n<h3 id=\"4-测试是否成功\"><a href=\"#4-测试是否成功\" class=\"headerlink\" title=\"4 测试是否成功\"></a>4 测试是否成功</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_connect_github.png\" alt=\"git_multiaccount_connect_github\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/git_multiaccount_connect_osc.png\" alt=\"git_multiaccount_connect_osc\"></p>\n<p>至此，git多账号配置完毕，需要更多账号也是一样的道理</p>\n"},{"title":"jsoup要点记录","date":"2018-03-16T04:50:17.000Z","_content":"\n\n### 查找dom元素 \n\n- getElementById: 根据id查询\n- getElementsByTag: 根据tag名称查询\n- getElementsByClass: 根据样式class名称查询\n- getElementsByAttribute: 根据属性名查询\n- getElementsByAttributeValue: 根据属性名和属性值查询\n\n实例代码\n\n``` java\n\t\n\timport org.apache.http.HttpEntity;\n\timport org.apache.http.client.methods.CloseableHttpResponse;\n\timport org.apache.http.client.methods.HttpGet;\n\timport org.apache.http.impl.client.CloseableHttpClient;\n\timport org.apache.http.impl.client.HttpClients;\n\timport org.apache.http.util.EntityUtils;\n\timport org.jsoup.Jsoup;\n\timport org.jsoup.nodes.Document;\n\timport org.jsoup.nodes.Element;\n\timport org.jsoup.select.Elements;\n\n\tpublic class Demo01 {\n\n\t\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\t\t/*用heepclient发起请求获取页面*/\n\t\t\tCloseableHttpClient httpClient = HttpClients.createDefault();\n\t\t\tHttpGet httpGet = new HttpGet(\"https://www.cnblogs.com/\");\n\t\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\t\tHttpEntity entity = response.getEntity();\n\t\t\tString content = EntityUtils.toString(entity, \"utf-8\");\n\t\t\tresponse.close();\n\t\t\tDocument doc = Jsoup.parse(content); //用jsoup解析\n\t\t\t\n\t\t\t//通过标签名称查询\n\t\t\tElements elements = doc.getElementsByTag(\"title\");\n\t\t\tElement element = elements.get(0);\n\t\t\tString title = element.text();\n\t\t\tSystem.out.println(\"网页标题：\" + title);\n\t\t\t\n\t\t\t//获取首个标题标签内容\n\t\t\tElement titleElement = doc.getElementsByTag(\"title\").first(); \n\t\t\tSystem.out.println(\"首个标题： \" + titleElement.text());\n\t\t\t\n\t\t\t//通过id查询\n\t\t\tElement idElement = doc.getElementById(\"site_nav_top\"); \n\t\t\tSystem.out.println(\"id查询：\" + idElement.text());\n\t\t\t\n\t\t\t//通过class样式获取查询\n\t\t\tElements itemElements = doc.getElementsByClass(\"post_item\"); \n\t\t\tSystem.out.println(\"**********样式查询**********\");\n\t\t\tfor(Element e: itemElements) {\n\t\t\t\tSystem.out.println(e.text());\n\t\t\t\tSystem.out.println(\"-------\");\n\t\t\t}\n\t\t\n\t\t\t//属性名称查询\n\t\t\tElements attrElements = doc.getElementsByAttribute(\"width\");\n\t\t\tSystem.out.println(\"**********属性查询**********\");\n\t\t\tfor(Element e: attrElements) {\n\t\t\t\tSystem.out.println(e.toString());\n\t\t\t}\n\t\t\n\t\t\t//属性名称和属性值查询\n\t\t\tElements attrValueElements = doc.getElementsByAttributeValue(\"target\", \"_blank\");\n\t\t\tSystem.out.println(\"**********属性和属性值查询**********\");\n\t\t\tfor(Element e: attrValueElements) {\n\t\t\t\tSystem.out.println(e.toString());\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\n```\n\n\n### 查找dom元素属性值 \n\n\n实例代码\n\n```java\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\n\npublic class Demo2 {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\t/*用heepclient发起请求获取页面*/\n\t\tCloseableHttpClient httpClient = HttpClients.createDefault();\n\t\tHttpGet httpGet = new HttpGet(\"https://www.cnblogs.com/\");\n\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\tHttpEntity entity = response.getEntity();\n\t\tString content = EntityUtils.toString(entity, \"utf-8\");\n\t\tresponse.close();\n\t\tDocument doc = Jsoup.parse(content); //用jsoup解析\n\n\t\t\n\t\t//获取带有href属性的a标签\n\t\tElements attrElements = doc.select(\"a[href]\");\n\t\tSystem.out.println(\"**********获取属性值**********\");\n\t\tfor(Element e: attrElements) {\n\t\t\tSystem.out.println(e.toString());\n\t\t\tSystem.out.println(\"-------\");\n\t\t}\n\t\t\n\t\t//查找拓展名为gif的img标签\n\t\tElements imgElements = doc.select(\"img[src$=.gif]\");\n\t\tSystem.out.println(\"**********带有拓展名查询**********\");\n\t\tfor(Element e: imgElements) {\n\t\t\tSystem.out.println(e.toString());\n\t\t}\n\t}\n\n}\n\n\n```\n\n\n\n### 使用选择器查询\n\n **Jsoup 支持css，jquery的选择器**\n\n实例代码\n\n``` java\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\n\npublic class Demo03 {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\t/*用heepclient发起请求获取页面*/\n\t\tCloseableHttpClient httpClient = HttpClients.createDefault();\n\t\tHttpGet httpGet = new HttpGet(\"https://www.cnblogs.com/\");\n\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\tHttpEntity entity = response.getEntity();\n\t\tString content = EntityUtils.toString(entity, \"utf-8\");\n\t\tresponse.close();\n\t\tDocument doc = Jsoup.parse(content); //用jsoup解析\n\t\t\n\t\t//通过选择器查询\n\t\tElements linkElements = doc.select(\".headline ul .editor_pick a\");\n\t\tSystem.out.println(\"**********选择器查询**********\");\n\t\tfor(Element e: linkElements) {\n\t\t\tSystem.out.println(e.toString());\n\t\t\tSystem.out.println(\"地址： \" + e.attr(\"href\"));\n\t\t\tSystem.out.println(\"-------\");\n\t\t}\n\t\t\n\t\tElement linkElement = doc.select(\".headline ul li\").first();\n\t\tSystem.out.println(\"文本： \" + linkElement.text());\n\t\tSystem.out.println(\"html: \" + linkElement.html());\n\t\tSystem.out.println(\"class属性值： \" + linkElement.attr(\"class\"));\n\t\t\t\n\t}\n\n}\n\n```\n\n","source":"_posts/jsoup要点记录.md","raw":"---\ntitle: jsoup要点记录\ndate: 2018-03-16 12:50:17\ncategories: \"Jsoup笔记\" \ntags:\n\t- java爬虫\n\t- Jsoup\n---\n\n\n### 查找dom元素 \n\n- getElementById: 根据id查询\n- getElementsByTag: 根据tag名称查询\n- getElementsByClass: 根据样式class名称查询\n- getElementsByAttribute: 根据属性名查询\n- getElementsByAttributeValue: 根据属性名和属性值查询\n\n实例代码\n\n``` java\n\t\n\timport org.apache.http.HttpEntity;\n\timport org.apache.http.client.methods.CloseableHttpResponse;\n\timport org.apache.http.client.methods.HttpGet;\n\timport org.apache.http.impl.client.CloseableHttpClient;\n\timport org.apache.http.impl.client.HttpClients;\n\timport org.apache.http.util.EntityUtils;\n\timport org.jsoup.Jsoup;\n\timport org.jsoup.nodes.Document;\n\timport org.jsoup.nodes.Element;\n\timport org.jsoup.select.Elements;\n\n\tpublic class Demo01 {\n\n\t\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\t\t/*用heepclient发起请求获取页面*/\n\t\t\tCloseableHttpClient httpClient = HttpClients.createDefault();\n\t\t\tHttpGet httpGet = new HttpGet(\"https://www.cnblogs.com/\");\n\t\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\t\tHttpEntity entity = response.getEntity();\n\t\t\tString content = EntityUtils.toString(entity, \"utf-8\");\n\t\t\tresponse.close();\n\t\t\tDocument doc = Jsoup.parse(content); //用jsoup解析\n\t\t\t\n\t\t\t//通过标签名称查询\n\t\t\tElements elements = doc.getElementsByTag(\"title\");\n\t\t\tElement element = elements.get(0);\n\t\t\tString title = element.text();\n\t\t\tSystem.out.println(\"网页标题：\" + title);\n\t\t\t\n\t\t\t//获取首个标题标签内容\n\t\t\tElement titleElement = doc.getElementsByTag(\"title\").first(); \n\t\t\tSystem.out.println(\"首个标题： \" + titleElement.text());\n\t\t\t\n\t\t\t//通过id查询\n\t\t\tElement idElement = doc.getElementById(\"site_nav_top\"); \n\t\t\tSystem.out.println(\"id查询：\" + idElement.text());\n\t\t\t\n\t\t\t//通过class样式获取查询\n\t\t\tElements itemElements = doc.getElementsByClass(\"post_item\"); \n\t\t\tSystem.out.println(\"**********样式查询**********\");\n\t\t\tfor(Element e: itemElements) {\n\t\t\t\tSystem.out.println(e.text());\n\t\t\t\tSystem.out.println(\"-------\");\n\t\t\t}\n\t\t\n\t\t\t//属性名称查询\n\t\t\tElements attrElements = doc.getElementsByAttribute(\"width\");\n\t\t\tSystem.out.println(\"**********属性查询**********\");\n\t\t\tfor(Element e: attrElements) {\n\t\t\t\tSystem.out.println(e.toString());\n\t\t\t}\n\t\t\n\t\t\t//属性名称和属性值查询\n\t\t\tElements attrValueElements = doc.getElementsByAttributeValue(\"target\", \"_blank\");\n\t\t\tSystem.out.println(\"**********属性和属性值查询**********\");\n\t\t\tfor(Element e: attrValueElements) {\n\t\t\t\tSystem.out.println(e.toString());\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\n```\n\n\n### 查找dom元素属性值 \n\n\n实例代码\n\n```java\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\n\npublic class Demo2 {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\t/*用heepclient发起请求获取页面*/\n\t\tCloseableHttpClient httpClient = HttpClients.createDefault();\n\t\tHttpGet httpGet = new HttpGet(\"https://www.cnblogs.com/\");\n\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\tHttpEntity entity = response.getEntity();\n\t\tString content = EntityUtils.toString(entity, \"utf-8\");\n\t\tresponse.close();\n\t\tDocument doc = Jsoup.parse(content); //用jsoup解析\n\n\t\t\n\t\t//获取带有href属性的a标签\n\t\tElements attrElements = doc.select(\"a[href]\");\n\t\tSystem.out.println(\"**********获取属性值**********\");\n\t\tfor(Element e: attrElements) {\n\t\t\tSystem.out.println(e.toString());\n\t\t\tSystem.out.println(\"-------\");\n\t\t}\n\t\t\n\t\t//查找拓展名为gif的img标签\n\t\tElements imgElements = doc.select(\"img[src$=.gif]\");\n\t\tSystem.out.println(\"**********带有拓展名查询**********\");\n\t\tfor(Element e: imgElements) {\n\t\t\tSystem.out.println(e.toString());\n\t\t}\n\t}\n\n}\n\n\n```\n\n\n\n### 使用选择器查询\n\n **Jsoup 支持css，jquery的选择器**\n\n实例代码\n\n``` java\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\n\npublic class Demo03 {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\t/*用heepclient发起请求获取页面*/\n\t\tCloseableHttpClient httpClient = HttpClients.createDefault();\n\t\tHttpGet httpGet = new HttpGet(\"https://www.cnblogs.com/\");\n\t\tCloseableHttpResponse response = httpClient.execute(httpGet);\n\t\tHttpEntity entity = response.getEntity();\n\t\tString content = EntityUtils.toString(entity, \"utf-8\");\n\t\tresponse.close();\n\t\tDocument doc = Jsoup.parse(content); //用jsoup解析\n\t\t\n\t\t//通过选择器查询\n\t\tElements linkElements = doc.select(\".headline ul .editor_pick a\");\n\t\tSystem.out.println(\"**********选择器查询**********\");\n\t\tfor(Element e: linkElements) {\n\t\t\tSystem.out.println(e.toString());\n\t\t\tSystem.out.println(\"地址： \" + e.attr(\"href\"));\n\t\t\tSystem.out.println(\"-------\");\n\t\t}\n\t\t\n\t\tElement linkElement = doc.select(\".headline ul li\").first();\n\t\tSystem.out.println(\"文本： \" + linkElement.text());\n\t\tSystem.out.println(\"html: \" + linkElement.html());\n\t\tSystem.out.println(\"class属性值： \" + linkElement.attr(\"class\"));\n\t\t\t\n\t}\n\n}\n\n```\n\n","slug":"jsoup要点记录","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdg001ku7yjpvcwkvll","content":"<h3 id=\"查找dom元素\"><a href=\"#查找dom元素\" class=\"headerlink\" title=\"查找dom元素\"></a>查找dom元素</h3><ul>\n<li>getElementById: 根据id查询</li>\n<li>getElementsByTag: 根据tag名称查询</li>\n<li>getElementsByClass: 根据样式class名称查询</li>\n<li>getElementsByAttribute: 根据属性名查询</li>\n<li>getElementsByAttributeValue: 根据属性名和属性值查询</li>\n</ul>\n<p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.HttpEntity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.util.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.Jsoup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Document;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.select.Elements;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*用heepclient发起请求获取页面*/</span></span><br><span class=\"line\">\t\tCloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">\"https://www.cnblogs.com/\"</span>);</span><br><span class=\"line\">\t\tCloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">\t\tHttpEntity entity = response.getEntity();</span><br><span class=\"line\">\t\tString content = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">\t\tresponse.close();</span><br><span class=\"line\">\t\tDocument doc = Jsoup.parse(content); <span class=\"comment\">//用jsoup解析</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过标签名称查询</span></span><br><span class=\"line\">\t\tElements elements = doc.getElementsByTag(<span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">\t\tElement element = elements.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tString title = element.text();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"网页标题：\"</span> + title);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取首个标题标签内容</span></span><br><span class=\"line\">\t\tElement titleElement = doc.getElementsByTag(<span class=\"string\">\"title\"</span>).first(); </span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"首个标题： \"</span> + titleElement.text());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过id查询</span></span><br><span class=\"line\">\t\tElement idElement = doc.getElementById(<span class=\"string\">\"site_nav_top\"</span>); </span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"id查询：\"</span> + idElement.text());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过class样式获取查询</span></span><br><span class=\"line\">\t\tElements itemElements = doc.getElementsByClass(<span class=\"string\">\"post_item\"</span>); </span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********样式查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: itemElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.text());</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"-------\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//属性名称查询</span></span><br><span class=\"line\">\t\tElements attrElements = doc.getElementsByAttribute(<span class=\"string\">\"width\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********属性查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: attrElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//属性名称和属性值查询</span></span><br><span class=\"line\">\t\tElements attrValueElements = doc.getElementsByAttributeValue(<span class=\"string\">\"target\"</span>, <span class=\"string\">\"_blank\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********属性和属性值查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: attrValueElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找dom元素属性值\"><a href=\"#查找dom元素属性值\" class=\"headerlink\" title=\"查找dom元素属性值\"></a>查找dom元素属性值</h3><p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.HttpEntity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.util.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.Jsoup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Document;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.select.Elements;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*用heepclient发起请求获取页面*/</span></span><br><span class=\"line\">\t\tCloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">\"https://www.cnblogs.com/\"</span>);</span><br><span class=\"line\">\t\tCloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">\t\tHttpEntity entity = response.getEntity();</span><br><span class=\"line\">\t\tString content = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">\t\tresponse.close();</span><br><span class=\"line\">\t\tDocument doc = Jsoup.parse(content); <span class=\"comment\">//用jsoup解析</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取带有href属性的a标签</span></span><br><span class=\"line\">\t\tElements attrElements = doc.select(<span class=\"string\">\"a[href]\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********获取属性值**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: attrElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"-------\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//查找拓展名为gif的img标签</span></span><br><span class=\"line\">\t\tElements imgElements = doc.select(<span class=\"string\">\"img[src$=.gif]\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********带有拓展名查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: imgElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用选择器查询\"><a href=\"#使用选择器查询\" class=\"headerlink\" title=\"使用选择器查询\"></a>使用选择器查询</h3><p> <strong>Jsoup 支持css，jquery的选择器</strong></p>\n<p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.HttpEntity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.util.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.Jsoup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Document;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.select.Elements;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo03</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*用heepclient发起请求获取页面*/</span></span><br><span class=\"line\">\t\tCloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">\"https://www.cnblogs.com/\"</span>);</span><br><span class=\"line\">\t\tCloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">\t\tHttpEntity entity = response.getEntity();</span><br><span class=\"line\">\t\tString content = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">\t\tresponse.close();</span><br><span class=\"line\">\t\tDocument doc = Jsoup.parse(content); <span class=\"comment\">//用jsoup解析</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过选择器查询</span></span><br><span class=\"line\">\t\tElements linkElements = doc.select(<span class=\"string\">\".headline ul .editor_pick a\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********选择器查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: linkElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"地址： \"</span> + e.attr(<span class=\"string\">\"href\"</span>));</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"-------\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tElement linkElement = doc.select(<span class=\"string\">\".headline ul li\"</span>).first();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"文本： \"</span> + linkElement.text());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"html: \"</span> + linkElement.html());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"class属性值： \"</span> + linkElement.attr(<span class=\"string\">\"class\"</span>));</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"查找dom元素\"><a href=\"#查找dom元素\" class=\"headerlink\" title=\"查找dom元素\"></a>查找dom元素</h3><ul>\n<li>getElementById: 根据id查询</li>\n<li>getElementsByTag: 根据tag名称查询</li>\n<li>getElementsByClass: 根据样式class名称查询</li>\n<li>getElementsByAttribute: 根据属性名查询</li>\n<li>getElementsByAttributeValue: 根据属性名和属性值查询</li>\n</ul>\n<p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.HttpEntity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.util.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.Jsoup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Document;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.select.Elements;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo01</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*用heepclient发起请求获取页面*/</span></span><br><span class=\"line\">\t\tCloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">\"https://www.cnblogs.com/\"</span>);</span><br><span class=\"line\">\t\tCloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">\t\tHttpEntity entity = response.getEntity();</span><br><span class=\"line\">\t\tString content = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">\t\tresponse.close();</span><br><span class=\"line\">\t\tDocument doc = Jsoup.parse(content); <span class=\"comment\">//用jsoup解析</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过标签名称查询</span></span><br><span class=\"line\">\t\tElements elements = doc.getElementsByTag(<span class=\"string\">\"title\"</span>);</span><br><span class=\"line\">\t\tElement element = elements.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tString title = element.text();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"网页标题：\"</span> + title);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取首个标题标签内容</span></span><br><span class=\"line\">\t\tElement titleElement = doc.getElementsByTag(<span class=\"string\">\"title\"</span>).first(); </span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"首个标题： \"</span> + titleElement.text());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过id查询</span></span><br><span class=\"line\">\t\tElement idElement = doc.getElementById(<span class=\"string\">\"site_nav_top\"</span>); </span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"id查询：\"</span> + idElement.text());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过class样式获取查询</span></span><br><span class=\"line\">\t\tElements itemElements = doc.getElementsByClass(<span class=\"string\">\"post_item\"</span>); </span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********样式查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: itemElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.text());</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"-------\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//属性名称查询</span></span><br><span class=\"line\">\t\tElements attrElements = doc.getElementsByAttribute(<span class=\"string\">\"width\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********属性查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: attrElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//属性名称和属性值查询</span></span><br><span class=\"line\">\t\tElements attrValueElements = doc.getElementsByAttributeValue(<span class=\"string\">\"target\"</span>, <span class=\"string\">\"_blank\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********属性和属性值查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: attrValueElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找dom元素属性值\"><a href=\"#查找dom元素属性值\" class=\"headerlink\" title=\"查找dom元素属性值\"></a>查找dom元素属性值</h3><p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.HttpEntity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.util.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.Jsoup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Document;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.select.Elements;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/*用heepclient发起请求获取页面*/</span></span><br><span class=\"line\">\t\tCloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">\"https://www.cnblogs.com/\"</span>);</span><br><span class=\"line\">\t\tCloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">\t\tHttpEntity entity = response.getEntity();</span><br><span class=\"line\">\t\tString content = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">\t\tresponse.close();</span><br><span class=\"line\">\t\tDocument doc = Jsoup.parse(content); <span class=\"comment\">//用jsoup解析</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//获取带有href属性的a标签</span></span><br><span class=\"line\">\t\tElements attrElements = doc.select(<span class=\"string\">\"a[href]\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********获取属性值**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: attrElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"-------\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//查找拓展名为gif的img标签</span></span><br><span class=\"line\">\t\tElements imgElements = doc.select(<span class=\"string\">\"img[src$=.gif]\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********带有拓展名查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: imgElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用选择器查询\"><a href=\"#使用选择器查询\" class=\"headerlink\" title=\"使用选择器查询\"></a>使用选择器查询</h3><p> <strong>Jsoup 支持css，jquery的选择器</strong></p>\n<p>实例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.HttpEntity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.util.EntityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.Jsoup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Document;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.nodes.Element;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.jsoup.select.Elements;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo03</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*用heepclient发起请求获取页面*/</span></span><br><span class=\"line\">\t\tCloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class=\"line\">\t\tHttpGet httpGet = <span class=\"keyword\">new</span> HttpGet(<span class=\"string\">\"https://www.cnblogs.com/\"</span>);</span><br><span class=\"line\">\t\tCloseableHttpResponse response = httpClient.execute(httpGet);</span><br><span class=\"line\">\t\tHttpEntity entity = response.getEntity();</span><br><span class=\"line\">\t\tString content = EntityUtils.toString(entity, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">\t\tresponse.close();</span><br><span class=\"line\">\t\tDocument doc = Jsoup.parse(content); <span class=\"comment\">//用jsoup解析</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过选择器查询</span></span><br><span class=\"line\">\t\tElements linkElements = doc.select(<span class=\"string\">\".headline ul .editor_pick a\"</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"**********选择器查询**********\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Element e: linkElements) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(e.toString());</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"地址： \"</span> + e.attr(<span class=\"string\">\"href\"</span>));</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"-------\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tElement linkElement = doc.select(<span class=\"string\">\".headline ul li\"</span>).first();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"文本： \"</span> + linkElement.text());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"html: \"</span> + linkElement.html());</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"class属性值： \"</span> + linkElement.attr(<span class=\"string\">\"class\"</span>));</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"markdownpad2 无法预览 显示This view has crashed!","date":"2018-03-10T09:46:33.000Z","_content":"\n在使用markdownpad2时，一直报错，说html渲染错误，上了官网查看解释如下，\n![error resport](/images/markdownpad2.png)\n要安装 [Awesomium 1.6.6 SDK](http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe)，如果不行再安装[DirectX最终用户运行时](http://www.microsoft.com/en-us/download/details.aspx?id=8109),\n不过一般只需要安装sdk就没问题了","source":"_posts/markdownpad2-无法预览-显示This-view-has-crashed.md","raw":"---\ntitle: markdownpad2 无法预览 显示This view has crashed!\ndate: 2018-03-10 17:46:33\ncategories: \"踩过的坑\"\ntags: \n    - markdownPad\n---\n\n在使用markdownpad2时，一直报错，说html渲染错误，上了官网查看解释如下，\n![error resport](/images/markdownpad2.png)\n要安装 [Awesomium 1.6.6 SDK](http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe)，如果不行再安装[DirectX最终用户运行时](http://www.microsoft.com/en-us/download/details.aspx?id=8109),\n不过一般只需要安装sdk就没问题了","slug":"markdownpad2-无法预览-显示This-view-has-crashed","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdi001pu7yjl3cr45gs","content":"<p>在使用markdownpad2时，一直报错，说html渲染错误，上了官网查看解释如下，<br><img src=\"/images/markdownpad2.png\" alt=\"error resport\"><br>要安装 <a href=\"http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe\" target=\"_blank\" rel=\"noopener\">Awesomium 1.6.6 SDK</a>，如果不行再安装<a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=8109\" target=\"_blank\" rel=\"noopener\">DirectX最终用户运行时</a>,<br>不过一般只需要安装sdk就没问题了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用markdownpad2时，一直报错，说html渲染错误，上了官网查看解释如下，<br><img src=\"/images/markdownpad2.png\" alt=\"error resport\"><br>要安装 <a href=\"http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe\" target=\"_blank\" rel=\"noopener\">Awesomium 1.6.6 SDK</a>，如果不行再安装<a href=\"http://www.microsoft.com/en-us/download/details.aspx?id=8109\" target=\"_blank\" rel=\"noopener\">DirectX最终用户运行时</a>,<br>不过一般只需要安装sdk就没问题了</p>\n"},{"title":"nginx 配置实现端口转发","date":"2018-04-04T14:14:46.000Z","_content":"最近在部署一个小程序的后台，但是小程序调用的接口是不能带端口号的，那么如果服务器上面80端口已经被其他程序占用，就只能采用端口转发或者虚拟目录，我采用的是端口转发，或者说当在一台主机上需要部署多个web应用，并且需要能在80端口访问这些web时，就可以采用这种方法，也可以叫做nginx反向代理用于实现负载均衡，这里记录一下遇到的一些小问题。\n\n加入服务器域名是test.com,那么你可以通过test.com/news在80端口访问新闻应用，但是服务器上分配的是其他端口，如8081。\n对应的nginx配置如下：\n\n80端口的配置： 访问test.com/news => 127.0.0.1:8081 ,这里有一个需要注意的地方是转发的url最后需要加上'/'，\n这相当指定了url'/',如果代理服务器地址中是带有URL的，此URL会替换掉 location 所匹配的URL部分, test.com/news/api,访问的是ip:8081/api;而如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器,test.com/news/api,访问的是ip:8081/news/api;\n\n``` bash\n\nserver {\n        listen       80;\n #      listen       [::]:80 default_server;\n        server_name  test.com\n        root         /usr/share/nginx/html;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n        }\n\n        location /news{\n                proxy_pass http:test.com:8081/;\n        }\n\n    }\n\n```\n\n8081端口的配置： 与平时配置没什么差别\n\n``` bash\n\n\tserver {\n        listen 8081;\n        server_name localhost;\n        root /var/www/project;\n\n\n        location / {\n        index index.php index.html index.htm;\n        if ( !-e $request_filename){\n        rewrite ^(.*)$ /index.php?s=/$1 last;\n        break;\n                }\n        }\n\n\t   #error_page 500 502 503 504  /50x.html;\n       #location = /50x.html {\n       #root /usr/share/ngixn/html;\n       #}\n\n       #我部署的是PHP项目，这里配置PHP解析\n        location ~ \\.php$ {\n        fastcgi_pass 127.0.0.1:9000;\n        fastcgi_index index.php;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        include /etc/nginx/fastcgi_params;\n        include /etc/nginx/fastcgi.conf;\n        }\n}\n\n```\n\n","source":"_posts/nginx-配置实现端口转发.md","raw":"---\ntitle: nginx 配置实现端口转发\ndate: 2018-04-04 22:14:46\ncategories: \"服务器\"\ntags: \n    - nginx\n    - 服务器\n---\n最近在部署一个小程序的后台，但是小程序调用的接口是不能带端口号的，那么如果服务器上面80端口已经被其他程序占用，就只能采用端口转发或者虚拟目录，我采用的是端口转发，或者说当在一台主机上需要部署多个web应用，并且需要能在80端口访问这些web时，就可以采用这种方法，也可以叫做nginx反向代理用于实现负载均衡，这里记录一下遇到的一些小问题。\n\n加入服务器域名是test.com,那么你可以通过test.com/news在80端口访问新闻应用，但是服务器上分配的是其他端口，如8081。\n对应的nginx配置如下：\n\n80端口的配置： 访问test.com/news => 127.0.0.1:8081 ,这里有一个需要注意的地方是转发的url最后需要加上'/'，\n这相当指定了url'/',如果代理服务器地址中是带有URL的，此URL会替换掉 location 所匹配的URL部分, test.com/news/api,访问的是ip:8081/api;而如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器,test.com/news/api,访问的是ip:8081/news/api;\n\n``` bash\n\nserver {\n        listen       80;\n #      listen       [::]:80 default_server;\n        server_name  test.com\n        root         /usr/share/nginx/html;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n        }\n\n        location /news{\n                proxy_pass http:test.com:8081/;\n        }\n\n    }\n\n```\n\n8081端口的配置： 与平时配置没什么差别\n\n``` bash\n\n\tserver {\n        listen 8081;\n        server_name localhost;\n        root /var/www/project;\n\n\n        location / {\n        index index.php index.html index.htm;\n        if ( !-e $request_filename){\n        rewrite ^(.*)$ /index.php?s=/$1 last;\n        break;\n                }\n        }\n\n\t   #error_page 500 502 503 504  /50x.html;\n       #location = /50x.html {\n       #root /usr/share/ngixn/html;\n       #}\n\n       #我部署的是PHP项目，这里配置PHP解析\n        location ~ \\.php$ {\n        fastcgi_pass 127.0.0.1:9000;\n        fastcgi_index index.php;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        include /etc/nginx/fastcgi_params;\n        include /etc/nginx/fastcgi.conf;\n        }\n}\n\n```\n\n","slug":"nginx-配置实现端口转发","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdj001su7yj7xo0yfk9","content":"<p>最近在部署一个小程序的后台，但是小程序调用的接口是不能带端口号的，那么如果服务器上面80端口已经被其他程序占用，就只能采用端口转发或者虚拟目录，我采用的是端口转发，或者说当在一台主机上需要部署多个web应用，并且需要能在80端口访问这些web时，就可以采用这种方法，也可以叫做nginx反向代理用于实现负载均衡，这里记录一下遇到的一些小问题。</p>\n<p>加入服务器域名是test.com,那么你可以通过test.com/news在80端口访问新闻应用，但是服务器上分配的是其他端口，如8081。<br>对应的nginx配置如下：</p>\n<p>80端口的配置： 访问test.com/news =&gt; 127.0.0.1:8081 ,这里有一个需要注意的地方是转发的url最后需要加上’/‘，<br>这相当指定了url’/‘,如果代理服务器地址中是带有URL的，此URL会替换掉 location 所匹配的URL部分, test.com/news/api,访问的是ip:8081/api;而如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器,test.com/news/api,访问的是ip:8081/news/api;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\"> <span class=\"comment\">#      listen       [::]:80 default_server;</span></span><br><span class=\"line\">        server_name  test.com</span><br><span class=\"line\">        root         /usr/share/nginx/html;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Load configuration files for the default server block.</span></span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        location /news&#123;</span><br><span class=\"line\">                proxy_pass http:test.com:8081/;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>8081端口的配置： 与平时配置没什么差别</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">        listen 8081;</span><br><span class=\"line\">        server_name localhost;</span><br><span class=\"line\">        root /var/www/project;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        index index.php index.html index.htm;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !-e <span class=\"variable\">$request_filename</span>)&#123;</span><br><span class=\"line\">        rewrite ^(.*)$ /index.php?s=/<span class=\"variable\">$1</span> last;</span><br><span class=\"line\">        <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t   <span class=\"comment\">#error_page 500 502 503 504  /50x.html;</span></span><br><span class=\"line\">       <span class=\"comment\">#location = /50x.html &#123;</span></span><br><span class=\"line\">       <span class=\"comment\">#root /usr/share/ngixn/html;</span></span><br><span class=\"line\">       <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">#我部署的是PHP项目，这里配置PHP解析</span></span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">        fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">        fastcgi_index index.php;</span><br><span class=\"line\">        fastcgi_param SCRIPT_FILENAME <span class=\"variable\">$document_root</span><span class=\"variable\">$fastcgi_script_name</span>;</span><br><span class=\"line\">        include /etc/nginx/fastcgi_params;</span><br><span class=\"line\">        include /etc/nginx/fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在部署一个小程序的后台，但是小程序调用的接口是不能带端口号的，那么如果服务器上面80端口已经被其他程序占用，就只能采用端口转发或者虚拟目录，我采用的是端口转发，或者说当在一台主机上需要部署多个web应用，并且需要能在80端口访问这些web时，就可以采用这种方法，也可以叫做nginx反向代理用于实现负载均衡，这里记录一下遇到的一些小问题。</p>\n<p>加入服务器域名是test.com,那么你可以通过test.com/news在80端口访问新闻应用，但是服务器上分配的是其他端口，如8081。<br>对应的nginx配置如下：</p>\n<p>80端口的配置： 访问test.com/news =&gt; 127.0.0.1:8081 ,这里有一个需要注意的地方是转发的url最后需要加上’/‘，<br>这相当指定了url’/‘,如果代理服务器地址中是带有URL的，此URL会替换掉 location 所匹配的URL部分, test.com/news/api,访问的是ip:8081/api;而如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器,test.com/news/api,访问的是ip:8081/news/api;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\"> <span class=\"comment\">#      listen       [::]:80 default_server;</span></span><br><span class=\"line\">        server_name  test.com</span><br><span class=\"line\">        root         /usr/share/nginx/html;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Load configuration files for the default server block.</span></span><br><span class=\"line\">        include /etc/nginx/default.d/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        location /news&#123;</span><br><span class=\"line\">                proxy_pass http:test.com:8081/;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>8081端口的配置： 与平时配置没什么差别</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">        listen 8081;</span><br><span class=\"line\">        server_name localhost;</span><br><span class=\"line\">        root /var/www/project;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">        index index.php index.html index.htm;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !-e <span class=\"variable\">$request_filename</span>)&#123;</span><br><span class=\"line\">        rewrite ^(.*)$ /index.php?s=/<span class=\"variable\">$1</span> last;</span><br><span class=\"line\">        <span class=\"built_in\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t   <span class=\"comment\">#error_page 500 502 503 504  /50x.html;</span></span><br><span class=\"line\">       <span class=\"comment\">#location = /50x.html &#123;</span></span><br><span class=\"line\">       <span class=\"comment\">#root /usr/share/ngixn/html;</span></span><br><span class=\"line\">       <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">#我部署的是PHP项目，这里配置PHP解析</span></span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">        fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">        fastcgi_index index.php;</span><br><span class=\"line\">        fastcgi_param SCRIPT_FILENAME <span class=\"variable\">$document_root</span><span class=\"variable\">$fastcgi_script_name</span>;</span><br><span class=\"line\">        include /etc/nginx/fastcgi_params;</span><br><span class=\"line\">        include /etc/nginx/fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"五层体系结构之运输层","date":"2018-11-18T06:09:37.000Z","copyright":null,"_content":"### 运输层协议概述\n#### 进程之间的通信\n1. 运输层的重要功能：复用和分用\n- **复用**: 应用层所有的应用进程都可以通过运输层再传送到IP层\n- **分用**: 运输层从IP层收到数据后必须交付给指明的应用进程\n\n2. 网络层与运输层的区别\n- **网络层**: 为主机之间提供逻辑通信\n- **运输层**: 为应用进程之间提供端到端的逻辑通信\n\n#### 运输层的端口（软件端口）\n> 给应用层的每个应用进程赋予一个明确的标志\n\n1. 服务器端使用的端口号\n- **熟知端口号（系统端口号）**：0~1023,指派给了TCP/IP最重要的一些应用程序\n- **登记端口号**: 1024~49151\n2. 客户端使用的端口号\n- 又叫 **短暂端口号** ,49152~65535，仅在客户进程运行时动态选择\n\n### 用户数据报协议UDP\n> 在IP的数据服务上加了复用和分用，差错检测的功能\n\n#### 主要特点\n- **UDP是无连接的**: 发送数据之前不需要建立连接\n- **UDP使用尽最大努力交付**\n- **UDP是面向报文的**: 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文\n- **UDP没有拥塞控制**: 因此网络出现的拥塞不会使源主机的发送速率降低 \n- **UDP支持一对一、一对多、多对一和多对多的交互通信**\n- **UDP的首部开销小**:只要8个字节\n\n#### UDP的首部格式\n> 四个字段，每个字段两个字节\n\n- 源端口\n- 目的端口\n- 长度\n- 检验和\n![UDP header](/images/udp_header.png)\n\n----\n\n### 传输控制协议TCP\n#### 概述\n1. 主要特点\n- **TCP是面向连接的运输层协议**: 使用之前，必须建立连接；数据传输完毕之后，必须释放已经建立的连接\n- **每一条TCP连接只能有两个端点**: 点对点（一对一）\n- **TCP提供可靠交付的服务**: 无差错、不丢失、不重复，按序到达\n- **TCP提供全双工通信**: 允许通信双方的应用进程在任何时候都能发送数据。发送时，应用程序在把数据传送给TCP的缓存之后就可以做自己的事，然后TCP在合适的时候把数据发送出去；接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据\n- **面向字节流**: 应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流\n![读取流程](/images/tcp_stream.png)\n\n2. TCP的连接\n- TCP连接的端点叫做套接字或插口\n- 端口号拼接到IP地址构成了套接字\n- 每一条TCP连接唯一地被通信两端的两个端点所确定\n- 同一个IP地址可以有多个不同的TCP链接，而同一个端口号也可以出现在多个不同的TCP连接\n\n#### 可靠传输的工作原理\n##### 停止等待协议\n> ”停止等待“就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组\n\n1. 无差错情况\n![tcp_no_error](/images/tcp_no_error.jpg)\n\n2. 出现差错(超时重传)\n> 发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组\n\n![tcp_timeout_resend](/images/tcp_timeout_resend.jpg)\n三点注意：\n- 发送方发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传时使用）,收到确认后才可以清除副本。\n- 分组和确认分组都必须编号（才能明确是哪一个发送出去的分组收到了确认）\n- 重传时间应当比数据在分组传输的平均往返时间更长一些\n\n3. 确认丢失和确认迟到\n- **确认丢失**: 接收方发送的对分组的确认丢失了\n    当接收方又收到重传的分组时（发送方没有收到确认信息会重传），采取两个行动：\n    i. 丢弃这个重复的分组\n    ii. 向发送方发送确认\n![tcp_confirm_lose](/images/tcp_confirm_lose.jpg)\n- **确认迟到**: 传输过程没有差错，但接收方对分组的确认迟到了\n    i. 发送方会收到重复的确认，收下后丢弃；\n    ii. 接收方会收到重复的分组， 同样丢弃，并重传确认分组\n\n4. 信道利用率\n信道利用率计算：\n![tcp_channel_utilization](/images/tcp_channel_utilization.jpg)\n\n> 当往返时间RTT远大于分组发送时间Td时，信道的利用率会非常低，因而需要采用流水线传输\n\n##### 连续ARQ协议\n- 发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方的确认\n- 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置\n- 接收方一般采用累积确认的方式，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后对按序到达的最后一个分组发送确认，这表示：到这个分组为止的素有分组都已正确收到了\n- 优点： 容易实现，确认丢失也不必重传\n- 缺点： 不能正确反映出接收方已经正确收到的所有分组的信息，比如5个中的第3个丢了，就只能对前两个分组发出确认，后面三个重传\n\n#### TCP报文段的首部格式\n> TCP的全部功能都体现在它首部中各字段的作用\n\n![tcp_header](/images/tcp_header.jpg)\n- **源端口和目的端口**: \n- **序号**: 范围[0, 2^32 - 1],序号增加到2^32 - 1后，下一个序号又回到0。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号\n- **确认号**: 期望收到对方下一个报文段的第一个数据字节的序号，若确认号=N,则表明：到序号N-1为止的所有数据都已正确收到\n- **数据偏移**: 单位是4个字节，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出TCP报文段的首部长度\n- **保留**: 保留为今后用，目前应置为0\n- **紧急URG**: 当URG=1时，表示文段中有紧急数据，发送应用进程告诉发送方的TCP有紧急数据要传送，发送方TCP就把紧急数据插入到被报文段的最前面，要与紧急指针字段配合使用\n- **确认ACK**: 在TCP连接建立后所有传送的报文都必须把ACK置1\n- **推送PSH**: 发送方TCP把PSH置为1时，立即创建一个报文段发送出去，接收方尽快地交付接收应用进程，不用等到缓存填满\n- **复位RST**: 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接\n- **同步SYN**: 在连接建立事用来同步序号\n- **终止FIN**: 用来释放一个连接\n- **窗口**: 指的是发送本报文段的一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量\n- **校验和**: 计算方法和UDP一样\n- **紧急指针**: 当URG=1时才有意义，指出本报文段中的紧急数据的字节数\n- **选项**: 长度可变，最长达40字节\n\n#### TCP可靠传输的实现\n1.以字节为单位的滑动窗口\n- TCP的滑动窗口以字节为单位\n- 发送窗口里面的序号表示允许发送出去的序号\n- 如图，假定A收到B发来的确认报文段，其中窗口是20，确认窗口是31，表明B期望收到的下一个序号是31,30为止的数据已经收到了\n![](/images/tcp_window_send.jpg)\n- 凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传\n- 描述一个发送窗口的状态需要三个指针，如图：\n![](/images/tcp_window_state.jpg)\n- 发送缓存用来暂时存放：\n    i. 发送应用程序传送给发送方TCP准备发送的数据；\n    ii. TCP已发送出但尚未收到确认的数据；\n![](/images/tcp_send_cahce.jpg)tcp_recieve_cahce\n- 接收缓存用来暂时存放：\n    i. 按序到达的、但尚未被接收应用程序读取的数据；\n    ii. 未按序到达的数据；\n![](/images/tcp_recieve_cahce.jpg)\n\n- 三点强调：\n    i. 发送窗口并不总是和接收窗口一样大\n    ii. 对于不按序到达的数据，先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程\n    iii. TCP要求接收方必须有累积确认的功能 \n    \n2.超时重传时间的选择\nRTTs（加权平均往返时间）计算：\n![](/images/tcp_rtts_calculate.jpg)\nRTTd（RTT的偏差的加权平均值）计算：\n![](/images/tcp_rttd_calculate.jpg)\nRTO（超时重传时间）：\n![](/images/tcp_rto_calculate.jpg)\n\n3.选择确认SACK\n> 用来解决只传送缺少的数据而不重传已经正确到达接收方的数据\n\n#### TCP的流量控制\n\n> 流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。\n\n1. 利用滑动窗口实现流量控制\n> 发送方的发送窗口不能超过接收方给出的接收窗口的数值\n\n![](/images/tcp_window_flow_control.jpg)\n2. 传输效率\n三种控制TCP报文段发送时机的机制:\n- 维持一个变量，等于最大报文段长度MSS\n- 发送方的应有进程指明要求发送报文段，即推送(push)操作\n- 发送方的计时器期限\n \n#### TCP的拥塞控制\n1. 拥塞控制的一般原理\n两种方法：\n- 开环控制：在设计网络时事先将有关发送拥塞的因素考虑周到，力求网络在工作时不发生拥塞，但系统运行起来中途不能改正\n- 闭环控制：三种措施：\n    i. 检测网络系统以便检测到拥塞何时、何处发生；\n    ii. 把拥塞发送的信息传送到可采取行动的地方；\n    iii. 调整网络系统的运行以解决问题；\n2. 四种拥塞控制方法\n**慢开始和拥塞避免**：发送方维持一个叫做拥塞窗口cwnd的状态变量，发送方让自己的发送窗口等于拥塞窗口；\n- 慢开始：由小到大逐渐增大拥塞窗口数值（为了防止拥塞窗口cwnd增长过大引起网络拥塞，需要设置一个慢开始门限状态变量ssthresh）\n![](/images/tcp_slow_start.jpg)\n- 拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间就把发送方的拥塞窗口加1（拥塞避免并非完全能够避免了拥塞）\n慢开始和拥塞避免算法实现举例：\n![](/images/tcp_congestion_avoid.jpg)\n**快重传和快恢复**: \n- 快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未搜到的报文段，而不必继续等待重传计时器到期\n![](/images/tcp_quick_resend.jpg)\n- 快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”，把慢开始门限ssthresh减半（而不是直接设置cwnd为1），然后开始拥塞避免算法\n快重传和快恢复算法实现举例：\n![](/images/tcp_quick_recovery.jpg)\n3. 随机早期检测RED\n- 随机早期检测： 在检测到网络拥塞的早期征兆时，就以概率p随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，少量的分组被丢弃，避免发生全局性的拥塞控制\n- 需要选择好三个参数：最小门限THmin，最大门限THmax和概率p\n- 丢弃概率p与两个门限值的关系图：\n![](/images/tcp_red.jpg)\n\n#### TCP的运输连接管理\n> 运输连接有三个阶段：连接建立，数据传送，连接释放\n\n1. TCP的连接建立：三次握手\n![](/images/tcp_build_connect.jpg)\n- **第一次握手**：客户进程A创建传输控制模块TCB，向服务进程发出连接请求报文段，等待B确认，这时A进入SYN-SENT（同步已发送）状态\n> 报文段首部中SYN=1，同时选择一个初始序号seq=x，不携带任何数据，但要消耗一个序号\n\n- **第二次握手**：服务进程B收到请求报文段后，如同意建立连接，则向A发送确认，这时TCP服务进程进入SYN-RCVD（同步已发送）状态\n> 将SYN和ACK都置1，确认号是ack=x+1，同时也为自己选一个初始序列号seq=y\n\n- **第三次握手**：A收到B的确认后，要向B给出确认，这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态，当B收到A的确认后，也进入ESTABLISHED状态\n> A发送的确认报文段ACK置1，确认号ack=y+1，自己的序号seq=x+1，ACK报文段可以携带数据，但不携带数据则不消耗序号。**A发送一次确认是为了防止已失效的连接请求报文段突然又传到了B**\n\n2. TCP的连接释放:四次挥手\n![](/images/tcp_release_connect.jpg)\n- **第一次挥手**：A向B发送释放连接报文段，A进入FIN-WAIT-1在（终止等待1）状态\n> 报文段首部中终止控制位FIN置1，其序号是seq=u，等于前面已传送过的数据的最后一个字节的序号加1，即使不携带任何数据，但要消耗一个序号\n\n- **第二次挥手**：B收到连接释放报文段后发出确认，B进入CLOSE-WAIT（关闭等待）状态，这时TCP连接处于半关闭状态，即A已经没有数据发送给B，但B若发送数据，A仍要接收。A收到确认之后，进入FIN-WAIT-2（终止等待2）状态\n> 确认号是ack=u+1，这个报文号自身的序号是v,等于前面已传送过的数据的最后一个字节的序号加1\n\n- **第三次挥手**：若B已经没有要想向A发送的数据，就通知TCP释放连接，B进入LAST-ACK（最后确认状态），等待A的确认\n> B发出的报文段令FIN=1，而且必须重复上次已发送过的确认号ack=u+1\n\n- **第四次挥手**：A收到B的连接释放报文段后，必须对此发出确认。然后A进入TIME-WAIT（时间等待）状态\n> A发送的确认报文段ACK置1，确认号ack=w+1，自身的序号是seq=u+1。**注意这时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。**\n\n3. TCP的有限状态机\n> 粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，细线箭头表示异常变迁\n\n![](/images/tcp_limited_state_machine.jpg)\n\n","source":"_posts/五层体系结构之运输层.md","raw":"---\ntitle: 五层体系结构之运输层\ndate: 2018-11-18 14:09:37\ncategories: \"计算机网络笔记\"\ntags:\n    - 计算机网络\n    - TCP\ncopyright:\n---\n### 运输层协议概述\n#### 进程之间的通信\n1. 运输层的重要功能：复用和分用\n- **复用**: 应用层所有的应用进程都可以通过运输层再传送到IP层\n- **分用**: 运输层从IP层收到数据后必须交付给指明的应用进程\n\n2. 网络层与运输层的区别\n- **网络层**: 为主机之间提供逻辑通信\n- **运输层**: 为应用进程之间提供端到端的逻辑通信\n\n#### 运输层的端口（软件端口）\n> 给应用层的每个应用进程赋予一个明确的标志\n\n1. 服务器端使用的端口号\n- **熟知端口号（系统端口号）**：0~1023,指派给了TCP/IP最重要的一些应用程序\n- **登记端口号**: 1024~49151\n2. 客户端使用的端口号\n- 又叫 **短暂端口号** ,49152~65535，仅在客户进程运行时动态选择\n\n### 用户数据报协议UDP\n> 在IP的数据服务上加了复用和分用，差错检测的功能\n\n#### 主要特点\n- **UDP是无连接的**: 发送数据之前不需要建立连接\n- **UDP使用尽最大努力交付**\n- **UDP是面向报文的**: 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文\n- **UDP没有拥塞控制**: 因此网络出现的拥塞不会使源主机的发送速率降低 \n- **UDP支持一对一、一对多、多对一和多对多的交互通信**\n- **UDP的首部开销小**:只要8个字节\n\n#### UDP的首部格式\n> 四个字段，每个字段两个字节\n\n- 源端口\n- 目的端口\n- 长度\n- 检验和\n![UDP header](/images/udp_header.png)\n\n----\n\n### 传输控制协议TCP\n#### 概述\n1. 主要特点\n- **TCP是面向连接的运输层协议**: 使用之前，必须建立连接；数据传输完毕之后，必须释放已经建立的连接\n- **每一条TCP连接只能有两个端点**: 点对点（一对一）\n- **TCP提供可靠交付的服务**: 无差错、不丢失、不重复，按序到达\n- **TCP提供全双工通信**: 允许通信双方的应用进程在任何时候都能发送数据。发送时，应用程序在把数据传送给TCP的缓存之后就可以做自己的事，然后TCP在合适的时候把数据发送出去；接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据\n- **面向字节流**: 应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流\n![读取流程](/images/tcp_stream.png)\n\n2. TCP的连接\n- TCP连接的端点叫做套接字或插口\n- 端口号拼接到IP地址构成了套接字\n- 每一条TCP连接唯一地被通信两端的两个端点所确定\n- 同一个IP地址可以有多个不同的TCP链接，而同一个端口号也可以出现在多个不同的TCP连接\n\n#### 可靠传输的工作原理\n##### 停止等待协议\n> ”停止等待“就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组\n\n1. 无差错情况\n![tcp_no_error](/images/tcp_no_error.jpg)\n\n2. 出现差错(超时重传)\n> 发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组\n\n![tcp_timeout_resend](/images/tcp_timeout_resend.jpg)\n三点注意：\n- 发送方发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传时使用）,收到确认后才可以清除副本。\n- 分组和确认分组都必须编号（才能明确是哪一个发送出去的分组收到了确认）\n- 重传时间应当比数据在分组传输的平均往返时间更长一些\n\n3. 确认丢失和确认迟到\n- **确认丢失**: 接收方发送的对分组的确认丢失了\n    当接收方又收到重传的分组时（发送方没有收到确认信息会重传），采取两个行动：\n    i. 丢弃这个重复的分组\n    ii. 向发送方发送确认\n![tcp_confirm_lose](/images/tcp_confirm_lose.jpg)\n- **确认迟到**: 传输过程没有差错，但接收方对分组的确认迟到了\n    i. 发送方会收到重复的确认，收下后丢弃；\n    ii. 接收方会收到重复的分组， 同样丢弃，并重传确认分组\n\n4. 信道利用率\n信道利用率计算：\n![tcp_channel_utilization](/images/tcp_channel_utilization.jpg)\n\n> 当往返时间RTT远大于分组发送时间Td时，信道的利用率会非常低，因而需要采用流水线传输\n\n##### 连续ARQ协议\n- 发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方的确认\n- 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置\n- 接收方一般采用累积确认的方式，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后对按序到达的最后一个分组发送确认，这表示：到这个分组为止的素有分组都已正确收到了\n- 优点： 容易实现，确认丢失也不必重传\n- 缺点： 不能正确反映出接收方已经正确收到的所有分组的信息，比如5个中的第3个丢了，就只能对前两个分组发出确认，后面三个重传\n\n#### TCP报文段的首部格式\n> TCP的全部功能都体现在它首部中各字段的作用\n\n![tcp_header](/images/tcp_header.jpg)\n- **源端口和目的端口**: \n- **序号**: 范围[0, 2^32 - 1],序号增加到2^32 - 1后，下一个序号又回到0。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号\n- **确认号**: 期望收到对方下一个报文段的第一个数据字节的序号，若确认号=N,则表明：到序号N-1为止的所有数据都已正确收到\n- **数据偏移**: 单位是4个字节，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出TCP报文段的首部长度\n- **保留**: 保留为今后用，目前应置为0\n- **紧急URG**: 当URG=1时，表示文段中有紧急数据，发送应用进程告诉发送方的TCP有紧急数据要传送，发送方TCP就把紧急数据插入到被报文段的最前面，要与紧急指针字段配合使用\n- **确认ACK**: 在TCP连接建立后所有传送的报文都必须把ACK置1\n- **推送PSH**: 发送方TCP把PSH置为1时，立即创建一个报文段发送出去，接收方尽快地交付接收应用进程，不用等到缓存填满\n- **复位RST**: 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接\n- **同步SYN**: 在连接建立事用来同步序号\n- **终止FIN**: 用来释放一个连接\n- **窗口**: 指的是发送本报文段的一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量\n- **校验和**: 计算方法和UDP一样\n- **紧急指针**: 当URG=1时才有意义，指出本报文段中的紧急数据的字节数\n- **选项**: 长度可变，最长达40字节\n\n#### TCP可靠传输的实现\n1.以字节为单位的滑动窗口\n- TCP的滑动窗口以字节为单位\n- 发送窗口里面的序号表示允许发送出去的序号\n- 如图，假定A收到B发来的确认报文段，其中窗口是20，确认窗口是31，表明B期望收到的下一个序号是31,30为止的数据已经收到了\n![](/images/tcp_window_send.jpg)\n- 凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传\n- 描述一个发送窗口的状态需要三个指针，如图：\n![](/images/tcp_window_state.jpg)\n- 发送缓存用来暂时存放：\n    i. 发送应用程序传送给发送方TCP准备发送的数据；\n    ii. TCP已发送出但尚未收到确认的数据；\n![](/images/tcp_send_cahce.jpg)tcp_recieve_cahce\n- 接收缓存用来暂时存放：\n    i. 按序到达的、但尚未被接收应用程序读取的数据；\n    ii. 未按序到达的数据；\n![](/images/tcp_recieve_cahce.jpg)\n\n- 三点强调：\n    i. 发送窗口并不总是和接收窗口一样大\n    ii. 对于不按序到达的数据，先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程\n    iii. TCP要求接收方必须有累积确认的功能 \n    \n2.超时重传时间的选择\nRTTs（加权平均往返时间）计算：\n![](/images/tcp_rtts_calculate.jpg)\nRTTd（RTT的偏差的加权平均值）计算：\n![](/images/tcp_rttd_calculate.jpg)\nRTO（超时重传时间）：\n![](/images/tcp_rto_calculate.jpg)\n\n3.选择确认SACK\n> 用来解决只传送缺少的数据而不重传已经正确到达接收方的数据\n\n#### TCP的流量控制\n\n> 流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。\n\n1. 利用滑动窗口实现流量控制\n> 发送方的发送窗口不能超过接收方给出的接收窗口的数值\n\n![](/images/tcp_window_flow_control.jpg)\n2. 传输效率\n三种控制TCP报文段发送时机的机制:\n- 维持一个变量，等于最大报文段长度MSS\n- 发送方的应有进程指明要求发送报文段，即推送(push)操作\n- 发送方的计时器期限\n \n#### TCP的拥塞控制\n1. 拥塞控制的一般原理\n两种方法：\n- 开环控制：在设计网络时事先将有关发送拥塞的因素考虑周到，力求网络在工作时不发生拥塞，但系统运行起来中途不能改正\n- 闭环控制：三种措施：\n    i. 检测网络系统以便检测到拥塞何时、何处发生；\n    ii. 把拥塞发送的信息传送到可采取行动的地方；\n    iii. 调整网络系统的运行以解决问题；\n2. 四种拥塞控制方法\n**慢开始和拥塞避免**：发送方维持一个叫做拥塞窗口cwnd的状态变量，发送方让自己的发送窗口等于拥塞窗口；\n- 慢开始：由小到大逐渐增大拥塞窗口数值（为了防止拥塞窗口cwnd增长过大引起网络拥塞，需要设置一个慢开始门限状态变量ssthresh）\n![](/images/tcp_slow_start.jpg)\n- 拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间就把发送方的拥塞窗口加1（拥塞避免并非完全能够避免了拥塞）\n慢开始和拥塞避免算法实现举例：\n![](/images/tcp_congestion_avoid.jpg)\n**快重传和快恢复**: \n- 快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未搜到的报文段，而不必继续等待重传计时器到期\n![](/images/tcp_quick_resend.jpg)\n- 快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”，把慢开始门限ssthresh减半（而不是直接设置cwnd为1），然后开始拥塞避免算法\n快重传和快恢复算法实现举例：\n![](/images/tcp_quick_recovery.jpg)\n3. 随机早期检测RED\n- 随机早期检测： 在检测到网络拥塞的早期征兆时，就以概率p随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，少量的分组被丢弃，避免发生全局性的拥塞控制\n- 需要选择好三个参数：最小门限THmin，最大门限THmax和概率p\n- 丢弃概率p与两个门限值的关系图：\n![](/images/tcp_red.jpg)\n\n#### TCP的运输连接管理\n> 运输连接有三个阶段：连接建立，数据传送，连接释放\n\n1. TCP的连接建立：三次握手\n![](/images/tcp_build_connect.jpg)\n- **第一次握手**：客户进程A创建传输控制模块TCB，向服务进程发出连接请求报文段，等待B确认，这时A进入SYN-SENT（同步已发送）状态\n> 报文段首部中SYN=1，同时选择一个初始序号seq=x，不携带任何数据，但要消耗一个序号\n\n- **第二次握手**：服务进程B收到请求报文段后，如同意建立连接，则向A发送确认，这时TCP服务进程进入SYN-RCVD（同步已发送）状态\n> 将SYN和ACK都置1，确认号是ack=x+1，同时也为自己选一个初始序列号seq=y\n\n- **第三次握手**：A收到B的确认后，要向B给出确认，这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态，当B收到A的确认后，也进入ESTABLISHED状态\n> A发送的确认报文段ACK置1，确认号ack=y+1，自己的序号seq=x+1，ACK报文段可以携带数据，但不携带数据则不消耗序号。**A发送一次确认是为了防止已失效的连接请求报文段突然又传到了B**\n\n2. TCP的连接释放:四次挥手\n![](/images/tcp_release_connect.jpg)\n- **第一次挥手**：A向B发送释放连接报文段，A进入FIN-WAIT-1在（终止等待1）状态\n> 报文段首部中终止控制位FIN置1，其序号是seq=u，等于前面已传送过的数据的最后一个字节的序号加1，即使不携带任何数据，但要消耗一个序号\n\n- **第二次挥手**：B收到连接释放报文段后发出确认，B进入CLOSE-WAIT（关闭等待）状态，这时TCP连接处于半关闭状态，即A已经没有数据发送给B，但B若发送数据，A仍要接收。A收到确认之后，进入FIN-WAIT-2（终止等待2）状态\n> 确认号是ack=u+1，这个报文号自身的序号是v,等于前面已传送过的数据的最后一个字节的序号加1\n\n- **第三次挥手**：若B已经没有要想向A发送的数据，就通知TCP释放连接，B进入LAST-ACK（最后确认状态），等待A的确认\n> B发出的报文段令FIN=1，而且必须重复上次已发送过的确认号ack=u+1\n\n- **第四次挥手**：A收到B的连接释放报文段后，必须对此发出确认。然后A进入TIME-WAIT（时间等待）状态\n> A发送的确认报文段ACK置1，确认号ack=w+1，自身的序号是seq=u+1。**注意这时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。**\n\n3. TCP的有限状态机\n> 粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，细线箭头表示异常变迁\n\n![](/images/tcp_limited_state_machine.jpg)\n\n","slug":"五层体系结构之运输层","published":1,"updated":"2018-12-12T03:07:12.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdl001xu7yjdbj1wfnc","content":"<h3 id=\"运输层协议概述\"><a href=\"#运输层协议概述\" class=\"headerlink\" title=\"运输层协议概述\"></a>运输层协议概述</h3><h4 id=\"进程之间的通信\"><a href=\"#进程之间的通信\" class=\"headerlink\" title=\"进程之间的通信\"></a>进程之间的通信</h4><ol>\n<li>运输层的重要功能：复用和分用</li>\n</ol>\n<ul>\n<li><strong>复用</strong>: 应用层所有的应用进程都可以通过运输层再传送到IP层</li>\n<li><strong>分用</strong>: 运输层从IP层收到数据后必须交付给指明的应用进程</li>\n</ul>\n<ol>\n<li>网络层与运输层的区别</li>\n</ol>\n<ul>\n<li><strong>网络层</strong>: 为主机之间提供逻辑通信</li>\n<li><strong>运输层</strong>: 为应用进程之间提供端到端的逻辑通信</li>\n</ul>\n<h4 id=\"运输层的端口（软件端口）\"><a href=\"#运输层的端口（软件端口）\" class=\"headerlink\" title=\"运输层的端口（软件端口）\"></a>运输层的端口（软件端口）</h4><blockquote>\n<p>给应用层的每个应用进程赋予一个明确的标志</p>\n</blockquote>\n<ol>\n<li>服务器端使用的端口号</li>\n</ol>\n<ul>\n<li><strong>熟知端口号（系统端口号）</strong>：0~1023,指派给了TCP/IP最重要的一些应用程序</li>\n<li><strong>登记端口号</strong>: 1024~49151</li>\n</ul>\n<ol>\n<li>客户端使用的端口号</li>\n</ol>\n<ul>\n<li>又叫 <strong>短暂端口号</strong> ,49152~65535，仅在客户进程运行时动态选择</li>\n</ul>\n<h3 id=\"用户数据报协议UDP\"><a href=\"#用户数据报协议UDP\" class=\"headerlink\" title=\"用户数据报协议UDP\"></a>用户数据报协议UDP</h3><blockquote>\n<p>在IP的数据服务上加了复用和分用，差错检测的功能</p>\n</blockquote>\n<h4 id=\"主要特点\"><a href=\"#主要特点\" class=\"headerlink\" title=\"主要特点\"></a>主要特点</h4><ul>\n<li><strong>UDP是无连接的</strong>: 发送数据之前不需要建立连接</li>\n<li><strong>UDP使用尽最大努力交付</strong></li>\n<li><strong>UDP是面向报文的</strong>: 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</li>\n<li><strong>UDP没有拥塞控制</strong>: 因此网络出现的拥塞不会使源主机的发送速率降低 </li>\n<li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong></li>\n<li><strong>UDP的首部开销小</strong>:只要8个字节</li>\n</ul>\n<h4 id=\"UDP的首部格式\"><a href=\"#UDP的首部格式\" class=\"headerlink\" title=\"UDP的首部格式\"></a>UDP的首部格式</h4><blockquote>\n<p>四个字段，每个字段两个字节</p>\n</blockquote>\n<ul>\n<li>源端口</li>\n<li>目的端口</li>\n<li>长度</li>\n<li>检验和<br><img src=\"/images/udp_header.png\" alt=\"UDP header\"></li>\n</ul>\n<hr>\n<h3 id=\"传输控制协议TCP\"><a href=\"#传输控制协议TCP\" class=\"headerlink\" title=\"传输控制协议TCP\"></a>传输控制协议TCP</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><ol>\n<li>主要特点</li>\n</ol>\n<ul>\n<li><strong>TCP是面向连接的运输层协议</strong>: 使用之前，必须建立连接；数据传输完毕之后，必须释放已经建立的连接</li>\n<li><strong>每一条TCP连接只能有两个端点</strong>: 点对点（一对一）</li>\n<li><strong>TCP提供可靠交付的服务</strong>: 无差错、不丢失、不重复，按序到达</li>\n<li><strong>TCP提供全双工通信</strong>: 允许通信双方的应用进程在任何时候都能发送数据。发送时，应用程序在把数据传送给TCP的缓存之后就可以做自己的事，然后TCP在合适的时候把数据发送出去；接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</li>\n<li><strong>面向字节流</strong>: 应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流<br><img src=\"/images/tcp_stream.png\" alt=\"读取流程\"></li>\n</ul>\n<ol>\n<li>TCP的连接</li>\n</ol>\n<ul>\n<li>TCP连接的端点叫做套接字或插口</li>\n<li>端口号拼接到IP地址构成了套接字</li>\n<li>每一条TCP连接唯一地被通信两端的两个端点所确定</li>\n<li>同一个IP地址可以有多个不同的TCP链接，而同一个端口号也可以出现在多个不同的TCP连接</li>\n</ul>\n<h4 id=\"可靠传输的工作原理\"><a href=\"#可靠传输的工作原理\" class=\"headerlink\" title=\"可靠传输的工作原理\"></a>可靠传输的工作原理</h4><h5 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h5><blockquote>\n<p>”停止等待“就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组</p>\n</blockquote>\n<ol>\n<li><p>无差错情况<br><img src=\"/images/tcp_no_error.jpg\" alt=\"tcp_no_error\"></p>\n</li>\n<li><p>出现差错(超时重传)</p>\n<blockquote>\n<p>发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/tcp_timeout_resend.jpg\" alt=\"tcp_timeout_resend\"><br>三点注意：</p>\n<ul>\n<li>发送方发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传时使用）,收到确认后才可以清除副本。</li>\n<li>分组和确认分组都必须编号（才能明确是哪一个发送出去的分组收到了确认）</li>\n<li>重传时间应当比数据在分组传输的平均往返时间更长一些</li>\n</ul>\n<ol>\n<li>确认丢失和确认迟到</li>\n</ol>\n<ul>\n<li><strong>确认丢失</strong>: 接收方发送的对分组的确认丢失了<br>  当接收方又收到重传的分组时（发送方没有收到确认信息会重传），采取两个行动：<br>  i. 丢弃这个重复的分组<br>  ii. 向发送方发送确认<br><img src=\"/images/tcp_confirm_lose.jpg\" alt=\"tcp_confirm_lose\"></li>\n<li><strong>确认迟到</strong>: 传输过程没有差错，但接收方对分组的确认迟到了<br>  i. 发送方会收到重复的确认，收下后丢弃；<br>  ii. 接收方会收到重复的分组， 同样丢弃，并重传确认分组</li>\n</ul>\n<ol>\n<li>信道利用率<br>信道利用率计算：<br><img src=\"/images/tcp_channel_utilization.jpg\" alt=\"tcp_channel_utilization\"></li>\n</ol>\n<blockquote>\n<p>当往返时间RTT远大于分组发送时间Td时，信道的利用率会非常低，因而需要采用流水线传输</p>\n</blockquote>\n<h5 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h5><ul>\n<li>发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方的确认</li>\n<li>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置</li>\n<li>接收方一般采用累积确认的方式，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后对按序到达的最后一个分组发送确认，这表示：到这个分组为止的素有分组都已正确收到了</li>\n<li>优点： 容易实现，确认丢失也不必重传</li>\n<li>缺点： 不能正确反映出接收方已经正确收到的所有分组的信息，比如5个中的第3个丢了，就只能对前两个分组发出确认，后面三个重传</li>\n</ul>\n<h4 id=\"TCP报文段的首部格式\"><a href=\"#TCP报文段的首部格式\" class=\"headerlink\" title=\"TCP报文段的首部格式\"></a>TCP报文段的首部格式</h4><blockquote>\n<p>TCP的全部功能都体现在它首部中各字段的作用</p>\n</blockquote>\n<p><img src=\"/images/tcp_header.jpg\" alt=\"tcp_header\"></p>\n<ul>\n<li><strong>源端口和目的端口</strong>: </li>\n<li><strong>序号</strong>: 范围[0, 2^32 - 1],序号增加到2^32 - 1后，下一个序号又回到0。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li>\n<li><strong>确认号</strong>: 期望收到对方下一个报文段的第一个数据字节的序号，若确认号=N,则表明：到序号N-1为止的所有数据都已正确收到</li>\n<li><strong>数据偏移</strong>: 单位是4个字节，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出TCP报文段的首部长度</li>\n<li><strong>保留</strong>: 保留为今后用，目前应置为0</li>\n<li><strong>紧急URG</strong>: 当URG=1时，表示文段中有紧急数据，发送应用进程告诉发送方的TCP有紧急数据要传送，发送方TCP就把紧急数据插入到被报文段的最前面，要与紧急指针字段配合使用</li>\n<li><strong>确认ACK</strong>: 在TCP连接建立后所有传送的报文都必须把ACK置1</li>\n<li><strong>推送PSH</strong>: 发送方TCP把PSH置为1时，立即创建一个报文段发送出去，接收方尽快地交付接收应用进程，不用等到缓存填满</li>\n<li><strong>复位RST</strong>: 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li>\n<li><strong>同步SYN</strong>: 在连接建立事用来同步序号</li>\n<li><strong>终止FIN</strong>: 用来释放一个连接</li>\n<li><strong>窗口</strong>: 指的是发送本报文段的一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量</li>\n<li><strong>校验和</strong>: 计算方法和UDP一样</li>\n<li><strong>紧急指针</strong>: 当URG=1时才有意义，指出本报文段中的紧急数据的字节数</li>\n<li><strong>选项</strong>: 长度可变，最长达40字节</li>\n</ul>\n<h4 id=\"TCP可靠传输的实现\"><a href=\"#TCP可靠传输的实现\" class=\"headerlink\" title=\"TCP可靠传输的实现\"></a>TCP可靠传输的实现</h4><p>1.以字节为单位的滑动窗口</p>\n<ul>\n<li>TCP的滑动窗口以字节为单位</li>\n<li>发送窗口里面的序号表示允许发送出去的序号</li>\n<li>如图，假定A收到B发来的确认报文段，其中窗口是20，确认窗口是31，表明B期望收到的下一个序号是31,30为止的数据已经收到了<br><img src=\"/images/tcp_window_send.jpg\" alt=\"\"></li>\n<li>凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传</li>\n<li>描述一个发送窗口的状态需要三个指针，如图：<br><img src=\"/images/tcp_window_state.jpg\" alt=\"\"></li>\n<li>发送缓存用来暂时存放：<br>  i. 发送应用程序传送给发送方TCP准备发送的数据；<br>  ii. TCP已发送出但尚未收到确认的数据；<br><img src=\"/images/tcp_send_cahce.jpg\" alt=\"\">tcp_recieve_cahce</li>\n<li><p>接收缓存用来暂时存放：<br>  i. 按序到达的、但尚未被接收应用程序读取的数据；<br>  ii. 未按序到达的数据；<br><img src=\"/images/tcp_recieve_cahce.jpg\" alt=\"\"></p>\n</li>\n<li><p>三点强调：<br>  i. 发送窗口并不总是和接收窗口一样大<br>  ii. 对于不按序到达的数据，先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程<br>  iii. TCP要求接收方必须有累积确认的功能 </p>\n</li>\n</ul>\n<p>2.超时重传时间的选择<br>RTTs（加权平均往返时间）计算：<br><img src=\"/images/tcp_rtts_calculate.jpg\" alt=\"\"><br>RTTd（RTT的偏差的加权平均值）计算：<br><img src=\"/images/tcp_rttd_calculate.jpg\" alt=\"\"><br>RTO（超时重传时间）：<br><img src=\"/images/tcp_rto_calculate.jpg\" alt=\"\"></p>\n<p>3.选择确认SACK</p>\n<blockquote>\n<p>用来解决只传送缺少的数据而不重传已经正确到达接收方的数据</p>\n</blockquote>\n<h4 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h4><blockquote>\n<p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。</p>\n</blockquote>\n<ol>\n<li>利用滑动窗口实现流量控制<blockquote>\n<p>发送方的发送窗口不能超过接收方给出的接收窗口的数值</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/tcp_window_flow_control.jpg\" alt=\"\"></p>\n<ol>\n<li>传输效率<br>三种控制TCP报文段发送时机的机制:</li>\n</ol>\n<ul>\n<li>维持一个变量，等于最大报文段长度MSS</li>\n<li>发送方的应有进程指明要求发送报文段，即推送(push)操作</li>\n<li>发送方的计时器期限</li>\n</ul>\n<h4 id=\"TCP的拥塞控制\"><a href=\"#TCP的拥塞控制\" class=\"headerlink\" title=\"TCP的拥塞控制\"></a>TCP的拥塞控制</h4><ol>\n<li>拥塞控制的一般原理<br>两种方法：</li>\n</ol>\n<ul>\n<li>开环控制：在设计网络时事先将有关发送拥塞的因素考虑周到，力求网络在工作时不发生拥塞，但系统运行起来中途不能改正</li>\n<li>闭环控制：三种措施：<br>  i. 检测网络系统以便检测到拥塞何时、何处发生；<br>  ii. 把拥塞发送的信息传送到可采取行动的地方；<br>  iii. 调整网络系统的运行以解决问题；</li>\n</ul>\n<ol>\n<li>四种拥塞控制方法<br><strong>慢开始和拥塞避免</strong>：发送方维持一个叫做拥塞窗口cwnd的状态变量，发送方让自己的发送窗口等于拥塞窗口；</li>\n</ol>\n<ul>\n<li>慢开始：由小到大逐渐增大拥塞窗口数值（为了防止拥塞窗口cwnd增长过大引起网络拥塞，需要设置一个慢开始门限状态变量ssthresh）<br><img src=\"/images/tcp_slow_start.jpg\" alt=\"\"></li>\n<li>拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间就把发送方的拥塞窗口加1（拥塞避免并非完全能够避免了拥塞）<br>慢开始和拥塞避免算法实现举例：<br><img src=\"/images/tcp_congestion_avoid.jpg\" alt=\"\"><br><strong>快重传和快恢复</strong>: </li>\n<li>快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未搜到的报文段，而不必继续等待重传计时器到期<br><img src=\"/images/tcp_quick_resend.jpg\" alt=\"\"></li>\n<li>快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”，把慢开始门限ssthresh减半（而不是直接设置cwnd为1），然后开始拥塞避免算法<br>快重传和快恢复算法实现举例：<br><img src=\"/images/tcp_quick_recovery.jpg\" alt=\"\"></li>\n</ul>\n<ol>\n<li>随机早期检测RED</li>\n</ol>\n<ul>\n<li>随机早期检测： 在检测到网络拥塞的早期征兆时，就以概率p随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，少量的分组被丢弃，避免发生全局性的拥塞控制</li>\n<li>需要选择好三个参数：最小门限THmin，最大门限THmax和概率p</li>\n<li>丢弃概率p与两个门限值的关系图：<br><img src=\"/images/tcp_red.jpg\" alt=\"\"></li>\n</ul>\n<h4 id=\"TCP的运输连接管理\"><a href=\"#TCP的运输连接管理\" class=\"headerlink\" title=\"TCP的运输连接管理\"></a>TCP的运输连接管理</h4><blockquote>\n<p>运输连接有三个阶段：连接建立，数据传送，连接释放</p>\n</blockquote>\n<ol>\n<li>TCP的连接建立：三次握手<br><img src=\"/images/tcp_build_connect.jpg\" alt=\"\"></li>\n</ol>\n<ul>\n<li><p><strong>第一次握手</strong>：客户进程A创建传输控制模块TCB，向服务进程发出连接请求报文段，等待B确认，这时A进入SYN-SENT（同步已发送）状态</p>\n<blockquote>\n<p>报文段首部中SYN=1，同时选择一个初始序号seq=x，不携带任何数据，但要消耗一个序号</p>\n</blockquote>\n</li>\n<li><p><strong>第二次握手</strong>：服务进程B收到请求报文段后，如同意建立连接，则向A发送确认，这时TCP服务进程进入SYN-RCVD（同步已发送）状态</p>\n<blockquote>\n<p>将SYN和ACK都置1，确认号是ack=x+1，同时也为自己选一个初始序列号seq=y</p>\n</blockquote>\n</li>\n<li><p><strong>第三次握手</strong>：A收到B的确认后，要向B给出确认，这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态，当B收到A的确认后，也进入ESTABLISHED状态</p>\n<blockquote>\n<p>A发送的确认报文段ACK置1，确认号ack=y+1，自己的序号seq=x+1，ACK报文段可以携带数据，但不携带数据则不消耗序号。<strong>A发送一次确认是为了防止已失效的连接请求报文段突然又传到了B</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>TCP的连接释放:四次挥手<br><img src=\"/images/tcp_release_connect.jpg\" alt=\"\"></li>\n</ol>\n<ul>\n<li><p><strong>第一次挥手</strong>：A向B发送释放连接报文段，A进入FIN-WAIT-1在（终止等待1）状态</p>\n<blockquote>\n<p>报文段首部中终止控制位FIN置1，其序号是seq=u，等于前面已传送过的数据的最后一个字节的序号加1，即使不携带任何数据，但要消耗一个序号</p>\n</blockquote>\n</li>\n<li><p><strong>第二次挥手</strong>：B收到连接释放报文段后发出确认，B进入CLOSE-WAIT（关闭等待）状态，这时TCP连接处于半关闭状态，即A已经没有数据发送给B，但B若发送数据，A仍要接收。A收到确认之后，进入FIN-WAIT-2（终止等待2）状态</p>\n<blockquote>\n<p>确认号是ack=u+1，这个报文号自身的序号是v,等于前面已传送过的数据的最后一个字节的序号加1</p>\n</blockquote>\n</li>\n<li><p><strong>第三次挥手</strong>：若B已经没有要想向A发送的数据，就通知TCP释放连接，B进入LAST-ACK（最后确认状态），等待A的确认</p>\n<blockquote>\n<p>B发出的报文段令FIN=1，而且必须重复上次已发送过的确认号ack=u+1</p>\n</blockquote>\n</li>\n<li><p><strong>第四次挥手</strong>：A收到B的连接释放报文段后，必须对此发出确认。然后A进入TIME-WAIT（时间等待）状态</p>\n<blockquote>\n<p>A发送的确认报文段ACK置1，确认号ack=w+1，自身的序号是seq=u+1。<strong>注意这时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>TCP的有限状态机<blockquote>\n<p>粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，细线箭头表示异常变迁</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/tcp_limited_state_machine.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"运输层协议概述\"><a href=\"#运输层协议概述\" class=\"headerlink\" title=\"运输层协议概述\"></a>运输层协议概述</h3><h4 id=\"进程之间的通信\"><a href=\"#进程之间的通信\" class=\"headerlink\" title=\"进程之间的通信\"></a>进程之间的通信</h4><ol>\n<li>运输层的重要功能：复用和分用</li>\n</ol>\n<ul>\n<li><strong>复用</strong>: 应用层所有的应用进程都可以通过运输层再传送到IP层</li>\n<li><strong>分用</strong>: 运输层从IP层收到数据后必须交付给指明的应用进程</li>\n</ul>\n<ol>\n<li>网络层与运输层的区别</li>\n</ol>\n<ul>\n<li><strong>网络层</strong>: 为主机之间提供逻辑通信</li>\n<li><strong>运输层</strong>: 为应用进程之间提供端到端的逻辑通信</li>\n</ul>\n<h4 id=\"运输层的端口（软件端口）\"><a href=\"#运输层的端口（软件端口）\" class=\"headerlink\" title=\"运输层的端口（软件端口）\"></a>运输层的端口（软件端口）</h4><blockquote>\n<p>给应用层的每个应用进程赋予一个明确的标志</p>\n</blockquote>\n<ol>\n<li>服务器端使用的端口号</li>\n</ol>\n<ul>\n<li><strong>熟知端口号（系统端口号）</strong>：0~1023,指派给了TCP/IP最重要的一些应用程序</li>\n<li><strong>登记端口号</strong>: 1024~49151</li>\n</ul>\n<ol>\n<li>客户端使用的端口号</li>\n</ol>\n<ul>\n<li>又叫 <strong>短暂端口号</strong> ,49152~65535，仅在客户进程运行时动态选择</li>\n</ul>\n<h3 id=\"用户数据报协议UDP\"><a href=\"#用户数据报协议UDP\" class=\"headerlink\" title=\"用户数据报协议UDP\"></a>用户数据报协议UDP</h3><blockquote>\n<p>在IP的数据服务上加了复用和分用，差错检测的功能</p>\n</blockquote>\n<h4 id=\"主要特点\"><a href=\"#主要特点\" class=\"headerlink\" title=\"主要特点\"></a>主要特点</h4><ul>\n<li><strong>UDP是无连接的</strong>: 发送数据之前不需要建立连接</li>\n<li><strong>UDP使用尽最大努力交付</strong></li>\n<li><strong>UDP是面向报文的</strong>: 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</li>\n<li><strong>UDP没有拥塞控制</strong>: 因此网络出现的拥塞不会使源主机的发送速率降低 </li>\n<li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong></li>\n<li><strong>UDP的首部开销小</strong>:只要8个字节</li>\n</ul>\n<h4 id=\"UDP的首部格式\"><a href=\"#UDP的首部格式\" class=\"headerlink\" title=\"UDP的首部格式\"></a>UDP的首部格式</h4><blockquote>\n<p>四个字段，每个字段两个字节</p>\n</blockquote>\n<ul>\n<li>源端口</li>\n<li>目的端口</li>\n<li>长度</li>\n<li>检验和<br><img src=\"/images/udp_header.png\" alt=\"UDP header\"></li>\n</ul>\n<hr>\n<h3 id=\"传输控制协议TCP\"><a href=\"#传输控制协议TCP\" class=\"headerlink\" title=\"传输控制协议TCP\"></a>传输控制协议TCP</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><ol>\n<li>主要特点</li>\n</ol>\n<ul>\n<li><strong>TCP是面向连接的运输层协议</strong>: 使用之前，必须建立连接；数据传输完毕之后，必须释放已经建立的连接</li>\n<li><strong>每一条TCP连接只能有两个端点</strong>: 点对点（一对一）</li>\n<li><strong>TCP提供可靠交付的服务</strong>: 无差错、不丢失、不重复，按序到达</li>\n<li><strong>TCP提供全双工通信</strong>: 允许通信双方的应用进程在任何时候都能发送数据。发送时，应用程序在把数据传送给TCP的缓存之后就可以做自己的事，然后TCP在合适的时候把数据发送出去；接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据</li>\n<li><strong>面向字节流</strong>: 应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流<br><img src=\"/images/tcp_stream.png\" alt=\"读取流程\"></li>\n</ul>\n<ol>\n<li>TCP的连接</li>\n</ol>\n<ul>\n<li>TCP连接的端点叫做套接字或插口</li>\n<li>端口号拼接到IP地址构成了套接字</li>\n<li>每一条TCP连接唯一地被通信两端的两个端点所确定</li>\n<li>同一个IP地址可以有多个不同的TCP链接，而同一个端口号也可以出现在多个不同的TCP连接</li>\n</ul>\n<h4 id=\"可靠传输的工作原理\"><a href=\"#可靠传输的工作原理\" class=\"headerlink\" title=\"可靠传输的工作原理\"></a>可靠传输的工作原理</h4><h5 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h5><blockquote>\n<p>”停止等待“就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组</p>\n</blockquote>\n<ol>\n<li><p>无差错情况<br><img src=\"/images/tcp_no_error.jpg\" alt=\"tcp_no_error\"></p>\n</li>\n<li><p>出现差错(超时重传)</p>\n<blockquote>\n<p>发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/tcp_timeout_resend.jpg\" alt=\"tcp_timeout_resend\"><br>三点注意：</p>\n<ul>\n<li>发送方发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传时使用）,收到确认后才可以清除副本。</li>\n<li>分组和确认分组都必须编号（才能明确是哪一个发送出去的分组收到了确认）</li>\n<li>重传时间应当比数据在分组传输的平均往返时间更长一些</li>\n</ul>\n<ol>\n<li>确认丢失和确认迟到</li>\n</ol>\n<ul>\n<li><strong>确认丢失</strong>: 接收方发送的对分组的确认丢失了<br>  当接收方又收到重传的分组时（发送方没有收到确认信息会重传），采取两个行动：<br>  i. 丢弃这个重复的分组<br>  ii. 向发送方发送确认<br><img src=\"/images/tcp_confirm_lose.jpg\" alt=\"tcp_confirm_lose\"></li>\n<li><strong>确认迟到</strong>: 传输过程没有差错，但接收方对分组的确认迟到了<br>  i. 发送方会收到重复的确认，收下后丢弃；<br>  ii. 接收方会收到重复的分组， 同样丢弃，并重传确认分组</li>\n</ul>\n<ol>\n<li>信道利用率<br>信道利用率计算：<br><img src=\"/images/tcp_channel_utilization.jpg\" alt=\"tcp_channel_utilization\"></li>\n</ol>\n<blockquote>\n<p>当往返时间RTT远大于分组发送时间Td时，信道的利用率会非常低，因而需要采用流水线传输</p>\n</blockquote>\n<h5 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h5><ul>\n<li>发送方维持一个发送窗口，位于发送窗口内的分组可以连续发送出去，不需要等待对方的确认</li>\n<li>发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置</li>\n<li>接收方一般采用累积确认的方式，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后对按序到达的最后一个分组发送确认，这表示：到这个分组为止的素有分组都已正确收到了</li>\n<li>优点： 容易实现，确认丢失也不必重传</li>\n<li>缺点： 不能正确反映出接收方已经正确收到的所有分组的信息，比如5个中的第3个丢了，就只能对前两个分组发出确认，后面三个重传</li>\n</ul>\n<h4 id=\"TCP报文段的首部格式\"><a href=\"#TCP报文段的首部格式\" class=\"headerlink\" title=\"TCP报文段的首部格式\"></a>TCP报文段的首部格式</h4><blockquote>\n<p>TCP的全部功能都体现在它首部中各字段的作用</p>\n</blockquote>\n<p><img src=\"/images/tcp_header.jpg\" alt=\"tcp_header\"></p>\n<ul>\n<li><strong>源端口和目的端口</strong>: </li>\n<li><strong>序号</strong>: 范围[0, 2^32 - 1],序号增加到2^32 - 1后，下一个序号又回到0。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号</li>\n<li><strong>确认号</strong>: 期望收到对方下一个报文段的第一个数据字节的序号，若确认号=N,则表明：到序号N-1为止的所有数据都已正确收到</li>\n<li><strong>数据偏移</strong>: 单位是4个字节，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，这个字段实际上是指出TCP报文段的首部长度</li>\n<li><strong>保留</strong>: 保留为今后用，目前应置为0</li>\n<li><strong>紧急URG</strong>: 当URG=1时，表示文段中有紧急数据，发送应用进程告诉发送方的TCP有紧急数据要传送，发送方TCP就把紧急数据插入到被报文段的最前面，要与紧急指针字段配合使用</li>\n<li><strong>确认ACK</strong>: 在TCP连接建立后所有传送的报文都必须把ACK置1</li>\n<li><strong>推送PSH</strong>: 发送方TCP把PSH置为1时，立即创建一个报文段发送出去，接收方尽快地交付接收应用进程，不用等到缓存填满</li>\n<li><strong>复位RST</strong>: 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接</li>\n<li><strong>同步SYN</strong>: 在连接建立事用来同步序号</li>\n<li><strong>终止FIN</strong>: 用来释放一个连接</li>\n<li><strong>窗口</strong>: 指的是发送本报文段的一方的接收窗口。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量</li>\n<li><strong>校验和</strong>: 计算方法和UDP一样</li>\n<li><strong>紧急指针</strong>: 当URG=1时才有意义，指出本报文段中的紧急数据的字节数</li>\n<li><strong>选项</strong>: 长度可变，最长达40字节</li>\n</ul>\n<h4 id=\"TCP可靠传输的实现\"><a href=\"#TCP可靠传输的实现\" class=\"headerlink\" title=\"TCP可靠传输的实现\"></a>TCP可靠传输的实现</h4><p>1.以字节为单位的滑动窗口</p>\n<ul>\n<li>TCP的滑动窗口以字节为单位</li>\n<li>发送窗口里面的序号表示允许发送出去的序号</li>\n<li>如图，假定A收到B发来的确认报文段，其中窗口是20，确认窗口是31，表明B期望收到的下一个序号是31,30为止的数据已经收到了<br><img src=\"/images/tcp_window_send.jpg\" alt=\"\"></li>\n<li>凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传</li>\n<li>描述一个发送窗口的状态需要三个指针，如图：<br><img src=\"/images/tcp_window_state.jpg\" alt=\"\"></li>\n<li>发送缓存用来暂时存放：<br>  i. 发送应用程序传送给发送方TCP准备发送的数据；<br>  ii. TCP已发送出但尚未收到确认的数据；<br><img src=\"/images/tcp_send_cahce.jpg\" alt=\"\">tcp_recieve_cahce</li>\n<li><p>接收缓存用来暂时存放：<br>  i. 按序到达的、但尚未被接收应用程序读取的数据；<br>  ii. 未按序到达的数据；<br><img src=\"/images/tcp_recieve_cahce.jpg\" alt=\"\"></p>\n</li>\n<li><p>三点强调：<br>  i. 发送窗口并不总是和接收窗口一样大<br>  ii. 对于不按序到达的数据，先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程<br>  iii. TCP要求接收方必须有累积确认的功能 </p>\n</li>\n</ul>\n<p>2.超时重传时间的选择<br>RTTs（加权平均往返时间）计算：<br><img src=\"/images/tcp_rtts_calculate.jpg\" alt=\"\"><br>RTTd（RTT的偏差的加权平均值）计算：<br><img src=\"/images/tcp_rttd_calculate.jpg\" alt=\"\"><br>RTO（超时重传时间）：<br><img src=\"/images/tcp_rto_calculate.jpg\" alt=\"\"></p>\n<p>3.选择确认SACK</p>\n<blockquote>\n<p>用来解决只传送缺少的数据而不重传已经正确到达接收方的数据</p>\n</blockquote>\n<h4 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h4><blockquote>\n<p>流量控制：让发送方的发送速率不要太快，要让接收方来得及接收。</p>\n</blockquote>\n<ol>\n<li>利用滑动窗口实现流量控制<blockquote>\n<p>发送方的发送窗口不能超过接收方给出的接收窗口的数值</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/tcp_window_flow_control.jpg\" alt=\"\"></p>\n<ol>\n<li>传输效率<br>三种控制TCP报文段发送时机的机制:</li>\n</ol>\n<ul>\n<li>维持一个变量，等于最大报文段长度MSS</li>\n<li>发送方的应有进程指明要求发送报文段，即推送(push)操作</li>\n<li>发送方的计时器期限</li>\n</ul>\n<h4 id=\"TCP的拥塞控制\"><a href=\"#TCP的拥塞控制\" class=\"headerlink\" title=\"TCP的拥塞控制\"></a>TCP的拥塞控制</h4><ol>\n<li>拥塞控制的一般原理<br>两种方法：</li>\n</ol>\n<ul>\n<li>开环控制：在设计网络时事先将有关发送拥塞的因素考虑周到，力求网络在工作时不发生拥塞，但系统运行起来中途不能改正</li>\n<li>闭环控制：三种措施：<br>  i. 检测网络系统以便检测到拥塞何时、何处发生；<br>  ii. 把拥塞发送的信息传送到可采取行动的地方；<br>  iii. 调整网络系统的运行以解决问题；</li>\n</ul>\n<ol>\n<li>四种拥塞控制方法<br><strong>慢开始和拥塞避免</strong>：发送方维持一个叫做拥塞窗口cwnd的状态变量，发送方让自己的发送窗口等于拥塞窗口；</li>\n</ol>\n<ul>\n<li>慢开始：由小到大逐渐增大拥塞窗口数值（为了防止拥塞窗口cwnd增长过大引起网络拥塞，需要设置一个慢开始门限状态变量ssthresh）<br><img src=\"/images/tcp_slow_start.jpg\" alt=\"\"></li>\n<li>拥塞避免：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间就把发送方的拥塞窗口加1（拥塞避免并非完全能够避免了拥塞）<br>慢开始和拥塞避免算法实现举例：<br><img src=\"/images/tcp_congestion_avoid.jpg\" alt=\"\"><br><strong>快重传和快恢复</strong>: </li>\n<li>快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未搜到的报文段，而不必继续等待重传计时器到期<br><img src=\"/images/tcp_quick_resend.jpg\" alt=\"\"></li>\n<li>快恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”，把慢开始门限ssthresh减半（而不是直接设置cwnd为1），然后开始拥塞避免算法<br>快重传和快恢复算法实现举例：<br><img src=\"/images/tcp_quick_recovery.jpg\" alt=\"\"></li>\n</ul>\n<ol>\n<li>随机早期检测RED</li>\n</ol>\n<ul>\n<li>随机早期检测： 在检测到网络拥塞的早期征兆时，就以概率p随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，少量的分组被丢弃，避免发生全局性的拥塞控制</li>\n<li>需要选择好三个参数：最小门限THmin，最大门限THmax和概率p</li>\n<li>丢弃概率p与两个门限值的关系图：<br><img src=\"/images/tcp_red.jpg\" alt=\"\"></li>\n</ul>\n<h4 id=\"TCP的运输连接管理\"><a href=\"#TCP的运输连接管理\" class=\"headerlink\" title=\"TCP的运输连接管理\"></a>TCP的运输连接管理</h4><blockquote>\n<p>运输连接有三个阶段：连接建立，数据传送，连接释放</p>\n</blockquote>\n<ol>\n<li>TCP的连接建立：三次握手<br><img src=\"/images/tcp_build_connect.jpg\" alt=\"\"></li>\n</ol>\n<ul>\n<li><p><strong>第一次握手</strong>：客户进程A创建传输控制模块TCB，向服务进程发出连接请求报文段，等待B确认，这时A进入SYN-SENT（同步已发送）状态</p>\n<blockquote>\n<p>报文段首部中SYN=1，同时选择一个初始序号seq=x，不携带任何数据，但要消耗一个序号</p>\n</blockquote>\n</li>\n<li><p><strong>第二次握手</strong>：服务进程B收到请求报文段后，如同意建立连接，则向A发送确认，这时TCP服务进程进入SYN-RCVD（同步已发送）状态</p>\n<blockquote>\n<p>将SYN和ACK都置1，确认号是ack=x+1，同时也为自己选一个初始序列号seq=y</p>\n</blockquote>\n</li>\n<li><p><strong>第三次握手</strong>：A收到B的确认后，要向B给出确认，这时TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态，当B收到A的确认后，也进入ESTABLISHED状态</p>\n<blockquote>\n<p>A发送的确认报文段ACK置1，确认号ack=y+1，自己的序号seq=x+1，ACK报文段可以携带数据，但不携带数据则不消耗序号。<strong>A发送一次确认是为了防止已失效的连接请求报文段突然又传到了B</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>TCP的连接释放:四次挥手<br><img src=\"/images/tcp_release_connect.jpg\" alt=\"\"></li>\n</ol>\n<ul>\n<li><p><strong>第一次挥手</strong>：A向B发送释放连接报文段，A进入FIN-WAIT-1在（终止等待1）状态</p>\n<blockquote>\n<p>报文段首部中终止控制位FIN置1，其序号是seq=u，等于前面已传送过的数据的最后一个字节的序号加1，即使不携带任何数据，但要消耗一个序号</p>\n</blockquote>\n</li>\n<li><p><strong>第二次挥手</strong>：B收到连接释放报文段后发出确认，B进入CLOSE-WAIT（关闭等待）状态，这时TCP连接处于半关闭状态，即A已经没有数据发送给B，但B若发送数据，A仍要接收。A收到确认之后，进入FIN-WAIT-2（终止等待2）状态</p>\n<blockquote>\n<p>确认号是ack=u+1，这个报文号自身的序号是v,等于前面已传送过的数据的最后一个字节的序号加1</p>\n</blockquote>\n</li>\n<li><p><strong>第三次挥手</strong>：若B已经没有要想向A发送的数据，就通知TCP释放连接，B进入LAST-ACK（最后确认状态），等待A的确认</p>\n<blockquote>\n<p>B发出的报文段令FIN=1，而且必须重复上次已发送过的确认号ack=u+1</p>\n</blockquote>\n</li>\n<li><p><strong>第四次挥手</strong>：A收到B的连接释放报文段后，必须对此发出确认。然后A进入TIME-WAIT（时间等待）状态</p>\n<blockquote>\n<p>A发送的确认报文段ACK置1，确认号ack=w+1，自身的序号是seq=u+1。<strong>注意这时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。</strong></p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>TCP的有限状态机<blockquote>\n<p>粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，细线箭头表示异常变迁</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/tcp_limited_state_machine.jpg\" alt=\"\"></p>\n"},{"title":"单例模式的几种写法对比","date":"2019-02-15T12:41:28.000Z","copyright":null,"_content":"\n### 懒汉模式\n#### 1. 最简单的懒汉模式\n**线程不安全，不推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n> 在多线程环境下，当多个线程执行到第9行代码时，此时instance都为空，那么这些线程都会执行第10行代码，从而创建了多个对象\n\n#### 2. 在上面的基础上给getInstance方法加上synchronized\n**线程安全，不推荐**，加上synchronized之后，方法内的所有实现在同一时间只允许一个线程访问，可以保证线程安全，但是synchronized会带来性上很大的开销\n\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n#### 3. 双重同步锁单例模式\n**线程不安全，可以改进**\n\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) { // 双重检测机制        \n            synchronized (Singleton.class) { // 同步锁\n                if (instance == null) {\n                    instance = new Singleton(); \n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n> 对于`instance = new Singleton(); ` 这一行代码，实际上可以看出以下三步：\n    1、memory = allocate() 分配对象的内存空间\n    2、ctorInstance() 初始化对象\n    3、instance = memory 设置instance指向刚分配的内存\n   由于第二步和第三步不能由先行发生原则到处出来，JVM和cpu优化，发生了指令重排，顺序如下：\n    1、memory = allocate() 分配对象的内存空间\n    3、instance = memory 设置instance指向刚分配的内存\n    2、ctorInstance() 初始化对象\n   那么可能存在这样一种情况，在多线程情况下，当线程A执行到第10行代码`instance = new Singleton(); `的第3步`instance = memory 设置instance指向刚分配的内存`时，线程B执行到第8行代码`if (instance == null) `， 这时对象还没有初始化完毕，然而instance已经指向了分配给对象的内存，instance已经不为空，会造成对象逸出，因而线程不安全；\n\n\n#### 4. volatile + 双重检测机制，禁止指令重排\n**线程安全，推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) { // 双重检测机制        \n            synchronized (Singleton.class) { // 同步锁\n                if (instance == null) {\n                    instance = new Singleton(); \n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 饿汉模式，单例实例在类装载时进行创建\n如果构造方法中没有很多的处理，那么饿汉模式是可以接收的，但是如果构造方法中有非常多的处理，会导致类加载的时候很慢，会导致一些性能的问题。 如果只进行类的加载，而没有进行实际的调用，就会造成资源的浪费，因此使用饿汉模式的时候应该考虑两个问题：\n1. 构造方法有没有过多的处理\n2. 这个类是否一定会被使用，避免装载之后没有调用造成资源浪费\n\n#### 1. 普通饿汉模式\n**线程安全，可以改进**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = new Singleton();\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n#### 2. 将创建对象的代码放到static块中\n**线程安全，推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    static {\n        instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n### 枚举模式\n**最安全，推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        return Singleton.INSTANCE.getInstance();\n    }\n\n    private enum Singleton {\n        INSTANCE;\n\n        private Singleton singleton;\n\n        // JVM保证这个方法绝对只调用一次\n        Singleton() {\n            singleton = new Singleton();\n        }\n\n        public Singleton getInstance() {\n            return singleton;\n        }\n    }\n}\n```","source":"_posts/单例模式的几种写法对比.md","raw":"---\ntitle: 单例模式的几种写法对比\ndate: 2019-02-15 20:41:28\ncategories: \"设计模式\"\ntags:\n    - 设计模式\n    - Java并发\ncopyright:\n---\n\n### 懒汉模式\n#### 1. 最简单的懒汉模式\n**线程不安全，不推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n> 在多线程环境下，当多个线程执行到第9行代码时，此时instance都为空，那么这些线程都会执行第10行代码，从而创建了多个对象\n\n#### 2. 在上面的基础上给getInstance方法加上synchronized\n**线程安全，不推荐**，加上synchronized之后，方法内的所有实现在同一时间只允许一个线程访问，可以保证线程安全，但是synchronized会带来性上很大的开销\n\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n```\n\n#### 3. 双重同步锁单例模式\n**线程不安全，可以改进**\n\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) { // 双重检测机制        \n            synchronized (Singleton.class) { // 同步锁\n                if (instance == null) {\n                    instance = new Singleton(); \n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n> 对于`instance = new Singleton(); ` 这一行代码，实际上可以看出以下三步：\n    1、memory = allocate() 分配对象的内存空间\n    2、ctorInstance() 初始化对象\n    3、instance = memory 设置instance指向刚分配的内存\n   由于第二步和第三步不能由先行发生原则到处出来，JVM和cpu优化，发生了指令重排，顺序如下：\n    1、memory = allocate() 分配对象的内存空间\n    3、instance = memory 设置instance指向刚分配的内存\n    2、ctorInstance() 初始化对象\n   那么可能存在这样一种情况，在多线程情况下，当线程A执行到第10行代码`instance = new Singleton(); `的第3步`instance = memory 设置instance指向刚分配的内存`时，线程B执行到第8行代码`if (instance == null) `， 这时对象还没有初始化完毕，然而instance已经指向了分配给对象的内存，instance已经不为空，会造成对象逸出，因而线程不安全；\n\n\n#### 4. volatile + 双重检测机制，禁止指令重排\n**线程安全，推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) { // 双重检测机制        \n            synchronized (Singleton.class) { // 同步锁\n                if (instance == null) {\n                    instance = new Singleton(); \n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 饿汉模式，单例实例在类装载时进行创建\n如果构造方法中没有很多的处理，那么饿汉模式是可以接收的，但是如果构造方法中有非常多的处理，会导致类加载的时候很慢，会导致一些性能的问题。 如果只进行类的加载，而没有进行实际的调用，就会造成资源的浪费，因此使用饿汉模式的时候应该考虑两个问题：\n1. 构造方法有没有过多的处理\n2. 这个类是否一定会被使用，避免装载之后没有调用造成资源浪费\n\n#### 1. 普通饿汉模式\n**线程安全，可以改进**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = new Singleton();\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n#### 2. 将创建对象的代码放到static块中\n**线程安全，推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    private static Singleton instance = null;\n\n    static {\n        instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n```\n\n### 枚举模式\n**最安全，推荐**\n```java\npublic class Singleton {\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        return Singleton.INSTANCE.getInstance();\n    }\n\n    private enum Singleton {\n        INSTANCE;\n\n        private Singleton singleton;\n\n        // JVM保证这个方法绝对只调用一次\n        Singleton() {\n            singleton = new Singleton();\n        }\n\n        public Singleton getInstance() {\n            return singleton;\n        }\n    }\n}\n```","slug":"单例模式的几种写法对比","published":1,"updated":"2019-02-15T13:51:38.016Z","_id":"cjs641fdn0020u7yjvpmmm1x8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h3><h4 id=\"1-最简单的懒汉模式\"><a href=\"#1-最简单的懒汉模式\" class=\"headerlink\" title=\"1. 最简单的懒汉模式\"></a>1. 最简单的懒汉模式</h4><p><strong>线程不安全，不推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在多线程环境下，当多个线程执行到第9行代码时，此时instance都为空，那么这些线程都会执行第10行代码，从而创建了多个对象</p>\n</blockquote>\n<h4 id=\"2-在上面的基础上给getInstance方法加上synchronized\"><a href=\"#2-在上面的基础上给getInstance方法加上synchronized\" class=\"headerlink\" title=\"2. 在上面的基础上给getInstance方法加上synchronized\"></a>2. 在上面的基础上给getInstance方法加上synchronized</h4><p><strong>线程安全，不推荐</strong>，加上synchronized之后，方法内的所有实现在同一时间只允许一个线程访问，可以保证线程安全，但是synchronized会带来性上很大的开销</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-双重同步锁单例模式\"><a href=\"#3-双重同步锁单例模式\" class=\"headerlink\" title=\"3. 双重同步锁单例模式\"></a>3. 双重同步锁单例模式</h4><p><strong>线程不安全，可以改进</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 双重检测机制        </span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123; <span class=\"comment\">// 同步锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton(); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于<code>instance = new Singleton();</code> 这一行代码，实际上可以看出以下三步：<br>    1、memory = allocate() 分配对象的内存空间<br>    2、ctorInstance() 初始化对象<br>    3、instance = memory 设置instance指向刚分配的内存<br>   由于第二步和第三步不能由先行发生原则到处出来，JVM和cpu优化，发生了指令重排，顺序如下：<br>    1、memory = allocate() 分配对象的内存空间<br>    3、instance = memory 设置instance指向刚分配的内存<br>    2、ctorInstance() 初始化对象<br>   那么可能存在这样一种情况，在多线程情况下，当线程A执行到第10行代码<code>instance = new Singleton();</code>的第3步<code>instance = memory 设置instance指向刚分配的内存</code>时，线程B执行到第8行代码<code>if (instance == null)</code>， 这时对象还没有初始化完毕，然而instance已经指向了分配给对象的内存，instance已经不为空，会造成对象逸出，因而线程不安全；</p>\n</blockquote>\n<h4 id=\"4-volatile-双重检测机制，禁止指令重排\"><a href=\"#4-volatile-双重检测机制，禁止指令重排\" class=\"headerlink\" title=\"4. volatile + 双重检测机制，禁止指令重排\"></a>4. volatile + 双重检测机制，禁止指令重排</h4><p><strong>线程安全，推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 双重检测机制        </span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123; <span class=\"comment\">// 同步锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton(); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"饿汉模式，单例实例在类装载时进行创建\"><a href=\"#饿汉模式，单例实例在类装载时进行创建\" class=\"headerlink\" title=\"饿汉模式，单例实例在类装载时进行创建\"></a>饿汉模式，单例实例在类装载时进行创建</h3><p>如果构造方法中没有很多的处理，那么饿汉模式是可以接收的，但是如果构造方法中有非常多的处理，会导致类加载的时候很慢，会导致一些性能的问题。 如果只进行类的加载，而没有进行实际的调用，就会造成资源的浪费，因此使用饿汉模式的时候应该考虑两个问题：</p>\n<ol>\n<li>构造方法有没有过多的处理</li>\n<li>这个类是否一定会被使用，避免装载之后没有调用造成资源浪费</li>\n</ol>\n<h4 id=\"1-普通饿汉模式\"><a href=\"#1-普通饿汉模式\" class=\"headerlink\" title=\"1. 普通饿汉模式\"></a>1. 普通饿汉模式</h4><p><strong>线程安全，可以改进</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-将创建对象的代码放到static块中\"><a href=\"#2-将创建对象的代码放到static块中\" class=\"headerlink\" title=\"2. 将创建对象的代码放到static块中\"></a>2. 将创建对象的代码放到static块中</h4><p><strong>线程安全，推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"枚举模式\"><a href=\"#枚举模式\" class=\"headerlink\" title=\"枚举模式\"></a>枚举模式</h3><p><strong>最安全，推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton.INSTANCE.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> Singleton &#123;</span><br><span class=\"line\">        INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// JVM保证这个方法绝对只调用一次</span></span><br><span class=\"line\">        Singleton() &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h3><h4 id=\"1-最简单的懒汉模式\"><a href=\"#1-最简单的懒汉模式\" class=\"headerlink\" title=\"1. 最简单的懒汉模式\"></a>1. 最简单的懒汉模式</h4><p><strong>线程不安全，不推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在多线程环境下，当多个线程执行到第9行代码时，此时instance都为空，那么这些线程都会执行第10行代码，从而创建了多个对象</p>\n</blockquote>\n<h4 id=\"2-在上面的基础上给getInstance方法加上synchronized\"><a href=\"#2-在上面的基础上给getInstance方法加上synchronized\" class=\"headerlink\" title=\"2. 在上面的基础上给getInstance方法加上synchronized\"></a>2. 在上面的基础上给getInstance方法加上synchronized</h4><p><strong>线程安全，不推荐</strong>，加上synchronized之后，方法内的所有实现在同一时间只允许一个线程访问，可以保证线程安全，但是synchronized会带来性上很大的开销</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-双重同步锁单例模式\"><a href=\"#3-双重同步锁单例模式\" class=\"headerlink\" title=\"3. 双重同步锁单例模式\"></a>3. 双重同步锁单例模式</h4><p><strong>线程不安全，可以改进</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 双重检测机制        </span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123; <span class=\"comment\">// 同步锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton(); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于<code>instance = new Singleton();</code> 这一行代码，实际上可以看出以下三步：<br>    1、memory = allocate() 分配对象的内存空间<br>    2、ctorInstance() 初始化对象<br>    3、instance = memory 设置instance指向刚分配的内存<br>   由于第二步和第三步不能由先行发生原则到处出来，JVM和cpu优化，发生了指令重排，顺序如下：<br>    1、memory = allocate() 分配对象的内存空间<br>    3、instance = memory 设置instance指向刚分配的内存<br>    2、ctorInstance() 初始化对象<br>   那么可能存在这样一种情况，在多线程情况下，当线程A执行到第10行代码<code>instance = new Singleton();</code>的第3步<code>instance = memory 设置instance指向刚分配的内存</code>时，线程B执行到第8行代码<code>if (instance == null)</code>， 这时对象还没有初始化完毕，然而instance已经指向了分配给对象的内存，instance已经不为空，会造成对象逸出，因而线程不安全；</p>\n</blockquote>\n<h4 id=\"4-volatile-双重检测机制，禁止指令重排\"><a href=\"#4-volatile-双重检测机制，禁止指令重排\" class=\"headerlink\" title=\"4. volatile + 双重检测机制，禁止指令重排\"></a>4. volatile + 双重检测机制，禁止指令重排</h4><p><strong>线程安全，推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 双重检测机制        </span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123; <span class=\"comment\">// 同步锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton(); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"饿汉模式，单例实例在类装载时进行创建\"><a href=\"#饿汉模式，单例实例在类装载时进行创建\" class=\"headerlink\" title=\"饿汉模式，单例实例在类装载时进行创建\"></a>饿汉模式，单例实例在类装载时进行创建</h3><p>如果构造方法中没有很多的处理，那么饿汉模式是可以接收的，但是如果构造方法中有非常多的处理，会导致类加载的时候很慢，会导致一些性能的问题。 如果只进行类的加载，而没有进行实际的调用，就会造成资源的浪费，因此使用饿汉模式的时候应该考虑两个问题：</p>\n<ol>\n<li>构造方法有没有过多的处理</li>\n<li>这个类是否一定会被使用，避免装载之后没有调用造成资源浪费</li>\n</ol>\n<h4 id=\"1-普通饿汉模式\"><a href=\"#1-普通饿汉模式\" class=\"headerlink\" title=\"1. 普通饿汉模式\"></a>1. 普通饿汉模式</h4><p><strong>线程安全，可以改进</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-将创建对象的代码放到static块中\"><a href=\"#2-将创建对象的代码放到static块中\" class=\"headerlink\" title=\"2. 将创建对象的代码放到static块中\"></a>2. 将创建对象的代码放到static块中</h4><p><strong>线程安全，推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"枚举模式\"><a href=\"#枚举模式\" class=\"headerlink\" title=\"枚举模式\"></a>枚举模式</h3><p><strong>最安全，推荐</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton.INSTANCE.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> Singleton &#123;</span><br><span class=\"line\">        INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// JVM保证这个方法绝对只调用一次</span></span><br><span class=\"line\">        Singleton() &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"实现简单的jdk动态代理","date":"2019-01-21T13:01:06.000Z","copyright":null,"_content":"\n","source":"_posts/实现简单的jdk动态代理.md","raw":"---\ntitle: 实现简单的jdk动态代理\ndate: 2019-01-21 21:01:06\ncategories:\ntags:\ncopyright:\n---\n\n","slug":"实现简单的jdk动态代理","published":1,"updated":"2019-01-21T13:01:40.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdp0025u7yj1hlryobt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"数据库事务管理","date":"2018-11-05T07:42:40.000Z","copyright":null,"_content":"\n### 事务的ACID特性\n\n- **原子性**: 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。\n\n- **一致性**: 隔离执行事务时（即不考虑其他事务并发执行）保持数据库的一致性。 在数据库系统中由恢复系统负责。\n\n- **隔离性**: 尽管多个事务可能并发执行，但系统保证对于多个事务，如T1和T2，对于T1来说，T1要么在T2开始之前已经完成执行，要么在T2完成之后开始执行。确保隔离性在数据库系统中由并发控制系统部件负责。\n\n- **持久性**: 一旦事务成功完成后，它对数据库的更新必须是永久的，即使出现系统故障，在数据库系统中由恢复系统负责。 可以通过一下两条中的其中任何一条来确保持久性。\n1. 事务做的更新在事务结束前已经给写入磁盘\n2. 有关事务已执行的更新信息已写到磁盘上，并且此类信息必须充分，能让数据库在系统出现故障后重新启动时重新构造更新\n\n----\n\n### 事务原子性和持久性\n#### 五种状态\n可以为事务建立一个简单的抽象事务类型，分为五种状态，事务必须处于以下状态之一\n- **活动的**： 初始状态，事务正在执行时处于此状态\n- **部分提交的**： 最后一条语句执行后\n- **失败的**： 发现正常的执行不能继续后\n- **中止的**： 事务回滚并且数据库已恢复到事务开始执行前的状态后\n- **提交的**： 成功完成后\n\n![事务管理状态](/images/transaction_state.png)\n\n#### 中止状态事务回滚的两种选择\n\n- **重启事务**，但仅当引起事务中止的是硬件错误而不是有事务内部逻辑所产生的软件错误。\n- **杀死事务**, 这样做通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正\n\n----\n\n### 事务隔离性\n#### 可串行化调度\n- **冲突**: 假设I和J是不同事务在在相同数据项上的操作，并且其中至少有一个是write指令时，I与J是冲突的\n- **冲突等价**: 调度S经过一系列非冲突指令交换转换成S'，S与S'冲突等价\n- **冲突可串行化**: 一个调度S与另一个串行调度冲突等价，则称调度S是冲突可串行化的\n\n#### 可恢复性\n- **可恢复调度**: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1先于T2提交\n- **无级联调度**: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1必须在T2这一读操作前提交\n\n#### 事务隔离性级别\n- **可串行化**: 通常保证可串行化调度\n- **可重复读**: 只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据，但该事务不要求与其他事务可串行化\n- **已提交读**: 只允许读取已提交数据，但不要求可重复读功能\n- **未提交读**: 允许读未提交数据\n\n----\n\n### 并发控制\n#### 基于锁的协议\n##### 锁\n- **共享锁（S)**: 如果事务T1获得了数据项Q上的共享型锁（记为S），则T1可读但不能写\n- **排他锁(X)**: 如果事务T1获得了数据项Q上的排他型锁（记为X），则T1既可读又可写Q\n- **相容的锁**: 数据项Q上存在B类型锁，如果事务T可以立即获得数据项Q上的A类型锁，则说A类型锁与B类型锁是相容的，即comp(A,B)=true\n\n##### 锁的授予\n- **避免饿死**: 可以通过在数据项Q上加M型锁，加锁条件如下：\n    1.不存在在数据项Q上持有与M型锁冲突的锁的事务\n    2.不存在等待对数据项Q上先于T申请枷锁的事务\n\n##### 两阶段封锁协议\n- **增长阶段**: 事务可以获得锁，但不能释放锁\n- **缩减阶段**: 事务可以释放锁，但不能获得新锁\n- **严格两阶段封锁协议**: 事务持有的所有排他锁必须在事务提交后方可释放\n- **强两阶段封锁协议**: 事务提交之前不得释放任何锁\n\n##### 多粒度\n- **多级粒度机制**: 通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大力度数据项中来实现。这种层次结构可以图形化地表示为树\n- **意向锁**: 如果一个结点佳航了意向锁，则意味着要在树的叫底层进行显式加锁，在一个结点显式加锁前，该结点的的全部祖先结点都加上了意向锁。 这样子可以避免了需要从头遍历结点才能发现子结点已经加锁\n- **共享意向锁(IS)**: 一个结点加上了共享意向锁，树的较低层进行显式封锁，但只能加共享锁。\n- **排他意向锁(IX)**: 一个结点加上了排他意向锁，树的较低层进行显式封锁，可以加共享锁或排他锁。\n- **共享排他意向锁(SIX)**: 一个结点加上了共享排他意向锁，则以该结点为根的子树显式地加上了共享锁，并且将在数的更低层显式地加排他锁。\n- **各种锁类型相容函数**：\n![各种锁类型相容函数](/images/lock_types_comp.png)\n\n#### 基于时间戳的协议\n对于系统中的每个事务T，把一个唯一的固定时间戳与他联系起来，此时间戳记为TS(T)。该时间戳是在事务T开始执行前由数据库系统赋予的。实现这种机制可以用以下两种方法：\n- 使用系统始终的值作为时间戳，即事务的时间戳等于该事务进入系统时的时钟值。\n- 使用逻辑计数器，没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值。\n\n每个数据项需要与两个时间戳相关联：\n- W-timestamp（Q）表示成功执行write（Q）的所有事务的最大时间戳\n- R-timestamp（Q）表示成功执行read（Q）的所有事务的最大时间戳\n\n协议运作方式如下：\n1.假设事务T发出read（Q）\n&emsp; a.若TS（T）< W-timestamp（Q），则T需要读入的Q值已被覆盖。因此read操作被拒绝，T回滚；\n&emsp; b.若TS（T）>= W-timestamp（Q），则执行read操作，R-timestamp（Q）被设置为R-timestamp（Q）与TS(T)两者的最大值\n2.假设事务T发出write（Q）\n&emsp; a.若TS（T）< R-timestamp（Q），则T产生的Q值是先前所需要的值，且系统已假定该值不会在产生，因此write被拒绝，T回滚\n&emsp; b.若TS（T）< W-timestamp（Q），则T试图写入的Q值已过时，write操作被拒绝，T回滚\n&emsp; c.其他情况，系统执行write操作，将W-timestamp（Q）设置为TS（T）。\n\n\n\n\n\n\n","source":"_posts/数据库事务管理.md","raw":"---\ntitle: 数据库事务管理\ndate: 2018-11-05 15:42:40\ncategories: \"数据库\"\ntags:\n    - 计算机基础\ncopyright:\n---\n\n### 事务的ACID特性\n\n- **原子性**: 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。\n\n- **一致性**: 隔离执行事务时（即不考虑其他事务并发执行）保持数据库的一致性。 在数据库系统中由恢复系统负责。\n\n- **隔离性**: 尽管多个事务可能并发执行，但系统保证对于多个事务，如T1和T2，对于T1来说，T1要么在T2开始之前已经完成执行，要么在T2完成之后开始执行。确保隔离性在数据库系统中由并发控制系统部件负责。\n\n- **持久性**: 一旦事务成功完成后，它对数据库的更新必须是永久的，即使出现系统故障，在数据库系统中由恢复系统负责。 可以通过一下两条中的其中任何一条来确保持久性。\n1. 事务做的更新在事务结束前已经给写入磁盘\n2. 有关事务已执行的更新信息已写到磁盘上，并且此类信息必须充分，能让数据库在系统出现故障后重新启动时重新构造更新\n\n----\n\n### 事务原子性和持久性\n#### 五种状态\n可以为事务建立一个简单的抽象事务类型，分为五种状态，事务必须处于以下状态之一\n- **活动的**： 初始状态，事务正在执行时处于此状态\n- **部分提交的**： 最后一条语句执行后\n- **失败的**： 发现正常的执行不能继续后\n- **中止的**： 事务回滚并且数据库已恢复到事务开始执行前的状态后\n- **提交的**： 成功完成后\n\n![事务管理状态](/images/transaction_state.png)\n\n#### 中止状态事务回滚的两种选择\n\n- **重启事务**，但仅当引起事务中止的是硬件错误而不是有事务内部逻辑所产生的软件错误。\n- **杀死事务**, 这样做通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正\n\n----\n\n### 事务隔离性\n#### 可串行化调度\n- **冲突**: 假设I和J是不同事务在在相同数据项上的操作，并且其中至少有一个是write指令时，I与J是冲突的\n- **冲突等价**: 调度S经过一系列非冲突指令交换转换成S'，S与S'冲突等价\n- **冲突可串行化**: 一个调度S与另一个串行调度冲突等价，则称调度S是冲突可串行化的\n\n#### 可恢复性\n- **可恢复调度**: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1先于T2提交\n- **无级联调度**: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1必须在T2这一读操作前提交\n\n#### 事务隔离性级别\n- **可串行化**: 通常保证可串行化调度\n- **可重复读**: 只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据，但该事务不要求与其他事务可串行化\n- **已提交读**: 只允许读取已提交数据，但不要求可重复读功能\n- **未提交读**: 允许读未提交数据\n\n----\n\n### 并发控制\n#### 基于锁的协议\n##### 锁\n- **共享锁（S)**: 如果事务T1获得了数据项Q上的共享型锁（记为S），则T1可读但不能写\n- **排他锁(X)**: 如果事务T1获得了数据项Q上的排他型锁（记为X），则T1既可读又可写Q\n- **相容的锁**: 数据项Q上存在B类型锁，如果事务T可以立即获得数据项Q上的A类型锁，则说A类型锁与B类型锁是相容的，即comp(A,B)=true\n\n##### 锁的授予\n- **避免饿死**: 可以通过在数据项Q上加M型锁，加锁条件如下：\n    1.不存在在数据项Q上持有与M型锁冲突的锁的事务\n    2.不存在等待对数据项Q上先于T申请枷锁的事务\n\n##### 两阶段封锁协议\n- **增长阶段**: 事务可以获得锁，但不能释放锁\n- **缩减阶段**: 事务可以释放锁，但不能获得新锁\n- **严格两阶段封锁协议**: 事务持有的所有排他锁必须在事务提交后方可释放\n- **强两阶段封锁协议**: 事务提交之前不得释放任何锁\n\n##### 多粒度\n- **多级粒度机制**: 通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大力度数据项中来实现。这种层次结构可以图形化地表示为树\n- **意向锁**: 如果一个结点佳航了意向锁，则意味着要在树的叫底层进行显式加锁，在一个结点显式加锁前，该结点的的全部祖先结点都加上了意向锁。 这样子可以避免了需要从头遍历结点才能发现子结点已经加锁\n- **共享意向锁(IS)**: 一个结点加上了共享意向锁，树的较低层进行显式封锁，但只能加共享锁。\n- **排他意向锁(IX)**: 一个结点加上了排他意向锁，树的较低层进行显式封锁，可以加共享锁或排他锁。\n- **共享排他意向锁(SIX)**: 一个结点加上了共享排他意向锁，则以该结点为根的子树显式地加上了共享锁，并且将在数的更低层显式地加排他锁。\n- **各种锁类型相容函数**：\n![各种锁类型相容函数](/images/lock_types_comp.png)\n\n#### 基于时间戳的协议\n对于系统中的每个事务T，把一个唯一的固定时间戳与他联系起来，此时间戳记为TS(T)。该时间戳是在事务T开始执行前由数据库系统赋予的。实现这种机制可以用以下两种方法：\n- 使用系统始终的值作为时间戳，即事务的时间戳等于该事务进入系统时的时钟值。\n- 使用逻辑计数器，没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值。\n\n每个数据项需要与两个时间戳相关联：\n- W-timestamp（Q）表示成功执行write（Q）的所有事务的最大时间戳\n- R-timestamp（Q）表示成功执行read（Q）的所有事务的最大时间戳\n\n协议运作方式如下：\n1.假设事务T发出read（Q）\n&emsp; a.若TS（T）< W-timestamp（Q），则T需要读入的Q值已被覆盖。因此read操作被拒绝，T回滚；\n&emsp; b.若TS（T）>= W-timestamp（Q），则执行read操作，R-timestamp（Q）被设置为R-timestamp（Q）与TS(T)两者的最大值\n2.假设事务T发出write（Q）\n&emsp; a.若TS（T）< R-timestamp（Q），则T产生的Q值是先前所需要的值，且系统已假定该值不会在产生，因此write被拒绝，T回滚\n&emsp; b.若TS（T）< W-timestamp（Q），则T试图写入的Q值已过时，write操作被拒绝，T回滚\n&emsp; c.其他情况，系统执行write操作，将W-timestamp（Q）设置为TS（T）。\n\n\n\n\n\n\n","slug":"数据库事务管理","published":1,"updated":"2018-11-06T07:06:08.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdr0028u7yjkmvqfwnm","content":"<h3 id=\"事务的ACID特性\"><a href=\"#事务的ACID特性\" class=\"headerlink\" title=\"事务的ACID特性\"></a>事务的ACID特性</h3><ul>\n<li><p><strong>原子性</strong>: 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。</p>\n</li>\n<li><p><strong>一致性</strong>: 隔离执行事务时（即不考虑其他事务并发执行）保持数据库的一致性。 在数据库系统中由恢复系统负责。</p>\n</li>\n<li><p><strong>隔离性</strong>: 尽管多个事务可能并发执行，但系统保证对于多个事务，如T1和T2，对于T1来说，T1要么在T2开始之前已经完成执行，要么在T2完成之后开始执行。确保隔离性在数据库系统中由并发控制系统部件负责。</p>\n</li>\n<li><p><strong>持久性</strong>: 一旦事务成功完成后，它对数据库的更新必须是永久的，即使出现系统故障，在数据库系统中由恢复系统负责。 可以通过一下两条中的其中任何一条来确保持久性。</p>\n</li>\n</ul>\n<ol>\n<li>事务做的更新在事务结束前已经给写入磁盘</li>\n<li>有关事务已执行的更新信息已写到磁盘上，并且此类信息必须充分，能让数据库在系统出现故障后重新启动时重新构造更新</li>\n</ol>\n<hr>\n<h3 id=\"事务原子性和持久性\"><a href=\"#事务原子性和持久性\" class=\"headerlink\" title=\"事务原子性和持久性\"></a>事务原子性和持久性</h3><h4 id=\"五种状态\"><a href=\"#五种状态\" class=\"headerlink\" title=\"五种状态\"></a>五种状态</h4><p>可以为事务建立一个简单的抽象事务类型，分为五种状态，事务必须处于以下状态之一</p>\n<ul>\n<li><strong>活动的</strong>： 初始状态，事务正在执行时处于此状态</li>\n<li><strong>部分提交的</strong>： 最后一条语句执行后</li>\n<li><strong>失败的</strong>： 发现正常的执行不能继续后</li>\n<li><strong>中止的</strong>： 事务回滚并且数据库已恢复到事务开始执行前的状态后</li>\n<li><strong>提交的</strong>： 成功完成后</li>\n</ul>\n<p><img src=\"/images/transaction_state.png\" alt=\"事务管理状态\"></p>\n<h4 id=\"中止状态事务回滚的两种选择\"><a href=\"#中止状态事务回滚的两种选择\" class=\"headerlink\" title=\"中止状态事务回滚的两种选择\"></a>中止状态事务回滚的两种选择</h4><ul>\n<li><strong>重启事务</strong>，但仅当引起事务中止的是硬件错误而不是有事务内部逻辑所产生的软件错误。</li>\n<li><strong>杀死事务</strong>, 这样做通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正</li>\n</ul>\n<hr>\n<h3 id=\"事务隔离性\"><a href=\"#事务隔离性\" class=\"headerlink\" title=\"事务隔离性\"></a>事务隔离性</h3><h4 id=\"可串行化调度\"><a href=\"#可串行化调度\" class=\"headerlink\" title=\"可串行化调度\"></a>可串行化调度</h4><ul>\n<li><strong>冲突</strong>: 假设I和J是不同事务在在相同数据项上的操作，并且其中至少有一个是write指令时，I与J是冲突的</li>\n<li><strong>冲突等价</strong>: 调度S经过一系列非冲突指令交换转换成S’，S与S’冲突等价</li>\n<li><strong>冲突可串行化</strong>: 一个调度S与另一个串行调度冲突等价，则称调度S是冲突可串行化的</li>\n</ul>\n<h4 id=\"可恢复性\"><a href=\"#可恢复性\" class=\"headerlink\" title=\"可恢复性\"></a>可恢复性</h4><ul>\n<li><strong>可恢复调度</strong>: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1先于T2提交</li>\n<li><strong>无级联调度</strong>: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1必须在T2这一读操作前提交</li>\n</ul>\n<h4 id=\"事务隔离性级别\"><a href=\"#事务隔离性级别\" class=\"headerlink\" title=\"事务隔离性级别\"></a>事务隔离性级别</h4><ul>\n<li><strong>可串行化</strong>: 通常保证可串行化调度</li>\n<li><strong>可重复读</strong>: 只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据，但该事务不要求与其他事务可串行化</li>\n<li><strong>已提交读</strong>: 只允许读取已提交数据，但不要求可重复读功能</li>\n<li><strong>未提交读</strong>: 允许读未提交数据</li>\n</ul>\n<hr>\n<h3 id=\"并发控制\"><a href=\"#并发控制\" class=\"headerlink\" title=\"并发控制\"></a>并发控制</h3><h4 id=\"基于锁的协议\"><a href=\"#基于锁的协议\" class=\"headerlink\" title=\"基于锁的协议\"></a>基于锁的协议</h4><h5 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h5><ul>\n<li><strong>共享锁（S)</strong>: 如果事务T1获得了数据项Q上的共享型锁（记为S），则T1可读但不能写</li>\n<li><strong>排他锁(X)</strong>: 如果事务T1获得了数据项Q上的排他型锁（记为X），则T1既可读又可写Q</li>\n<li><strong>相容的锁</strong>: 数据项Q上存在B类型锁，如果事务T可以立即获得数据项Q上的A类型锁，则说A类型锁与B类型锁是相容的，即comp(A,B)=true</li>\n</ul>\n<h5 id=\"锁的授予\"><a href=\"#锁的授予\" class=\"headerlink\" title=\"锁的授予\"></a>锁的授予</h5><ul>\n<li><strong>避免饿死</strong>: 可以通过在数据项Q上加M型锁，加锁条件如下：<br>  1.不存在在数据项Q上持有与M型锁冲突的锁的事务<br>  2.不存在等待对数据项Q上先于T申请枷锁的事务</li>\n</ul>\n<h5 id=\"两阶段封锁协议\"><a href=\"#两阶段封锁协议\" class=\"headerlink\" title=\"两阶段封锁协议\"></a>两阶段封锁协议</h5><ul>\n<li><strong>增长阶段</strong>: 事务可以获得锁，但不能释放锁</li>\n<li><strong>缩减阶段</strong>: 事务可以释放锁，但不能获得新锁</li>\n<li><strong>严格两阶段封锁协议</strong>: 事务持有的所有排他锁必须在事务提交后方可释放</li>\n<li><strong>强两阶段封锁协议</strong>: 事务提交之前不得释放任何锁</li>\n</ul>\n<h5 id=\"多粒度\"><a href=\"#多粒度\" class=\"headerlink\" title=\"多粒度\"></a>多粒度</h5><ul>\n<li><strong>多级粒度机制</strong>: 通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大力度数据项中来实现。这种层次结构可以图形化地表示为树</li>\n<li><strong>意向锁</strong>: 如果一个结点佳航了意向锁，则意味着要在树的叫底层进行显式加锁，在一个结点显式加锁前，该结点的的全部祖先结点都加上了意向锁。 这样子可以避免了需要从头遍历结点才能发现子结点已经加锁</li>\n<li><strong>共享意向锁(IS)</strong>: 一个结点加上了共享意向锁，树的较低层进行显式封锁，但只能加共享锁。</li>\n<li><strong>排他意向锁(IX)</strong>: 一个结点加上了排他意向锁，树的较低层进行显式封锁，可以加共享锁或排他锁。</li>\n<li><strong>共享排他意向锁(SIX)</strong>: 一个结点加上了共享排他意向锁，则以该结点为根的子树显式地加上了共享锁，并且将在数的更低层显式地加排他锁。</li>\n<li><strong>各种锁类型相容函数</strong>：<br><img src=\"/images/lock_types_comp.png\" alt=\"各种锁类型相容函数\"></li>\n</ul>\n<h4 id=\"基于时间戳的协议\"><a href=\"#基于时间戳的协议\" class=\"headerlink\" title=\"基于时间戳的协议\"></a>基于时间戳的协议</h4><p>对于系统中的每个事务T，把一个唯一的固定时间戳与他联系起来，此时间戳记为TS(T)。该时间戳是在事务T开始执行前由数据库系统赋予的。实现这种机制可以用以下两种方法：</p>\n<ul>\n<li>使用系统始终的值作为时间戳，即事务的时间戳等于该事务进入系统时的时钟值。</li>\n<li>使用逻辑计数器，没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值。</li>\n</ul>\n<p>每个数据项需要与两个时间戳相关联：</p>\n<ul>\n<li>W-timestamp（Q）表示成功执行write（Q）的所有事务的最大时间戳</li>\n<li>R-timestamp（Q）表示成功执行read（Q）的所有事务的最大时间戳</li>\n</ul>\n<p>协议运作方式如下：<br>1.假设事务T发出read（Q）<br>&emsp; a.若TS（T）&lt; W-timestamp（Q），则T需要读入的Q值已被覆盖。因此read操作被拒绝，T回滚；<br>&emsp; b.若TS（T）&gt;= W-timestamp（Q），则执行read操作，R-timestamp（Q）被设置为R-timestamp（Q）与TS(T)两者的最大值<br>2.假设事务T发出write（Q）<br>&emsp; a.若TS（T）&lt; R-timestamp（Q），则T产生的Q值是先前所需要的值，且系统已假定该值不会在产生，因此write被拒绝，T回滚<br>&emsp; b.若TS（T）&lt; W-timestamp（Q），则T试图写入的Q值已过时，write操作被拒绝，T回滚<br>&emsp; c.其他情况，系统执行write操作，将W-timestamp（Q）设置为TS（T）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"事务的ACID特性\"><a href=\"#事务的ACID特性\" class=\"headerlink\" title=\"事务的ACID特性\"></a>事务的ACID特性</h3><ul>\n<li><p><strong>原子性</strong>: 事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。</p>\n</li>\n<li><p><strong>一致性</strong>: 隔离执行事务时（即不考虑其他事务并发执行）保持数据库的一致性。 在数据库系统中由恢复系统负责。</p>\n</li>\n<li><p><strong>隔离性</strong>: 尽管多个事务可能并发执行，但系统保证对于多个事务，如T1和T2，对于T1来说，T1要么在T2开始之前已经完成执行，要么在T2完成之后开始执行。确保隔离性在数据库系统中由并发控制系统部件负责。</p>\n</li>\n<li><p><strong>持久性</strong>: 一旦事务成功完成后，它对数据库的更新必须是永久的，即使出现系统故障，在数据库系统中由恢复系统负责。 可以通过一下两条中的其中任何一条来确保持久性。</p>\n</li>\n</ul>\n<ol>\n<li>事务做的更新在事务结束前已经给写入磁盘</li>\n<li>有关事务已执行的更新信息已写到磁盘上，并且此类信息必须充分，能让数据库在系统出现故障后重新启动时重新构造更新</li>\n</ol>\n<hr>\n<h3 id=\"事务原子性和持久性\"><a href=\"#事务原子性和持久性\" class=\"headerlink\" title=\"事务原子性和持久性\"></a>事务原子性和持久性</h3><h4 id=\"五种状态\"><a href=\"#五种状态\" class=\"headerlink\" title=\"五种状态\"></a>五种状态</h4><p>可以为事务建立一个简单的抽象事务类型，分为五种状态，事务必须处于以下状态之一</p>\n<ul>\n<li><strong>活动的</strong>： 初始状态，事务正在执行时处于此状态</li>\n<li><strong>部分提交的</strong>： 最后一条语句执行后</li>\n<li><strong>失败的</strong>： 发现正常的执行不能继续后</li>\n<li><strong>中止的</strong>： 事务回滚并且数据库已恢复到事务开始执行前的状态后</li>\n<li><strong>提交的</strong>： 成功完成后</li>\n</ul>\n<p><img src=\"/images/transaction_state.png\" alt=\"事务管理状态\"></p>\n<h4 id=\"中止状态事务回滚的两种选择\"><a href=\"#中止状态事务回滚的两种选择\" class=\"headerlink\" title=\"中止状态事务回滚的两种选择\"></a>中止状态事务回滚的两种选择</h4><ul>\n<li><strong>重启事务</strong>，但仅当引起事务中止的是硬件错误而不是有事务内部逻辑所产生的软件错误。</li>\n<li><strong>杀死事务</strong>, 这样做通常是由于事务内部逻辑造成的错误，只有重写应用程序才能改正</li>\n</ul>\n<hr>\n<h3 id=\"事务隔离性\"><a href=\"#事务隔离性\" class=\"headerlink\" title=\"事务隔离性\"></a>事务隔离性</h3><h4 id=\"可串行化调度\"><a href=\"#可串行化调度\" class=\"headerlink\" title=\"可串行化调度\"></a>可串行化调度</h4><ul>\n<li><strong>冲突</strong>: 假设I和J是不同事务在在相同数据项上的操作，并且其中至少有一个是write指令时，I与J是冲突的</li>\n<li><strong>冲突等价</strong>: 调度S经过一系列非冲突指令交换转换成S’，S与S’冲突等价</li>\n<li><strong>冲突可串行化</strong>: 一个调度S与另一个串行调度冲突等价，则称调度S是冲突可串行化的</li>\n</ul>\n<h4 id=\"可恢复性\"><a href=\"#可恢复性\" class=\"headerlink\" title=\"可恢复性\"></a>可恢复性</h4><ul>\n<li><strong>可恢复调度</strong>: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1先于T2提交</li>\n<li><strong>无级联调度</strong>: 对于每对事务T1和T2，如果T2读取了之前由T1所写的数据项，则T1必须在T2这一读操作前提交</li>\n</ul>\n<h4 id=\"事务隔离性级别\"><a href=\"#事务隔离性级别\" class=\"headerlink\" title=\"事务隔离性级别\"></a>事务隔离性级别</h4><ul>\n<li><strong>可串行化</strong>: 通常保证可串行化调度</li>\n<li><strong>可重复读</strong>: 只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据，但该事务不要求与其他事务可串行化</li>\n<li><strong>已提交读</strong>: 只允许读取已提交数据，但不要求可重复读功能</li>\n<li><strong>未提交读</strong>: 允许读未提交数据</li>\n</ul>\n<hr>\n<h3 id=\"并发控制\"><a href=\"#并发控制\" class=\"headerlink\" title=\"并发控制\"></a>并发控制</h3><h4 id=\"基于锁的协议\"><a href=\"#基于锁的协议\" class=\"headerlink\" title=\"基于锁的协议\"></a>基于锁的协议</h4><h5 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h5><ul>\n<li><strong>共享锁（S)</strong>: 如果事务T1获得了数据项Q上的共享型锁（记为S），则T1可读但不能写</li>\n<li><strong>排他锁(X)</strong>: 如果事务T1获得了数据项Q上的排他型锁（记为X），则T1既可读又可写Q</li>\n<li><strong>相容的锁</strong>: 数据项Q上存在B类型锁，如果事务T可以立即获得数据项Q上的A类型锁，则说A类型锁与B类型锁是相容的，即comp(A,B)=true</li>\n</ul>\n<h5 id=\"锁的授予\"><a href=\"#锁的授予\" class=\"headerlink\" title=\"锁的授予\"></a>锁的授予</h5><ul>\n<li><strong>避免饿死</strong>: 可以通过在数据项Q上加M型锁，加锁条件如下：<br>  1.不存在在数据项Q上持有与M型锁冲突的锁的事务<br>  2.不存在等待对数据项Q上先于T申请枷锁的事务</li>\n</ul>\n<h5 id=\"两阶段封锁协议\"><a href=\"#两阶段封锁协议\" class=\"headerlink\" title=\"两阶段封锁协议\"></a>两阶段封锁协议</h5><ul>\n<li><strong>增长阶段</strong>: 事务可以获得锁，但不能释放锁</li>\n<li><strong>缩减阶段</strong>: 事务可以释放锁，但不能获得新锁</li>\n<li><strong>严格两阶段封锁协议</strong>: 事务持有的所有排他锁必须在事务提交后方可释放</li>\n<li><strong>强两阶段封锁协议</strong>: 事务提交之前不得释放任何锁</li>\n</ul>\n<h5 id=\"多粒度\"><a href=\"#多粒度\" class=\"headerlink\" title=\"多粒度\"></a>多粒度</h5><ul>\n<li><strong>多级粒度机制</strong>: 通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大力度数据项中来实现。这种层次结构可以图形化地表示为树</li>\n<li><strong>意向锁</strong>: 如果一个结点佳航了意向锁，则意味着要在树的叫底层进行显式加锁，在一个结点显式加锁前，该结点的的全部祖先结点都加上了意向锁。 这样子可以避免了需要从头遍历结点才能发现子结点已经加锁</li>\n<li><strong>共享意向锁(IS)</strong>: 一个结点加上了共享意向锁，树的较低层进行显式封锁，但只能加共享锁。</li>\n<li><strong>排他意向锁(IX)</strong>: 一个结点加上了排他意向锁，树的较低层进行显式封锁，可以加共享锁或排他锁。</li>\n<li><strong>共享排他意向锁(SIX)</strong>: 一个结点加上了共享排他意向锁，则以该结点为根的子树显式地加上了共享锁，并且将在数的更低层显式地加排他锁。</li>\n<li><strong>各种锁类型相容函数</strong>：<br><img src=\"/images/lock_types_comp.png\" alt=\"各种锁类型相容函数\"></li>\n</ul>\n<h4 id=\"基于时间戳的协议\"><a href=\"#基于时间戳的协议\" class=\"headerlink\" title=\"基于时间戳的协议\"></a>基于时间戳的协议</h4><p>对于系统中的每个事务T，把一个唯一的固定时间戳与他联系起来，此时间戳记为TS(T)。该时间戳是在事务T开始执行前由数据库系统赋予的。实现这种机制可以用以下两种方法：</p>\n<ul>\n<li>使用系统始终的值作为时间戳，即事务的时间戳等于该事务进入系统时的时钟值。</li>\n<li>使用逻辑计数器，没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值。</li>\n</ul>\n<p>每个数据项需要与两个时间戳相关联：</p>\n<ul>\n<li>W-timestamp（Q）表示成功执行write（Q）的所有事务的最大时间戳</li>\n<li>R-timestamp（Q）表示成功执行read（Q）的所有事务的最大时间戳</li>\n</ul>\n<p>协议运作方式如下：<br>1.假设事务T发出read（Q）<br>&emsp; a.若TS（T）&lt; W-timestamp（Q），则T需要读入的Q值已被覆盖。因此read操作被拒绝，T回滚；<br>&emsp; b.若TS（T）&gt;= W-timestamp（Q），则执行read操作，R-timestamp（Q）被设置为R-timestamp（Q）与TS(T)两者的最大值<br>2.假设事务T发出write（Q）<br>&emsp; a.若TS（T）&lt; R-timestamp（Q），则T产生的Q值是先前所需要的值，且系统已假定该值不会在产生，因此write被拒绝，T回滚<br>&emsp; b.若TS（T）&lt; W-timestamp（Q），则T试图写入的Q值已过时，write操作被拒绝，T回滚<br>&emsp; c.其他情况，系统执行write操作，将W-timestamp（Q）设置为TS（T）。</p>\n"},{"title":"vim的使用","date":"2018-04-30T11:42:21.000Z","_content":"### 一、一般模式：光标的移动、复制粘贴、搜索替换\n#### 移动光标： \n** 向左移动一个字符：h 或 ← **\n** 向右移动一个字符：l 或 → **\n** 向上移动一个字符：k 或 ↑ **\n** 向下移动一个字符：j 或 ↓ **\n向左移动n个字符：n + h（其他同理)，如10h\n向右移动这一行的n个字符(会换到下一行)：n + space,如20space\n屏幕向上移动一页：Ctrl + b\n屏幕向下移动一页：Ctrl + f\n屏幕向上移动半页：Ctrl + u\n屏幕向下移动半页：Ctrl + d\n移动到非空格的下一行：+\n移动到非空格的上一行：-\n移动到屏幕最上方那一行的第一个字符：H\n移动到屏幕最中间那一行的第一个字符：M\n移动到屏幕最下方那一行的第一个字符：L\n** 移动到这个文件的最后一行：G **\n移动到这个文件的第n行：nG\n** 移动到这个文件的第一行:gg **\n** 向下移动n行：n + enter,如10enter **\n> 加粗部分为常用，以下同理\n\n#### 搜索替换：\n** 向光标往下搜索一个word的字符串：/word **\n** 向光标往上搜索一个word的字符串：?word **\n** 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 **\n** 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g **\n** 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g **\n** 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc **\n\n#### 删除\n** 向前（后）删除一个字符：x(X)，相当于backspace **\n** 连续向后删除n个字符： nx,如10x **\n** 删除光标所在的一整行：dd **\n** 删除光标所在的向下n行：ndd **\n删除光标所在到第一行的所有数据：d1G\n输出光标所在到最后一行的所有数据:dG\n删除光标所在到该行最后一个字符：d$\n删除光标所在到该行第一个字符：d0\n\n#### 复制\n** 复制光标所在的那一行：yy **\n** 复制光标所在的向下n行：nyy **\n复制光标所在行到第一行的所有数据：y1G\n复制光标所在行到最后一行的所有数据:yG\n复制光标所在到该行最后一个字符：y$\n复制光标所在到该行第一个字符：y0\n\n#### 粘贴\n** 将已复制的数据在光标下（上）一行贴上：p(P); **\n** 将光标所在行与 下一行的数据结合成一行： J **\n重复删除多个数据:c，如向下删除10行：10cj\n** 复原前一个动作：u **\n** 重复上一个动作：Ctrl + r **\n\n### 二、一般模式到编辑模式的切换\n#### 进去输入模式\n- i/I\n** 从目前光标所在处输入：i **\n** 从目前所在行的第一个非空格符处开始输入：I **\n\n- a/A\n从目前光标所在的下一个字符处开始输入:a\n从光标所在行的最后一个字符处开始输入:A\n\n- o/O\n** 在光标所在的下一行输入新的一行：o **\n** 在光标所在的上一行输入新的一行：O **\n\n#### 进入取代模式\n- r/R\n** 取代光标所在的那一个字符一次：r **\n** 一直取代光标所在的字符，直到按esc **\n\n\n### 三、一般模式到命令行模式的切换\n#### 指令行的存储、离开等\n** 保存编辑： :w **\n** 强制写入： :w! **\n** 退出： :q **\n** 强制退出，不保存修改： :q! **\n** 保存修改后退出： :wq **\n** 将修改后的数据另存为一个文件： :w filename **\n在当前编辑的数据中，读入另一个文件的数据： :r filename \n将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename\n** \t暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 **\n\n#### vim环境的变更\n显示行号： :set nu\n取消显示行号： :set nonu","source":"_posts/vim的使用.md","raw":"---\ntitle: vim的使用\ndate: 2018-04-30 19:42:21\ncategories: \"编辑器\"\ntags:\n\t- vim\n---\n### 一、一般模式：光标的移动、复制粘贴、搜索替换\n#### 移动光标： \n** 向左移动一个字符：h 或 ← **\n** 向右移动一个字符：l 或 → **\n** 向上移动一个字符：k 或 ↑ **\n** 向下移动一个字符：j 或 ↓ **\n向左移动n个字符：n + h（其他同理)，如10h\n向右移动这一行的n个字符(会换到下一行)：n + space,如20space\n屏幕向上移动一页：Ctrl + b\n屏幕向下移动一页：Ctrl + f\n屏幕向上移动半页：Ctrl + u\n屏幕向下移动半页：Ctrl + d\n移动到非空格的下一行：+\n移动到非空格的上一行：-\n移动到屏幕最上方那一行的第一个字符：H\n移动到屏幕最中间那一行的第一个字符：M\n移动到屏幕最下方那一行的第一个字符：L\n** 移动到这个文件的最后一行：G **\n移动到这个文件的第n行：nG\n** 移动到这个文件的第一行:gg **\n** 向下移动n行：n + enter,如10enter **\n> 加粗部分为常用，以下同理\n\n#### 搜索替换：\n** 向光标往下搜索一个word的字符串：/word **\n** 向光标往上搜索一个word的字符串：?word **\n** 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 **\n** 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g **\n** 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g **\n** 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc **\n\n#### 删除\n** 向前（后）删除一个字符：x(X)，相当于backspace **\n** 连续向后删除n个字符： nx,如10x **\n** 删除光标所在的一整行：dd **\n** 删除光标所在的向下n行：ndd **\n删除光标所在到第一行的所有数据：d1G\n输出光标所在到最后一行的所有数据:dG\n删除光标所在到该行最后一个字符：d$\n删除光标所在到该行第一个字符：d0\n\n#### 复制\n** 复制光标所在的那一行：yy **\n** 复制光标所在的向下n行：nyy **\n复制光标所在行到第一行的所有数据：y1G\n复制光标所在行到最后一行的所有数据:yG\n复制光标所在到该行最后一个字符：y$\n复制光标所在到该行第一个字符：y0\n\n#### 粘贴\n** 将已复制的数据在光标下（上）一行贴上：p(P); **\n** 将光标所在行与 下一行的数据结合成一行： J **\n重复删除多个数据:c，如向下删除10行：10cj\n** 复原前一个动作：u **\n** 重复上一个动作：Ctrl + r **\n\n### 二、一般模式到编辑模式的切换\n#### 进去输入模式\n- i/I\n** 从目前光标所在处输入：i **\n** 从目前所在行的第一个非空格符处开始输入：I **\n\n- a/A\n从目前光标所在的下一个字符处开始输入:a\n从光标所在行的最后一个字符处开始输入:A\n\n- o/O\n** 在光标所在的下一行输入新的一行：o **\n** 在光标所在的上一行输入新的一行：O **\n\n#### 进入取代模式\n- r/R\n** 取代光标所在的那一个字符一次：r **\n** 一直取代光标所在的字符，直到按esc **\n\n\n### 三、一般模式到命令行模式的切换\n#### 指令行的存储、离开等\n** 保存编辑： :w **\n** 强制写入： :w! **\n** 退出： :q **\n** 强制退出，不保存修改： :q! **\n** 保存修改后退出： :wq **\n** 将修改后的数据另存为一个文件： :w filename **\n在当前编辑的数据中，读入另一个文件的数据： :r filename \n将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename\n** \t暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 **\n\n#### vim环境的变更\n显示行号： :set nu\n取消显示行号： :set nonu","slug":"vim的使用","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdt002du7yj6jzifi0z","content":"<h3 id=\"一、一般模式：光标的移动、复制粘贴、搜索替换\"><a href=\"#一、一般模式：光标的移动、复制粘贴、搜索替换\" class=\"headerlink\" title=\"一、一般模式：光标的移动、复制粘贴、搜索替换\"></a>一、一般模式：光标的移动、复制粘贴、搜索替换</h3><h4 id=\"移动光标：\"><a href=\"#移动光标：\" class=\"headerlink\" title=\"移动光标：\"></a>移动光标：</h4><p><strong> 向左移动一个字符：h 或 ← </strong><br><strong> 向右移动一个字符：l 或 → </strong><br><strong> 向上移动一个字符：k 或 ↑ </strong><br><strong> 向下移动一个字符：j 或 ↓ </strong><br>向左移动n个字符：n + h（其他同理)，如10h<br>向右移动这一行的n个字符(会换到下一行)：n + space,如20space<br>屏幕向上移动一页：Ctrl + b<br>屏幕向下移动一页：Ctrl + f<br>屏幕向上移动半页：Ctrl + u<br>屏幕向下移动半页：Ctrl + d<br>移动到非空格的下一行：+<br>移动到非空格的上一行：-<br>移动到屏幕最上方那一行的第一个字符：H<br>移动到屏幕最中间那一行的第一个字符：M<br>移动到屏幕最下方那一行的第一个字符：L<br><strong> 移动到这个文件的最后一行：G </strong><br>移动到这个文件的第n行：nG<br><strong> 移动到这个文件的第一行:gg </strong><br><strong> 向下移动n行：n + enter,如10enter </strong></p>\n<blockquote>\n<p>加粗部分为常用，以下同理</p>\n</blockquote>\n<h4 id=\"搜索替换：\"><a href=\"#搜索替换：\" class=\"headerlink\" title=\"搜索替换：\"></a>搜索替换：</h4><p><strong> 向光标往下搜索一个word的字符串：/word </strong><br><strong> 向光标往上搜索一个word的字符串：?word </strong><br><strong> 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 </strong><br><strong> 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g </strong><br><strong> 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g </strong><br><strong> 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc </strong></p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p><strong> 向前（后）删除一个字符：x(X)，相当于backspace </strong><br><strong> 连续向后删除n个字符： nx,如10x </strong><br><strong> 删除光标所在的一整行：dd </strong><br><strong> 删除光标所在的向下n行：ndd </strong><br>删除光标所在到第一行的所有数据：d1G<br>输出光标所在到最后一行的所有数据:dG<br>删除光标所在到该行最后一个字符：d$<br>删除光标所在到该行第一个字符：d0</p>\n<h4 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h4><p><strong> 复制光标所在的那一行：yy </strong><br><strong> 复制光标所在的向下n行：nyy </strong><br>复制光标所在行到第一行的所有数据：y1G<br>复制光标所在行到最后一行的所有数据:yG<br>复制光标所在到该行最后一个字符：y$<br>复制光标所在到该行第一个字符：y0</p>\n<h4 id=\"粘贴\"><a href=\"#粘贴\" class=\"headerlink\" title=\"粘贴\"></a>粘贴</h4><p><strong> 将已复制的数据在光标下（上）一行贴上：p(P); </strong><br><strong> 将光标所在行与 下一行的数据结合成一行： J </strong><br>重复删除多个数据:c，如向下删除10行：10cj<br><strong> 复原前一个动作：u </strong><br><strong> 重复上一个动作：Ctrl + r </strong></p>\n<h3 id=\"二、一般模式到编辑模式的切换\"><a href=\"#二、一般模式到编辑模式的切换\" class=\"headerlink\" title=\"二、一般模式到编辑模式的切换\"></a>二、一般模式到编辑模式的切换</h3><h4 id=\"进去输入模式\"><a href=\"#进去输入模式\" class=\"headerlink\" title=\"进去输入模式\"></a>进去输入模式</h4><ul>\n<li><p>i/I<br><strong> 从目前光标所在处输入：i </strong><br><strong> 从目前所在行的第一个非空格符处开始输入：I </strong></p>\n</li>\n<li><p>a/A<br>从目前光标所在的下一个字符处开始输入:a<br>从光标所在行的最后一个字符处开始输入:A</p>\n</li>\n<li><p>o/O<br><strong> 在光标所在的下一行输入新的一行：o </strong><br><strong> 在光标所在的上一行输入新的一行：O </strong></p>\n</li>\n</ul>\n<h4 id=\"进入取代模式\"><a href=\"#进入取代模式\" class=\"headerlink\" title=\"进入取代模式\"></a>进入取代模式</h4><ul>\n<li>r/R<br><strong> 取代光标所在的那一个字符一次：r </strong><br><strong> 一直取代光标所在的字符，直到按esc </strong></li>\n</ul>\n<h3 id=\"三、一般模式到命令行模式的切换\"><a href=\"#三、一般模式到命令行模式的切换\" class=\"headerlink\" title=\"三、一般模式到命令行模式的切换\"></a>三、一般模式到命令行模式的切换</h3><h4 id=\"指令行的存储、离开等\"><a href=\"#指令行的存储、离开等\" class=\"headerlink\" title=\"指令行的存储、离开等\"></a>指令行的存储、离开等</h4><p><strong> 保存编辑： :w </strong><br><strong> 强制写入： :w! </strong><br><strong> 退出： :q </strong><br><strong> 强制退出，不保存修改： :q! </strong><br><strong> 保存修改后退出： :wq </strong><br><strong> 将修改后的数据另存为一个文件： :w filename </strong><br>在当前编辑的数据中，读入另一个文件的数据： :r filename<br>将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename<br><strong>     暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 </strong></p>\n<h4 id=\"vim环境的变更\"><a href=\"#vim环境的变更\" class=\"headerlink\" title=\"vim环境的变更\"></a>vim环境的变更</h4><p>显示行号： :set nu<br>取消显示行号： :set nonu</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、一般模式：光标的移动、复制粘贴、搜索替换\"><a href=\"#一、一般模式：光标的移动、复制粘贴、搜索替换\" class=\"headerlink\" title=\"一、一般模式：光标的移动、复制粘贴、搜索替换\"></a>一、一般模式：光标的移动、复制粘贴、搜索替换</h3><h4 id=\"移动光标：\"><a href=\"#移动光标：\" class=\"headerlink\" title=\"移动光标：\"></a>移动光标：</h4><p><strong> 向左移动一个字符：h 或 ← </strong><br><strong> 向右移动一个字符：l 或 → </strong><br><strong> 向上移动一个字符：k 或 ↑ </strong><br><strong> 向下移动一个字符：j 或 ↓ </strong><br>向左移动n个字符：n + h（其他同理)，如10h<br>向右移动这一行的n个字符(会换到下一行)：n + space,如20space<br>屏幕向上移动一页：Ctrl + b<br>屏幕向下移动一页：Ctrl + f<br>屏幕向上移动半页：Ctrl + u<br>屏幕向下移动半页：Ctrl + d<br>移动到非空格的下一行：+<br>移动到非空格的上一行：-<br>移动到屏幕最上方那一行的第一个字符：H<br>移动到屏幕最中间那一行的第一个字符：M<br>移动到屏幕最下方那一行的第一个字符：L<br><strong> 移动到这个文件的最后一行：G </strong><br>移动到这个文件的第n行：nG<br><strong> 移动到这个文件的第一行:gg </strong><br><strong> 向下移动n行：n + enter,如10enter </strong></p>\n<blockquote>\n<p>加粗部分为常用，以下同理</p>\n</blockquote>\n<h4 id=\"搜索替换：\"><a href=\"#搜索替换：\" class=\"headerlink\" title=\"搜索替换：\"></a>搜索替换：</h4><p><strong> 向光标往下搜索一个word的字符串：/word </strong><br><strong> 向光标往上搜索一个word的字符串：?word </strong><br><strong> 重复前一个搜寻动作 ，如果刚刚我们执行 /word 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 word 的字符串。如果是？word的话就向上搜寻。按下N则反向 </strong><br><strong> 在第n1行与第n2行之间寻找word1这个字符串，并将给字符串取代为word2:n1,n2s/word1/word2/g, 如:10,100s/word/WORD/g </strong><br><strong> 从第1行到最后一行寻找word1字符串，取代为word2: :1,$s/word1/word2/g </strong><br><strong> 从第1行到最后一行寻找word1字符串，取代为word2，取代前提示用户确认（confirm）是否需要取代: :1,$s/word1/word2/gc </strong></p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p><strong> 向前（后）删除一个字符：x(X)，相当于backspace </strong><br><strong> 连续向后删除n个字符： nx,如10x </strong><br><strong> 删除光标所在的一整行：dd </strong><br><strong> 删除光标所在的向下n行：ndd </strong><br>删除光标所在到第一行的所有数据：d1G<br>输出光标所在到最后一行的所有数据:dG<br>删除光标所在到该行最后一个字符：d$<br>删除光标所在到该行第一个字符：d0</p>\n<h4 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h4><p><strong> 复制光标所在的那一行：yy </strong><br><strong> 复制光标所在的向下n行：nyy </strong><br>复制光标所在行到第一行的所有数据：y1G<br>复制光标所在行到最后一行的所有数据:yG<br>复制光标所在到该行最后一个字符：y$<br>复制光标所在到该行第一个字符：y0</p>\n<h4 id=\"粘贴\"><a href=\"#粘贴\" class=\"headerlink\" title=\"粘贴\"></a>粘贴</h4><p><strong> 将已复制的数据在光标下（上）一行贴上：p(P); </strong><br><strong> 将光标所在行与 下一行的数据结合成一行： J </strong><br>重复删除多个数据:c，如向下删除10行：10cj<br><strong> 复原前一个动作：u </strong><br><strong> 重复上一个动作：Ctrl + r </strong></p>\n<h3 id=\"二、一般模式到编辑模式的切换\"><a href=\"#二、一般模式到编辑模式的切换\" class=\"headerlink\" title=\"二、一般模式到编辑模式的切换\"></a>二、一般模式到编辑模式的切换</h3><h4 id=\"进去输入模式\"><a href=\"#进去输入模式\" class=\"headerlink\" title=\"进去输入模式\"></a>进去输入模式</h4><ul>\n<li><p>i/I<br><strong> 从目前光标所在处输入：i </strong><br><strong> 从目前所在行的第一个非空格符处开始输入：I </strong></p>\n</li>\n<li><p>a/A<br>从目前光标所在的下一个字符处开始输入:a<br>从光标所在行的最后一个字符处开始输入:A</p>\n</li>\n<li><p>o/O<br><strong> 在光标所在的下一行输入新的一行：o </strong><br><strong> 在光标所在的上一行输入新的一行：O </strong></p>\n</li>\n</ul>\n<h4 id=\"进入取代模式\"><a href=\"#进入取代模式\" class=\"headerlink\" title=\"进入取代模式\"></a>进入取代模式</h4><ul>\n<li>r/R<br><strong> 取代光标所在的那一个字符一次：r </strong><br><strong> 一直取代光标所在的字符，直到按esc </strong></li>\n</ul>\n<h3 id=\"三、一般模式到命令行模式的切换\"><a href=\"#三、一般模式到命令行模式的切换\" class=\"headerlink\" title=\"三、一般模式到命令行模式的切换\"></a>三、一般模式到命令行模式的切换</h3><h4 id=\"指令行的存储、离开等\"><a href=\"#指令行的存储、离开等\" class=\"headerlink\" title=\"指令行的存储、离开等\"></a>指令行的存储、离开等</h4><p><strong> 保存编辑： :w </strong><br><strong> 强制写入： :w! </strong><br><strong> 退出： :q </strong><br><strong> 强制退出，不保存修改： :q! </strong><br><strong> 保存修改后退出： :wq </strong><br><strong> 将修改后的数据另存为一个文件： :w filename </strong><br>在当前编辑的数据中，读入另一个文件的数据： :r filename<br>将n1到n2的内容存储成另一个文件filename: :n1,n2 w filename<br><strong>     暂时离开 vi 到指令行模式下执行 command 的显示结果： :!command ;例如:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的文件信息 </strong></p>\n<h4 id=\"vim环境的变更\"><a href=\"#vim环境的变更\" class=\"headerlink\" title=\"vim环境的变更\"></a>vim环境的变更</h4><p>显示行号： :set nu<br>取消显示行号： :set nonu</p>\n"},{"title":"Java中的锁优化","date":"2018-11-12T12:08:20.000Z","copyright":null,"_content":"\n- **自旋锁**: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁\n> 自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统方式挂起线程\n- **自旋适应锁**: 自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。\n> 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且尺有所 的线程正在运行中，那么自旋等待时间将会持续相对更长；如果对于某个锁，自旋很少成功获得过，拿在以后要获取这个锁时将可能省略掉自旋过程\n\n- **锁消除**: 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不存在共享数据竞争的锁进行消除\n\n- **锁粗化**: 虚拟机探测到有一串零碎的操作对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，例如：\n``` java\n    public String concatString(String s1, String s2, String s3) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(s1);\n        sb.append(s2);\n        sb.append(s3);\n        return sb.tostring();\n    }\n```\n> 这里原先每次append操作都需要加一次锁，而虚拟机会扩展到第一个append操作之前到最后一个append操作之后，就只需要加一次锁\n\n- **轻量级锁**: 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制称为“重量级”锁\n> 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。\n\n- **偏向锁**: 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即在无精准的情况下把整个同步都消除掉\n","source":"_posts/深入理解Java虚拟机之Java中的锁优化.md","raw":"---\ntitle: Java中的锁优化\ndate: 2018-11-12 20:08:20\ncategories: \"深入理解java虚拟机笔记\"\ntags:\n    - JVM\n    - 多线程\ncopyright:\n---\n\n- **自旋锁**: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁\n> 自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统方式挂起线程\n- **自旋适应锁**: 自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。\n> 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且尺有所 的线程正在运行中，那么自旋等待时间将会持续相对更长；如果对于某个锁，自旋很少成功获得过，拿在以后要获取这个锁时将可能省略掉自旋过程\n\n- **锁消除**: 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不存在共享数据竞争的锁进行消除\n\n- **锁粗化**: 虚拟机探测到有一串零碎的操作对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，例如：\n``` java\n    public String concatString(String s1, String s2, String s3) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(s1);\n        sb.append(s2);\n        sb.append(s3);\n        return sb.tostring();\n    }\n```\n> 这里原先每次append操作都需要加一次锁，而虚拟机会扩展到第一个append操作之前到最后一个append操作之后，就只需要加一次锁\n\n- **轻量级锁**: 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制称为“重量级”锁\n> 轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。\n\n- **偏向锁**: 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即在无精准的情况下把整个同步都消除掉\n","slug":"深入理解Java虚拟机之Java中的锁优化","published":1,"updated":"2018-12-07T13:18:53.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdu002gu7yjrvtzm8vi","content":"<ul>\n<li><strong>自旋锁</strong>: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁<blockquote>\n<p>自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统方式挂起线程</p>\n</blockquote>\n</li>\n<li><p><strong>自旋适应锁</strong>: 自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>\n<blockquote>\n<p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且尺有所 的线程正在运行中，那么自旋等待时间将会持续相对更长；如果对于某个锁，自旋很少成功获得过，拿在以后要获取这个锁时将可能省略掉自旋过程</p>\n</blockquote>\n</li>\n<li><p><strong>锁消除</strong>: 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不存在共享数据竞争的锁进行消除</p>\n</li>\n<li><p><strong>锁粗化</strong>: 虚拟机探测到有一串零碎的操作对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concatString</span><span class=\"params\">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class=\"line\">    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    sb.append(s3);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.tostring();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>这里原先每次append操作都需要加一次锁，而虚拟机会扩展到第一个append操作之前到最后一个append操作之后，就只需要加一次锁</p>\n</blockquote>\n<ul>\n<li><p><strong>轻量级锁</strong>: 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制称为“重量级”锁</p>\n<blockquote>\n<p>轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。</p>\n</blockquote>\n</li>\n<li><p><strong>偏向锁</strong>: 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即在无精准的情况下把整个同步都消除掉</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><strong>自旋锁</strong>: 让请求锁的线程执行一个忙循环（自旋），不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁<blockquote>\n<p>自选等待时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统方式挂起线程</p>\n</blockquote>\n</li>\n<li><p><strong>自旋适应锁</strong>: 自旋的时间不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>\n<blockquote>\n<p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且尺有所 的线程正在运行中，那么自旋等待时间将会持续相对更长；如果对于某个锁，自旋很少成功获得过，拿在以后要获取这个锁时将可能省略掉自旋过程</p>\n</blockquote>\n</li>\n<li><p><strong>锁消除</strong>: 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不存在共享数据竞争的锁进行消除</p>\n</li>\n<li><p><strong>锁粗化</strong>: 虚拟机探测到有一串零碎的操作对同一对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concatString</span><span class=\"params\">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class=\"line\">    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    sb.append(s3);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.tostring();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>这里原先每次append操作都需要加一次锁，而虚拟机会扩展到第一个append操作之前到最后一个append操作之后，就只需要加一次锁</p>\n</blockquote>\n<ul>\n<li><p><strong>轻量级锁</strong>: 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统的锁机制称为“重量级”锁</p>\n<blockquote>\n<p>轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁产生的性能消耗。</p>\n</blockquote>\n</li>\n<li><p><strong>偏向锁</strong>: 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，即在无精准的情况下把整个同步都消除掉</p>\n</li>\n</ul>\n"},{"title":"java io流与文件","date":"2018-07-18T22:27:55.000Z","_content":"### 一、流 \n**读写字节**\n`InputStream.read和OutpueStream.write`\n**组合流过滤器**\n\n- 某些流（如`FileInputStream`或者`FileOutputStream`）只能支持在字节级别上的读写，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如：\t\n\n``` java\nFileInputStream fin = new FileInputStream(\"test.txt\");\nDataInputStream din = new DataInputStream(fin);\ndouble s = din.readDouble();\n```\n\n- 需要使用缓冲，可以使用一下构造器：\n\n```java\nDataInputStream din = new DataInputStream(\n\tnew BUfferInputStream(\n\t\tnew FileInputStream(test.txt\")));\n```\n\n- 需要浏览下一个字节以确定是否是想要的值时，可以：\n\n```java\nPushbackInputStream pbin = new PushbackInputStream(\n\tnew BUfferInputStream(\n\t\tnew FileInputStream(test.txt\")));\n//预读写一个字节\nint b = pbin.read();\n//不是所期望时将其推回流中\nif(b != '<') pbin.unead(b);\n```\n----\n### 二、文本输入与输出\n**输出：`PrintWrite`**\n`PrintWrite out = new PrintWrite(\"test.txt\");`等同于`PrintWrite out = new PrintWrite(new FileWrite(\"test.txt\"));`\n**输入：`Scanner`**\n**文本格式存储对象**\n用自己的格式依次存储各个字段，以特定字符分隔，如：`PINUULI|201625010417|1997|guangdong`\n\n----\n\n### 三、读写二进制数据\n**读**：实现`DataInput`接口，如`DataInputStream，readInt，readBoolean`等方法\n**写**：实现`DataOutpu`t接口，如`DataOutputStream，writeInt，writeBoolean`等方法\n**随机访问文件**：`RandomAccessFile`\n可以在文件中的任何位置查找或者写入数据：\n```java\nRandomAccessFile in = new RandomAccessFile(\"test.txt\",\"r\");\nRandomAccessFile inOut = new RandomAccessFile(\"test.txt\",\"rw\");\n```\n----\n### 四、ZIP文件\n每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。\n**读**：`ZipInputStream`\n- 用`getNextEntry`方法返回文档中这些项（文件）的`ZipEntry`对象\n- ` ZipInputStream`的`read`方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用`closeEntry`读入下一项\n- 在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项\n- 通读zip文件：\n\n``` java\nZipInputStream zin = new ZipInputStream(new FileInputStream(\"test.zip\"));\nZipEntry entry;\nScanner in = new Scanner(zin);\nwhile((entry = zin.getNextEntry()) != null){\n\twhile(in.hasNextLine()){\n\t\tSystem.out.println(in.nextLine());\n\t}\n\tzin.closeEntry();\n}\n```\n\n**写**：`ZipOutputStream`\n- 对于想要放入到zip文件中的每一个项，都应该创建一个`ZipEntry`对象，并将文件名传递给ZipEntry的构造器\n- 调用`ZipOutputStream`的`putNextEntry`方法开始写出新文件，并将数据发送到zip流中\n- 完成时调用`closeEntry`方法,如：\n\n```java\nFileOutputStream fout = new FilePutputStream(\"test.zip\");\nZipOutputStream zout = new ZipOutputStream(fout);\n\n// 写一个文件\nZipEntry ze = new ZipEntry(\"filename\");\nzout.putNextENtry(ze);\nsend data to zout;\nzout.closeEntry();\n\nzout.close();\n```\n----\n### 五、对象流与序列化\n- 序列化:`ObjectOutputStream.writeObject()`,\n- 反序列化：`ObjectInputream.readObject()`，\n- 都需要实现`Serializable`接口\n- 只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等\n- 序列化算法：\n\t- 对于遇到的每个对象都关联一个序列号\n\t- 对于每个对象，第一次遇到时，保存其对象数据到流中\n\t- 如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反\n\t- 对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联\n\t- 当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用\n- 修改默认的序列化机制\n\n> 一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。\n可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。\n\n当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现`Serializable`接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如：\n\t\t\n```java\npublic class LabeledPoint implements Serializable{\n\tprivate String label;\n\n\t//对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标\n\tprivate transient Point2D.Double point;\n\t···\n\t//重写读写方法\n\tprivate void writeObject(ObjectOutputStream out) throws Exception{\n\t\tout.defaultWriteObjecy();\n\t\tout.writeDouble(point.getX());\n\t\tout.writeDouble(point.getY());\n\t}\n\n\tprivate void readObject(ObjectInputStream in) throws IOException{\n\t\tin.defaultReadObject();\n\t\tdouble x = in.readDouble();\n\t\tdouble y = in.readDouble();\n\t\tpoint = new Point2D.DOuble(x,y);\n\t}\n}\n```\n\t\t\n当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现`Externalizable`接口，指定要保存的域\n\n```java\npublic class Student implements Externalizable{\n\tprivate String name;\n\tprivate String stuId;\n\tprivate int age;\n\t···\n\t//重写读写方法\n\tprivate void writeExternal(ObjectOutput out) throws IOException{\n\t\tout.writeUTF(name);\n\t\tout.writeInt(age);\n\t}\n\n\tprivate void readExternal(ObjectInput in) throws IOException{\n\t\tname = in.readUTF():\n\t\tage = in.readInt();\n\t}\n}\n```\n\t> PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。\n\n----\n### 六、操作文件\n**Path**\n- 静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\\）连接起来，返回一个Path对象，详情见API。如\n\n```java\nPath absolutye = Paths.get(\"/home\".\"cay\");\nPath relative = Paths.get(\"myprog\",\"conf\",\"user.properties\");\n```\n**读写文件**：Files类可以使得普通文件操作变得快捷\n- 读取文件所有内容：`byte[] bytes = Files.readAllBytes(path);`,之后可以将其当做字符串`String content = new String(bytes,charset);`\n- 向指定文件追加内容：`Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND);`\n\n\n> 参阅：\n  [慕课网：文件传输基础——Java IO流](https://www.imooc.com/learn/123)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)\n","source":"_posts/java-io流与文件.md","raw":"---\ntitle: java io流与文件\ndate: 2018-07-19 06:27:55\ncategories: \"JavaSE笔记\" \ntags:\n\t- JavaSE\n---\n### 一、流 \n**读写字节**\n`InputStream.read和OutpueStream.write`\n**组合流过滤器**\n\n- 某些流（如`FileInputStream`或者`FileOutputStream`）只能支持在字节级别上的读写，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如：\t\n\n``` java\nFileInputStream fin = new FileInputStream(\"test.txt\");\nDataInputStream din = new DataInputStream(fin);\ndouble s = din.readDouble();\n```\n\n- 需要使用缓冲，可以使用一下构造器：\n\n```java\nDataInputStream din = new DataInputStream(\n\tnew BUfferInputStream(\n\t\tnew FileInputStream(test.txt\")));\n```\n\n- 需要浏览下一个字节以确定是否是想要的值时，可以：\n\n```java\nPushbackInputStream pbin = new PushbackInputStream(\n\tnew BUfferInputStream(\n\t\tnew FileInputStream(test.txt\")));\n//预读写一个字节\nint b = pbin.read();\n//不是所期望时将其推回流中\nif(b != '<') pbin.unead(b);\n```\n----\n### 二、文本输入与输出\n**输出：`PrintWrite`**\n`PrintWrite out = new PrintWrite(\"test.txt\");`等同于`PrintWrite out = new PrintWrite(new FileWrite(\"test.txt\"));`\n**输入：`Scanner`**\n**文本格式存储对象**\n用自己的格式依次存储各个字段，以特定字符分隔，如：`PINUULI|201625010417|1997|guangdong`\n\n----\n\n### 三、读写二进制数据\n**读**：实现`DataInput`接口，如`DataInputStream，readInt，readBoolean`等方法\n**写**：实现`DataOutpu`t接口，如`DataOutputStream，writeInt，writeBoolean`等方法\n**随机访问文件**：`RandomAccessFile`\n可以在文件中的任何位置查找或者写入数据：\n```java\nRandomAccessFile in = new RandomAccessFile(\"test.txt\",\"r\");\nRandomAccessFile inOut = new RandomAccessFile(\"test.txt\",\"rw\");\n```\n----\n### 四、ZIP文件\n每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。\n**读**：`ZipInputStream`\n- 用`getNextEntry`方法返回文档中这些项（文件）的`ZipEntry`对象\n- ` ZipInputStream`的`read`方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用`closeEntry`读入下一项\n- 在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项\n- 通读zip文件：\n\n``` java\nZipInputStream zin = new ZipInputStream(new FileInputStream(\"test.zip\"));\nZipEntry entry;\nScanner in = new Scanner(zin);\nwhile((entry = zin.getNextEntry()) != null){\n\twhile(in.hasNextLine()){\n\t\tSystem.out.println(in.nextLine());\n\t}\n\tzin.closeEntry();\n}\n```\n\n**写**：`ZipOutputStream`\n- 对于想要放入到zip文件中的每一个项，都应该创建一个`ZipEntry`对象，并将文件名传递给ZipEntry的构造器\n- 调用`ZipOutputStream`的`putNextEntry`方法开始写出新文件，并将数据发送到zip流中\n- 完成时调用`closeEntry`方法,如：\n\n```java\nFileOutputStream fout = new FilePutputStream(\"test.zip\");\nZipOutputStream zout = new ZipOutputStream(fout);\n\n// 写一个文件\nZipEntry ze = new ZipEntry(\"filename\");\nzout.putNextENtry(ze);\nsend data to zout;\nzout.closeEntry();\n\nzout.close();\n```\n----\n### 五、对象流与序列化\n- 序列化:`ObjectOutputStream.writeObject()`,\n- 反序列化：`ObjectInputream.readObject()`，\n- 都需要实现`Serializable`接口\n- 只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等\n- 序列化算法：\n\t- 对于遇到的每个对象都关联一个序列号\n\t- 对于每个对象，第一次遇到时，保存其对象数据到流中\n\t- 如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反\n\t- 对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联\n\t- 当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用\n- 修改默认的序列化机制\n\n> 一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。\n可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。\n\n当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现`Serializable`接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如：\n\t\t\n```java\npublic class LabeledPoint implements Serializable{\n\tprivate String label;\n\n\t//对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标\n\tprivate transient Point2D.Double point;\n\t···\n\t//重写读写方法\n\tprivate void writeObject(ObjectOutputStream out) throws Exception{\n\t\tout.defaultWriteObjecy();\n\t\tout.writeDouble(point.getX());\n\t\tout.writeDouble(point.getY());\n\t}\n\n\tprivate void readObject(ObjectInputStream in) throws IOException{\n\t\tin.defaultReadObject();\n\t\tdouble x = in.readDouble();\n\t\tdouble y = in.readDouble();\n\t\tpoint = new Point2D.DOuble(x,y);\n\t}\n}\n```\n\t\t\n当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现`Externalizable`接口，指定要保存的域\n\n```java\npublic class Student implements Externalizable{\n\tprivate String name;\n\tprivate String stuId;\n\tprivate int age;\n\t···\n\t//重写读写方法\n\tprivate void writeExternal(ObjectOutput out) throws IOException{\n\t\tout.writeUTF(name);\n\t\tout.writeInt(age);\n\t}\n\n\tprivate void readExternal(ObjectInput in) throws IOException{\n\t\tname = in.readUTF():\n\t\tage = in.readInt();\n\t}\n}\n```\n\t> PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。\n\n----\n### 六、操作文件\n**Path**\n- 静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\\）连接起来，返回一个Path对象，详情见API。如\n\n```java\nPath absolutye = Paths.get(\"/home\".\"cay\");\nPath relative = Paths.get(\"myprog\",\"conf\",\"user.properties\");\n```\n**读写文件**：Files类可以使得普通文件操作变得快捷\n- 读取文件所有内容：`byte[] bytes = Files.readAllBytes(path);`,之后可以将其当做字符串`String content = new String(bytes,charset);`\n- 向指定文件追加内容：`Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND);`\n\n\n> 参阅：\n  [慕课网：文件传输基础——Java IO流](https://www.imooc.com/learn/123)\n  [java核心技术 卷II：高级特性](http://product.dangdang.com/25171892.html)\n","slug":"java-io流与文件","published":1,"updated":"2018-11-13T06:13:17.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdv002ku7yjzenhsjh4","content":"<h3 id=\"一、流\"><a href=\"#一、流\" class=\"headerlink\" title=\"一、流\"></a>一、流</h3><p><strong>读写字节</strong><br><code>InputStream.read和OutpueStream.write</code><br><strong>组合流过滤器</strong></p>\n<ul>\n<li>某些流（如<code>FileInputStream</code>或者<code>FileOutputStream</code>）只能支持在字节级别上的读写，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如：    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputStream fin = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"test.txt\"</span>);</span><br><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(fin);</span><br><span class=\"line\"><span class=\"keyword\">double</span> s = din.readDouble();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要使用缓冲，可以使用一下构造器：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> BUfferInputStream(</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> FileInputStream(test.txt<span class=\"string\">\")));</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要浏览下一个字节以确定是否是想要的值时，可以：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PushbackInputStream pbin = <span class=\"keyword\">new</span> PushbackInputStream(</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> BUfferInputStream(</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> FileInputStream(test.txt<span class=\"string\">\")));</span></span><br><span class=\"line\"><span class=\"string\">//预读写一个字节</span></span><br><span class=\"line\"><span class=\"string\">int b = pbin.read();</span></span><br><span class=\"line\"><span class=\"string\">//不是所期望时将其推回流中</span></span><br><span class=\"line\"><span class=\"string\">if(b != '&lt;') pbin.unead(b);</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"二、文本输入与输出\"><a href=\"#二、文本输入与输出\" class=\"headerlink\" title=\"二、文本输入与输出\"></a>二、文本输入与输出</h3><p><strong>输出：<code>PrintWrite</code></strong><br><code>PrintWrite out = new PrintWrite(&quot;test.txt&quot;);</code>等同于<code>PrintWrite out = new PrintWrite(new FileWrite(&quot;test.txt&quot;));</code><br><strong>输入：<code>Scanner</code></strong><br><strong>文本格式存储对象</strong><br>用自己的格式依次存储各个字段，以特定字符分隔，如：<code>PINUULI|201625010417|1997|guangdong</code></p>\n<hr>\n<h3 id=\"三、读写二进制数据\"><a href=\"#三、读写二进制数据\" class=\"headerlink\" title=\"三、读写二进制数据\"></a>三、读写二进制数据</h3><p><strong>读</strong>：实现<code>DataInput</code>接口，如<code>DataInputStream，readInt，readBoolean</code>等方法<br><strong>写</strong>：实现<code>DataOutpu</code>t接口，如<code>DataOutputStream，writeInt，writeBoolean</code>等方法<br><strong>随机访问文件</strong>：<code>RandomAccessFile</code><br>可以在文件中的任何位置查找或者写入数据：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile in = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"test.txt\"</span>,<span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">RandomAccessFile inOut = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"test.txt\"</span>,<span class=\"string\">\"rw\"</span>);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"四、ZIP文件\"><a href=\"#四、ZIP文件\" class=\"headerlink\" title=\"四、ZIP文件\"></a>四、ZIP文件</h3><p>每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。<br><strong>读</strong>：<code>ZipInputStream</code></p>\n<ul>\n<li>用<code>getNextEntry</code>方法返回文档中这些项（文件）的<code>ZipEntry</code>对象</li>\n<li><code>ZipInputStream</code>的<code>read</code>方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用<code>closeEntry</code>读入下一项</li>\n<li>在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项</li>\n<li>通读zip文件：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZipInputStream zin = <span class=\"keyword\">new</span> ZipInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"test.zip\"</span>));</span><br><span class=\"line\">ZipEntry entry;</span><br><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(zin);</span><br><span class=\"line\"><span class=\"keyword\">while</span>((entry = zin.getNextEntry()) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(in.hasNextLine())&#123;</span><br><span class=\"line\">\t\tSystem.out.println(in.nextLine());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tzin.closeEntry();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>写</strong>：<code>ZipOutputStream</code></p>\n<ul>\n<li>对于想要放入到zip文件中的每一个项，都应该创建一个<code>ZipEntry</code>对象，并将文件名传递给ZipEntry的构造器</li>\n<li>调用<code>ZipOutputStream</code>的<code>putNextEntry</code>方法开始写出新文件，并将数据发送到zip流中</li>\n<li>完成时调用<code>closeEntry</code>方法,如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileOutputStream fout = <span class=\"keyword\">new</span> FilePutputStream(<span class=\"string\">\"test.zip\"</span>);</span><br><span class=\"line\">ZipOutputStream zout = <span class=\"keyword\">new</span> ZipOutputStream(fout);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写一个文件</span></span><br><span class=\"line\">ZipEntry ze = <span class=\"keyword\">new</span> ZipEntry(<span class=\"string\">\"filename\"</span>);</span><br><span class=\"line\">zout.putNextENtry(ze);</span><br><span class=\"line\">send data to zout;</span><br><span class=\"line\">zout.closeEntry();</span><br><span class=\"line\"></span><br><span class=\"line\">zout.close();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"五、对象流与序列化\"><a href=\"#五、对象流与序列化\" class=\"headerlink\" title=\"五、对象流与序列化\"></a>五、对象流与序列化</h3><ul>\n<li>序列化:<code>ObjectOutputStream.writeObject()</code>,</li>\n<li>反序列化：<code>ObjectInputream.readObject()</code>，</li>\n<li>都需要实现<code>Serializable</code>接口</li>\n<li>只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等</li>\n<li>序列化算法：<ul>\n<li>对于遇到的每个对象都关联一个序列号</li>\n<li>对于每个对象，第一次遇到时，保存其对象数据到流中</li>\n<li>如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反</li>\n<li>对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联</li>\n<li>当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用</li>\n</ul>\n</li>\n<li>修改默认的序列化机制</li>\n</ul>\n<blockquote>\n<p>一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。<br>可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。</p>\n</blockquote>\n<p>当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现<code>Serializable</code>接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LabeledPoint</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String label;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Point2D.Double point;</span><br><span class=\"line\">\t···</span><br><span class=\"line\">\t<span class=\"comment\">//重写读写方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeObject</span><span class=\"params\">(ObjectOutputStream out)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">\t\tout.defaultWriteObjecy();</span><br><span class=\"line\">\t\tout.writeDouble(point.getX());</span><br><span class=\"line\">\t\tout.writeDouble(point.getY());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObject</span><span class=\"params\">(ObjectInputStream in)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">\t\tin.defaultReadObject();</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> x = in.readDouble();</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> y = in.readDouble();</span><br><span class=\"line\">\t\tpoint = <span class=\"keyword\">new</span> Point2D.DOuble(x,y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现<code>Externalizable</code>接口，指定要保存的域</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Externalizable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String stuId;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t···</span><br><span class=\"line\">\t<span class=\"comment\">//重写读写方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeExternal</span><span class=\"params\">(ObjectOutput out)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">\t\tout.writeUTF(name);</span><br><span class=\"line\">\t\tout.writeInt(age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readExternal</span><span class=\"params\">(ObjectInput in)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">\t\tname = in.readUTF():</span><br><span class=\"line\">\t\tage = in.readInt();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>&gt; PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。\n</code></pre><hr>\n<h3 id=\"六、操作文件\"><a href=\"#六、操作文件\" class=\"headerlink\" title=\"六、操作文件\"></a>六、操作文件</h3><p><strong>Path</strong></p>\n<ul>\n<li>静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\\）连接起来，返回一个Path对象，详情见API。如</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Path absolutye = Paths.get(<span class=\"string\">\"/home\"</span>.<span class=\"string\">\"cay\"</span>);</span><br><span class=\"line\">Path relative = Paths.get(<span class=\"string\">\"myprog\"</span>,<span class=\"string\">\"conf\"</span>,<span class=\"string\">\"user.properties\"</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>读写文件</strong>：Files类可以使得普通文件操作变得快捷</p>\n<ul>\n<li>读取文件所有内容：<code>byte[] bytes = Files.readAllBytes(path);</code>,之后可以将其当做字符串<code>String content = new String(bytes,charset);</code></li>\n<li>向指定文件追加内容：<code>Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND);</code></li>\n</ul>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/123\" target=\"_blank\" rel=\"noopener\">慕课网：文件传输基础——Java IO流</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、流\"><a href=\"#一、流\" class=\"headerlink\" title=\"一、流\"></a>一、流</h3><p><strong>读写字节</strong><br><code>InputStream.read和OutpueStream.write</code><br><strong>组合流过滤器</strong></p>\n<ul>\n<li>某些流（如<code>FileInputStream</code>或者<code>FileOutputStream</code>）只能支持在字节级别上的读写，没有读入数据类型的方法，而其他的流（DataInputStream）这些类就之只能读入数值类型，无法从文件中获取数据，因而对二者进行组合。如：    </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputStream fin = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"test.txt\"</span>);</span><br><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(fin);</span><br><span class=\"line\"><span class=\"keyword\">double</span> s = din.readDouble();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要使用缓冲，可以使用一下构造器：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> BUfferInputStream(</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> FileInputStream(test.txt<span class=\"string\">\")));</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>需要浏览下一个字节以确定是否是想要的值时，可以：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PushbackInputStream pbin = <span class=\"keyword\">new</span> PushbackInputStream(</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> BUfferInputStream(</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> FileInputStream(test.txt<span class=\"string\">\")));</span></span><br><span class=\"line\"><span class=\"string\">//预读写一个字节</span></span><br><span class=\"line\"><span class=\"string\">int b = pbin.read();</span></span><br><span class=\"line\"><span class=\"string\">//不是所期望时将其推回流中</span></span><br><span class=\"line\"><span class=\"string\">if(b != '&lt;') pbin.unead(b);</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"二、文本输入与输出\"><a href=\"#二、文本输入与输出\" class=\"headerlink\" title=\"二、文本输入与输出\"></a>二、文本输入与输出</h3><p><strong>输出：<code>PrintWrite</code></strong><br><code>PrintWrite out = new PrintWrite(&quot;test.txt&quot;);</code>等同于<code>PrintWrite out = new PrintWrite(new FileWrite(&quot;test.txt&quot;));</code><br><strong>输入：<code>Scanner</code></strong><br><strong>文本格式存储对象</strong><br>用自己的格式依次存储各个字段，以特定字符分隔，如：<code>PINUULI|201625010417|1997|guangdong</code></p>\n<hr>\n<h3 id=\"三、读写二进制数据\"><a href=\"#三、读写二进制数据\" class=\"headerlink\" title=\"三、读写二进制数据\"></a>三、读写二进制数据</h3><p><strong>读</strong>：实现<code>DataInput</code>接口，如<code>DataInputStream，readInt，readBoolean</code>等方法<br><strong>写</strong>：实现<code>DataOutpu</code>t接口，如<code>DataOutputStream，writeInt，writeBoolean</code>等方法<br><strong>随机访问文件</strong>：<code>RandomAccessFile</code><br>可以在文件中的任何位置查找或者写入数据：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile in = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"test.txt\"</span>,<span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">RandomAccessFile inOut = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">\"test.txt\"</span>,<span class=\"string\">\"rw\"</span>);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"四、ZIP文件\"><a href=\"#四、ZIP文件\" class=\"headerlink\" title=\"四、ZIP文件\"></a>四、ZIP文件</h3><p>每个zip文档都有一个头，包含注入给个文件名字和使用的压缩方法等信息。<br><strong>读</strong>：<code>ZipInputStream</code></p>\n<ul>\n<li>用<code>getNextEntry</code>方法返回文档中这些项（文件）的<code>ZipEntry</code>对象</li>\n<li><code>ZipInputStream</code>的<code>read</code>方法被修改为碰到当前项的结尾时返回-1，而不是整个zip文件的结尾，读完一个项之后，用<code>closeEntry</code>读入下一项</li>\n<li>在读入单个zip项后，不要关闭zip输入流，否则就不能再读入后续的项</li>\n<li>通读zip文件：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZipInputStream zin = <span class=\"keyword\">new</span> ZipInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"test.zip\"</span>));</span><br><span class=\"line\">ZipEntry entry;</span><br><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(zin);</span><br><span class=\"line\"><span class=\"keyword\">while</span>((entry = zin.getNextEntry()) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(in.hasNextLine())&#123;</span><br><span class=\"line\">\t\tSystem.out.println(in.nextLine());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tzin.closeEntry();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>写</strong>：<code>ZipOutputStream</code></p>\n<ul>\n<li>对于想要放入到zip文件中的每一个项，都应该创建一个<code>ZipEntry</code>对象，并将文件名传递给ZipEntry的构造器</li>\n<li>调用<code>ZipOutputStream</code>的<code>putNextEntry</code>方法开始写出新文件，并将数据发送到zip流中</li>\n<li>完成时调用<code>closeEntry</code>方法,如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileOutputStream fout = <span class=\"keyword\">new</span> FilePutputStream(<span class=\"string\">\"test.zip\"</span>);</span><br><span class=\"line\">ZipOutputStream zout = <span class=\"keyword\">new</span> ZipOutputStream(fout);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写一个文件</span></span><br><span class=\"line\">ZipEntry ze = <span class=\"keyword\">new</span> ZipEntry(<span class=\"string\">\"filename\"</span>);</span><br><span class=\"line\">zout.putNextENtry(ze);</span><br><span class=\"line\">send data to zout;</span><br><span class=\"line\">zout.closeEntry();</span><br><span class=\"line\"></span><br><span class=\"line\">zout.close();</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"五、对象流与序列化\"><a href=\"#五、对象流与序列化\" class=\"headerlink\" title=\"五、对象流与序列化\"></a>五、对象流与序列化</h3><ul>\n<li>序列化:<code>ObjectOutputStream.writeObject()</code>,</li>\n<li>反序列化：<code>ObjectInputream.readObject()</code>，</li>\n<li>都需要实现<code>Serializable</code>接口</li>\n<li>只有读写对象时才能用writeObject/readObject方法，对于基本类型，使用writeInt/readInt等</li>\n<li>序列化算法：<ul>\n<li>对于遇到的每个对象都关联一个序列号</li>\n<li>对于每个对象，第一次遇到时，保存其对象数据到流中</li>\n<li>如果某个对象之前已经被保存过，那么只写出“与之前保存过的序列号为x的对象相同”，在反序列化时整个过程相反</li>\n<li>对于流中的对象，在第一次遇到其序列号时，构建它并使用流中的数据初始化，然后记录这个序列号与新对象之间的关联</li>\n<li>当遇到“与之前保存过的序列号为x的对象相同”标记时，获取与这个序列号相关联的对象引用，即相同对象的重复出现被存储为对这个对象的序列号的引用</li>\n</ul>\n</li>\n<li>修改默认的序列化机制</li>\n</ul>\n<blockquote>\n<p>一些数据域是不可序列化，或者没必要序列化的，比如只对本地方法有意义的窗口句柄的整数值，重新加载或者传送到其他机器上都没有用，那么就可以将他们标记成是transient，这些域在序列化时就会被跳过。<br>可以把一些域存储为你想要的格式，想要为默认的读写行文添加验证时。</p>\n</blockquote>\n<p>当你只是想跳过一些域，或者想将这些域保存为你想要的格式，而大部分域依然按照默认的格式保存时，可以仍然实现<code>Serializable</code>接口，将那些数据域标记成transient，读写时调用默认的读写方法之后，再做自己想要的处理，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LabeledPoint</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String label;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对于类LabeledPoint，point不能序列化，那么标志成transient，序列化时就会被跳过,之后存储点的坐标</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Point2D.Double point;</span><br><span class=\"line\">\t···</span><br><span class=\"line\">\t<span class=\"comment\">//重写读写方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeObject</span><span class=\"params\">(ObjectOutputStream out)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">\t\tout.defaultWriteObjecy();</span><br><span class=\"line\">\t\tout.writeDouble(point.getX());</span><br><span class=\"line\">\t\tout.writeDouble(point.getY());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObject</span><span class=\"params\">(ObjectInputStream in)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">\t\tin.defaultReadObject();</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> x = in.readDouble();</span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> y = in.readDouble();</span><br><span class=\"line\">\t\tpoint = <span class=\"keyword\">new</span> Point2D.DOuble(x,y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你只需要保存一部分域时，使用transient关键字就有点麻烦，那么可以通过实现<code>Externalizable</code>接口，指定要保存的域</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Externalizable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String stuId;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">\t···</span><br><span class=\"line\">\t<span class=\"comment\">//重写读写方法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeExternal</span><span class=\"params\">(ObjectOutput out)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">\t\tout.writeUTF(name);</span><br><span class=\"line\">\t\tout.writeInt(age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readExternal</span><span class=\"params\">(ObjectInput in)</span> <span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">\t\tname = in.readUTF():</span><br><span class=\"line\">\t\tage = in.readInt();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>&gt; PS:readObjecty和writeObject方法时私有的，只有被序列化机制调用，在流中只记录该对象所属的类，而readExternal/writeExternal方法时公共的，而且对包括超类数据在内的整个对象的存储和回复负责。\n</code></pre><hr>\n<h3 id=\"六、操作文件\"><a href=\"#六、操作文件\" class=\"headerlink\" title=\"六、操作文件\"></a>六、操作文件</h3><p><strong>Path</strong></p>\n<ul>\n<li>静态的Paths.get方法接收一个或多个字符串，并将它们用默认文件系统的路径分隔符（类Unix文件系统是/，Windows是\\）连接起来，返回一个Path对象，详情见API。如</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Path absolutye = Paths.get(<span class=\"string\">\"/home\"</span>.<span class=\"string\">\"cay\"</span>);</span><br><span class=\"line\">Path relative = Paths.get(<span class=\"string\">\"myprog\"</span>,<span class=\"string\">\"conf\"</span>,<span class=\"string\">\"user.properties\"</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>读写文件</strong>：Files类可以使得普通文件操作变得快捷</p>\n<ul>\n<li>读取文件所有内容：<code>byte[] bytes = Files.readAllBytes(path);</code>,之后可以将其当做字符串<code>String content = new String(bytes,charset);</code></li>\n<li>向指定文件追加内容：<code>Files.write(path,content.getBytes(charset),StandardOpenOption.APPEND);</code></li>\n</ul>\n<blockquote>\n<p>参阅：<br>  <a href=\"https://www.imooc.com/learn/123\" target=\"_blank\" rel=\"noopener\">慕课网：文件传输基础——Java IO流</a><br>  <a href=\"http://product.dangdang.com/25171892.html\" target=\"_blank\" rel=\"noopener\">java核心技术 卷II：高级特性</a></p>\n</blockquote>\n"},{"title":"深入理解Java虚拟机之Class类文件结构","date":"2018-12-07T13:17:08.000Z","copyright":null,"_content":"> Class文件十一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上的空间的数据项时，按照 **高位在前(最高位字节在地址最低位)**的方式分割成若干个8为字节进行存储\n\nClass文件格式：\n![](/images/jvm_class_file_format.jpg)\n\n### 1. 魔数与Class文件的版本\n- 每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件（很多文件存储标准都是用魔数来进行身份识别，譬如图片格式等）\n- 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件\n\n### 2. 常量池\n- 紧接着主次版本号之后的是常量池入口，常量池可以 理解为Class文件之中的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值，这个计数值从1开始\n- 常量池中主要存放两大类常量：字面量和符号引用：\n    - 字面量：比较接近于Java语言层面的常量概念\n    - 符号引用：属于编译原理方面的概念，包括了下面三类常量：\n        - 类和接口的全限定名\n        - 字段的名称和描述符\n        - 方法的名称和描述符\n- 常量池中每一项常量都是一个表，每个表开始的第一位都是一个u1类型的标志位，代表 当前这个常量属于那种类型常量\n\n常量池的项目类型：\n![](/images/jvm_class_file_finaltype.jpg)\n\n### 3. 访问标志\n- 2个字节，用于标识一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否为abstract类型等\n\n### 4. 类索引、父类索引与接口索引集合\n- Class文件中由这三项数据来确定这个类的继承关系\n- 类索引和父类索引引用两个u2类型的索引值表示，他们各自指向一个类型为CONSTANT_Class_info的类描述常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串\n- 接口索引集合，入口第一项--u2类型的数据为接口计数器，表示索引表的容量\n\n### 5. 字段表集合\n- 用于描述接口或者类中声明的变量\n- 字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量\n\n### 6. 方法表集合\n- Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式\n\n### 7. 属性表集合\n- 在Class文件，字段表、方法表都可以携带自己的属性表集合\n\n","source":"_posts/深入理解Java虚拟机之Class类文件结构.md","raw":"---\ntitle: 深入理解Java虚拟机之Class类文件结构\ndate: 2018-12-07 21:17:08\ncategories: \"深入理解java虚拟机笔记\"\ntags:\n    - JVM\ncopyright:\n---\n> Class文件十一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上的空间的数据项时，按照 **高位在前(最高位字节在地址最低位)**的方式分割成若干个8为字节进行存储\n\nClass文件格式：\n![](/images/jvm_class_file_format.jpg)\n\n### 1. 魔数与Class文件的版本\n- 每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件（很多文件存储标准都是用魔数来进行身份识别，譬如图片格式等）\n- 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件\n\n### 2. 常量池\n- 紧接着主次版本号之后的是常量池入口，常量池可以 理解为Class文件之中的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值，这个计数值从1开始\n- 常量池中主要存放两大类常量：字面量和符号引用：\n    - 字面量：比较接近于Java语言层面的常量概念\n    - 符号引用：属于编译原理方面的概念，包括了下面三类常量：\n        - 类和接口的全限定名\n        - 字段的名称和描述符\n        - 方法的名称和描述符\n- 常量池中每一项常量都是一个表，每个表开始的第一位都是一个u1类型的标志位，代表 当前这个常量属于那种类型常量\n\n常量池的项目类型：\n![](/images/jvm_class_file_finaltype.jpg)\n\n### 3. 访问标志\n- 2个字节，用于标识一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否为abstract类型等\n\n### 4. 类索引、父类索引与接口索引集合\n- Class文件中由这三项数据来确定这个类的继承关系\n- 类索引和父类索引引用两个u2类型的索引值表示，他们各自指向一个类型为CONSTANT_Class_info的类描述常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串\n- 接口索引集合，入口第一项--u2类型的数据为接口计数器，表示索引表的容量\n\n### 5. 字段表集合\n- 用于描述接口或者类中声明的变量\n- 字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量\n\n### 6. 方法表集合\n- Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式\n\n### 7. 属性表集合\n- 在Class文件，字段表、方法表都可以携带自己的属性表集合\n\n","slug":"深入理解Java虚拟机之Class类文件结构","published":1,"updated":"2018-12-07T13:26:18.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdx002nu7yj9zgbey7c","content":"<blockquote>\n<p>Class文件十一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上的空间的数据项时，按照 <strong>高位在前(最高位字节在地址最低位)</strong>的方式分割成若干个8为字节进行存储</p>\n</blockquote>\n<p>Class文件格式：<br><img src=\"/images/jvm_class_file_format.jpg\" alt=\"\"></p>\n<h3 id=\"1-魔数与Class文件的版本\"><a href=\"#1-魔数与Class文件的版本\" class=\"headerlink\" title=\"1. 魔数与Class文件的版本\"></a>1. 魔数与Class文件的版本</h3><ul>\n<li>每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件（很多文件存储标准都是用魔数来进行身份识别，譬如图片格式等）</li>\n<li>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件</li>\n</ul>\n<h3 id=\"2-常量池\"><a href=\"#2-常量池\" class=\"headerlink\" title=\"2. 常量池\"></a>2. 常量池</h3><ul>\n<li>紧接着主次版本号之后的是常量池入口，常量池可以 理解为Class文件之中的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值，这个计数值从1开始</li>\n<li>常量池中主要存放两大类常量：字面量和符号引用：<ul>\n<li>字面量：比较接近于Java语言层面的常量概念</li>\n<li>符号引用：属于编译原理方面的概念，包括了下面三类常量：<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>常量池中每一项常量都是一个表，每个表开始的第一位都是一个u1类型的标志位，代表 当前这个常量属于那种类型常量</li>\n</ul>\n<p>常量池的项目类型：<br><img src=\"/images/jvm_class_file_finaltype.jpg\" alt=\"\"></p>\n<h3 id=\"3-访问标志\"><a href=\"#3-访问标志\" class=\"headerlink\" title=\"3. 访问标志\"></a>3. 访问标志</h3><ul>\n<li>2个字节，用于标识一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否为abstract类型等</li>\n</ul>\n<h3 id=\"4-类索引、父类索引与接口索引集合\"><a href=\"#4-类索引、父类索引与接口索引集合\" class=\"headerlink\" title=\"4. 类索引、父类索引与接口索引集合\"></a>4. 类索引、父类索引与接口索引集合</h3><ul>\n<li>Class文件中由这三项数据来确定这个类的继承关系</li>\n<li>类索引和父类索引引用两个u2类型的索引值表示，他们各自指向一个类型为CONSTANT_Class_info的类描述常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</li>\n<li>接口索引集合，入口第一项–u2类型的数据为接口计数器，表示索引表的容量</li>\n</ul>\n<h3 id=\"5-字段表集合\"><a href=\"#5-字段表集合\" class=\"headerlink\" title=\"5. 字段表集合\"></a>5. 字段表集合</h3><ul>\n<li>用于描述接口或者类中声明的变量</li>\n<li>字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</li>\n</ul>\n<h3 id=\"6-方法表集合\"><a href=\"#6-方法表集合\" class=\"headerlink\" title=\"6. 方法表集合\"></a>6. 方法表集合</h3><ul>\n<li>Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式</li>\n</ul>\n<h3 id=\"7-属性表集合\"><a href=\"#7-属性表集合\" class=\"headerlink\" title=\"7. 属性表集合\"></a>7. 属性表集合</h3><ul>\n<li>在Class文件，字段表、方法表都可以携带自己的属性表集合</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Class文件十一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，当遇到需要占用8位字节以上的空间的数据项时，按照 <strong>高位在前(最高位字节在地址最低位)</strong>的方式分割成若干个8为字节进行存储</p>\n</blockquote>\n<p>Class文件格式：<br><img src=\"/images/jvm_class_file_format.jpg\" alt=\"\"></p>\n<h3 id=\"1-魔数与Class文件的版本\"><a href=\"#1-魔数与Class文件的版本\" class=\"headerlink\" title=\"1. 魔数与Class文件的版本\"></a>1. 魔数与Class文件的版本</h3><ul>\n<li>每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件（很多文件存储标准都是用魔数来进行身份识别，譬如图片格式等）</li>\n<li>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号，第7和第8个字节是主版本号，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件</li>\n</ul>\n<h3 id=\"2-常量池\"><a href=\"#2-常量池\" class=\"headerlink\" title=\"2. 常量池\"></a>2. 常量池</h3><ul>\n<li>紧接着主次版本号之后的是常量池入口，常量池可以 理解为Class文件之中的资源仓库，常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值，这个计数值从1开始</li>\n<li>常量池中主要存放两大类常量：字面量和符号引用：<ul>\n<li>字面量：比较接近于Java语言层面的常量概念</li>\n<li>符号引用：属于编译原理方面的概念，包括了下面三类常量：<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>常量池中每一项常量都是一个表，每个表开始的第一位都是一个u1类型的标志位，代表 当前这个常量属于那种类型常量</li>\n</ul>\n<p>常量池的项目类型：<br><img src=\"/images/jvm_class_file_finaltype.jpg\" alt=\"\"></p>\n<h3 id=\"3-访问标志\"><a href=\"#3-访问标志\" class=\"headerlink\" title=\"3. 访问标志\"></a>3. 访问标志</h3><ul>\n<li>2个字节，用于标识一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，是否为abstract类型等</li>\n</ul>\n<h3 id=\"4-类索引、父类索引与接口索引集合\"><a href=\"#4-类索引、父类索引与接口索引集合\" class=\"headerlink\" title=\"4. 类索引、父类索引与接口索引集合\"></a>4. 类索引、父类索引与接口索引集合</h3><ul>\n<li>Class文件中由这三项数据来确定这个类的继承关系</li>\n<li>类索引和父类索引引用两个u2类型的索引值表示，他们各自指向一个类型为CONSTANT_Class_info的类描述常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</li>\n<li>接口索引集合，入口第一项–u2类型的数据为接口计数器，表示索引表的容量</li>\n</ul>\n<h3 id=\"5-字段表集合\"><a href=\"#5-字段表集合\" class=\"headerlink\" title=\"5. 字段表集合\"></a>5. 字段表集合</h3><ul>\n<li>用于描述接口或者类中声明的变量</li>\n<li>字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</li>\n</ul>\n<h3 id=\"6-方法表集合\"><a href=\"#6-方法表集合\" class=\"headerlink\" title=\"6. 方法表集合\"></a>6. 方法表集合</h3><ul>\n<li>Class文件存储格式对方法的描述与对字段的描述几乎采用了完全一致的方式</li>\n</ul>\n<h3 id=\"7-属性表集合\"><a href=\"#7-属性表集合\" class=\"headerlink\" title=\"7. 属性表集合\"></a>7. 属性表集合</h3><ul>\n<li>在Class文件，字段表、方法表都可以携带自己的属性表集合</li>\n</ul>\n"},{"title":"深入理解Java虚拟机之垃圾收集器与内存分配策略","date":"2018-12-01T13:17:54.000Z","copyright":null,"_content":"### 对象存活判断算法\n#### 引用计数算法\n给对象添加一个引用计数器，有一个地方引用它计数值就加1，引用失效时减1，任何时刻计数器为0则不可能再被使用\n> 实现简单，判定效率高，但很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用这种方式管理内存\n\n#### 可达性分析算法\n通过一系列的称为\"GC Roots\"的对象作为起始点，从这些节点开始向下搜索，搜索所走过 的路径称为引用链，当一个对象到GC Roots没有任何引用链时，证明此对象是不可用的\n> Java中扩展为GC Roots的对象包括以下几种 ：\n- 虚拟机栈中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI（即一般说的Native方法）引用的对象\n\n#### 对象死亡的判定\n真正宣告一个对象死亡，至少要经理两次标记过程：\n1. 在进行可达性分析后发现不可达，将会被第一次标记并且进行一次筛选\n\n> 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，视为“没有必要执行\nfinalize”的情况，若有必要执行finalize，则将对象放入F-Queue的队列之中，并稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行。（一个对象的finalize()方法只会被系统调用一次）\n\n2. GC对F-Queue中的对象进行第二次标记\n\n> 对象逃脱的唯一机会就在finalize()方法中，只要重新与引用链上的任何一个对象建立关联即可\n\n#### 回收方法区（即HotSpot中的永久代）\n> 永久代的垃圾主要回收两部分的内容：废弃常量和无用的类。\n\n\"无用的类\"需要满足的三个条件：\n1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例\n2. 加载该类的ClassLoader已经被回收\n3. 该类对应的java.class.Class对象没有在任何地方被引用\n\n### 垃圾收集算法\n#### 标记-清除算法\n- **标记阶段**: 标记所有需要回收的对象\n- **清除阶段**: 统一回收所有被标记的对象\n![](/images/jvm_gc_markclean.jpg)\n两个不足：\n- **效率问题**，标记和清除的效率都不高\n- **空间问题**，标记清除之后产生大量不连续的碎片\n\n#### 复制算法\n> 将可用内存按**容量**划分为大小相等的凉快，每次之使用给一块。当这一块的内存用完时，就将还存活的对象复制到另外一块上，然后把已使用过的内存空间一次清理掉。\n\n- 现在商业虚拟机用这种算法回收新生代，将内存分为一块 较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将这两块上还存活的对象一次性复制到Survivor上，最后清理掉Eden和Survivor（在HotSpot默认Eden和Survivor的大小比例为8:1）\n- 当Survivor内存不够用时，需要依赖其他内存（这里指老年代）进行分配担保\n![](/images/jvm_gc_duplicate.jpg)\n\n#### 标记-整理算法\n> 和“标记-清除算法”一样，但后续步骤是不是直接对可回收对象进行清理，而是 **让所有存活的对象都向一端移动**\n\n![](/images/jvm_gc_markarrange.jpg)\n\n#### 分代收集算法\n> 把Java堆分为 **新生代**和 **老年代**，这样可以根据各个年代的特点采用最适当的收集算法\n\n- 新生代每次垃圾收集都发现大批对象死去，只有少量存活，选用复制算法\n- 老年代对象存活率高、没有额外空间对它进行分配担保，使用“标记清理”或者“标记整理”算法\n\n----\n### HotSpot的算法实现\n#### 枚举根节点\n在HotSpot中，使用OopMap来直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些未知是应用\n\n#### 安全点\n- HotSpot没有为每条指令都生成OopMap，只是在安全点（Safepoint）记录了这些信息\n> 即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停\n\n- 当GC发生时让所有线程都跑到最近的安全点上停顿下来的两种方案：\n1. 抢先式中断\n2. 主动式中断： 当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志\n\n#### 安全区域\n指正在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。\n> 当线程执行到安全区域中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM发起GC时，就不用管标识自己为Safe Region的线程了\n\n----\n### 内存分配与回收策略\n#### 1. 对象有限在Eden分配\n- 大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC\n- Minor GC期间虚拟机若发现已有的对象无法放入Survivor空间，就通过分配担保机制提前转移到老年代去\n- 新生代GC（Minor GC）与老年代GC（Major GC/Full GC）：\n    i. 新生代GC：Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快\n    ii. 老年代GC：出现了Major GC经常会伴随着至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上\n\n#### 2. 大对象直接进入老年代\n- 大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组\n- 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，目的是避免在Eden区及两个Survivor区之间发送大量的内存复制\n\n#### 3. 长期存活的对象将进入老年代\n- 虚拟机给每个对象定义了一个对象年龄计数器\n- 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，对象年龄设为1\n- 对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（可以用过参数-XX：MaxTenuringThreshold设置，默认为15），就将会被晋升到老年代中\n#### 4. 动态对象年龄判定\n\n- 虚拟机并不是永远地要求 对象的年龄必须达到了XX：MaxTenuringThreshold才能晋升老年代\n- 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代\n\n#### 5. 空间分配担保\n- 发送Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可以确保是安全的\n- 如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败：\n    - 如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小：\n        - 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；\n        - 如果小于，那么这时要改为进行一次Full GC\n    - 如果不允许，那么也要改为进行一次Full GC\n\n> JDK6 Update24之后规则变为只要老年代最大可用的连续空间大于新生代总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。（HandlePromotionFailure仍存在但不起影响）\n        \n\n\n\n\n\n\n","source":"_posts/深入理解Java虚拟机之垃圾收集器与内存分配策略.md","raw":"---\ntitle: 深入理解Java虚拟机之垃圾收集器与内存分配策略\ndate: 2018-12-01 21:17:54\ncategories: \"深入理解java虚拟机笔记\"\ntags:\n    - JVM\ncopyright:\n---\n### 对象存活判断算法\n#### 引用计数算法\n给对象添加一个引用计数器，有一个地方引用它计数值就加1，引用失效时减1，任何时刻计数器为0则不可能再被使用\n> 实现简单，判定效率高，但很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用这种方式管理内存\n\n#### 可达性分析算法\n通过一系列的称为\"GC Roots\"的对象作为起始点，从这些节点开始向下搜索，搜索所走过 的路径称为引用链，当一个对象到GC Roots没有任何引用链时，证明此对象是不可用的\n> Java中扩展为GC Roots的对象包括以下几种 ：\n- 虚拟机栈中引用的对象\n- 方法区中类静态属性引用的对象\n- 方法区中常量引用的对象\n- 本地方法栈中JNI（即一般说的Native方法）引用的对象\n\n#### 对象死亡的判定\n真正宣告一个对象死亡，至少要经理两次标记过程：\n1. 在进行可达性分析后发现不可达，将会被第一次标记并且进行一次筛选\n\n> 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，视为“没有必要执行\nfinalize”的情况，若有必要执行finalize，则将对象放入F-Queue的队列之中，并稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行。（一个对象的finalize()方法只会被系统调用一次）\n\n2. GC对F-Queue中的对象进行第二次标记\n\n> 对象逃脱的唯一机会就在finalize()方法中，只要重新与引用链上的任何一个对象建立关联即可\n\n#### 回收方法区（即HotSpot中的永久代）\n> 永久代的垃圾主要回收两部分的内容：废弃常量和无用的类。\n\n\"无用的类\"需要满足的三个条件：\n1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例\n2. 加载该类的ClassLoader已经被回收\n3. 该类对应的java.class.Class对象没有在任何地方被引用\n\n### 垃圾收集算法\n#### 标记-清除算法\n- **标记阶段**: 标记所有需要回收的对象\n- **清除阶段**: 统一回收所有被标记的对象\n![](/images/jvm_gc_markclean.jpg)\n两个不足：\n- **效率问题**，标记和清除的效率都不高\n- **空间问题**，标记清除之后产生大量不连续的碎片\n\n#### 复制算法\n> 将可用内存按**容量**划分为大小相等的凉快，每次之使用给一块。当这一块的内存用完时，就将还存活的对象复制到另外一块上，然后把已使用过的内存空间一次清理掉。\n\n- 现在商业虚拟机用这种算法回收新生代，将内存分为一块 较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将这两块上还存活的对象一次性复制到Survivor上，最后清理掉Eden和Survivor（在HotSpot默认Eden和Survivor的大小比例为8:1）\n- 当Survivor内存不够用时，需要依赖其他内存（这里指老年代）进行分配担保\n![](/images/jvm_gc_duplicate.jpg)\n\n#### 标记-整理算法\n> 和“标记-清除算法”一样，但后续步骤是不是直接对可回收对象进行清理，而是 **让所有存活的对象都向一端移动**\n\n![](/images/jvm_gc_markarrange.jpg)\n\n#### 分代收集算法\n> 把Java堆分为 **新生代**和 **老年代**，这样可以根据各个年代的特点采用最适当的收集算法\n\n- 新生代每次垃圾收集都发现大批对象死去，只有少量存活，选用复制算法\n- 老年代对象存活率高、没有额外空间对它进行分配担保，使用“标记清理”或者“标记整理”算法\n\n----\n### HotSpot的算法实现\n#### 枚举根节点\n在HotSpot中，使用OopMap来直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些未知是应用\n\n#### 安全点\n- HotSpot没有为每条指令都生成OopMap，只是在安全点（Safepoint）记录了这些信息\n> 即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停\n\n- 当GC发生时让所有线程都跑到最近的安全点上停顿下来的两种方案：\n1. 抢先式中断\n2. 主动式中断： 当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志\n\n#### 安全区域\n指正在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。\n> 当线程执行到安全区域中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM发起GC时，就不用管标识自己为Safe Region的线程了\n\n----\n### 内存分配与回收策略\n#### 1. 对象有限在Eden分配\n- 大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC\n- Minor GC期间虚拟机若发现已有的对象无法放入Survivor空间，就通过分配担保机制提前转移到老年代去\n- 新生代GC（Minor GC）与老年代GC（Major GC/Full GC）：\n    i. 新生代GC：Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快\n    ii. 老年代GC：出现了Major GC经常会伴随着至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上\n\n#### 2. 大对象直接进入老年代\n- 大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组\n- 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，目的是避免在Eden区及两个Survivor区之间发送大量的内存复制\n\n#### 3. 长期存活的对象将进入老年代\n- 虚拟机给每个对象定义了一个对象年龄计数器\n- 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，对象年龄设为1\n- 对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（可以用过参数-XX：MaxTenuringThreshold设置，默认为15），就将会被晋升到老年代中\n#### 4. 动态对象年龄判定\n\n- 虚拟机并不是永远地要求 对象的年龄必须达到了XX：MaxTenuringThreshold才能晋升老年代\n- 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代\n\n#### 5. 空间分配担保\n- 发送Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可以确保是安全的\n- 如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败：\n    - 如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小：\n        - 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；\n        - 如果小于，那么这时要改为进行一次Full GC\n    - 如果不允许，那么也要改为进行一次Full GC\n\n> JDK6 Update24之后规则变为只要老年代最大可用的连续空间大于新生代总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。（HandlePromotionFailure仍存在但不起影响）\n        \n\n\n\n\n\n\n","slug":"深入理解Java虚拟机之垃圾收集器与内存分配策略","published":1,"updated":"2018-12-07T13:32:15.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fdy002qu7yjjinkj9fk","content":"<h3 id=\"对象存活判断算法\"><a href=\"#对象存活判断算法\" class=\"headerlink\" title=\"对象存活判断算法\"></a>对象存活判断算法</h3><h4 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h4><p>给对象添加一个引用计数器，有一个地方引用它计数值就加1，引用失效时减1，任何时刻计数器为0则不可能再被使用</p>\n<blockquote>\n<p>实现简单，判定效率高，但很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用这种方式管理内存</p>\n</blockquote>\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过 的路径称为引用链，当一个对象到GC Roots没有任何引用链时，证明此对象是不可用的</p>\n<blockquote>\n<p>Java中扩展为GC Roots的对象包括以下几种 ：</p>\n<ul>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>\n</ul>\n</blockquote>\n<h4 id=\"对象死亡的判定\"><a href=\"#对象死亡的判定\" class=\"headerlink\" title=\"对象死亡的判定\"></a>对象死亡的判定</h4><p>真正宣告一个对象死亡，至少要经理两次标记过程：</p>\n<ol>\n<li>在进行可达性分析后发现不可达，将会被第一次标记并且进行一次筛选</li>\n</ol>\n<blockquote>\n<p>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，视为“没有必要执行<br>finalize”的情况，若有必要执行finalize，则将对象放入F-Queue的队列之中，并稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行。（一个对象的finalize()方法只会被系统调用一次）</p>\n</blockquote>\n<ol>\n<li>GC对F-Queue中的对象进行第二次标记</li>\n</ol>\n<blockquote>\n<p>对象逃脱的唯一机会就在finalize()方法中，只要重新与引用链上的任何一个对象建立关联即可</p>\n</blockquote>\n<h4 id=\"回收方法区（即HotSpot中的永久代）\"><a href=\"#回收方法区（即HotSpot中的永久代）\" class=\"headerlink\" title=\"回收方法区（即HotSpot中的永久代）\"></a>回收方法区（即HotSpot中的永久代）</h4><blockquote>\n<p>永久代的垃圾主要回收两部分的内容：废弃常量和无用的类。</p>\n</blockquote>\n<p>“无用的类”需要满足的三个条件：</p>\n<ol>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li>\n<li>加载该类的ClassLoader已经被回收</li>\n<li>该类对应的java.class.Class对象没有在任何地方被引用</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><h4 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h4><ul>\n<li><strong>标记阶段</strong>: 标记所有需要回收的对象</li>\n<li><strong>清除阶段</strong>: 统一回收所有被标记的对象<br><img src=\"/images/jvm_gc_markclean.jpg\" alt=\"\"><br>两个不足：</li>\n<li><strong>效率问题</strong>，标记和清除的效率都不高</li>\n<li><strong>空间问题</strong>，标记清除之后产生大量不连续的碎片</li>\n</ul>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><blockquote>\n<p>将可用内存按<strong>容量</strong>划分为大小相等的凉快，每次之使用给一块。当这一块的内存用完时，就将还存活的对象复制到另外一块上，然后把已使用过的内存空间一次清理掉。</p>\n</blockquote>\n<ul>\n<li>现在商业虚拟机用这种算法回收新生代，将内存分为一块 较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将这两块上还存活的对象一次性复制到Survivor上，最后清理掉Eden和Survivor（在HotSpot默认Eden和Survivor的大小比例为8:1）</li>\n<li>当Survivor内存不够用时，需要依赖其他内存（这里指老年代）进行分配担保<br><img src=\"/images/jvm_gc_duplicate.jpg\" alt=\"\"></li>\n</ul>\n<h4 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h4><blockquote>\n<p>和“标记-清除算法”一样，但后续步骤是不是直接对可回收对象进行清理，而是 <strong>让所有存活的对象都向一端移动</strong></p>\n</blockquote>\n<p><img src=\"/images/jvm_gc_markarrange.jpg\" alt=\"\"></p>\n<h4 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h4><blockquote>\n<p>把Java堆分为 <strong>新生代</strong>和 <strong>老年代</strong>，这样可以根据各个年代的特点采用最适当的收集算法</p>\n</blockquote>\n<ul>\n<li>新生代每次垃圾收集都发现大批对象死去，只有少量存活，选用复制算法</li>\n<li>老年代对象存活率高、没有额外空间对它进行分配担保，使用“标记清理”或者“标记整理”算法</li>\n</ul>\n<hr>\n<h3 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h3><h4 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h4><p>在HotSpot中，使用OopMap来直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些未知是应用</p>\n<h4 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h4><ul>\n<li><p>HotSpot没有为每条指令都生成OopMap，只是在安全点（Safepoint）记录了这些信息</p>\n<blockquote>\n<p>即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</p>\n</blockquote>\n</li>\n<li><p>当GC发生时让所有线程都跑到最近的安全点上停顿下来的两种方案：</p>\n</li>\n</ul>\n<ol>\n<li>抢先式中断</li>\n<li>主动式中断： 当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志</li>\n</ol>\n<h4 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h4><p>指正在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。</p>\n<blockquote>\n<p>当线程执行到安全区域中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM发起GC时，就不用管标识自己为Safe Region的线程了</p>\n</blockquote>\n<hr>\n<h3 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h3><h4 id=\"1-对象有限在Eden分配\"><a href=\"#1-对象有限在Eden分配\" class=\"headerlink\" title=\"1. 对象有限在Eden分配\"></a>1. 对象有限在Eden分配</h4><ul>\n<li>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</li>\n<li>Minor GC期间虚拟机若发现已有的对象无法放入Survivor空间，就通过分配担保机制提前转移到老年代去</li>\n<li>新生代GC（Minor GC）与老年代GC（Major GC/Full GC）：<br>  i. 新生代GC：Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快<br>  ii. 老年代GC：出现了Major GC经常会伴随着至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上</li>\n</ul>\n<h4 id=\"2-大对象直接进入老年代\"><a href=\"#2-大对象直接进入老年代\" class=\"headerlink\" title=\"2. 大对象直接进入老年代\"></a>2. 大对象直接进入老年代</h4><ul>\n<li>大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组</li>\n<li>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，目的是避免在Eden区及两个Survivor区之间发送大量的内存复制</li>\n</ul>\n<h4 id=\"3-长期存活的对象将进入老年代\"><a href=\"#3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"3. 长期存活的对象将进入老年代\"></a>3. 长期存活的对象将进入老年代</h4><ul>\n<li>虚拟机给每个对象定义了一个对象年龄计数器</li>\n<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，对象年龄设为1</li>\n<li><p>对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（可以用过参数-XX：MaxTenuringThreshold设置，默认为15），就将会被晋升到老年代中</p>\n<h4 id=\"4-动态对象年龄判定\"><a href=\"#4-动态对象年龄判定\" class=\"headerlink\" title=\"4. 动态对象年龄判定\"></a>4. 动态对象年龄判定</h4></li>\n<li><p>虚拟机并不是永远地要求 对象的年龄必须达到了XX：MaxTenuringThreshold才能晋升老年代</p>\n</li>\n<li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代</li>\n</ul>\n<h4 id=\"5-空间分配担保\"><a href=\"#5-空间分配担保\" class=\"headerlink\" title=\"5. 空间分配担保\"></a>5. 空间分配担保</h4><ul>\n<li>发送Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可以确保是安全的</li>\n<li>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败：<ul>\n<li>如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小：<ul>\n<li>如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；</li>\n<li>如果小于，那么这时要改为进行一次Full GC</li>\n</ul>\n</li>\n<li>如果不允许，那么也要改为进行一次Full GC</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>JDK6 Update24之后规则变为只要老年代最大可用的连续空间大于新生代总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。（HandlePromotionFailure仍存在但不起影响）</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"对象存活判断算法\"><a href=\"#对象存活判断算法\" class=\"headerlink\" title=\"对象存活判断算法\"></a>对象存活判断算法</h3><h4 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h4><p>给对象添加一个引用计数器，有一个地方引用它计数值就加1，引用失效时减1，任何时刻计数器为0则不可能再被使用</p>\n<blockquote>\n<p>实现简单，判定效率高，但很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用这种方式管理内存</p>\n</blockquote>\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过 的路径称为引用链，当一个对象到GC Roots没有任何引用链时，证明此对象是不可用的</p>\n<blockquote>\n<p>Java中扩展为GC Roots的对象包括以下几种 ：</p>\n<ul>\n<li>虚拟机栈中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>\n</ul>\n</blockquote>\n<h4 id=\"对象死亡的判定\"><a href=\"#对象死亡的判定\" class=\"headerlink\" title=\"对象死亡的判定\"></a>对象死亡的判定</h4><p>真正宣告一个对象死亡，至少要经理两次标记过程：</p>\n<ol>\n<li>在进行可达性分析后发现不可达，将会被第一次标记并且进行一次筛选</li>\n</ol>\n<blockquote>\n<p>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，视为“没有必要执行<br>finalize”的情况，若有必要执行finalize，则将对象放入F-Queue的队列之中，并稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行。（一个对象的finalize()方法只会被系统调用一次）</p>\n</blockquote>\n<ol>\n<li>GC对F-Queue中的对象进行第二次标记</li>\n</ol>\n<blockquote>\n<p>对象逃脱的唯一机会就在finalize()方法中，只要重新与引用链上的任何一个对象建立关联即可</p>\n</blockquote>\n<h4 id=\"回收方法区（即HotSpot中的永久代）\"><a href=\"#回收方法区（即HotSpot中的永久代）\" class=\"headerlink\" title=\"回收方法区（即HotSpot中的永久代）\"></a>回收方法区（即HotSpot中的永久代）</h4><blockquote>\n<p>永久代的垃圾主要回收两部分的内容：废弃常量和无用的类。</p>\n</blockquote>\n<p>“无用的类”需要满足的三个条件：</p>\n<ol>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li>\n<li>加载该类的ClassLoader已经被回收</li>\n<li>该类对应的java.class.Class对象没有在任何地方被引用</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><h4 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h4><ul>\n<li><strong>标记阶段</strong>: 标记所有需要回收的对象</li>\n<li><strong>清除阶段</strong>: 统一回收所有被标记的对象<br><img src=\"/images/jvm_gc_markclean.jpg\" alt=\"\"><br>两个不足：</li>\n<li><strong>效率问题</strong>，标记和清除的效率都不高</li>\n<li><strong>空间问题</strong>，标记清除之后产生大量不连续的碎片</li>\n</ul>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><blockquote>\n<p>将可用内存按<strong>容量</strong>划分为大小相等的凉快，每次之使用给一块。当这一块的内存用完时，就将还存活的对象复制到另外一块上，然后把已使用过的内存空间一次清理掉。</p>\n</blockquote>\n<ul>\n<li>现在商业虚拟机用这种算法回收新生代，将内存分为一块 较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时将这两块上还存活的对象一次性复制到Survivor上，最后清理掉Eden和Survivor（在HotSpot默认Eden和Survivor的大小比例为8:1）</li>\n<li>当Survivor内存不够用时，需要依赖其他内存（这里指老年代）进行分配担保<br><img src=\"/images/jvm_gc_duplicate.jpg\" alt=\"\"></li>\n</ul>\n<h4 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h4><blockquote>\n<p>和“标记-清除算法”一样，但后续步骤是不是直接对可回收对象进行清理，而是 <strong>让所有存活的对象都向一端移动</strong></p>\n</blockquote>\n<p><img src=\"/images/jvm_gc_markarrange.jpg\" alt=\"\"></p>\n<h4 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h4><blockquote>\n<p>把Java堆分为 <strong>新生代</strong>和 <strong>老年代</strong>，这样可以根据各个年代的特点采用最适当的收集算法</p>\n</blockquote>\n<ul>\n<li>新生代每次垃圾收集都发现大批对象死去，只有少量存活，选用复制算法</li>\n<li>老年代对象存活率高、没有额外空间对它进行分配担保，使用“标记清理”或者“标记整理”算法</li>\n</ul>\n<hr>\n<h3 id=\"HotSpot的算法实现\"><a href=\"#HotSpot的算法实现\" class=\"headerlink\" title=\"HotSpot的算法实现\"></a>HotSpot的算法实现</h3><h4 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h4><p>在HotSpot中，使用OopMap来直接得知哪些地方存放着对象引用，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些未知是应用</p>\n<h4 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h4><ul>\n<li><p>HotSpot没有为每条指令都生成OopMap，只是在安全点（Safepoint）记录了这些信息</p>\n<blockquote>\n<p>即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</p>\n</blockquote>\n</li>\n<li><p>当GC发生时让所有线程都跑到最近的安全点上停顿下来的两种方案：</p>\n</li>\n</ul>\n<ol>\n<li>抢先式中断</li>\n<li>主动式中断： 当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志</li>\n</ol>\n<h4 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h4><p>指正在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。</p>\n<blockquote>\n<p>当线程执行到安全区域中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM发起GC时，就不用管标识自己为Safe Region的线程了</p>\n</blockquote>\n<hr>\n<h3 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h3><h4 id=\"1-对象有限在Eden分配\"><a href=\"#1-对象有限在Eden分配\" class=\"headerlink\" title=\"1. 对象有限在Eden分配\"></a>1. 对象有限在Eden分配</h4><ul>\n<li>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</li>\n<li>Minor GC期间虚拟机若发现已有的对象无法放入Survivor空间，就通过分配担保机制提前转移到老年代去</li>\n<li>新生代GC（Minor GC）与老年代GC（Major GC/Full GC）：<br>  i. 新生代GC：Java对象大多具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快<br>  ii. 老年代GC：出现了Major GC经常会伴随着至少一次的Minor GC，Major GC的速度一般会比Minor GC慢10倍以上</li>\n</ul>\n<h4 id=\"2-大对象直接进入老年代\"><a href=\"#2-大对象直接进入老年代\" class=\"headerlink\" title=\"2. 大对象直接进入老年代\"></a>2. 大对象直接进入老年代</h4><ul>\n<li>大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组</li>\n<li>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配，目的是避免在Eden区及两个Survivor区之间发送大量的内存复制</li>\n</ul>\n<h4 id=\"3-长期存活的对象将进入老年代\"><a href=\"#3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"3. 长期存活的对象将进入老年代\"></a>3. 长期存活的对象将进入老年代</h4><ul>\n<li>虚拟机给每个对象定义了一个对象年龄计数器</li>\n<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，对象年龄设为1</li>\n<li><p>对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（可以用过参数-XX：MaxTenuringThreshold设置，默认为15），就将会被晋升到老年代中</p>\n<h4 id=\"4-动态对象年龄判定\"><a href=\"#4-动态对象年龄判定\" class=\"headerlink\" title=\"4. 动态对象年龄判定\"></a>4. 动态对象年龄判定</h4></li>\n<li><p>虚拟机并不是永远地要求 对象的年龄必须达到了XX：MaxTenuringThreshold才能晋升老年代</p>\n</li>\n<li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代</li>\n</ul>\n<h4 id=\"5-空间分配担保\"><a href=\"#5-空间分配担保\" class=\"headerlink\" title=\"5. 空间分配担保\"></a>5. 空间分配担保</h4><ul>\n<li>发送Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么Minor GC可以确保是安全的</li>\n<li>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败：<ul>\n<li>如果允许，那么继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小：<ul>\n<li>如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；</li>\n<li>如果小于，那么这时要改为进行一次Full GC</li>\n</ul>\n</li>\n<li>如果不允许，那么也要改为进行一次Full GC</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>JDK6 Update24之后规则变为只要老年代最大可用的连续空间大于新生代总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。（HandlePromotionFailure仍存在但不起影响）</p>\n</blockquote>\n"},{"title":"Java内存模型","date":"2018-11-12T06:31:35.000Z","copyright":null,"_content":"\n### 主内存与工作内存\n\n- **主内存**: Java内存模型规定了所有的变量都存储在主内存中。\n    > 这里的主内存与物理硬件的主内存可以类比，但这里的主内存仅是指虚拟机内存的一部分。\n- **工作内存**: 每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中，而不能直接读写主内存中的变量。\n    > 工作内存可以与处理器的高速缓存类比\n- **线程、主内存、工作内存的交互关系**\n![](/images/thread_wm_mm.png)\n----\n\n### 内存间交互操作\n#### java内存模型定义的8种操作\n- **lock(锁定)**: 作用于主内存的变量，它把一个变量标识为一条线程独占的状态\n- **unlock(解锁)**: 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n- **read(读取)**: 作用于主内存的变量，它把一个变量的值从主内存传输到线程的总做内存中，以便随后的load动作使用\n- **load(载入)**: 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存给的变量副本中\n> 把一个变量从主内存复制到工作内存，那就要顺序地执行read和load，但不要求连续执行\n- **use(使用)**: 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时会执行这个操作\n- **assign(赋值)**: 作用于工作内存的变量，它把一个从执行亲情接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\n- **store(存储)**: 作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中一遍随后的write操作使用\n- **write(写入)**: 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中\n> 把一个变量从工作内存同步到主内存，那就要顺序地执行store和write，但不要求连续执行\n\n#### 8种操作需要满足的规则\n- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现\n- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须将该变化同步回主内存\n- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中\n- 一个新的变量只能在主内存”诞生“，不允许在工作内存中直接使用一个未被初始化（load或assign）的变脸，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作\n- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁\n- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这变量前，，需要重新执行load或assign操作初始化变量的值\n- 如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定住的变量\n- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存。\n\n----\n\n### volatile型变量的特殊规则\n#### volatile\n当一个变量定义为volatile之后，它将具备两种特性：\n- **可见性**: 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存完成\n\n    > volatile变量只能在一下两种场景保证可见性\n    1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值\n    2.变量不需要与其他的状态变量共同参与不变约束\n\n- **禁止指令重排序优化**: 普通变量仅仅会保证在该方法的执行过程中所有依赋值结果的地方都能获取到正确的结果，而不能保证变量复制的顺序与程序代码中的执行顺序一致。\n\n#### volatile与锁之间的区别\n\n> volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，**不过大多数场景volatile的总开销仍然要比锁低，我们在volatile与锁之间的选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求**\n\n#### volatile变量的特殊规则\n> 假设T表示一个线程，V和W分别表示两个volatile变量，在进行read、load、use、assign、store和write操作时需要满足如下规则：\n\n- 线程T对变量V的use动作可以认为是和线程T对变量的load、read动作的相关联，必须连续一起出现（即在工作内存中，每次使用V之前必须先从主内存刷新最新的值）\n- 线程T对变量V的assign动作可以认为是和线程T对变量的store、write动作的相关联，必须连续一起出现（即在工作内存中，每次修改V之后必须立刻同步回主内存中）\n- 假设A是T对V的use或assign动作，F是和A相关联的load或store动作，P是和F相关联的read或write动作；类似的B是T对W实施的use或assign动作，G是和B相关联的load或store动作，Q是和G相关联的read或write动作。 **如果A先于B，那么P先于Q**（这要求volatile变量不会被指令重排序优化）\n\n----\n\n### 原子性、可见性、有序性\n#### 原子性\n- 基本数据类型的访问读写是具备原子性的（long和double除外）\n- synchronized可以满足更大范围的原子性保证\n#### 可见性 \n> 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改\n- **volatile**： 保证多线程操作时变量的可见性而普通变量不可以\n- **synchronized**： 对一个变量执行unlock之前，必须先把此变量同步回主内存\n- **final**： 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递，拿在其他线程中就能看见final字段的值\n#### 有序性\n> 如果在本线程内管程，所有的操作都是有序的（线程内表现为串行）， 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序，工作内存与主内存同步延迟）\n\n- volatile关键字本身包含了禁止指令重排序的语义\n- synchronized决定了持有用一个锁的同步快只能串行地进行\n\n----\n\n### “天然的“先行发生关系\n\n- **程序次序规则**: 在一个线程内，按照控制流顺序发生\n- **管程锁定规则**: 一个unlock操作先行发生于后面对同一个锁的lock操作\n- **volatile变量规则**: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作\n- **线程启动规则**: Thread对象的start（）方法先行发生于此线程的每一个动作\n- **线程中止规则**: 线程中的所有操作都先行发生于对此线程的终止检测\n- **线程中断规则**: 对线程interrupt（）方法的调动先行发生于被中断线程的代码检测到中断事件的发生\n- **对象终结规则**: 一个对象的初始化完成先行发生于他的finalize（）方法的开始\n- **传递性**: A先行发生于B，B先行发生于C，则A先行发生于C\n\n> 这些先行发生关系无须任何同步协助就已经存在，可以直接使用\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/深入理解Java虚拟机之Java内存模型.md","raw":"---\ntitle: Java内存模型\ndate: 2018-11-12 14:31:35\ncategories: \"深入理解java虚拟机笔记\"\ntags:\n - JVM\ncopyright:\n---\n\n### 主内存与工作内存\n\n- **主内存**: Java内存模型规定了所有的变量都存储在主内存中。\n    > 这里的主内存与物理硬件的主内存可以类比，但这里的主内存仅是指虚拟机内存的一部分。\n- **工作内存**: 每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中，而不能直接读写主内存中的变量。\n    > 工作内存可以与处理器的高速缓存类比\n- **线程、主内存、工作内存的交互关系**\n![](/images/thread_wm_mm.png)\n----\n\n### 内存间交互操作\n#### java内存模型定义的8种操作\n- **lock(锁定)**: 作用于主内存的变量，它把一个变量标识为一条线程独占的状态\n- **unlock(解锁)**: 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n- **read(读取)**: 作用于主内存的变量，它把一个变量的值从主内存传输到线程的总做内存中，以便随后的load动作使用\n- **load(载入)**: 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存给的变量副本中\n> 把一个变量从主内存复制到工作内存，那就要顺序地执行read和load，但不要求连续执行\n- **use(使用)**: 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时会执行这个操作\n- **assign(赋值)**: 作用于工作内存的变量，它把一个从执行亲情接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\n- **store(存储)**: 作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中一遍随后的write操作使用\n- **write(写入)**: 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中\n> 把一个变量从工作内存同步到主内存，那就要顺序地执行store和write，但不要求连续执行\n\n#### 8种操作需要满足的规则\n- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现\n- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须将该变化同步回主内存\n- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中\n- 一个新的变量只能在主内存”诞生“，不允许在工作内存中直接使用一个未被初始化（load或assign）的变脸，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作\n- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁\n- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这变量前，，需要重新执行load或assign操作初始化变量的值\n- 如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定住的变量\n- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存。\n\n----\n\n### volatile型变量的特殊规则\n#### volatile\n当一个变量定义为volatile之后，它将具备两种特性：\n- **可见性**: 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存完成\n\n    > volatile变量只能在一下两种场景保证可见性\n    1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值\n    2.变量不需要与其他的状态变量共同参与不变约束\n\n- **禁止指令重排序优化**: 普通变量仅仅会保证在该方法的执行过程中所有依赋值结果的地方都能获取到正确的结果，而不能保证变量复制的顺序与程序代码中的执行顺序一致。\n\n#### volatile与锁之间的区别\n\n> volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，**不过大多数场景volatile的总开销仍然要比锁低，我们在volatile与锁之间的选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求**\n\n#### volatile变量的特殊规则\n> 假设T表示一个线程，V和W分别表示两个volatile变量，在进行read、load、use、assign、store和write操作时需要满足如下规则：\n\n- 线程T对变量V的use动作可以认为是和线程T对变量的load、read动作的相关联，必须连续一起出现（即在工作内存中，每次使用V之前必须先从主内存刷新最新的值）\n- 线程T对变量V的assign动作可以认为是和线程T对变量的store、write动作的相关联，必须连续一起出现（即在工作内存中，每次修改V之后必须立刻同步回主内存中）\n- 假设A是T对V的use或assign动作，F是和A相关联的load或store动作，P是和F相关联的read或write动作；类似的B是T对W实施的use或assign动作，G是和B相关联的load或store动作，Q是和G相关联的read或write动作。 **如果A先于B，那么P先于Q**（这要求volatile变量不会被指令重排序优化）\n\n----\n\n### 原子性、可见性、有序性\n#### 原子性\n- 基本数据类型的访问读写是具备原子性的（long和double除外）\n- synchronized可以满足更大范围的原子性保证\n#### 可见性 \n> 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改\n- **volatile**： 保证多线程操作时变量的可见性而普通变量不可以\n- **synchronized**： 对一个变量执行unlock之前，必须先把此变量同步回主内存\n- **final**： 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递，拿在其他线程中就能看见final字段的值\n#### 有序性\n> 如果在本线程内管程，所有的操作都是有序的（线程内表现为串行）， 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序，工作内存与主内存同步延迟）\n\n- volatile关键字本身包含了禁止指令重排序的语义\n- synchronized决定了持有用一个锁的同步快只能串行地进行\n\n----\n\n### “天然的“先行发生关系\n\n- **程序次序规则**: 在一个线程内，按照控制流顺序发生\n- **管程锁定规则**: 一个unlock操作先行发生于后面对同一个锁的lock操作\n- **volatile变量规则**: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作\n- **线程启动规则**: Thread对象的start（）方法先行发生于此线程的每一个动作\n- **线程中止规则**: 线程中的所有操作都先行发生于对此线程的终止检测\n- **线程中断规则**: 对线程interrupt（）方法的调动先行发生于被中断线程的代码检测到中断事件的发生\n- **对象终结规则**: 一个对象的初始化完成先行发生于他的finalize（）方法的开始\n- **传递性**: A先行发生于B，B先行发生于C，则A先行发生于C\n\n> 这些先行发生关系无须任何同步协助就已经存在，可以直接使用\n\n\n\n\n\n\n\n\n\n\n","slug":"深入理解Java虚拟机之Java内存模型","published":1,"updated":"2018-12-07T13:19:09.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fe1002vu7yjtwa5c6p4","content":"<h3 id=\"主内存与工作内存\"><a href=\"#主内存与工作内存\" class=\"headerlink\" title=\"主内存与工作内存\"></a>主内存与工作内存</h3><ul>\n<li><strong>主内存</strong>: Java内存模型规定了所有的变量都存储在主内存中。<blockquote>\n<p>这里的主内存与物理硬件的主内存可以类比，但这里的主内存仅是指虚拟机内存的一部分。</p>\n</blockquote>\n</li>\n<li><strong>工作内存</strong>: 每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中，而不能直接读写主内存中的变量。<blockquote>\n<p>工作内存可以与处理器的高速缓存类比</p>\n</blockquote>\n</li>\n<li><strong>线程、主内存、工作内存的交互关系</strong><br><img src=\"/images/thread_wm_mm.png\" alt=\"\"></li>\n</ul>\n<hr>\n<h3 id=\"内存间交互操作\"><a href=\"#内存间交互操作\" class=\"headerlink\" title=\"内存间交互操作\"></a>内存间交互操作</h3><h4 id=\"java内存模型定义的8种操作\"><a href=\"#java内存模型定义的8种操作\" class=\"headerlink\" title=\"java内存模型定义的8种操作\"></a>java内存模型定义的8种操作</h4><ul>\n<li><strong>lock(锁定)</strong>: 作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li>\n<li><strong>unlock(解锁)</strong>: 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>\n<li><strong>read(读取)</strong>: 作用于主内存的变量，它把一个变量的值从主内存传输到线程的总做内存中，以便随后的load动作使用</li>\n<li><strong>load(载入)</strong>: 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存给的变量副本中<blockquote>\n<p>把一个变量从主内存复制到工作内存，那就要顺序地执行read和load，但不要求连续执行</p>\n</blockquote>\n</li>\n<li><strong>use(使用)</strong>: 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时会执行这个操作</li>\n<li><strong>assign(赋值)</strong>: 作用于工作内存的变量，它把一个从执行亲情接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>\n<li><strong>store(存储)</strong>: 作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中一遍随后的write操作使用</li>\n<li><strong>write(写入)</strong>: 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中<blockquote>\n<p>把一个变量从工作内存同步到主内存，那就要顺序地执行store和write，但不要求连续执行</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"8种操作需要满足的规则\"><a href=\"#8种操作需要满足的规则\" class=\"headerlink\" title=\"8种操作需要满足的规则\"></a>8种操作需要满足的规则</h4><ul>\n<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现</li>\n<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须将该变化同步回主内存</li>\n<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li>\n<li>一个新的变量只能在主内存”诞生“，不允许在工作内存中直接使用一个未被初始化（load或assign）的变脸，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作</li>\n<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li>\n<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这变量前，，需要重新执行load或assign操作初始化变量的值</li>\n<li>如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定住的变量</li>\n<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存。</li>\n</ul>\n<hr>\n<h3 id=\"volatile型变量的特殊规则\"><a href=\"#volatile型变量的特殊规则\" class=\"headerlink\" title=\"volatile型变量的特殊规则\"></a>volatile型变量的特殊规则</h3><h4 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h4><p>当一个变量定义为volatile之后，它将具备两种特性：</p>\n<ul>\n<li><p><strong>可见性</strong>: 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存完成</p>\n<blockquote>\n<p>volatile变量只能在一下两种场景保证可见性<br>  1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值<br>  2.变量不需要与其他的状态变量共同参与不变约束</p>\n</blockquote>\n</li>\n<li><p><strong>禁止指令重排序优化</strong>: 普通变量仅仅会保证在该方法的执行过程中所有依赋值结果的地方都能获取到正确的结果，而不能保证变量复制的顺序与程序代码中的执行顺序一致。</p>\n</li>\n</ul>\n<h4 id=\"volatile与锁之间的区别\"><a href=\"#volatile与锁之间的区别\" class=\"headerlink\" title=\"volatile与锁之间的区别\"></a>volatile与锁之间的区别</h4><blockquote>\n<p>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，<strong>不过大多数场景volatile的总开销仍然要比锁低，我们在volatile与锁之间的选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求</strong></p>\n</blockquote>\n<h4 id=\"volatile变量的特殊规则\"><a href=\"#volatile变量的特殊规则\" class=\"headerlink\" title=\"volatile变量的特殊规则\"></a>volatile变量的特殊规则</h4><blockquote>\n<p>假设T表示一个线程，V和W分别表示两个volatile变量，在进行read、load、use、assign、store和write操作时需要满足如下规则：</p>\n</blockquote>\n<ul>\n<li>线程T对变量V的use动作可以认为是和线程T对变量的load、read动作的相关联，必须连续一起出现（即在工作内存中，每次使用V之前必须先从主内存刷新最新的值）</li>\n<li>线程T对变量V的assign动作可以认为是和线程T对变量的store、write动作的相关联，必须连续一起出现（即在工作内存中，每次修改V之后必须立刻同步回主内存中）</li>\n<li>假设A是T对V的use或assign动作，F是和A相关联的load或store动作，P是和F相关联的read或write动作；类似的B是T对W实施的use或assign动作，G是和B相关联的load或store动作，Q是和G相关联的read或write动作。 <strong>如果A先于B，那么P先于Q</strong>（这要求volatile变量不会被指令重排序优化）</li>\n</ul>\n<hr>\n<h3 id=\"原子性、可见性、有序性\"><a href=\"#原子性、可见性、有序性\" class=\"headerlink\" title=\"原子性、可见性、有序性\"></a>原子性、可见性、有序性</h3><h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><ul>\n<li>基本数据类型的访问读写是具备原子性的（long和double除外）</li>\n<li>synchronized可以满足更大范围的原子性保证<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><blockquote>\n<p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</p>\n</blockquote>\n</li>\n<li><strong>volatile</strong>： 保证多线程操作时变量的可见性而普通变量不可以</li>\n<li><strong>synchronized</strong>： 对一个变量执行unlock之前，必须先把此变量同步回主内存</li>\n<li><p><strong>final</strong>： 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递，拿在其他线程中就能看见final字段的值</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><blockquote>\n<p>如果在本线程内管程，所有的操作都是有序的（线程内表现为串行）， 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序，工作内存与主内存同步延迟）</p>\n</blockquote>\n</li>\n<li><p>volatile关键字本身包含了禁止指令重排序的语义</p>\n</li>\n<li>synchronized决定了持有用一个锁的同步快只能串行地进行</li>\n</ul>\n<hr>\n<h3 id=\"“天然的“先行发生关系\"><a href=\"#“天然的“先行发生关系\" class=\"headerlink\" title=\"“天然的“先行发生关系\"></a>“天然的“先行发生关系</h3><ul>\n<li><strong>程序次序规则</strong>: 在一个线程内，按照控制流顺序发生</li>\n<li><strong>管程锁定规则</strong>: 一个unlock操作先行发生于后面对同一个锁的lock操作</li>\n<li><strong>volatile变量规则</strong>: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li>\n<li><strong>线程启动规则</strong>: Thread对象的start（）方法先行发生于此线程的每一个动作</li>\n<li><strong>线程中止规则</strong>: 线程中的所有操作都先行发生于对此线程的终止检测</li>\n<li><strong>线程中断规则</strong>: 对线程interrupt（）方法的调动先行发生于被中断线程的代码检测到中断事件的发生</li>\n<li><strong>对象终结规则</strong>: 一个对象的初始化完成先行发生于他的finalize（）方法的开始</li>\n<li><strong>传递性</strong>: A先行发生于B，B先行发生于C，则A先行发生于C</li>\n</ul>\n<blockquote>\n<p>这些先行发生关系无须任何同步协助就已经存在，可以直接使用</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"主内存与工作内存\"><a href=\"#主内存与工作内存\" class=\"headerlink\" title=\"主内存与工作内存\"></a>主内存与工作内存</h3><ul>\n<li><strong>主内存</strong>: Java内存模型规定了所有的变量都存储在主内存中。<blockquote>\n<p>这里的主内存与物理硬件的主内存可以类比，但这里的主内存仅是指虚拟机内存的一部分。</p>\n</blockquote>\n</li>\n<li><strong>工作内存</strong>: 每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中，而不能直接读写主内存中的变量。<blockquote>\n<p>工作内存可以与处理器的高速缓存类比</p>\n</blockquote>\n</li>\n<li><strong>线程、主内存、工作内存的交互关系</strong><br><img src=\"/images/thread_wm_mm.png\" alt=\"\"></li>\n</ul>\n<hr>\n<h3 id=\"内存间交互操作\"><a href=\"#内存间交互操作\" class=\"headerlink\" title=\"内存间交互操作\"></a>内存间交互操作</h3><h4 id=\"java内存模型定义的8种操作\"><a href=\"#java内存模型定义的8种操作\" class=\"headerlink\" title=\"java内存模型定义的8种操作\"></a>java内存模型定义的8种操作</h4><ul>\n<li><strong>lock(锁定)</strong>: 作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li>\n<li><strong>unlock(解锁)</strong>: 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>\n<li><strong>read(读取)</strong>: 作用于主内存的变量，它把一个变量的值从主内存传输到线程的总做内存中，以便随后的load动作使用</li>\n<li><strong>load(载入)</strong>: 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存给的变量副本中<blockquote>\n<p>把一个变量从主内存复制到工作内存，那就要顺序地执行read和load，但不要求连续执行</p>\n</blockquote>\n</li>\n<li><strong>use(使用)</strong>: 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时会执行这个操作</li>\n<li><strong>assign(赋值)</strong>: 作用于工作内存的变量，它把一个从执行亲情接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>\n<li><strong>store(存储)</strong>: 作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中一遍随后的write操作使用</li>\n<li><strong>write(写入)</strong>: 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中<blockquote>\n<p>把一个变量从工作内存同步到主内存，那就要顺序地执行store和write，但不要求连续执行</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"8种操作需要满足的规则\"><a href=\"#8种操作需要满足的规则\" class=\"headerlink\" title=\"8种操作需要满足的规则\"></a>8种操作需要满足的规则</h4><ul>\n<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现</li>\n<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须将该变化同步回主内存</li>\n<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li>\n<li>一个新的变量只能在主内存”诞生“，不允许在工作内存中直接使用一个未被初始化（load或assign）的变脸，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作</li>\n<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li>\n<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这变量前，，需要重新执行load或assign操作初始化变量的值</li>\n<li>如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定住的变量</li>\n<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存。</li>\n</ul>\n<hr>\n<h3 id=\"volatile型变量的特殊规则\"><a href=\"#volatile型变量的特殊规则\" class=\"headerlink\" title=\"volatile型变量的特殊规则\"></a>volatile型变量的特殊规则</h3><h4 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h4><p>当一个变量定义为volatile之后，它将具备两种特性：</p>\n<ul>\n<li><p><strong>可见性</strong>: 当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递需要通过主内存完成</p>\n<blockquote>\n<p>volatile变量只能在一下两种场景保证可见性<br>  1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值<br>  2.变量不需要与其他的状态变量共同参与不变约束</p>\n</blockquote>\n</li>\n<li><p><strong>禁止指令重排序优化</strong>: 普通变量仅仅会保证在该方法的执行过程中所有依赋值结果的地方都能获取到正确的结果，而不能保证变量复制的顺序与程序代码中的执行顺序一致。</p>\n</li>\n</ul>\n<h4 id=\"volatile与锁之间的区别\"><a href=\"#volatile与锁之间的区别\" class=\"headerlink\" title=\"volatile与锁之间的区别\"></a>volatile与锁之间的区别</h4><blockquote>\n<p>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，<strong>不过大多数场景volatile的总开销仍然要比锁低，我们在volatile与锁之间的选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求</strong></p>\n</blockquote>\n<h4 id=\"volatile变量的特殊规则\"><a href=\"#volatile变量的特殊规则\" class=\"headerlink\" title=\"volatile变量的特殊规则\"></a>volatile变量的特殊规则</h4><blockquote>\n<p>假设T表示一个线程，V和W分别表示两个volatile变量，在进行read、load、use、assign、store和write操作时需要满足如下规则：</p>\n</blockquote>\n<ul>\n<li>线程T对变量V的use动作可以认为是和线程T对变量的load、read动作的相关联，必须连续一起出现（即在工作内存中，每次使用V之前必须先从主内存刷新最新的值）</li>\n<li>线程T对变量V的assign动作可以认为是和线程T对变量的store、write动作的相关联，必须连续一起出现（即在工作内存中，每次修改V之后必须立刻同步回主内存中）</li>\n<li>假设A是T对V的use或assign动作，F是和A相关联的load或store动作，P是和F相关联的read或write动作；类似的B是T对W实施的use或assign动作，G是和B相关联的load或store动作，Q是和G相关联的read或write动作。 <strong>如果A先于B，那么P先于Q</strong>（这要求volatile变量不会被指令重排序优化）</li>\n</ul>\n<hr>\n<h3 id=\"原子性、可见性、有序性\"><a href=\"#原子性、可见性、有序性\" class=\"headerlink\" title=\"原子性、可见性、有序性\"></a>原子性、可见性、有序性</h3><h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><ul>\n<li>基本数据类型的访问读写是具备原子性的（long和double除外）</li>\n<li>synchronized可以满足更大范围的原子性保证<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><blockquote>\n<p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改</p>\n</blockquote>\n</li>\n<li><strong>volatile</strong>： 保证多线程操作时变量的可见性而普通变量不可以</li>\n<li><strong>synchronized</strong>： 对一个变量执行unlock之前，必须先把此变量同步回主内存</li>\n<li><p><strong>final</strong>： 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递，拿在其他线程中就能看见final字段的值</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><blockquote>\n<p>如果在本线程内管程，所有的操作都是有序的（线程内表现为串行）， 如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序，工作内存与主内存同步延迟）</p>\n</blockquote>\n</li>\n<li><p>volatile关键字本身包含了禁止指令重排序的语义</p>\n</li>\n<li>synchronized决定了持有用一个锁的同步快只能串行地进行</li>\n</ul>\n<hr>\n<h3 id=\"“天然的“先行发生关系\"><a href=\"#“天然的“先行发生关系\" class=\"headerlink\" title=\"“天然的“先行发生关系\"></a>“天然的“先行发生关系</h3><ul>\n<li><strong>程序次序规则</strong>: 在一个线程内，按照控制流顺序发生</li>\n<li><strong>管程锁定规则</strong>: 一个unlock操作先行发生于后面对同一个锁的lock操作</li>\n<li><strong>volatile变量规则</strong>: 对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li>\n<li><strong>线程启动规则</strong>: Thread对象的start（）方法先行发生于此线程的每一个动作</li>\n<li><strong>线程中止规则</strong>: 线程中的所有操作都先行发生于对此线程的终止检测</li>\n<li><strong>线程中断规则</strong>: 对线程interrupt（）方法的调动先行发生于被中断线程的代码检测到中断事件的发生</li>\n<li><strong>对象终结规则</strong>: 一个对象的初始化完成先行发生于他的finalize（）方法的开始</li>\n<li><strong>传递性</strong>: A先行发生于B，B先行发生于C，则A先行发生于C</li>\n</ul>\n<blockquote>\n<p>这些先行发生关系无须任何同步协助就已经存在，可以直接使用</p>\n</blockquote>\n"},{"title":"深入理解Java虚拟机之虚拟机类加载机制","date":"2018-11-30T13:18:22.000Z","copyright":null,"_content":"### 类加载的时机\n- 类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载，其中验证、准备、解析3个部分统称为 **连接**\n- 加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，但是解析阶段则不一定，有些情况下可在初始化阶段之后再开始（为了支持Java语言的运行时绑定）\n- 虚拟机规范严格规定了 **有且只有**5种情况必须立即对类进行“初始化”：\n    - 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时\n    - 使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化\n    - 当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化\n    - 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类\n    - 使用JDK1,7的动态语言支持时，java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄\n\n> 这5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用\n\n- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\n----\n### 类加载的过程\n#### 1. 加载\n在加载阶段，虚拟机需要完成以下3件事：\n    - 通过一个类的全限定名来获取定义此类的二进制字节流\n    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n- 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中\n- 对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面\n\n#### 2. 验证\n验证阶段大致上会完成下面4个阶段的校验动作：**文件格式验证、元数据验证、字节码验证、符号引用验证**:\n- **文件格式验证**：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，保证输入的字节流能正确地解析并存储于方法区，格式上符合描述一个Java类型信息的要求\n- **元数据验证**:对类的元数据信息语义校验，保证不存在不符合Java语言规范的元数据信息\n- **字节码验证**:通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的\n- **符合引用验证**:可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行，发生在虚拟机将符号引用转化为直接引用时\n> 如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间\n- 验证的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全\n\n#### 3. 准备\n准备阶段是 **正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值）** 的阶段，这些变量所使用的内存都将在方法区中进行分配\n- 这里进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中\n- 如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值\n\n#### 4. 解析\n解析阶段是 **虚拟机将常量池内的符号引用替换为直接引用的过程** \n- **符号引用与直接引用**：\n    - 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可\n    - 直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄\n\n- **解析发生的时间**：虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它\n- 除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行\n- **解析动作**：\n    - 类和接口的解析\n    - 字段解析\n    - 类方法解析\n    - 接口方法解析\n    \n#### 5. 初始化\n在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，可以从另外一个角度来表达：初始化阶段是执行类构造器`<clinit>()`方法的过程\n- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。\n示例：\n```java\npublic class Test {\n    static {\n        i = 0;  //  给变量复制可以正常编译通过\n        System.out.print(i);  // 这句编译器会提示“非法向前引用”  \n    }\n    static int i = 1;\n}\n```\n- 虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕\n- 父类的`<clinit>()`方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作\n- `<clinit>()`方法对于类和接口不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法\n- 执行接口的`<clinit>()`方法不需要先执行父接口菜单`<clinit>()`方法，只要当父接口中定义的变量使用时，父接口才会初始化\n- 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步\n\n----\n### 类加载器\n#### 类与类加载器\n对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。\n> 即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等\n\n#### 双亲委派模型\n从Java虚拟机的角度来讲，只存在两种不同的类加载器：\ni. 启动类加载器，是虚拟机的一部分;\nii. 另一种是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader\n\n- **启动类加载器**：负责将存放在<JAVA_HOME>\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，开发者无法直接引用\n- **扩展类加载器**：负责加载<JAVA_HOME>\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用\n- **应用程序类加载器**：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，开发者可以直接使用\n- **双亲委派模型的工作过程**：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载\n> 这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码\n\n![](/images/jvm_classloader_doubleparent.jpg)\n\n\n","source":"_posts/深入理解Java虚拟机之虚拟机类加载机制.md","raw":"---\ntitle: 深入理解Java虚拟机之虚拟机类加载机制\ndate: 2018-11-30 21:18:22\ncategories: \"深入理解java虚拟机笔记\"\ntags:\n    - JVM\ncopyright:\n---\n### 类加载的时机\n- 类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载，其中验证、准备、解析3个部分统称为 **连接**\n- 加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，但是解析阶段则不一定，有些情况下可在初始化阶段之后再开始（为了支持Java语言的运行时绑定）\n- 虚拟机规范严格规定了 **有且只有**5种情况必须立即对类进行“初始化”：\n    - 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时\n    - 使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化\n    - 当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化\n    - 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类\n    - 使用JDK1,7的动态语言支持时，java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄\n\n> 这5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用\n\n- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\n----\n### 类加载的过程\n#### 1. 加载\n在加载阶段，虚拟机需要完成以下3件事：\n    - 通过一个类的全限定名来获取定义此类的二进制字节流\n    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n- 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中\n- 对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面\n\n#### 2. 验证\n验证阶段大致上会完成下面4个阶段的校验动作：**文件格式验证、元数据验证、字节码验证、符号引用验证**:\n- **文件格式验证**：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，保证输入的字节流能正确地解析并存储于方法区，格式上符合描述一个Java类型信息的要求\n- **元数据验证**:对类的元数据信息语义校验，保证不存在不符合Java语言规范的元数据信息\n- **字节码验证**:通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的\n- **符合引用验证**:可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行，发生在虚拟机将符号引用转化为直接引用时\n> 如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间\n- 验证的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全\n\n#### 3. 准备\n准备阶段是 **正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值）** 的阶段，这些变量所使用的内存都将在方法区中进行分配\n- 这里进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中\n- 如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值\n\n#### 4. 解析\n解析阶段是 **虚拟机将常量池内的符号引用替换为直接引用的过程** \n- **符号引用与直接引用**：\n    - 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可\n    - 直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄\n\n- **解析发生的时间**：虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它\n- 除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行\n- **解析动作**：\n    - 类和接口的解析\n    - 字段解析\n    - 类方法解析\n    - 接口方法解析\n    \n#### 5. 初始化\n在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，可以从另外一个角度来表达：初始化阶段是执行类构造器`<clinit>()`方法的过程\n- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。\n示例：\n```java\npublic class Test {\n    static {\n        i = 0;  //  给变量复制可以正常编译通过\n        System.out.print(i);  // 这句编译器会提示“非法向前引用”  \n    }\n    static int i = 1;\n}\n```\n- 虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕\n- 父类的`<clinit>()`方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作\n- `<clinit>()`方法对于类和接口不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法\n- 执行接口的`<clinit>()`方法不需要先执行父接口菜单`<clinit>()`方法，只要当父接口中定义的变量使用时，父接口才会初始化\n- 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步\n\n----\n### 类加载器\n#### 类与类加载器\n对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。\n> 即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等\n\n#### 双亲委派模型\n从Java虚拟机的角度来讲，只存在两种不同的类加载器：\ni. 启动类加载器，是虚拟机的一部分;\nii. 另一种是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader\n\n- **启动类加载器**：负责将存放在<JAVA_HOME>\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，开发者无法直接引用\n- **扩展类加载器**：负责加载<JAVA_HOME>\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用\n- **应用程序类加载器**：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，开发者可以直接使用\n- **双亲委派模型的工作过程**：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载\n> 这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码\n\n![](/images/jvm_classloader_doubleparent.jpg)\n\n\n","slug":"深入理解Java虚拟机之虚拟机类加载机制","published":1,"updated":"2018-12-07T13:37:42.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fe3002yu7yjei31bbai","content":"<h3 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h3><ul>\n<li>类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载，其中验证、准备、解析3个部分统称为 <strong>连接</strong></li>\n<li>加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，但是解析阶段则不一定，有些情况下可在初始化阶段之后再开始（为了支持Java语言的运行时绑定）</li>\n<li>虚拟机规范严格规定了 <strong>有且只有</strong>5种情况必须立即对类进行“初始化”：<ul>\n<li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化</li>\n<li>当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化</li>\n<li>虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li>\n<li>使用JDK1,7的动态语言支持时，java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用</p>\n</blockquote>\n<h2 id=\"当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\"><a href=\"#当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\" class=\"headerlink\" title=\"- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\"></a>- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化</h2><h3 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h3><h4 id=\"1-加载\"><a href=\"#1-加载\" class=\"headerlink\" title=\"1. 加载\"></a>1. 加载</h4><p>在加载阶段，虚拟机需要完成以下3件事：</p>\n<pre><code>- 通过一个类的全限定名来获取定义此类的二进制字节流\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n</code></pre><ul>\n<li>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中</li>\n<li>对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面</li>\n</ul>\n<h4 id=\"2-验证\"><a href=\"#2-验证\" class=\"headerlink\" title=\"2. 验证\"></a>2. 验证</h4><p>验证阶段大致上会完成下面4个阶段的校验动作：<strong>文件格式验证、元数据验证、字节码验证、符号引用验证</strong>:</p>\n<ul>\n<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，保证输入的字节流能正确地解析并存储于方法区，格式上符合描述一个Java类型信息的要求</li>\n<li><strong>元数据验证</strong>:对类的元数据信息语义校验，保证不存在不符合Java语言规范的元数据信息</li>\n<li><strong>字节码验证</strong>:通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li>\n<li><strong>符合引用验证</strong>:可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行，发生在虚拟机将符号引用转化为直接引用时<blockquote>\n<p>如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p>\n</blockquote>\n</li>\n<li>验证的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>\n</ul>\n<h4 id=\"3-准备\"><a href=\"#3-准备\" class=\"headerlink\" title=\"3. 准备\"></a>3. 准备</h4><p>准备阶段是 <strong>正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值）</strong> 的阶段，这些变量所使用的内存都将在方法区中进行分配</p>\n<ul>\n<li>这里进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中</li>\n<li>如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值</li>\n</ul>\n<h4 id=\"4-解析\"><a href=\"#4-解析\" class=\"headerlink\" title=\"4. 解析\"></a>4. 解析</h4><p>解析阶段是 <strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong> </p>\n<ul>\n<li><p><strong>符号引用与直接引用</strong>：</p>\n<ul>\n<li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</li>\n<li>直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li>\n</ul>\n</li>\n<li><p><strong>解析发生的时间</strong>：虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它</p>\n</li>\n<li>除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行</li>\n<li><strong>解析动作</strong>：<ul>\n<li>类和接口的解析</li>\n<li>字段解析</li>\n<li>类方法解析</li>\n<li>接口方法解析</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-初始化\"><a href=\"#5-初始化\" class=\"headerlink\" title=\"5. 初始化\"></a>5. 初始化</h4><p>在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，可以从另外一个角度来表达：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</p>\n<ul>\n<li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<br>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;  <span class=\"comment\">//  给变量复制可以正常编译通过</span></span><br><span class=\"line\">        System.out.print(i);  <span class=\"comment\">// 这句编译器会提示“非法向前引用”  </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕</p>\n</li>\n<li>父类的<code>&lt;clinit&gt;()</code>方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作</li>\n<li><code>&lt;clinit&gt;()</code>方法对于类和接口不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li>\n<li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口菜单<code>&lt;clinit&gt;()</code>方法，只要当父接口中定义的变量使用时，父接口才会初始化</li>\n<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步</li>\n</ul>\n<hr>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><h4 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h4><p>对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>\n<blockquote>\n<p>即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p>\n</blockquote>\n<h4 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h4><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：<br>i. 启动类加载器，是虚拟机的一部分;<br>ii. 另一种是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader</p>\n<ul>\n<li><strong>启动类加载器</strong>：负责将存放在<java_home>\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，开发者无法直接引用</java_home></li>\n<li><strong>扩展类加载器</strong>：负责加载<java_home>\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用</java_home></li>\n<li><strong>应用程序类加载器</strong>：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，开发者可以直接使用</li>\n<li><strong>双亲委派模型的工作过程</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载<blockquote>\n<p>这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/images/jvm_classloader_doubleparent.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h3><ul>\n<li>类从被加载到虚拟机内存中开始，到卸载出内存为止，他的生命周期包括：加载、验证、准备、解析、初始化、使用和卸载，其中验证、准备、解析3个部分统称为 <strong>连接</strong></li>\n<li>加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，但是解析阶段则不一定，有些情况下可在初始化阶段之后再开始（为了支持Java语言的运行时绑定）</li>\n<li>虚拟机规范严格规定了 <strong>有且只有</strong>5种情况必须立即对类进行“初始化”：<ul>\n<li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用时，若类没有进行过初始化，则需要先触发其初始化</li>\n<li>当初始化一个类时，如果其父类还没有进行过初始化，则需要先触发其父类的初始化</li>\n<li>虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li>\n<li>使用JDK1,7的动态语言支持时，java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这5中场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用</p>\n</blockquote>\n<h2 id=\"当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\"><a href=\"#当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\" class=\"headerlink\" title=\"- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化\"></a>- 当一个类在初始化时，要求其父类全都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全都完成了初始化，只有在真正使用到父接接口的时候（如引用接口中定义的常量）才会初始化</h2><h3 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h3><h4 id=\"1-加载\"><a href=\"#1-加载\" class=\"headerlink\" title=\"1. 加载\"></a>1. 加载</h4><p>在加载阶段，虚拟机需要完成以下3件事：</p>\n<pre><code>- 通过一个类的全限定名来获取定义此类的二进制字节流\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n</code></pre><ul>\n<li>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中</li>\n<li>对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面</li>\n</ul>\n<h4 id=\"2-验证\"><a href=\"#2-验证\" class=\"headerlink\" title=\"2. 验证\"></a>2. 验证</h4><p>验证阶段大致上会完成下面4个阶段的校验动作：<strong>文件格式验证、元数据验证、字节码验证、符号引用验证</strong>:</p>\n<ul>\n<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，保证输入的字节流能正确地解析并存储于方法区，格式上符合描述一个Java类型信息的要求</li>\n<li><strong>元数据验证</strong>:对类的元数据信息语义校验，保证不存在不符合Java语言规范的元数据信息</li>\n<li><strong>字节码验证</strong>:通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li>\n<li><strong>符合引用验证</strong>:可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行，发生在虚拟机将符号引用转化为直接引用时<blockquote>\n<p>如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p>\n</blockquote>\n</li>\n<li>验证的目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全</li>\n</ul>\n<h4 id=\"3-准备\"><a href=\"#3-准备\" class=\"headerlink\" title=\"3. 准备\"></a>3. 准备</h4><p>准备阶段是 <strong>正式为类变量分配内存并设置类变量初始值（通常情况下是数据类型的零值）</strong> 的阶段，这些变量所使用的内存都将在方法区中进行分配</p>\n<ul>\n<li>这里进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中</li>\n<li>如果类字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值</li>\n</ul>\n<h4 id=\"4-解析\"><a href=\"#4-解析\" class=\"headerlink\" title=\"4. 解析\"></a>4. 解析</h4><p>解析阶段是 <strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong> </p>\n<ul>\n<li><p><strong>符号引用与直接引用</strong>：</p>\n<ul>\n<li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</li>\n<li>直接引用：可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄</li>\n</ul>\n</li>\n<li><p><strong>解析发生的时间</strong>：虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它</p>\n</li>\n<li>除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行</li>\n<li><strong>解析动作</strong>：<ul>\n<li>类和接口的解析</li>\n<li>字段解析</li>\n<li>类方法解析</li>\n<li>接口方法解析</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-初始化\"><a href=\"#5-初始化\" class=\"headerlink\" title=\"5. 初始化\"></a>5. 初始化</h4><p>在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源，可以从另外一个角度来表达：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</p>\n<ul>\n<li><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<br>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">0</span>;  <span class=\"comment\">//  给变量复制可以正常编译通过</span></span><br><span class=\"line\">        System.out.print(i);  <span class=\"comment\">// 这句编译器会提示“非法向前引用”  </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕</p>\n</li>\n<li>父类的<code>&lt;clinit&gt;()</code>方法先执行，所以父类中定义的静态语句块要优先于子类的变量赋值操作</li>\n<li><code>&lt;clinit&gt;()</code>方法对于类和接口不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法</li>\n<li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口菜单<code>&lt;clinit&gt;()</code>方法，只要当父接口中定义的变量使用时，父接口才会初始化</li>\n<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁、同步</li>\n</ul>\n<hr>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><h4 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h4><p>对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>\n<blockquote>\n<p>即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p>\n</blockquote>\n<h4 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h4><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：<br>i. 启动类加载器，是虚拟机的一部分;<br>ii. 另一种是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader</p>\n<ul>\n<li><strong>启动类加载器</strong>：负责将存放在<java_home>\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，开发者无法直接引用</java_home></li>\n<li><strong>扩展类加载器</strong>：负责加载<java_home>\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用</java_home></li>\n<li><strong>应用程序类加载器</strong>：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，开发者可以直接使用</li>\n<li><strong>双亲委派模型的工作过程</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载<blockquote>\n<p>这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/images/jvm_classloader_doubleparent.jpg\" alt=\"\"></p>\n"},{"title":"进程并发常见问题基于信号量解决方法总结：生产者/消费者问题、读/写者问题、银行家算法、哲学家进餐","date":"2018-04-16T11:07:43.000Z","_content":"\n### 一、信号量\n\n- 信号量是一个与队列有关的整型变量。\n- 可以初始化成非负数；\n- semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；\n- semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。\n\n#### 信号量原语semWait和semSignal的定义\n``` bash\nstrcut semaphore{\n\tint count;\n\taueueType queue;\n};\n\nvoid semWait(semaphore s) {\n\ts.count--;\n\tif(s.count < 0) {\n\t\tplace this process in s.queue;\n\t\tblock this process;\n\t}\n}\n\nvoid semSignal(semaphore s) {\n\ts.count ++;\n\tif(s.count <= 0) {\n\t\tremove a process P from s.queue;\n\t\tplace process P on ready list;\n\t}\n}\n```\n\n#### 信号量实现互斥\n``` bash\nconst int n;\nsemaphore s = 1;\nvoid P(int i) {\n\twhile(true) {\n\t\tsemWait(s);\n\t\toperate;\n\t\tsemSignal(s);\n\t}\n}\n\nvoid main() {\n\tparbegin(P(1), P(2), ...,P(n));\n}\n```\n\n\n#### 总结\n\n**信号量**\n\n- 一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。\n- 用于互斥时，S初值为1，取值为1~ - (n-1)        （相当于临界区的通行证，实际上也是资源个数）\n\tS=1：临界区可用\n\tS=0：已有一进程进入临界区\n\tS<0：临界区已被占用，|S|个进程正等待进入\n- 用于同步时，S初值>=0\n\tS>=0:表示可用资源个数\n\tS<0: 表示该资源的等待队列长度\n\n**semWait、semSignal操作**\n- semWait(S)：请求分配一个资源。\n- semSignal(S)：释放一个资源。\n- semWait、semSignal操作必须成对出现。\n- 用于互斥时，位于同一进程内；\n- 用于同步时，交错出现于两个合作进程内。\n- 多个semWait操作的次序不能颠倒，否则可能导致死锁。 \n- 多个semSignal操作的次序可任意。\n\n二、生产者/消费者问题\n\n**问题描述：**\n\t有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；\n\t有一个消费者从缓冲区中取数据，每次取一项；\n\t系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区;\n\t缓存已满时，生产者不能继续添加数据；\n\t缓存已空时，消费者不能继续移走数据。\n\n**producer:**\n\n``` bash\n\t\n\twhile(true) {\n\t\t/* produce item v */\n\t\twhile((in + 1) % n == out) //等待缓存有空位\n\t\t\t/* doing nothing */\n\t\tb[in] = v;\n\t\tin = (in + 1) % n;\n\t}\t\n\t\n```\n**consumer:**\n\t\n``` bash\n\n\twhile(true) {\n\t\twhile(in == out) //此时缓存为空，等待生产者生产放入缓存后才可消费\n\t\t\t/* doing nothing */\n\t\tw = b[out];\n\t\tout = (out + 1) % n;\n\t\t/* consume item w */\n\t}\n\n```\n\n**有限缓冲区：**\n\n![process_concurrent_finite_buffer](/images/process_concurrent_finite_buffer.png)\n\n\n**使用信号量解决有限缓冲区生产者消费者问题:**\n\n> n 表示已生产产品的数量\ns 用来控制互斥\ne 表示空闲空间数目\n\n``` bash\n\n\tsemaphore n = 0, s = 1, e = buf - size;\n\n\tvoid producer() {\n\t\twhile(true) {\n\t\t\tproduce();\n\t\t\tsemWait(e);\n\t\t\tsemWait(s);\n\t\t\tappend();\n\t\t\tsemSignal(s);\n\t\t\tsemSignal(e);\n\t\t}\n\t}\n\n\tvoid consumer() {\n\t\twhile(true) {\n\t\t\tsemWait(n);\n\t\t\tsemWait(s);\n\t\t\ttake();\n\t\t\tsemSignal(s);\n\t\t\tsemSignal(e);\n\t\t\tconsume();\n\t\t}\n\t}\n\n\n```\n\n例题\n1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。\n\n分析：\n\t生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。\n\n数据结构： semaphore dish, apple, banana;\n\tdish: 表示盘子是否为空,用于控制互斥\n\tapple：表示盘子中是否有苹果，初始值为0\n\tbanana:表示盘子中是否有香蕉，初始值为0\n\n``` bash\n\t\nprocess father() {\n\tsemWait(dish);\n\tput the apple in the dish;\n\tsemSignal(apple);\n}\n\nprocess mother() {\n\tsemWait(dish);\n\tput the banana in the dish;\n\tsemSignal(banana);\n}\n\nprocess son() {\n\tsemWait(banana);\n\tget the banana from the dish;\n\tsemSignal(dish);\n}\n\nprocess daughter() {\n\tsemWait(apple);\n\tget the apple from the dish;\n\tsemSignal(dish);\n}\n\n```\n\n2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。\n\n分析：\n\t实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系\n\n数据结构：semaphore s1, s2;\n\ts1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0；\n\t\n\n ``` bash\n\nprocess p1() {\n\twhile(true){\n\t\tsemWait(s1);\n\t\tPick a white chessman;\n\t\tsemSignal(s2);\n\t}\n}\n\nprocess p2() {\n\twhile(true){\n\t\tsemWait(s2);\n\t\tPick a white chessman;\n\t\tsemSignal(s1);\n\t}\n}\n\n ```\n\n\n3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。\n\n分析：\n\t实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室\n\n数据结构：\n\tstrcut {\n\t\tchar name[10];\n\t\tint number;\n\t} a[100]; //表示进入阅览室的小朋友\n\tsemaphore mutex, seatcount;\n\t\tmutex: 用来控制互斥，初始值为1\n\t\tseatcount： 对空座位进行计数，初始值为100；\n\t\n\t初始化入室人员信息\n\tfor(int i = 0; i < 100; i++){\n\t\ta[i].number = i;\n\t\ta[i].name = null;\n\t}\n\n\n ``` bash\n\t\nprocess readeri(char readername[]) {\n\tsemWait(seatcount);  \t//等待空余作为，若人数未满100，则直接进入，到达100，则等待\n\tsemWait(mutex);\t\t \t//控制互斥\n\n\t/* 进入是登记 */\n\tfor(int i = 0; i < 100; i++)\n\t\tif(a[i].name == null){\t//找到名字为空的座位\n\t\t\ta[i].name = readername;\n\t\t\tbreak;\n\t\t}\n\treader get the seat nember i;\n\tsemSiganl(mutex);\n\tgo into the reading room and sit down at the seat number i.\n\t\n\t/* 离开时登记 */\n\tsemWait(mutex);\n\ta[i].name = null;  \n\tsemSignal(mutex);\n\tsemSignal(seatcount);\n\tleave reading room;\n}\n\n ```\n\n\t\n\n二、读/写者问题\n\t描述：\n\t有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件：\n\t任意多的读进程可以同时读文件；\n\t一次只有一个写进程可以写文件；\n\t如果一个写进程正在写文件，那么禁止任何读进程读文件。\n\n读者优先\n\n分析：\n\t当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。\t\n\t\n数据结构：\n\treadcount: 控制wsem的的设置\n\twsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。\n\tx: 用于确保readcount被正确更新。\n\t\n\n``` bash\n\t\n\tint readcount;\n\tsemphore x = 1, wsem = 1;\n\tvoid reader() {\n\t\twhile (true) {\n\t \tsemWait(x);\n   \t\treadcount++;\n   \t\tif(readcount==1)\n      \t\tsemWait(wsem);  //如果是第一个读者，则要控制wsem\n   \t\tsemSignal(x);\n   \t\tREADUNIT();   \n\t\tsemWait(x);\n\t\treadcount--;\n\t\tif(readcount==0)\n   \t\tsemSignal(wsem);\n\t\tsemSignal(x);\n\t\t}\n\n\t}\n\n\tvoid writer(){\n\t\t while (true) {\n \t \t\tsemWait(wsem);\n   \t\t\tWRITEUNIT();\n   \t\t\tsemSignal(wsem);\n \t\t}\n\t}\n\n\n```\n\n实例：\n\t独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法)\n\n数据结构：\n\t\n\n\tmutex1/mutex2: 用于确保count1/count2被准备更新\n\tcount1/count2: 控制wait的设置\n    wait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。\n\n``` bash\n\n\t\tsemaphore wait=1, mutex1=1, mutex2=1;\n\t\tint count1=0, count2=0; \n\n\t\tprocess P east(){\n    \tsemWait(mutex1);\n      \tcount1++;\n      \tif(count1==1)   semWait(wait);\n      \tsemSignal(mutex1);\n       \tthrough the singal-log bridge；\n      \tsemWait(mutex1);\n      \tcount1--;\n      \tif(count1==0)   semSignal(wait);\n      \tsemSignal(mutex1);\n   }\n\n\tprocess P west(){\n    \tsemWait(mutex2);\n      \tcount2++;\n      \tif(count2==1)   semWait(wait);\n      \tsemSignal(mutex2);\n        through the singal-log bridge；\n      \tsemWait(mutex2);\n      \tcount2--;\n      \tif(count2==0)   semSignal(wait);\n      \tsemSignal(mutex2);\n   }\n\n```\n\n待整理。。。","source":"_posts/进程并发常见问题基于信号量解决方法总结：生产者消费者问题、读写者问题、银行家算法、哲学家进餐.md","raw":"---\ntitle: 进程并发常见问题基于信号量解决方法总结：生产者/消费者问题、读/写者问题、银行家算法、哲学家进餐\ndate: 2018-04-16 19:07:43\ncategories: \"计算机基础\"\ntags:\n\t- OS\n\t- 计算机基础\n---\n\n### 一、信号量\n\n- 信号量是一个与队列有关的整型变量。\n- 可以初始化成非负数；\n- semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；\n- semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。\n\n#### 信号量原语semWait和semSignal的定义\n``` bash\nstrcut semaphore{\n\tint count;\n\taueueType queue;\n};\n\nvoid semWait(semaphore s) {\n\ts.count--;\n\tif(s.count < 0) {\n\t\tplace this process in s.queue;\n\t\tblock this process;\n\t}\n}\n\nvoid semSignal(semaphore s) {\n\ts.count ++;\n\tif(s.count <= 0) {\n\t\tremove a process P from s.queue;\n\t\tplace process P on ready list;\n\t}\n}\n```\n\n#### 信号量实现互斥\n``` bash\nconst int n;\nsemaphore s = 1;\nvoid P(int i) {\n\twhile(true) {\n\t\tsemWait(s);\n\t\toperate;\n\t\tsemSignal(s);\n\t}\n}\n\nvoid main() {\n\tparbegin(P(1), P(2), ...,P(n));\n}\n```\n\n\n#### 总结\n\n**信号量**\n\n- 一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。\n- 用于互斥时，S初值为1，取值为1~ - (n-1)        （相当于临界区的通行证，实际上也是资源个数）\n\tS=1：临界区可用\n\tS=0：已有一进程进入临界区\n\tS<0：临界区已被占用，|S|个进程正等待进入\n- 用于同步时，S初值>=0\n\tS>=0:表示可用资源个数\n\tS<0: 表示该资源的等待队列长度\n\n**semWait、semSignal操作**\n- semWait(S)：请求分配一个资源。\n- semSignal(S)：释放一个资源。\n- semWait、semSignal操作必须成对出现。\n- 用于互斥时，位于同一进程内；\n- 用于同步时，交错出现于两个合作进程内。\n- 多个semWait操作的次序不能颠倒，否则可能导致死锁。 \n- 多个semSignal操作的次序可任意。\n\n二、生产者/消费者问题\n\n**问题描述：**\n\t有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；\n\t有一个消费者从缓冲区中取数据，每次取一项；\n\t系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区;\n\t缓存已满时，生产者不能继续添加数据；\n\t缓存已空时，消费者不能继续移走数据。\n\n**producer:**\n\n``` bash\n\t\n\twhile(true) {\n\t\t/* produce item v */\n\t\twhile((in + 1) % n == out) //等待缓存有空位\n\t\t\t/* doing nothing */\n\t\tb[in] = v;\n\t\tin = (in + 1) % n;\n\t}\t\n\t\n```\n**consumer:**\n\t\n``` bash\n\n\twhile(true) {\n\t\twhile(in == out) //此时缓存为空，等待生产者生产放入缓存后才可消费\n\t\t\t/* doing nothing */\n\t\tw = b[out];\n\t\tout = (out + 1) % n;\n\t\t/* consume item w */\n\t}\n\n```\n\n**有限缓冲区：**\n\n![process_concurrent_finite_buffer](/images/process_concurrent_finite_buffer.png)\n\n\n**使用信号量解决有限缓冲区生产者消费者问题:**\n\n> n 表示已生产产品的数量\ns 用来控制互斥\ne 表示空闲空间数目\n\n``` bash\n\n\tsemaphore n = 0, s = 1, e = buf - size;\n\n\tvoid producer() {\n\t\twhile(true) {\n\t\t\tproduce();\n\t\t\tsemWait(e);\n\t\t\tsemWait(s);\n\t\t\tappend();\n\t\t\tsemSignal(s);\n\t\t\tsemSignal(e);\n\t\t}\n\t}\n\n\tvoid consumer() {\n\t\twhile(true) {\n\t\t\tsemWait(n);\n\t\t\tsemWait(s);\n\t\t\ttake();\n\t\t\tsemSignal(s);\n\t\t\tsemSignal(e);\n\t\t\tconsume();\n\t\t}\n\t}\n\n\n```\n\n例题\n1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。\n\n分析：\n\t生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。\n\n数据结构： semaphore dish, apple, banana;\n\tdish: 表示盘子是否为空,用于控制互斥\n\tapple：表示盘子中是否有苹果，初始值为0\n\tbanana:表示盘子中是否有香蕉，初始值为0\n\n``` bash\n\t\nprocess father() {\n\tsemWait(dish);\n\tput the apple in the dish;\n\tsemSignal(apple);\n}\n\nprocess mother() {\n\tsemWait(dish);\n\tput the banana in the dish;\n\tsemSignal(banana);\n}\n\nprocess son() {\n\tsemWait(banana);\n\tget the banana from the dish;\n\tsemSignal(dish);\n}\n\nprocess daughter() {\n\tsemWait(apple);\n\tget the apple from the dish;\n\tsemSignal(dish);\n}\n\n```\n\n2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。\n\n分析：\n\t实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系\n\n数据结构：semaphore s1, s2;\n\ts1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0；\n\t\n\n ``` bash\n\nprocess p1() {\n\twhile(true){\n\t\tsemWait(s1);\n\t\tPick a white chessman;\n\t\tsemSignal(s2);\n\t}\n}\n\nprocess p2() {\n\twhile(true){\n\t\tsemWait(s2);\n\t\tPick a white chessman;\n\t\tsemSignal(s1);\n\t}\n}\n\n ```\n\n\n3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。\n\n分析：\n\t实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室\n\n数据结构：\n\tstrcut {\n\t\tchar name[10];\n\t\tint number;\n\t} a[100]; //表示进入阅览室的小朋友\n\tsemaphore mutex, seatcount;\n\t\tmutex: 用来控制互斥，初始值为1\n\t\tseatcount： 对空座位进行计数，初始值为100；\n\t\n\t初始化入室人员信息\n\tfor(int i = 0; i < 100; i++){\n\t\ta[i].number = i;\n\t\ta[i].name = null;\n\t}\n\n\n ``` bash\n\t\nprocess readeri(char readername[]) {\n\tsemWait(seatcount);  \t//等待空余作为，若人数未满100，则直接进入，到达100，则等待\n\tsemWait(mutex);\t\t \t//控制互斥\n\n\t/* 进入是登记 */\n\tfor(int i = 0; i < 100; i++)\n\t\tif(a[i].name == null){\t//找到名字为空的座位\n\t\t\ta[i].name = readername;\n\t\t\tbreak;\n\t\t}\n\treader get the seat nember i;\n\tsemSiganl(mutex);\n\tgo into the reading room and sit down at the seat number i.\n\t\n\t/* 离开时登记 */\n\tsemWait(mutex);\n\ta[i].name = null;  \n\tsemSignal(mutex);\n\tsemSignal(seatcount);\n\tleave reading room;\n}\n\n ```\n\n\t\n\n二、读/写者问题\n\t描述：\n\t有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件：\n\t任意多的读进程可以同时读文件；\n\t一次只有一个写进程可以写文件；\n\t如果一个写进程正在写文件，那么禁止任何读进程读文件。\n\n读者优先\n\n分析：\n\t当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。\t\n\t\n数据结构：\n\treadcount: 控制wsem的的设置\n\twsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。\n\tx: 用于确保readcount被正确更新。\n\t\n\n``` bash\n\t\n\tint readcount;\n\tsemphore x = 1, wsem = 1;\n\tvoid reader() {\n\t\twhile (true) {\n\t \tsemWait(x);\n   \t\treadcount++;\n   \t\tif(readcount==1)\n      \t\tsemWait(wsem);  //如果是第一个读者，则要控制wsem\n   \t\tsemSignal(x);\n   \t\tREADUNIT();   \n\t\tsemWait(x);\n\t\treadcount--;\n\t\tif(readcount==0)\n   \t\tsemSignal(wsem);\n\t\tsemSignal(x);\n\t\t}\n\n\t}\n\n\tvoid writer(){\n\t\t while (true) {\n \t \t\tsemWait(wsem);\n   \t\t\tWRITEUNIT();\n   \t\t\tsemSignal(wsem);\n \t\t}\n\t}\n\n\n```\n\n实例：\n\t独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法)\n\n数据结构：\n\t\n\n\tmutex1/mutex2: 用于确保count1/count2被准备更新\n\tcount1/count2: 控制wait的设置\n    wait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。\n\n``` bash\n\n\t\tsemaphore wait=1, mutex1=1, mutex2=1;\n\t\tint count1=0, count2=0; \n\n\t\tprocess P east(){\n    \tsemWait(mutex1);\n      \tcount1++;\n      \tif(count1==1)   semWait(wait);\n      \tsemSignal(mutex1);\n       \tthrough the singal-log bridge；\n      \tsemWait(mutex1);\n      \tcount1--;\n      \tif(count1==0)   semSignal(wait);\n      \tsemSignal(mutex1);\n   }\n\n\tprocess P west(){\n    \tsemWait(mutex2);\n      \tcount2++;\n      \tif(count2==1)   semWait(wait);\n      \tsemSignal(mutex2);\n        through the singal-log bridge；\n      \tsemWait(mutex2);\n      \tcount2--;\n      \tif(count2==0)   semSignal(wait);\n      \tsemSignal(mutex2);\n   }\n\n```\n\n待整理。。。","slug":"进程并发常见问题基于信号量解决方法总结：生产者消费者问题、读写者问题、银行家算法、哲学家进餐","published":1,"updated":"2018-10-26T04:42:38.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fe50033u7yjg2y3nmto","content":"<h3 id=\"一、信号量\"><a href=\"#一、信号量\" class=\"headerlink\" title=\"一、信号量\"></a>一、信号量</h3><ul>\n<li>信号量是一个与队列有关的整型变量。</li>\n<li>可以初始化成非负数；</li>\n<li>semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；</li>\n<li>semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。</li>\n</ul>\n<h4 id=\"信号量原语semWait和semSignal的定义\"><a href=\"#信号量原语semWait和semSignal的定义\" class=\"headerlink\" title=\"信号量原语semWait和semSignal的定义\"></a>信号量原语semWait和semSignal的定义</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strcut semaphore&#123;</span><br><span class=\"line\">\tint count;</span><br><span class=\"line\">\taueueType queue;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void semWait(semaphore s) &#123;</span><br><span class=\"line\">\ts.count--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s.count &lt; 0) &#123;</span><br><span class=\"line\">\t\tplace this process <span class=\"keyword\">in</span> s.queue;</span><br><span class=\"line\">\t\tblock this process;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void semSignal(semaphore s) &#123;</span><br><span class=\"line\">\ts.count ++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s.count &lt;= 0) &#123;</span><br><span class=\"line\">\t\tremove a process P from s.queue;</span><br><span class=\"line\">\t\tplace process P on ready list;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量实现互斥\"><a href=\"#信号量实现互斥\" class=\"headerlink\" title=\"信号量实现互斥\"></a>信号量实现互斥</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int n;</span><br><span class=\"line\">semaphore s = 1;</span><br><span class=\"line\">void P(int i) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\tsemWait(s);</span><br><span class=\"line\">\t\toperate;</span><br><span class=\"line\">\t\tsemSignal(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">\tparbegin(P(1), P(2), ...,P(n));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><strong>信号量</strong></p>\n<ul>\n<li>一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。</li>\n<li>用于互斥时，S初值为1，取值为1~ - (n-1)        （相当于临界区的通行证，实际上也是资源个数）<br>  S=1：临界区可用<br>  S=0：已有一进程进入临界区<br>  S&lt;0：临界区已被占用，|S|个进程正等待进入</li>\n<li>用于同步时，S初值&gt;=0<br>  S&gt;=0:表示可用资源个数<br>  S&lt;0: 表示该资源的等待队列长度</li>\n</ul>\n<p><strong>semWait、semSignal操作</strong></p>\n<ul>\n<li>semWait(S)：请求分配一个资源。</li>\n<li>semSignal(S)：释放一个资源。</li>\n<li>semWait、semSignal操作必须成对出现。</li>\n<li>用于互斥时，位于同一进程内；</li>\n<li>用于同步时，交错出现于两个合作进程内。</li>\n<li>多个semWait操作的次序不能颠倒，否则可能导致死锁。 </li>\n<li>多个semSignal操作的次序可任意。</li>\n</ul>\n<p>二、生产者/消费者问题</p>\n<p><strong>问题描述：</strong><br>    有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；<br>    有一个消费者从缓冲区中取数据，每次取一项；<br>    系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区;<br>    缓存已满时，生产者不能继续添加数据；<br>    缓存已空时，消费者不能继续移走数据。</p>\n<p><strong>producer:</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t/* produce item v */</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>((<span class=\"keyword\">in</span> + 1) % n == out) //等待缓存有空位</span><br><span class=\"line\">\t\t/* doing nothing */</span><br><span class=\"line\">\tb[<span class=\"keyword\">in</span>] = v;</span><br><span class=\"line\">\t<span class=\"keyword\">in</span> = (<span class=\"keyword\">in</span> + 1) % n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>consumer:</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"keyword\">in</span> == out) //此时缓存为空，等待生产者生产放入缓存后才可消费</span><br><span class=\"line\">\t\t/* doing nothing */</span><br><span class=\"line\">\tw = b[out];</span><br><span class=\"line\">\tout = (out + 1) % n;</span><br><span class=\"line\">\t/* consume item w */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>有限缓冲区：</strong></p>\n<p><img src=\"/images/process_concurrent_finite_buffer.png\" alt=\"process_concurrent_finite_buffer\"></p>\n<p><strong>使用信号量解决有限缓冲区生产者消费者问题:</strong></p>\n<blockquote>\n<p>n 表示已生产产品的数量<br>s 用来控制互斥<br>e 表示空闲空间数目</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">semaphore n = 0, s = 1, e = buf - size;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">producer</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\tproduce();</span><br><span class=\"line\">\t\tsemWait(e);</span><br><span class=\"line\">\t\tsemWait(s);</span><br><span class=\"line\">\t\tappend();</span><br><span class=\"line\">\t\tsemSignal(s);</span><br><span class=\"line\">\t\tsemSignal(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">consumer</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\tsemWait(n);</span><br><span class=\"line\">\t\tsemWait(s);</span><br><span class=\"line\">\t\ttake();</span><br><span class=\"line\">\t\tsemSignal(s);</span><br><span class=\"line\">\t\tsemSignal(e);</span><br><span class=\"line\">\t\tconsume();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例题<br>1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。</p>\n<p>分析：<br>    生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。</p>\n<p>数据结构： semaphore dish, apple, banana;<br>    dish: 表示盘子是否为空,用于控制互斥<br>    apple：表示盘子中是否有苹果，初始值为0<br>    banana:表示盘子中是否有香蕉，初始值为0</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">father</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(dish);</span><br><span class=\"line\">\tput the apple <span class=\"keyword\">in</span> the dish;</span><br><span class=\"line\">\tsemSignal(apple);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">mother</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(dish);</span><br><span class=\"line\">\tput the banana <span class=\"keyword\">in</span> the dish;</span><br><span class=\"line\">\tsemSignal(banana);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">son</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(banana);</span><br><span class=\"line\">\tget the banana from the dish;</span><br><span class=\"line\">\tsemSignal(dish);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">daughter</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(apple);</span><br><span class=\"line\">\tget the apple from the dish;</span><br><span class=\"line\">\tsemSignal(dish);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。</p>\n<p>分析：<br>    实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系</p>\n<p>数据结构：semaphore s1, s2;<br>    s1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0；</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">p1</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\tsemWait(s1);</span><br><span class=\"line\">\t\tPick a white chessman;</span><br><span class=\"line\">\t\tsemSignal(s2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">p2</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\tsemWait(s2);</span><br><span class=\"line\">\t\tPick a white chessman;</span><br><span class=\"line\">\t\tsemSignal(s1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。</p>\n<p>分析：<br>    实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室</p>\n<p>数据结构：<br>    strcut {<br>        char name[10];<br>        int number;<br>    } a[100]; //表示进入阅览室的小朋友<br>    semaphore mutex, seatcount;<br>        mutex: 用来控制互斥，初始值为1<br>        seatcount： 对空座位进行计数，初始值为100；</p>\n<pre><code>初始化入室人员信息\nfor(int i = 0; i &lt; 100; i++){\n    a[i].number = i;\n    a[i].name = null;\n}\n</code></pre> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">process readeri(char readername[]) &#123;</span><br><span class=\"line\">\tsemWait(seatcount);  \t//等待空余作为，若人数未满100，则直接进入，到达100，则等待</span><br><span class=\"line\">\tsemWait(mutex);\t\t \t//控制互斥</span><br><span class=\"line\"></span><br><span class=\"line\">\t/* 进入是登记 */</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(int i = 0; i &lt; 100; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i].name == null)&#123;\t//找到名字为空的座位</span><br><span class=\"line\">\t\t\ta[i].name = readername;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\treader get the seat nember i;</span><br><span class=\"line\">\tsemSiganl(mutex);</span><br><span class=\"line\">\tgo into the reading room and sit down at the seat number i.</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t/* 离开时登记 */</span><br><span class=\"line\">\tsemWait(mutex);</span><br><span class=\"line\">\ta[i].name = null;  </span><br><span class=\"line\">\tsemSignal(mutex);</span><br><span class=\"line\">\tsemSignal(seatcount);</span><br><span class=\"line\">\tleave reading room;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二、读/写者问题<br>    描述：<br>    有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件：<br>    任意多的读进程可以同时读文件；<br>    一次只有一个写进程可以写文件；<br>    如果一个写进程正在写文件，那么禁止任何读进程读文件。</p>\n<p>读者优先</p>\n<p>分析：<br>    当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。    </p>\n<p>数据结构：<br>    readcount: 控制wsem的的设置<br>    wsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。<br>    x: 用于确保readcount被正确更新。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int readcount;</span><br><span class=\"line\">semphore x = 1, wsem = 1;</span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">reader</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\"> \tsemWait(x);</span><br><span class=\"line\">  \t\treadcount++;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(readcount==1)</span><br><span class=\"line\">     \t\tsemWait(wsem);  //如果是第一个读者，则要控制wsem</span><br><span class=\"line\">  \t\tsemSignal(x);</span><br><span class=\"line\">  \t\tREADUNIT();   </span><br><span class=\"line\">\tsemWait(x);</span><br><span class=\"line\">\treadcount--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(readcount==0)</span><br><span class=\"line\">  \t\tsemSignal(wsem);</span><br><span class=\"line\">\tsemSignal(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">writer</span></span>()&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t \t\tsemWait(wsem);</span><br><span class=\"line\">  \t\t\tWRITEUNIT();</span><br><span class=\"line\">  \t\t\tsemSignal(wsem);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例：<br>    独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法)</p>\n<p>数据结构：</p>\n<pre><code>mutex1/mutex2: 用于确保count1/count2被准备更新\ncount1/count2: 控制wait的设置\nwait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\tsemaphore <span class=\"built_in\">wait</span>=1, mutex1=1, mutex2=1;</span><br><span class=\"line\">\tint count1=0, count2=0; </span><br><span class=\"line\"></span><br><span class=\"line\">\tprocess P <span class=\"function\"><span class=\"title\">east</span></span>()&#123;</span><br><span class=\"line\">   \tsemWait(mutex1);</span><br><span class=\"line\">     \tcount1++;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count1==1)   semWait(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex1);</span><br><span class=\"line\">      \tthrough the singal-log bridge；</span><br><span class=\"line\">     \tsemWait(mutex1);</span><br><span class=\"line\">     \tcount1--;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count1==0)   semSignal(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process P <span class=\"function\"><span class=\"title\">west</span></span>()&#123;</span><br><span class=\"line\">   \tsemWait(mutex2);</span><br><span class=\"line\">     \tcount2++;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count2==1)   semWait(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex2);</span><br><span class=\"line\">       through the singal-log bridge；</span><br><span class=\"line\">     \tsemWait(mutex2);</span><br><span class=\"line\">     \tcount2--;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count2==0)   semSignal(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex2);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>待整理。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、信号量\"><a href=\"#一、信号量\" class=\"headerlink\" title=\"一、信号量\"></a>一、信号量</h3><ul>\n<li>信号量是一个与队列有关的整型变量。</li>\n<li>可以初始化成非负数；</li>\n<li>semWait操作使信号量减1。若值为负数，则执行semWait的进程阻塞，否则继续执行；</li>\n<li>semSignal操作使信号量加1。若值小于或等于0，则被semWait操作阻塞的进程被解除阻塞。</li>\n</ul>\n<h4 id=\"信号量原语semWait和semSignal的定义\"><a href=\"#信号量原语semWait和semSignal的定义\" class=\"headerlink\" title=\"信号量原语semWait和semSignal的定义\"></a>信号量原语semWait和semSignal的定义</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strcut semaphore&#123;</span><br><span class=\"line\">\tint count;</span><br><span class=\"line\">\taueueType queue;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void semWait(semaphore s) &#123;</span><br><span class=\"line\">\ts.count--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s.count &lt; 0) &#123;</span><br><span class=\"line\">\t\tplace this process <span class=\"keyword\">in</span> s.queue;</span><br><span class=\"line\">\t\tblock this process;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void semSignal(semaphore s) &#123;</span><br><span class=\"line\">\ts.count ++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(s.count &lt;= 0) &#123;</span><br><span class=\"line\">\t\tremove a process P from s.queue;</span><br><span class=\"line\">\t\tplace process P on ready list;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"信号量实现互斥\"><a href=\"#信号量实现互斥\" class=\"headerlink\" title=\"信号量实现互斥\"></a>信号量实现互斥</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int n;</span><br><span class=\"line\">semaphore s = 1;</span><br><span class=\"line\">void P(int i) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\tsemWait(s);</span><br><span class=\"line\">\t\toperate;</span><br><span class=\"line\">\t\tsemSignal(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">\tparbegin(P(1), P(2), ...,P(n));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><strong>信号量</strong></p>\n<ul>\n<li>一个信号量可用于n个进程的同步互斥；且只能由semWait、semSignal操作修改。</li>\n<li>用于互斥时，S初值为1，取值为1~ - (n-1)        （相当于临界区的通行证，实际上也是资源个数）<br>  S=1：临界区可用<br>  S=0：已有一进程进入临界区<br>  S&lt;0：临界区已被占用，|S|个进程正等待进入</li>\n<li>用于同步时，S初值&gt;=0<br>  S&gt;=0:表示可用资源个数<br>  S&lt;0: 表示该资源的等待队列长度</li>\n</ul>\n<p><strong>semWait、semSignal操作</strong></p>\n<ul>\n<li>semWait(S)：请求分配一个资源。</li>\n<li>semSignal(S)：释放一个资源。</li>\n<li>semWait、semSignal操作必须成对出现。</li>\n<li>用于互斥时，位于同一进程内；</li>\n<li>用于同步时，交错出现于两个合作进程内。</li>\n<li>多个semWait操作的次序不能颠倒，否则可能导致死锁。 </li>\n<li>多个semSignal操作的次序可任意。</li>\n</ul>\n<p>二、生产者/消费者问题</p>\n<p><strong>问题描述：</strong><br>    有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；<br>    有一个消费者从缓冲区中取数据，每次取一项；<br>    系统保证避免对缓冲区的重复操作，即任何时候只有一个主体（生产者或消费者）可以访问缓冲区;<br>    缓存已满时，生产者不能继续添加数据；<br>    缓存已空时，消费者不能继续移走数据。</p>\n<p><strong>producer:</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t/* produce item v */</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>((<span class=\"keyword\">in</span> + 1) % n == out) //等待缓存有空位</span><br><span class=\"line\">\t\t/* doing nothing */</span><br><span class=\"line\">\tb[<span class=\"keyword\">in</span>] = v;</span><br><span class=\"line\">\t<span class=\"keyword\">in</span> = (<span class=\"keyword\">in</span> + 1) % n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>consumer:</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"keyword\">in</span> == out) //此时缓存为空，等待生产者生产放入缓存后才可消费</span><br><span class=\"line\">\t\t/* doing nothing */</span><br><span class=\"line\">\tw = b[out];</span><br><span class=\"line\">\tout = (out + 1) % n;</span><br><span class=\"line\">\t/* consume item w */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>有限缓冲区：</strong></p>\n<p><img src=\"/images/process_concurrent_finite_buffer.png\" alt=\"process_concurrent_finite_buffer\"></p>\n<p><strong>使用信号量解决有限缓冲区生产者消费者问题:</strong></p>\n<blockquote>\n<p>n 表示已生产产品的数量<br>s 用来控制互斥<br>e 表示空闲空间数目</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">semaphore n = 0, s = 1, e = buf - size;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">producer</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\tproduce();</span><br><span class=\"line\">\t\tsemWait(e);</span><br><span class=\"line\">\t\tsemWait(s);</span><br><span class=\"line\">\t\tappend();</span><br><span class=\"line\">\t\tsemSignal(s);</span><br><span class=\"line\">\t\tsemSignal(e);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">consumer</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\tsemWait(n);</span><br><span class=\"line\">\t\tsemWait(s);</span><br><span class=\"line\">\t\ttake();</span><br><span class=\"line\">\t\tsemSignal(s);</span><br><span class=\"line\">\t\tsemSignal(e);</span><br><span class=\"line\">\t\tconsume();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例题<br>1) 桌子上有一个盘子，可以存放一个水果。父亲总是放苹果到盘子中，而母亲总是放香蕉到盘子中；儿子专等吃盘中的香蕉，而女儿专等吃盘中的苹果。</p>\n<p>分析：<br>    生产者－消费者问题的一种变形，生产者、消费者以及放入缓冲区的产品都有两类（苹果和香蕉），但每类消费者只消费其中固定的一种产品（儿子消费香蕉，女儿消费苹果）。</p>\n<p>数据结构： semaphore dish, apple, banana;<br>    dish: 表示盘子是否为空,用于控制互斥<br>    apple：表示盘子中是否有苹果，初始值为0<br>    banana:表示盘子中是否有香蕉，初始值为0</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">father</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(dish);</span><br><span class=\"line\">\tput the apple <span class=\"keyword\">in</span> the dish;</span><br><span class=\"line\">\tsemSignal(apple);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">mother</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(dish);</span><br><span class=\"line\">\tput the banana <span class=\"keyword\">in</span> the dish;</span><br><span class=\"line\">\tsemSignal(banana);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">son</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(banana);</span><br><span class=\"line\">\tget the banana from the dish;</span><br><span class=\"line\">\tsemSignal(dish);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">daughter</span></span>() &#123;</span><br><span class=\"line\">\tsemWait(apple);</span><br><span class=\"line\">\tget the apple from the dish;</span><br><span class=\"line\">\tsemSignal(dish);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2) 在一个盒子里，混装了数量相等的黑白围棋子。现在用自动分拣系统把黑子、白子分开，设分拣系统有两个进程P1和P2，其中P1拣白子，P2拣黑子。规定每个进程每次拣一子，当一个进程在拣时，不允许另一个进程去拣；当一个进程拣了一子时，必须让另一个进程去拣。试用信号量协调两个进程的并发执行。</p>\n<p>分析：<br>    实际上就是两个进程的同步问题，也就是拣了一个白棋子才能拣一个黑棋子，两者成合作关系</p>\n<p>数据结构：semaphore s1, s2;<br>    s1 和s2 分别表示可拣白子和黑子，不失一般性，若令先拣白子。初值， s1=1； s2=0；</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">p1</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\tsemWait(s1);</span><br><span class=\"line\">\t\tPick a white chessman;</span><br><span class=\"line\">\t\tsemSignal(s2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process <span class=\"function\"><span class=\"title\">p2</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">\t\tsemWait(s2);</span><br><span class=\"line\">\t\tPick a white chessman;</span><br><span class=\"line\">\t\tsemSignal(s1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3) 假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。</p>\n<p>分析：<br>    实际上是一个非常简单的同步-互斥问题，登记时需要保证互斥，室内人数在100之内时，无需等待，大于100人是，开始需要等待室内有人出来后方可有人入室</p>\n<p>数据结构：<br>    strcut {<br>        char name[10];<br>        int number;<br>    } a[100]; //表示进入阅览室的小朋友<br>    semaphore mutex, seatcount;<br>        mutex: 用来控制互斥，初始值为1<br>        seatcount： 对空座位进行计数，初始值为100；</p>\n<pre><code>初始化入室人员信息\nfor(int i = 0; i &lt; 100; i++){\n    a[i].number = i;\n    a[i].name = null;\n}\n</code></pre> <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">process readeri(char readername[]) &#123;</span><br><span class=\"line\">\tsemWait(seatcount);  \t//等待空余作为，若人数未满100，则直接进入，到达100，则等待</span><br><span class=\"line\">\tsemWait(mutex);\t\t \t//控制互斥</span><br><span class=\"line\"></span><br><span class=\"line\">\t/* 进入是登记 */</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(int i = 0; i &lt; 100; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i].name == null)&#123;\t//找到名字为空的座位</span><br><span class=\"line\">\t\t\ta[i].name = readername;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\treader get the seat nember i;</span><br><span class=\"line\">\tsemSiganl(mutex);</span><br><span class=\"line\">\tgo into the reading room and sit down at the seat number i.</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t/* 离开时登记 */</span><br><span class=\"line\">\tsemWait(mutex);</span><br><span class=\"line\">\ta[i].name = null;  </span><br><span class=\"line\">\tsemSignal(mutex);</span><br><span class=\"line\">\tsemSignal(seatcount);</span><br><span class=\"line\">\tleave reading room;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二、读/写者问题<br>    描述：<br>    有一个由多个进程共享的数据区，一些进程只读取这个数据区中的数据，一些进程只往数据区中写数据。并须满足以下条件：<br>    任意多的读进程可以同时读文件；<br>    一次只有一个写进程可以写文件；<br>    如果一个写进程正在写文件，那么禁止任何读进程读文件。</p>\n<p>读者优先</p>\n<p>分析：<br>    当一个读进程开始访问数据区时，只要至少有一个读进程正在读，就为读进程保留对这个数据区的控制权，因此，写进程有可能处于饥饿状态。    </p>\n<p>数据结构：<br>    readcount: 控制wsem的的设置<br>    wsem： 当没有读进程正在读时，第一个试图读的读进程需要在wsem上等待； 当至少有一个读进程在读时，随后的读进程无需等待直接进入。<br>    x: 用于确保readcount被正确更新。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int readcount;</span><br><span class=\"line\">semphore x = 1, wsem = 1;</span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">reader</span></span>() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\"> \tsemWait(x);</span><br><span class=\"line\">  \t\treadcount++;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">if</span>(readcount==1)</span><br><span class=\"line\">     \t\tsemWait(wsem);  //如果是第一个读者，则要控制wsem</span><br><span class=\"line\">  \t\tsemSignal(x);</span><br><span class=\"line\">  \t\tREADUNIT();   </span><br><span class=\"line\">\tsemWait(x);</span><br><span class=\"line\">\treadcount--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(readcount==0)</span><br><span class=\"line\">  \t\tsemSignal(wsem);</span><br><span class=\"line\">\tsemSignal(x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void <span class=\"function\"><span class=\"title\">writer</span></span>()&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t \t\tsemWait(wsem);</span><br><span class=\"line\">  \t\t\tWRITEUNIT();</span><br><span class=\"line\">  \t\t\tsemSignal(wsem);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实例：<br>    独木桥问题：东、西向汽车过独木桥。桥上无车时允许一方汽车过桥，待全部过完后才允许另一方汽车过桥。用信号量操作写出同步算法。(提示：参考读者优先的解法)</p>\n<p>数据结构：</p>\n<pre><code>mutex1/mutex2: 用于确保count1/count2被准备更新\ncount1/count2: 控制wait的设置\nwait: 当没有车同向的车通过独木桥时，第一辆通过的车需要在wait上等待； 当至少有一辆同向的车通过时，随后同方向的车无需等待直接进入。\n</code></pre><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\tsemaphore <span class=\"built_in\">wait</span>=1, mutex1=1, mutex2=1;</span><br><span class=\"line\">\tint count1=0, count2=0; </span><br><span class=\"line\"></span><br><span class=\"line\">\tprocess P <span class=\"function\"><span class=\"title\">east</span></span>()&#123;</span><br><span class=\"line\">   \tsemWait(mutex1);</span><br><span class=\"line\">     \tcount1++;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count1==1)   semWait(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex1);</span><br><span class=\"line\">      \tthrough the singal-log bridge；</span><br><span class=\"line\">     \tsemWait(mutex1);</span><br><span class=\"line\">     \tcount1--;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count1==0)   semSignal(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">process P <span class=\"function\"><span class=\"title\">west</span></span>()&#123;</span><br><span class=\"line\">   \tsemWait(mutex2);</span><br><span class=\"line\">     \tcount2++;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count2==1)   semWait(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex2);</span><br><span class=\"line\">       through the singal-log bridge；</span><br><span class=\"line\">     \tsemWait(mutex2);</span><br><span class=\"line\">     \tcount2--;</span><br><span class=\"line\">     \t<span class=\"keyword\">if</span>(count2==0)   semSignal(<span class=\"built_in\">wait</span>);</span><br><span class=\"line\">     \tsemSignal(mutex2);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>待整理。。。</p>\n"},{"title":"深入理解Java虚拟机之Java内存区域","date":"2018-12-07T13:17:36.000Z","copyright":null,"_content":"\n### 运行时数据内存\n#### 线程私有的内存区域\n> 每条线程都有，各线程之间互不影响，独立存储的一类内存区域\n\n- **程序计数器**: 可以看成是当前线程锁执行的字节码的行号指示器\n- **Java虚拟机栈**: 生命周期与线程相同，描述的是Java方法执行的内存模型：每个方法子执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息\n- **本地方法栈**: 为虚拟机使用到的Native方法服务（而虚拟机栈为Java方法服务）\n#### 线程共享的内存区域\n- **Java堆**: 在虚拟机启动时创建，用于存放对象实例，可以处于物理上不连续的内存空间，主要逻辑上连续即可\n- **方法区**: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，可以选择笃定大小或者可拓展外，还可以选择不实现垃圾收集\n- **运行时常量池**: 方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这部分内容在类加载后进入方法区的运行时常量池存放）\n\n### HotSpot虚拟机对象探秘\n#### 对象的创建\n1. 虚拟机遇到一条new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用\n2. 为新生对象分配内存\n- 两种分配内存的方法：\n    i. **指针碰撞**: Java堆中内存绝对规整时\n    ii. **空闲列表**: Java堆中内存不规整，已使用的内存和空闲的内存相互交错时\n- 并发情况下解决线程安全的两种方法：\n    i. 对分配内存空间的动作进行同步\n    ii. 把内存分配动作按照线程划分在不同的空间之中进行\n3. 将分配到的内存空间都初始化为零值（对象头除外）\n4. 对对象进行必要的设置（对象头）\n> 从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，还需要第5步\n5. 执行`<init>`方法\n\n#### 对象的内存布局\n> 对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充\n\n- **对象头**: 包括两部分：\n    i. 用于存储对象自身的运行时数据，如HashCode、GC分代年龄...\n    ii. 类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例（如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据）\n- **实例数据**: 对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容\n- **对齐填充**: 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍）\n\n#### 对象的访问定位\n> 取决于虚拟机的实现，主流的访问方式有两种：\n\n- **使用句柄**: Java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息\n![](/images/jvm_object_reference_handle.jpg)\n- **直接指针**: reference中存储的直接就是对象地址\n![](/images/jvm_object_reference_pointer.jpg)\n\n","source":"_posts/深入理解Java虚拟机之Java内存区域.md","raw":"---\ntitle: 深入理解Java虚拟机之Java内存区域\ndate: 2018-12-07 21:17:36\ncategories: \"深入理解java虚拟机笔记\"\ntags:\n    - JVM\ncopyright:\n---\n\n### 运行时数据内存\n#### 线程私有的内存区域\n> 每条线程都有，各线程之间互不影响，独立存储的一类内存区域\n\n- **程序计数器**: 可以看成是当前线程锁执行的字节码的行号指示器\n- **Java虚拟机栈**: 生命周期与线程相同，描述的是Java方法执行的内存模型：每个方法子执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息\n- **本地方法栈**: 为虚拟机使用到的Native方法服务（而虚拟机栈为Java方法服务）\n#### 线程共享的内存区域\n- **Java堆**: 在虚拟机启动时创建，用于存放对象实例，可以处于物理上不连续的内存空间，主要逻辑上连续即可\n- **方法区**: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，可以选择笃定大小或者可拓展外，还可以选择不实现垃圾收集\n- **运行时常量池**: 方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这部分内容在类加载后进入方法区的运行时常量池存放）\n\n### HotSpot虚拟机对象探秘\n#### 对象的创建\n1. 虚拟机遇到一条new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用\n2. 为新生对象分配内存\n- 两种分配内存的方法：\n    i. **指针碰撞**: Java堆中内存绝对规整时\n    ii. **空闲列表**: Java堆中内存不规整，已使用的内存和空闲的内存相互交错时\n- 并发情况下解决线程安全的两种方法：\n    i. 对分配内存空间的动作进行同步\n    ii. 把内存分配动作按照线程划分在不同的空间之中进行\n3. 将分配到的内存空间都初始化为零值（对象头除外）\n4. 对对象进行必要的设置（对象头）\n> 从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，还需要第5步\n5. 执行`<init>`方法\n\n#### 对象的内存布局\n> 对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充\n\n- **对象头**: 包括两部分：\n    i. 用于存储对象自身的运行时数据，如HashCode、GC分代年龄...\n    ii. 类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例（如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据）\n- **实例数据**: 对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容\n- **对齐填充**: 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍）\n\n#### 对象的访问定位\n> 取决于虚拟机的实现，主流的访问方式有两种：\n\n- **使用句柄**: Java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息\n![](/images/jvm_object_reference_handle.jpg)\n- **直接指针**: reference中存储的直接就是对象地址\n![](/images/jvm_object_reference_pointer.jpg)\n\n","slug":"深入理解Java虚拟机之Java内存区域","published":1,"updated":"2018-12-07T13:30:28.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fe70035u7yj11617icz","content":"<h3 id=\"运行时数据内存\"><a href=\"#运行时数据内存\" class=\"headerlink\" title=\"运行时数据内存\"></a>运行时数据内存</h3><h4 id=\"线程私有的内存区域\"><a href=\"#线程私有的内存区域\" class=\"headerlink\" title=\"线程私有的内存区域\"></a>线程私有的内存区域</h4><blockquote>\n<p>每条线程都有，各线程之间互不影响，独立存储的一类内存区域</p>\n</blockquote>\n<ul>\n<li><strong>程序计数器</strong>: 可以看成是当前线程锁执行的字节码的行号指示器</li>\n<li><strong>Java虚拟机栈</strong>: 生命周期与线程相同，描述的是Java方法执行的内存模型：每个方法子执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>\n<li><strong>本地方法栈</strong>: 为虚拟机使用到的Native方法服务（而虚拟机栈为Java方法服务）<h4 id=\"线程共享的内存区域\"><a href=\"#线程共享的内存区域\" class=\"headerlink\" title=\"线程共享的内存区域\"></a>线程共享的内存区域</h4></li>\n<li><strong>Java堆</strong>: 在虚拟机启动时创建，用于存放对象实例，可以处于物理上不连续的内存空间，主要逻辑上连续即可</li>\n<li><strong>方法区</strong>: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，可以选择笃定大小或者可拓展外，还可以选择不实现垃圾收集</li>\n<li><strong>运行时常量池</strong>: 方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这部分内容在类加载后进入方法区的运行时常量池存放）</li>\n</ul>\n<h3 id=\"HotSpot虚拟机对象探秘\"><a href=\"#HotSpot虚拟机对象探秘\" class=\"headerlink\" title=\"HotSpot虚拟机对象探秘\"></a>HotSpot虚拟机对象探秘</h3><h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><ol>\n<li>虚拟机遇到一条new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用</li>\n<li>为新生对象分配内存</li>\n</ol>\n<ul>\n<li>两种分配内存的方法：<br>  i. <strong>指针碰撞</strong>: Java堆中内存绝对规整时<br>  ii. <strong>空闲列表</strong>: Java堆中内存不规整，已使用的内存和空闲的内存相互交错时</li>\n<li>并发情况下解决线程安全的两种方法：<br>  i. 对分配内存空间的动作进行同步<br>  ii. 把内存分配动作按照线程划分在不同的空间之中进行</li>\n</ul>\n<ol>\n<li>将分配到的内存空间都初始化为零值（对象头除外）</li>\n<li>对对象进行必要的设置（对象头）<blockquote>\n<p>从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，还需要第5步</p>\n</blockquote>\n</li>\n<li>执行<code>&lt;init&gt;</code>方法</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><blockquote>\n<p>对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充</p>\n</blockquote>\n<ul>\n<li><strong>对象头</strong>: 包括两部分：<br>  i. 用于存储对象自身的运行时数据，如HashCode、GC分代年龄…<br>  ii. 类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例（如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据）</li>\n<li><strong>实例数据</strong>: 对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容</li>\n<li><strong>对齐填充</strong>: 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍）</li>\n</ul>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><blockquote>\n<p>取决于虚拟机的实现，主流的访问方式有两种：</p>\n</blockquote>\n<ul>\n<li><strong>使用句柄</strong>: Java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息<br><img src=\"/images/jvm_object_reference_handle.jpg\" alt=\"\"></li>\n<li><strong>直接指针</strong>: reference中存储的直接就是对象地址<br><img src=\"/images/jvm_object_reference_pointer.jpg\" alt=\"\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"运行时数据内存\"><a href=\"#运行时数据内存\" class=\"headerlink\" title=\"运行时数据内存\"></a>运行时数据内存</h3><h4 id=\"线程私有的内存区域\"><a href=\"#线程私有的内存区域\" class=\"headerlink\" title=\"线程私有的内存区域\"></a>线程私有的内存区域</h4><blockquote>\n<p>每条线程都有，各线程之间互不影响，独立存储的一类内存区域</p>\n</blockquote>\n<ul>\n<li><strong>程序计数器</strong>: 可以看成是当前线程锁执行的字节码的行号指示器</li>\n<li><strong>Java虚拟机栈</strong>: 生命周期与线程相同，描述的是Java方法执行的内存模型：每个方法子执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息</li>\n<li><strong>本地方法栈</strong>: 为虚拟机使用到的Native方法服务（而虚拟机栈为Java方法服务）<h4 id=\"线程共享的内存区域\"><a href=\"#线程共享的内存区域\" class=\"headerlink\" title=\"线程共享的内存区域\"></a>线程共享的内存区域</h4></li>\n<li><strong>Java堆</strong>: 在虚拟机启动时创建，用于存放对象实例，可以处于物理上不连续的内存空间，主要逻辑上连续即可</li>\n<li><strong>方法区</strong>: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，可以选择笃定大小或者可拓展外，还可以选择不实现垃圾收集</li>\n<li><strong>运行时常量池</strong>: 方法区的一部分，用于存放编译期生成的各种字面量和符号引用（这部分内容在类加载后进入方法区的运行时常量池存放）</li>\n</ul>\n<h3 id=\"HotSpot虚拟机对象探秘\"><a href=\"#HotSpot虚拟机对象探秘\" class=\"headerlink\" title=\"HotSpot虚拟机对象探秘\"></a>HotSpot虚拟机对象探秘</h3><h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><ol>\n<li>虚拟机遇到一条new指令时，检查这个指令的参数是否能在常量池中定位到一个类的符号引用</li>\n<li>为新生对象分配内存</li>\n</ol>\n<ul>\n<li>两种分配内存的方法：<br>  i. <strong>指针碰撞</strong>: Java堆中内存绝对规整时<br>  ii. <strong>空闲列表</strong>: Java堆中内存不规整，已使用的内存和空闲的内存相互交错时</li>\n<li>并发情况下解决线程安全的两种方法：<br>  i. 对分配内存空间的动作进行同步<br>  ii. 把内存分配动作按照线程划分在不同的空间之中进行</li>\n</ul>\n<ol>\n<li>将分配到的内存空间都初始化为零值（对象头除外）</li>\n<li>对对象进行必要的设置（对象头）<blockquote>\n<p>从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，还需要第5步</p>\n</blockquote>\n</li>\n<li>执行<code>&lt;init&gt;</code>方法</li>\n</ol>\n<h4 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h4><blockquote>\n<p>对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充</p>\n</blockquote>\n<ul>\n<li><strong>对象头</strong>: 包括两部分：<br>  i. 用于存储对象自身的运行时数据，如HashCode、GC分代年龄…<br>  ii. 类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例（如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据）</li>\n<li><strong>实例数据</strong>: 对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容</li>\n<li><strong>对齐填充</strong>: 并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用（HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍）</li>\n</ul>\n<h4 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h4><blockquote>\n<p>取决于虚拟机的实现，主流的访问方式有两种：</p>\n</blockquote>\n<ul>\n<li><strong>使用句柄</strong>: Java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息<br><img src=\"/images/jvm_object_reference_handle.jpg\" alt=\"\"></li>\n<li><strong>直接指针</strong>: reference中存储的直接就是对象地址<br><img src=\"/images/jvm_object_reference_pointer.jpg\" alt=\"\"></li>\n</ul>\n"},{"title":"servlet","date":"2018-07-23T13:48:35.000Z","_content":"### servlet生命周期\n1.初始化，调用`init()`方法，生成`Servlet`实例\n2.响应客户请求，调用`service()`方法，由`service()`方法根据提交方式悬着执行`doGet()`或者`doPost()`方法\n3.终止，调用`destroy()`方法\n![servlet life cycle](/images/servlet_life_cycle.png)\n\n### tomcat装载servlet的三种情况\n1.Servlet容器启动时自动装载某些Servlet，需要在web.xml文件中的`<Servlet></Servlet>`之间添加`<loadon-startup>1<load-sartup>`\n> 数字越小优先级越高\n2.在Servlet容器启动后，客户首次向Servlet发送请求\n3.Servlet类文件被修改时，重新装载Servlet\n\n### 获取初始化参数\n在web.xml中配置`Servle时可以配置初始化参数，通过`<init-param>`配置：\n```XML\n<init-param>\n    <param-name>username</param-name>\n    <param-value>pinnuli</param-value>\n</init-param>\n```\n在Servlet类中可以通过`getInitParameter()`获取：\n```java\nString username = this.getInitParameter(\"username\");\n```\n\n未完待续。。。","source":"_posts/servlet笔记.md","raw":"---\ntitle: servlet\ndate: 2018-07-23 21:48:35\ncategories: \"JavaWeb笔记\"\ntags:\n    - servlet\n    - JavaWeb\n---\n### servlet生命周期\n1.初始化，调用`init()`方法，生成`Servlet`实例\n2.响应客户请求，调用`service()`方法，由`service()`方法根据提交方式悬着执行`doGet()`或者`doPost()`方法\n3.终止，调用`destroy()`方法\n![servlet life cycle](/images/servlet_life_cycle.png)\n\n### tomcat装载servlet的三种情况\n1.Servlet容器启动时自动装载某些Servlet，需要在web.xml文件中的`<Servlet></Servlet>`之间添加`<loadon-startup>1<load-sartup>`\n> 数字越小优先级越高\n2.在Servlet容器启动后，客户首次向Servlet发送请求\n3.Servlet类文件被修改时，重新装载Servlet\n\n### 获取初始化参数\n在web.xml中配置`Servle时可以配置初始化参数，通过`<init-param>`配置：\n```XML\n<init-param>\n    <param-name>username</param-name>\n    <param-value>pinnuli</param-value>\n</init-param>\n```\n在Servlet类中可以通过`getInitParameter()`获取：\n```java\nString username = this.getInitParameter(\"username\");\n```\n\n未完待续。。。","slug":"servlet笔记","published":1,"updated":"2018-11-12T13:00:55.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fe8003au7yj7enihz95","content":"<h3 id=\"servlet生命周期\"><a href=\"#servlet生命周期\" class=\"headerlink\" title=\"servlet生命周期\"></a>servlet生命周期</h3><p>1.初始化，调用<code>init()</code>方法，生成<code>Servlet</code>实例<br>2.响应客户请求，调用<code>service()</code>方法，由<code>service()</code>方法根据提交方式悬着执行<code>doGet()</code>或者<code>doPost()</code>方法<br>3.终止，调用<code>destroy()</code>方法<br><img src=\"/images/servlet_life_cycle.png\" alt=\"servlet life cycle\"></p>\n<h3 id=\"tomcat装载servlet的三种情况\"><a href=\"#tomcat装载servlet的三种情况\" class=\"headerlink\" title=\"tomcat装载servlet的三种情况\"></a>tomcat装载servlet的三种情况</h3><p>1.Servlet容器启动时自动装载某些Servlet，需要在web.xml文件中的<code>&lt;Servlet&gt;&lt;/Servlet&gt;</code>之间添加<code>&lt;loadon-startup&gt;1&lt;load-sartup&gt;</code></p>\n<blockquote>\n<p>数字越小优先级越高<br>2.在Servlet容器启动后，客户首次向Servlet发送请求<br>3.Servlet类文件被修改时，重新装载Servlet</p>\n</blockquote>\n<h3 id=\"获取初始化参数\"><a href=\"#获取初始化参数\" class=\"headerlink\" title=\"获取初始化参数\"></a>获取初始化参数</h3><p>在web.xml中配置<code>Servle时可以配置初始化参数，通过</code><init-param>`配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>username<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>pinnuli<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></init-param></p>\n<p>在Servlet类中可以通过<code>getInitParameter()</code>获取：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String username = <span class=\"keyword\">this</span>.getInitParameter(<span class=\"string\">\"username\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>未完待续。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"servlet生命周期\"><a href=\"#servlet生命周期\" class=\"headerlink\" title=\"servlet生命周期\"></a>servlet生命周期</h3><p>1.初始化，调用<code>init()</code>方法，生成<code>Servlet</code>实例<br>2.响应客户请求，调用<code>service()</code>方法，由<code>service()</code>方法根据提交方式悬着执行<code>doGet()</code>或者<code>doPost()</code>方法<br>3.终止，调用<code>destroy()</code>方法<br><img src=\"/images/servlet_life_cycle.png\" alt=\"servlet life cycle\"></p>\n<h3 id=\"tomcat装载servlet的三种情况\"><a href=\"#tomcat装载servlet的三种情况\" class=\"headerlink\" title=\"tomcat装载servlet的三种情况\"></a>tomcat装载servlet的三种情况</h3><p>1.Servlet容器启动时自动装载某些Servlet，需要在web.xml文件中的<code>&lt;Servlet&gt;&lt;/Servlet&gt;</code>之间添加<code>&lt;loadon-startup&gt;1&lt;load-sartup&gt;</code></p>\n<blockquote>\n<p>数字越小优先级越高<br>2.在Servlet容器启动后，客户首次向Servlet发送请求<br>3.Servlet类文件被修改时，重新装载Servlet</p>\n</blockquote>\n<h3 id=\"获取初始化参数\"><a href=\"#获取初始化参数\" class=\"headerlink\" title=\"获取初始化参数\"></a>获取初始化参数</h3><p>在web.xml中配置<code>Servle时可以配置初始化参数，通过</code><init-param>`配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>username<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>pinnuli<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></init-param></p>\n<p>在Servlet类中可以通过<code>getInitParameter()</code>获取：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String username = <span class=\"keyword\">this</span>.getInitParameter(<span class=\"string\">\"username\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>未完待续。。。</p>\n"},{"title":"深入理解Java虚拟机之虚拟机字节码执行引擎","date":"2018-12-02T13:18:09.000Z","copyright":null,"_content":"### 运行时栈帧结构\n  i. 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。\n  ii. 每一个栈帧都包括了 **局部变量表，操作数栈，动态连接，方法返回地址**和一些额外的附加信息\n  iii. 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程\n  iv. 在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法\n\n栈帧的概念结构：\n(/images/jvm_stackframe_structure.jpg)\n\n#### 1. 局部变量表\n> 一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量\n\n- **单位**:局部变量表的容量以变量槽（Slot）为最小单位\n- **虚拟机定位**：虚拟机通过索引定位的方式使用局部变量表，索引值从0开始到局部变量表最大的Slot数量\n- **64位数据的访问**：对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用热任何方式单独访问其中的某一个\n- **局部变量表的空间分配**：\n    i. 如果执行的是实例方法，在那局部变量表最后还给你第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。 \n    ii. 其余参数按照参数表顺序排列，占用从1开始的局部变量Slot。 \n    ii. 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用于分配其余的Slot\n- **Slot重用**：如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用，但是Slot的复用会直接影响到系统的垃圾收集行为\n实例代码一：\n```Java\npublic static void main(String[] args)() {\n\t{\n\t\tbyte[] placeholder = new byte[64 * 1024 * 1024];\n\t}\n\tSystem.gc();\n}\n```\n实例代码二：\n```Java\npublic static void main(String[] args)() {\n\t{\n\t\tbyte[] placeholder = new byte[64 * 1024 * 1024];\n\t}\n\tint a = 0;\n\tSystem.gc();\n}\n```\n> 代码一的placeholder没有被回收，而代码二的被回收了\n\n#### 2. 操作数栈\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈写入和提取内容，也就是出栈/入栈操作\n\n- 在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的，但大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠\n(/images/jvm_stackframe_operandstack.jpg)\n\n#### 3. 动态链接\n常量池中的符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化为静态解析；另外一部分在每一次运行期间转化为直接引用，这部分称为动态连接\n\n#### 4. 方法返回地址\n一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器值；而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息\n\n#### 5. 附加信息\n虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息\n\n----\n### 方法调用\n方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程\n####1. 解析\n调用目标在程序代码写好，编译器进行编译时就必须确定下来，这类方法的调用称为解析。\n- **非虚方法和虚方法**:可以在解析阶段中确定唯一调用版本的方法有4类：静态方法、私有方法、实例构造器、父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为 **非虚方法**，其他方法称为 **虚方法**（除了final方法）\n- 解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及引用全部转变为可确定的直接引用\n\n#### 2. 分派\n解析和分派两者之间的关系不是二选一的排他关系，他们是在不同层次上筛选、确定目标方法的过程。\n##### 静态分派\n所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的经典应用和是方法重载。\n##### 动态分派\n在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。\n##### 单分派与多分派\n方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。\n> Java的静态分派属于多分派类型，动态分派属于单分派类型，所以Java是一门静态多分派、动态单分派的语言\n##### 虚拟机动态分派的实现\n最常用的“稳定优化”手段是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找,虚方法中存放着各个方法的实际入口地址\n!(/images/jvm_method_dispatch.jpg)\n> 方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把类的方法表也初始化完毕\n\n----\n### 基于栈的字节码解释执行引擎\n#### 解释执行\nJava编译器完成了程序代码经过了**词法分析、语法分析到抽象语法树**，再遍历语法树生成线性的字节码指令流的过程。 这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的变异就是 **半独立**的实现。\n![](/images/jvm_interpret.jpg)\n\n#### 基于栈的解释器执行过程\n看一个例子的执行流程基本可以了解\n```Java\npublic int calc() {\n    int a = 100;\n    int b = 200;\n    int c = 300;\n    return (a + b) * c;\n}\n```\n字节码：\n```java\npublic int calc();\n  Code:\n   Stack=2, Locals=4, Args_size=1\n   0:   bipush 100\n   2:   istore_1\n   3:   sipush 200\n   6:   istore_2\n   7:   sipush 300\n   10: istore_3\n   11: iload_1\n   12: iload_2\n   13: iadd\n   14: iload_3\n   15: imul\n   16: ireturn\n}\n\n```\n![](/images/jvm_interpret_execute_1.jpg)\n![](/images/jvm_interpret_execute_2.jpg)\n![](/images/jvm_interpret_execute_3.jpg)\n![](/images/jvm_interpret_execute_4.jpg)\n![](/images/jvm_interpret_execute_5.jpg)\n![](/images/jvm_interpret_execute_6.jpg)\n![](/images/jvm_interpret_execute_7.jpg)\n> 上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述\n","source":"_posts/深入理解Java虚拟机之虚拟机字节码执行引擎.md","raw":"---\ntitle: 深入理解Java虚拟机之虚拟机字节码执行引擎\ndate: 2018-12-02 21:18:09\ncategories: \"深入理解java虚拟机笔记\"\ntags:\n    - JVM\ncopyright:\n---\n### 运行时栈帧结构\n  i. 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。\n  ii. 每一个栈帧都包括了 **局部变量表，操作数栈，动态连接，方法返回地址**和一些额外的附加信息\n  iii. 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程\n  iv. 在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法\n\n栈帧的概念结构：\n(/images/jvm_stackframe_structure.jpg)\n\n#### 1. 局部变量表\n> 一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量\n\n- **单位**:局部变量表的容量以变量槽（Slot）为最小单位\n- **虚拟机定位**：虚拟机通过索引定位的方式使用局部变量表，索引值从0开始到局部变量表最大的Slot数量\n- **64位数据的访问**：对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用热任何方式单独访问其中的某一个\n- **局部变量表的空间分配**：\n    i. 如果执行的是实例方法，在那局部变量表最后还给你第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。 \n    ii. 其余参数按照参数表顺序排列，占用从1开始的局部变量Slot。 \n    ii. 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用于分配其余的Slot\n- **Slot重用**：如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用，但是Slot的复用会直接影响到系统的垃圾收集行为\n实例代码一：\n```Java\npublic static void main(String[] args)() {\n\t{\n\t\tbyte[] placeholder = new byte[64 * 1024 * 1024];\n\t}\n\tSystem.gc();\n}\n```\n实例代码二：\n```Java\npublic static void main(String[] args)() {\n\t{\n\t\tbyte[] placeholder = new byte[64 * 1024 * 1024];\n\t}\n\tint a = 0;\n\tSystem.gc();\n}\n```\n> 代码一的placeholder没有被回收，而代码二的被回收了\n\n#### 2. 操作数栈\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈写入和提取内容，也就是出栈/入栈操作\n\n- 在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的，但大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠\n(/images/jvm_stackframe_operandstack.jpg)\n\n#### 3. 动态链接\n常量池中的符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化为静态解析；另外一部分在每一次运行期间转化为直接引用，这部分称为动态连接\n\n#### 4. 方法返回地址\n一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器值；而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息\n\n#### 5. 附加信息\n虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息\n\n----\n### 方法调用\n方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程\n####1. 解析\n调用目标在程序代码写好，编译器进行编译时就必须确定下来，这类方法的调用称为解析。\n- **非虚方法和虚方法**:可以在解析阶段中确定唯一调用版本的方法有4类：静态方法、私有方法、实例构造器、父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为 **非虚方法**，其他方法称为 **虚方法**（除了final方法）\n- 解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及引用全部转变为可确定的直接引用\n\n#### 2. 分派\n解析和分派两者之间的关系不是二选一的排他关系，他们是在不同层次上筛选、确定目标方法的过程。\n##### 静态分派\n所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的经典应用和是方法重载。\n##### 动态分派\n在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。\n##### 单分派与多分派\n方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。\n> Java的静态分派属于多分派类型，动态分派属于单分派类型，所以Java是一门静态多分派、动态单分派的语言\n##### 虚拟机动态分派的实现\n最常用的“稳定优化”手段是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找,虚方法中存放着各个方法的实际入口地址\n!(/images/jvm_method_dispatch.jpg)\n> 方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把类的方法表也初始化完毕\n\n----\n### 基于栈的字节码解释执行引擎\n#### 解释执行\nJava编译器完成了程序代码经过了**词法分析、语法分析到抽象语法树**，再遍历语法树生成线性的字节码指令流的过程。 这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的变异就是 **半独立**的实现。\n![](/images/jvm_interpret.jpg)\n\n#### 基于栈的解释器执行过程\n看一个例子的执行流程基本可以了解\n```Java\npublic int calc() {\n    int a = 100;\n    int b = 200;\n    int c = 300;\n    return (a + b) * c;\n}\n```\n字节码：\n```java\npublic int calc();\n  Code:\n   Stack=2, Locals=4, Args_size=1\n   0:   bipush 100\n   2:   istore_1\n   3:   sipush 200\n   6:   istore_2\n   7:   sipush 300\n   10: istore_3\n   11: iload_1\n   12: iload_2\n   13: iadd\n   14: iload_3\n   15: imul\n   16: ireturn\n}\n\n```\n![](/images/jvm_interpret_execute_1.jpg)\n![](/images/jvm_interpret_execute_2.jpg)\n![](/images/jvm_interpret_execute_3.jpg)\n![](/images/jvm_interpret_execute_4.jpg)\n![](/images/jvm_interpret_execute_5.jpg)\n![](/images/jvm_interpret_execute_6.jpg)\n![](/images/jvm_interpret_execute_7.jpg)\n> 上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述\n","slug":"深入理解Java虚拟机之虚拟机字节码执行引擎","published":1,"updated":"2018-12-07T13:27:21.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs641fea003cu7yj96q09t6j","content":"<h3 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h3><p>  i. 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<br>  ii. 每一个栈帧都包括了 <strong>局部变量表，操作数栈，动态连接，方法返回地址</strong>和一些额外的附加信息<br>  iii. 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程<br>  iv. 在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法</p>\n<p>栈帧的概念结构：<br>(/images/jvm_stackframe_structure.jpg)</p>\n<h4 id=\"1-局部变量表\"><a href=\"#1-局部变量表\" class=\"headerlink\" title=\"1. 局部变量表\"></a>1. 局部变量表</h4><blockquote>\n<p>一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量</p>\n</blockquote>\n<ul>\n<li><strong>单位</strong>:局部变量表的容量以变量槽（Slot）为最小单位</li>\n<li><strong>虚拟机定位</strong>：虚拟机通过索引定位的方式使用局部变量表，索引值从0开始到局部变量表最大的Slot数量</li>\n<li><strong>64位数据的访问</strong>：对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用热任何方式单独访问其中的某一个</li>\n<li><strong>局部变量表的空间分配</strong>：<br>  i. 如果执行的是实例方法，在那局部变量表最后还给你第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。<br>  ii. 其余参数按照参数表顺序排列，占用从1开始的局部变量Slot。<br>  ii. 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用于分配其余的Slot</li>\n<li><strong>Slot重用</strong>：如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用，但是Slot的复用会直接影响到系统的垃圾收集行为<br>实例代码一：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] placeholder = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">64</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.gc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实例代码二：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] placeholder = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">64</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tSystem.gc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>代码一的placeholder没有被回收，而代码二的被回收了</p>\n</blockquote>\n<h4 id=\"2-操作数栈\"><a href=\"#2-操作数栈\" class=\"headerlink\" title=\"2. 操作数栈\"></a>2. 操作数栈</h4><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈写入和提取内容，也就是出栈/入栈操作</p>\n<ul>\n<li>在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的，但大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠<br>(/images/jvm_stackframe_operandstack.jpg)</li>\n</ul>\n<h4 id=\"3-动态链接\"><a href=\"#3-动态链接\" class=\"headerlink\" title=\"3. 动态链接\"></a>3. 动态链接</h4><p>常量池中的符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化为静态解析；另外一部分在每一次运行期间转化为直接引用，这部分称为动态连接</p>\n<h4 id=\"4-方法返回地址\"><a href=\"#4-方法返回地址\" class=\"headerlink\" title=\"4. 方法返回地址\"></a>4. 方法返回地址</h4><p>一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器值；而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息</p>\n<h4 id=\"5-附加信息\"><a href=\"#5-附加信息\" class=\"headerlink\" title=\"5. 附加信息\"></a>5. 附加信息</h4><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息</p>\n<hr>\n<h3 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h3><p>方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程</p>\n<p>####1. 解析<br>调用目标在程序代码写好，编译器进行编译时就必须确定下来，这类方法的调用称为解析。</p>\n<ul>\n<li><strong>非虚方法和虚方法</strong>:可以在解析阶段中确定唯一调用版本的方法有4类：静态方法、私有方法、实例构造器、父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为 <strong>非虚方法</strong>，其他方法称为 <strong>虚方法</strong>（除了final方法）</li>\n<li>解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及引用全部转变为可确定的直接引用</li>\n</ul>\n<h4 id=\"2-分派\"><a href=\"#2-分派\" class=\"headerlink\" title=\"2. 分派\"></a>2. 分派</h4><p>解析和分派两者之间的关系不是二选一的排他关系，他们是在不同层次上筛选、确定目标方法的过程。</p>\n<h5 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h5><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的经典应用和是方法重载。</p>\n<h5 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h5><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>\n<h5 id=\"单分派与多分派\"><a href=\"#单分派与多分派\" class=\"headerlink\" title=\"单分派与多分派\"></a>单分派与多分派</h5><p>方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>\n<blockquote>\n<p>Java的静态分派属于多分派类型，动态分派属于单分派类型，所以Java是一门静态多分派、动态单分派的语言</p>\n<h5 id=\"虚拟机动态分派的实现\"><a href=\"#虚拟机动态分派的实现\" class=\"headerlink\" title=\"虚拟机动态分派的实现\"></a>虚拟机动态分派的实现</h5><p>最常用的“稳定优化”手段是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找,虚方法中存放着各个方法的实际入口地址<br>!(/images/jvm_method_dispatch.jpg)<br>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把类的方法表也初始化完毕</p>\n</blockquote>\n<hr>\n<h3 id=\"基于栈的字节码解释执行引擎\"><a href=\"#基于栈的字节码解释执行引擎\" class=\"headerlink\" title=\"基于栈的字节码解释执行引擎\"></a>基于栈的字节码解释执行引擎</h3><h4 id=\"解释执行\"><a href=\"#解释执行\" class=\"headerlink\" title=\"解释执行\"></a>解释执行</h4><p>Java编译器完成了程序代码经过了<strong>词法分析、语法分析到抽象语法树</strong>，再遍历语法树生成线性的字节码指令流的过程。 这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的变异就是 <strong>半独立</strong>的实现。<br><img src=\"/images/jvm_interpret.jpg\" alt=\"\"></p>\n<h4 id=\"基于栈的解释器执行过程\"><a href=\"#基于栈的解释器执行过程\" class=\"headerlink\" title=\"基于栈的解释器执行过程\"></a>基于栈的解释器执行过程</h4><p>看一个例子的执行流程基本可以了解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a + b) * c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>字节码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  Code:</span><br><span class=\"line\">   Stack=<span class=\"number\">2</span>, Locals=<span class=\"number\">4</span>, Args_size=<span class=\"number\">1</span></span><br><span class=\"line\">   <span class=\"number\">0</span>:   bipush <span class=\"number\">100</span></span><br><span class=\"line\">   <span class=\"number\">2</span>:   istore_1</span><br><span class=\"line\">   <span class=\"number\">3</span>:   sipush <span class=\"number\">200</span></span><br><span class=\"line\">   <span class=\"number\">6</span>:   istore_2</span><br><span class=\"line\">   <span class=\"number\">7</span>:   sipush <span class=\"number\">300</span></span><br><span class=\"line\">   <span class=\"number\">10</span>: istore_3</span><br><span class=\"line\">   <span class=\"number\">11</span>: iload_1</span><br><span class=\"line\">   <span class=\"number\">12</span>: iload_2</span><br><span class=\"line\">   <span class=\"number\">13</span>: iadd</span><br><span class=\"line\">   <span class=\"number\">14</span>: iload_3</span><br><span class=\"line\">   <span class=\"number\">15</span>: imul</span><br><span class=\"line\">   <span class=\"number\">16</span>: ireturn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/jvm_interpret_execute_1.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_2.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_3.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_4.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_5.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_6.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_7.jpg\" alt=\"\"></p>\n<blockquote>\n<p>上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h3><p>  i. 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<br>  ii. 每一个栈帧都包括了 <strong>局部变量表，操作数栈，动态连接，方法返回地址</strong>和一些额外的附加信息<br>  iii. 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程<br>  iv. 在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法</p>\n<p>栈帧的概念结构：<br>(/images/jvm_stackframe_structure.jpg)</p>\n<h4 id=\"1-局部变量表\"><a href=\"#1-局部变量表\" class=\"headerlink\" title=\"1. 局部变量表\"></a>1. 局部变量表</h4><blockquote>\n<p>一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量</p>\n</blockquote>\n<ul>\n<li><strong>单位</strong>:局部变量表的容量以变量槽（Slot）为最小单位</li>\n<li><strong>虚拟机定位</strong>：虚拟机通过索引定位的方式使用局部变量表，索引值从0开始到局部变量表最大的Slot数量</li>\n<li><strong>64位数据的访问</strong>：对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用热任何方式单独访问其中的某一个</li>\n<li><strong>局部变量表的空间分配</strong>：<br>  i. 如果执行的是实例方法，在那局部变量表最后还给你第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。<br>  ii. 其余参数按照参数表顺序排列，占用从1开始的局部变量Slot。<br>  ii. 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用于分配其余的Slot</li>\n<li><strong>Slot重用</strong>：如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用，但是Slot的复用会直接影响到系统的垃圾收集行为<br>实例代码一：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] placeholder = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">64</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.gc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实例代码二：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] placeholder = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">64</span> * <span class=\"number\">1024</span> * <span class=\"number\">1024</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tSystem.gc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>代码一的placeholder没有被回收，而代码二的被回收了</p>\n</blockquote>\n<h4 id=\"2-操作数栈\"><a href=\"#2-操作数栈\" class=\"headerlink\" title=\"2. 操作数栈\"></a>2. 操作数栈</h4><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈写入和提取内容，也就是出栈/入栈操作</p>\n<ul>\n<li>在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的，但大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠<br>(/images/jvm_stackframe_operandstack.jpg)</li>\n</ul>\n<h4 id=\"3-动态链接\"><a href=\"#3-动态链接\" class=\"headerlink\" title=\"3. 动态链接\"></a>3. 动态链接</h4><p>常量池中的符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化为静态解析；另外一部分在每一次运行期间转化为直接引用，这部分称为动态连接</p>\n<h4 id=\"4-方法返回地址\"><a href=\"#4-方法返回地址\" class=\"headerlink\" title=\"4. 方法返回地址\"></a>4. 方法返回地址</h4><p>一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器值；而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息</p>\n<h4 id=\"5-附加信息\"><a href=\"#5-附加信息\" class=\"headerlink\" title=\"5. 附加信息\"></a>5. 附加信息</h4><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息</p>\n<hr>\n<h3 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h3><p>方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程</p>\n<p>####1. 解析<br>调用目标在程序代码写好，编译器进行编译时就必须确定下来，这类方法的调用称为解析。</p>\n<ul>\n<li><strong>非虚方法和虚方法</strong>:可以在解析阶段中确定唯一调用版本的方法有4类：静态方法、私有方法、实例构造器、父类方法，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为 <strong>非虚方法</strong>，其他方法称为 <strong>虚方法</strong>（除了final方法）</li>\n<li>解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及引用全部转变为可确定的直接引用</li>\n</ul>\n<h4 id=\"2-分派\"><a href=\"#2-分派\" class=\"headerlink\" title=\"2. 分派\"></a>2. 分派</h4><p>解析和分派两者之间的关系不是二选一的排他关系，他们是在不同层次上筛选、确定目标方法的过程。</p>\n<h5 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h5><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的经典应用和是方法重载。</p>\n<h5 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h5><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>\n<h5 id=\"单分派与多分派\"><a href=\"#单分派与多分派\" class=\"headerlink\" title=\"单分派与多分派\"></a>单分派与多分派</h5><p>方法的接受者与方法的参数统称为方法的宗量，单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>\n<blockquote>\n<p>Java的静态分派属于多分派类型，动态分派属于单分派类型，所以Java是一门静态多分派、动态单分派的语言</p>\n<h5 id=\"虚拟机动态分派的实现\"><a href=\"#虚拟机动态分派的实现\" class=\"headerlink\" title=\"虚拟机动态分派的实现\"></a>虚拟机动态分派的实现</h5><p>最常用的“稳定优化”手段是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找,虚方法中存放着各个方法的实际入口地址<br>!(/images/jvm_method_dispatch.jpg)<br>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把类的方法表也初始化完毕</p>\n</blockquote>\n<hr>\n<h3 id=\"基于栈的字节码解释执行引擎\"><a href=\"#基于栈的字节码解释执行引擎\" class=\"headerlink\" title=\"基于栈的字节码解释执行引擎\"></a>基于栈的字节码解释执行引擎</h3><h4 id=\"解释执行\"><a href=\"#解释执行\" class=\"headerlink\" title=\"解释执行\"></a>解释执行</h4><p>Java编译器完成了程序代码经过了<strong>词法分析、语法分析到抽象语法树</strong>，再遍历语法树生成线性的字节码指令流的过程。 这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的变异就是 <strong>半独立</strong>的实现。<br><img src=\"/images/jvm_interpret.jpg\" alt=\"\"></p>\n<h4 id=\"基于栈的解释器执行过程\"><a href=\"#基于栈的解释器执行过程\" class=\"headerlink\" title=\"基于栈的解释器执行过程\"></a>基于栈的解释器执行过程</h4><p>看一个例子的执行流程基本可以了解<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">200</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a + b) * c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>字节码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">calc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  Code:</span><br><span class=\"line\">   Stack=<span class=\"number\">2</span>, Locals=<span class=\"number\">4</span>, Args_size=<span class=\"number\">1</span></span><br><span class=\"line\">   <span class=\"number\">0</span>:   bipush <span class=\"number\">100</span></span><br><span class=\"line\">   <span class=\"number\">2</span>:   istore_1</span><br><span class=\"line\">   <span class=\"number\">3</span>:   sipush <span class=\"number\">200</span></span><br><span class=\"line\">   <span class=\"number\">6</span>:   istore_2</span><br><span class=\"line\">   <span class=\"number\">7</span>:   sipush <span class=\"number\">300</span></span><br><span class=\"line\">   <span class=\"number\">10</span>: istore_3</span><br><span class=\"line\">   <span class=\"number\">11</span>: iload_1</span><br><span class=\"line\">   <span class=\"number\">12</span>: iload_2</span><br><span class=\"line\">   <span class=\"number\">13</span>: iadd</span><br><span class=\"line\">   <span class=\"number\">14</span>: iload_3</span><br><span class=\"line\">   <span class=\"number\">15</span>: imul</span><br><span class=\"line\">   <span class=\"number\">16</span>: ireturn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/images/jvm_interpret_execute_1.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_2.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_3.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_4.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_5.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_6.jpg\" alt=\"\"><br><img src=\"/images/jvm_interpret_execute_7.jpg\" alt=\"\"></p>\n<blockquote>\n<p>上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjs641fcb0000u7yj6p922obh","category_id":"cjs641fcj0003u7yjdvi9472e","_id":"cjs641fcu000du7yj5wcj564j"},{"post_id":"cjs641fcq000bu7yjq8dae3dz","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fcy000ju7yj7xt0wgfq"},{"post_id":"cjs641fch0002u7yj7tte9eqs","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fd0000nu7yjlye1a93f"},{"post_id":"cjs641fcs000cu7yj1xhywf8a","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fd2000qu7yj8nxflw3r"},{"post_id":"cjs641fcv000gu7yjaj097hl0","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fd3000uu7yjkr2o3inj"},{"post_id":"cjs641fcl0005u7yjx7ie3iw9","category_id":"cjs641fcu000eu7yj2z7dloar","_id":"cjs641fd4000xu7yjd00wfhec"},{"post_id":"cjs641fcn0006u7yjiz1s5t2h","category_id":"cjs641fcz000ku7yjvi7ksab5","_id":"cjs641fd6000zu7yj4ty1wtok"},{"post_id":"cjs641fd4000wu7yj9tmxmwls","category_id":"cjs641fcz000ku7yjvi7ksab5","_id":"cjs641fda0015u7yj6opapezu"},{"post_id":"cjs641fco0007u7yjazty9ycu","category_id":"cjs641fd2000ru7yj3id7qsuo","_id":"cjs641fdc001au7yjp2dxo83i"},{"post_id":"cjs641fd5000yu7yjhmb8mjbr","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fdd001du7yjkha71h5c"},{"post_id":"cjs641fd80013u7yj70z23jv5","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fdf001iu7yjmq5829fw"},{"post_id":"cjs641fcx000iu7yj2affxghq","category_id":"cjs641fd60010u7yj8itxm0h4","_id":"cjs641fdh001lu7yjbuofawul"},{"post_id":"cjs641fd90014u7yj7j420y3e","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fdj001qu7yjj4cue9bj"},{"post_id":"cjs641fdb0019u7yj9n6r4wau","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fdk001tu7yjybapk192"},{"post_id":"cjs641fcz000mu7yj2pn71snr","category_id":"cjs641fd60010u7yj8itxm0h4","_id":"cjs641fdm001yu7yj464437s2"},{"post_id":"cjs641fd1000pu7yjquuf0ki3","category_id":"cjs641fde001eu7yj0pq8ksjc","_id":"cjs641fdo0021u7yjzbbn1sm6"},{"post_id":"cjs641fd2000tu7yjif59usok","category_id":"cjs641fd60010u7yj8itxm0h4","_id":"cjs641fdq0026u7yjkwaug1d6"},{"post_id":"cjs641fdj001su7yj7xo0yfk9","category_id":"cjs641fde001eu7yj0pq8ksjc","_id":"cjs641fds0029u7yjoij1r5nc"},{"post_id":"cjs641fdd001cu7yjz7us3f90","category_id":"cjs641fdk001uu7yj3mapgg2a","_id":"cjs641fdt002eu7yj8ueoxcmq"},{"post_id":"cjs641fde001hu7yjzcbrixas","category_id":"cjs641fdk001uu7yj3mapgg2a","_id":"cjs641fdv002iu7yjlfb7fo4f"},{"post_id":"cjs641fdt002du7yj6jzifi0z","category_id":"cjs641fcu000eu7yj2z7dloar","_id":"cjs641fdx002ou7yjfgs0enbi"},{"post_id":"cjs641fdg001ku7yjpvcwkvll","category_id":"cjs641fds002bu7yja7i5khi3","_id":"cjs641fdz002ru7yje7ekzi56"},{"post_id":"cjs641fdv002ku7yjzenhsjh4","category_id":"cjs641fcp0008u7yj9y5wtcin","_id":"cjs641fe2002wu7yj113x872l"},{"post_id":"cjs641fdi001pu7yjl3cr45gs","category_id":"cjs641fdw002lu7yjks5o3nuz","_id":"cjs641fe40030u7yji9f0854u"},{"post_id":"cjs641fdl001xu7yjdbj1wfnc","category_id":"cjs641fe0002tu7yjshagc74d","_id":"cjs641fe80037u7yjr056rv0d"},{"post_id":"cjs641fe8003au7yj7enihz95","category_id":"cjs641fcz000ku7yjvi7ksab5","_id":"cjs641fec003hu7yjausdfxyg"},{"post_id":"cjs641fdr0028u7yjkmvqfwnm","category_id":"cjs641fe80038u7yj8xa0wj66","_id":"cjs641fed003ju7yjguvrlhii"},{"post_id":"cjs641fdu002gu7yjrvtzm8vi","category_id":"cjs641fec003fu7yjwes1h2mu","_id":"cjs641fee003ou7yjjwuv0zpw"},{"post_id":"cjs641fdx002nu7yj9zgbey7c","category_id":"cjs641fec003fu7yjwes1h2mu","_id":"cjs641feg003ru7yjsqhpcewt"},{"post_id":"cjs641fdy002qu7yjjinkj9fk","category_id":"cjs641fec003fu7yjwes1h2mu","_id":"cjs641feh003wu7yjluj1no75"},{"post_id":"cjs641fe1002vu7yjtwa5c6p4","category_id":"cjs641fec003fu7yjwes1h2mu","_id":"cjs641fej003zu7yjd8as397v"},{"post_id":"cjs641fe3002yu7yjei31bbai","category_id":"cjs641fec003fu7yjwes1h2mu","_id":"cjs641fek0041u7yj8ixoi6kf"},{"post_id":"cjs641fe50033u7yjg2y3nmto","category_id":"cjs641fej003yu7yj850dmca1","_id":"cjs641fel0047u7yjpldfgvja"},{"post_id":"cjs641fe70035u7yj11617icz","category_id":"cjs641fec003fu7yjwes1h2mu","_id":"cjs641fel0049u7yjfkns4ade"},{"post_id":"cjs641fea003cu7yj96q09t6j","category_id":"cjs641fec003fu7yjwes1h2mu","_id":"cjs641fem004cu7yjx0xgosz2"},{"post_id":"cjs641fdn0020u7yjvpmmm1x8","category_id":"cjs641fe50031u7yjoqom69i9","_id":"cjs643ewc0002vlyjoxrailtl"}],"PostTag":[{"post_id":"cjs641fcb0000u7yj6p922obh","tag_id":"cjs641fcl0004u7yj2mx3zlzo","_id":"cjs641fcq000au7yjrm8wbby0"},{"post_id":"cjs641fch0002u7yj7tte9eqs","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fcw000hu7yjxojik84a"},{"post_id":"cjs641fcl0005u7yjx7ie3iw9","tag_id":"cjs641fcu000fu7yjam1b2rvx","_id":"cjs641fd1000ou7yjaz5z0wmt"},{"post_id":"cjs641fcn0006u7yjiz1s5t2h","tag_id":"cjs641fcz000lu7yjiharsxkr","_id":"cjs641fd3000vu7yj02vljsch"},{"post_id":"cjs641fd4000wu7yj9tmxmwls","tag_id":"cjs641fcz000lu7yjiharsxkr","_id":"cjs641fd80012u7yj4nfgjp0m"},{"post_id":"cjs641fd80013u7yj70z23jv5","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fdb0018u7yj9fxusu1d"},{"post_id":"cjs641fco0007u7yjazty9ycu","tag_id":"cjs641fd2000su7yj3t4ih0t0","_id":"cjs641fdc001bu7yjftkx0ikt"},{"post_id":"cjs641fco0007u7yjazty9ycu","tag_id":"cjs641fcz000lu7yjiharsxkr","_id":"cjs641fde001gu7yje9ovax5u"},{"post_id":"cjs641fd90014u7yj7j420y3e","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fdg001ju7yjfsdp5g5o"},{"post_id":"cjs641fdb0019u7yj9n6r4wau","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fdh001ou7yjmw40uybt"},{"post_id":"cjs641fcq000bu7yjq8dae3dz","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fdj001ru7yjft28v181"},{"post_id":"cjs641fcq000bu7yjq8dae3dz","tag_id":"cjs641fda0016u7yj528dzekp","_id":"cjs641fdl001wu7yjy1zbzmna"},{"post_id":"cjs641fcs000cu7yj1xhywf8a","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fdn001zu7yjvzvk085a"},{"post_id":"cjs641fcs000cu7yj1xhywf8a","tag_id":"cjs641fde001fu7yjyrm5zcs3","_id":"cjs641fdp0023u7yjwza4em77"},{"post_id":"cjs641fcv000gu7yjaj097hl0","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fdr0027u7yj9yhig2ib"},{"post_id":"cjs641fcv000gu7yjaj097hl0","tag_id":"cjs641fda0016u7yj528dzekp","_id":"cjs641fds002au7yj0zifw9fc"},{"post_id":"cjs641fcx000iu7yj2affxghq","tag_id":"cjs641fcz000lu7yjiharsxkr","_id":"cjs641fdu002fu7yj6z92jpgb"},{"post_id":"cjs641fcx000iu7yj2affxghq","tag_id":"cjs641fdp0022u7yjur7szavx","_id":"cjs641fdv002hu7yj8ez75d0e"},{"post_id":"cjs641fcz000mu7yj2pn71snr","tag_id":"cjs641fcz000lu7yjiharsxkr","_id":"cjs641fdx002mu7yjwl3cn1cm"},{"post_id":"cjs641fcz000mu7yj2pn71snr","tag_id":"cjs641fdp0022u7yjur7szavx","_id":"cjs641fdy002pu7yj1i4nxaxr"},{"post_id":"cjs641fdv002ku7yjzenhsjh4","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fe1002uu7yji6rmmpr8"},{"post_id":"cjs641fd1000pu7yjquuf0ki3","tag_id":"cjs641fdv002ju7yjm823o98v","_id":"cjs641fe3002xu7yjyqen27wp"},{"post_id":"cjs641fd2000tu7yjif59usok","tag_id":"cjs641fdp0022u7yjur7szavx","_id":"cjs641fe50032u7yjx8d1pc06"},{"post_id":"cjs641fd2000tu7yjif59usok","tag_id":"cjs641fcz000lu7yjiharsxkr","_id":"cjs641fe60034u7yjz6x2fv46"},{"post_id":"cjs641fd5000yu7yjhmb8mjbr","tag_id":"cjs641fcp0009u7yjv418dy48","_id":"cjs641fe80039u7yjxo4nxypa"},{"post_id":"cjs641fd5000yu7yjhmb8mjbr","tag_id":"cjs641fda0016u7yj528dzekp","_id":"cjs641fea003bu7yjlqqqz6hi"},{"post_id":"cjs641fdd001cu7yjz7us3f90","tag_id":"cjs641fe80036u7yjdbisfbdi","_id":"cjs641fec003gu7yjotxfqwam"},{"post_id":"cjs641fde001hu7yjzcbrixas","tag_id":"cjs641fe80036u7yjdbisfbdi","_id":"cjs641fed003ku7yjoaym2xzk"},{"post_id":"cjs641fdg001ku7yjpvcwkvll","tag_id":"cjs641fec003iu7yjjgjdr0d7","_id":"cjs641feg003su7yjm2cl4hwu"},{"post_id":"cjs641fdg001ku7yjpvcwkvll","tag_id":"cjs641fee003mu7yjhv7rho0b","_id":"cjs641feg003tu7yjuzewpj7k"},{"post_id":"cjs641fdi001pu7yjl3cr45gs","tag_id":"cjs641fef003pu7yjiy2c1rgo","_id":"cjs641fei003xu7yjqwveowzt"},{"post_id":"cjs641fdj001su7yj7xo0yfk9","tag_id":"cjs641feh003uu7yjds2pcs7g","_id":"cjs641fek0044u7yjedcng6fw"},{"post_id":"cjs641fdj001su7yj7xo0yfk9","tag_id":"cjs641fdv002ju7yjm823o98v","_id":"cjs641fek0045u7yjjfspdlti"},{"post_id":"cjs641fdl001xu7yjdbj1wfnc","tag_id":"cjs641fek0042u7yj5dt3nl1h","_id":"cjs641fem004bu7yj44vf0azp"},{"post_id":"cjs641fdl001xu7yjdbj1wfnc","tag_id":"cjs641fel0048u7yj7uye4edn","_id":"cjs641fem004du7yjlxtjaodo"},{"post_id":"cjs641fdr0028u7yjkmvqfwnm","tag_id":"cjs641fem004eu7yjuu9jvvyu","_id":"cjs641fem004iu7yjdpjp74jl"},{"post_id":"cjs641fdt002du7yj6jzifi0z","tag_id":"cjs641fem004hu7yjn19pr5ra","_id":"cjs641fen004ku7yj0qwuod9l"},{"post_id":"cjs641fdu002gu7yjrvtzm8vi","tag_id":"cjs641fem004ju7yji65pnpvl","_id":"cjs641feo004nu7yjrq7o1h9u"},{"post_id":"cjs641fdu002gu7yjrvtzm8vi","tag_id":"cjs641fen004lu7yjdsklmtsh","_id":"cjs641feo004ou7yj18tptpuw"},{"post_id":"cjs641fdx002nu7yj9zgbey7c","tag_id":"cjs641fem004ju7yji65pnpvl","_id":"cjs641fep004qu7yjeoiuon7t"},{"post_id":"cjs641fdy002qu7yjjinkj9fk","tag_id":"cjs641fem004ju7yji65pnpvl","_id":"cjs641feq004su7yjlsx23513"},{"post_id":"cjs641fe1002vu7yjtwa5c6p4","tag_id":"cjs641fem004ju7yji65pnpvl","_id":"cjs641feq004uu7yjrpmmiri3"},{"post_id":"cjs641fe3002yu7yjei31bbai","tag_id":"cjs641fem004ju7yji65pnpvl","_id":"cjs641feq004wu7yj1zr21afj"},{"post_id":"cjs641fe50033u7yjg2y3nmto","tag_id":"cjs641feq004vu7yjrmqlxa1n","_id":"cjs641fer004zu7yjhwa5cst8"},{"post_id":"cjs641fe50033u7yjg2y3nmto","tag_id":"cjs641fem004eu7yjuu9jvvyu","_id":"cjs641fes0050u7yjpqhcbapx"},{"post_id":"cjs641fe70035u7yj11617icz","tag_id":"cjs641fem004ju7yji65pnpvl","_id":"cjs641fes0052u7yj697ycy9d"},{"post_id":"cjs641fe8003au7yj7enihz95","tag_id":"cjs641fes0051u7yjtrdvymfp","_id":"cjs641fes0054u7yjlfxxsuxd"},{"post_id":"cjs641fe8003au7yj7enihz95","tag_id":"cjs641fcz000lu7yjiharsxkr","_id":"cjs641fet0055u7yj3tkgtfe5"},{"post_id":"cjs641fea003cu7yj96q09t6j","tag_id":"cjs641fem004ju7yji65pnpvl","_id":"cjs641fet0056u7yjmoyp0up4"},{"post_id":"cjs641fdn0020u7yjvpmmm1x8","tag_id":"cjs641fel004au7yjpb4u2xae","_id":"cjs643ewc0000vlyjx0rxrmbi"},{"post_id":"cjs641fdn0020u7yjvpmmm1x8","tag_id":"cjs641fde001fu7yjyrm5zcs3","_id":"cjs643ewc0001vlyjgafn7a50"}],"Tag":[{"name":"计划","_id":"cjs641fcl0004u7yj2mx3zlzo"},{"name":"JavaSE","_id":"cjs641fcp0009u7yjv418dy48"},{"name":"IDEA","_id":"cjs641fcu000fu7yjam1b2rvx"},{"name":"JavaWeb","_id":"cjs641fcz000lu7yjiharsxkr"},{"name":"Jsp","_id":"cjs641fd2000su7yj3t4ih0t0"},{"name":"XML","_id":"cjs641fda0016u7yj528dzekp"},{"name":"Java并发","_id":"cjs641fde001fu7yjyrm5zcs3"},{"name":"Spring","_id":"cjs641fdp0022u7yjur7szavx"},{"name":"服务器","_id":"cjs641fdv002ju7yjm823o98v"},{"name":"git","_id":"cjs641fe80036u7yjdbisfbdi"},{"name":"java爬虫","_id":"cjs641fec003iu7yjjgjdr0d7"},{"name":"Jsoup","_id":"cjs641fee003mu7yjhv7rho0b"},{"name":"markdownPad","_id":"cjs641fef003pu7yjiy2c1rgo"},{"name":"nginx","_id":"cjs641feh003uu7yjds2pcs7g"},{"name":"计算机网络","_id":"cjs641fek0042u7yj5dt3nl1h"},{"name":"TCP","_id":"cjs641fel0048u7yj7uye4edn"},{"name":"设计模式","_id":"cjs641fel004au7yjpb4u2xae"},{"name":"计算机基础","_id":"cjs641fem004eu7yjuu9jvvyu"},{"name":"vim","_id":"cjs641fem004hu7yjn19pr5ra"},{"name":"JVM","_id":"cjs641fem004ju7yji65pnpvl"},{"name":"多线程","_id":"cjs641fen004lu7yjdsklmtsh"},{"name":"OS","_id":"cjs641feq004vu7yjrmqlxa1n"},{"name":"servlet","_id":"cjs641fes0051u7yjtrdvymfp"}]}}